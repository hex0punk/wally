// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../node_modules/d3-selection/src/namespaces.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.xhtml = exports.default = void 0;
var xhtml = exports.xhtml = "http://www.w3.org/1999/xhtml";
var _default = exports.default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
},{}],"../node_modules/d3-selection/src/namespace.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _namespaces = _interopRequireDefault(require("./namespaces.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(name) {
  var prefix = name += "",
    i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces.default.hasOwnProperty(prefix) ? {
    space: _namespaces.default[prefix],
    local: name
  } : name; // eslint-disable-line no-prototype-builtins
}
},{"./namespaces.js":"../node_modules/d3-selection/src/namespaces.js"}],"../node_modules/d3-selection/src/creator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _namespace = _interopRequireDefault(require("./namespace.js"));
var _namespaces = require("./namespaces.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function creatorInherit(name) {
  return function () {
    var document = this.ownerDocument,
      uri = this.namespaceURI;
    return uri === _namespaces.xhtml && document.documentElement.namespaceURI === _namespaces.xhtml ? document.createElement(name) : document.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function () {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function _default(name) {
  var fullname = (0, _namespace.default)(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
},{"./namespace.js":"../node_modules/d3-selection/src/namespace.js","./namespaces.js":"../node_modules/d3-selection/src/namespaces.js"}],"../node_modules/d3-selection/src/selector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function none() {}
function _default(selector) {
  return selector == null ? none : function () {
    return this.querySelector(selector);
  };
}
},{}],"../node_modules/d3-selection/src/selection/select.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _index = require("./index.js");
var _selector = _interopRequireDefault(require("../selector.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(select) {
  if (typeof select !== "function") select = (0, _selector.default)(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new _index.Selection(subgroups, this._parents);
}
},{"./index.js":"../node_modules/d3-selection/src/selection/index.js","../selector.js":"../node_modules/d3-selection/src/selector.js"}],"../node_modules/d3-selection/src/array.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = array;
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we don’t ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}
},{}],"../node_modules/d3-selection/src/selectorAll.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function empty() {
  return [];
}
function _default(selector) {
  return selector == null ? empty : function () {
    return this.querySelectorAll(selector);
  };
}
},{}],"../node_modules/d3-selection/src/selection/selectAll.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _index = require("./index.js");
var _array = _interopRequireDefault(require("../array.js"));
var _selectorAll = _interopRequireDefault(require("../selectorAll.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function arrayAll(select) {
  return function () {
    return (0, _array.default)(select.apply(this, arguments));
  };
}
function _default(select) {
  if (typeof select === "function") select = arrayAll(select);else select = (0, _selectorAll.default)(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new _index.Selection(subgroups, parents);
}
},{"./index.js":"../node_modules/d3-selection/src/selection/index.js","../array.js":"../node_modules/d3-selection/src/array.js","../selectorAll.js":"../node_modules/d3-selection/src/selectorAll.js"}],"../node_modules/d3-selection/src/matcher.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.childMatcher = childMatcher;
exports.default = _default;
function _default(selector) {
  return function () {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function (node) {
    return node.matches(selector);
  };
}
},{}],"../node_modules/d3-selection/src/selection/selectChild.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _matcher = require("../matcher.js");
var find = Array.prototype.find;
function childFind(match) {
  return function () {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function _default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : (0, _matcher.childMatcher)(match)));
}
},{"../matcher.js":"../node_modules/d3-selection/src/matcher.js"}],"../node_modules/d3-selection/src/selection/selectChildren.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _matcher = require("../matcher.js");
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function () {
    return filter.call(this.children, match);
  };
}
function _default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : (0, _matcher.childMatcher)(match)));
}
},{"../matcher.js":"../node_modules/d3-selection/src/matcher.js"}],"../node_modules/d3-selection/src/selection/filter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _index = require("./index.js");
var _matcher = _interopRequireDefault(require("../matcher.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(match) {
  if (typeof match !== "function") match = (0, _matcher.default)(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new _index.Selection(subgroups, this._parents);
}
},{"./index.js":"../node_modules/d3-selection/src/selection/index.js","../matcher.js":"../node_modules/d3-selection/src/matcher.js"}],"../node_modules/d3-selection/src/selection/sparse.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(update) {
  return new Array(update.length);
}
},{}],"../node_modules/d3-selection/src/selection/enter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnterNode = EnterNode;
exports.default = _default;
var _sparse = _interopRequireDefault(require("./sparse.js"));
var _index = require("./index.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default() {
  return new _index.Selection(this._enter || this._groups.map(_sparse.default), this._parents);
}
function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function appendChild(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function insertBefore(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function querySelector(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function querySelectorAll(selector) {
    return this._parent.querySelectorAll(selector);
  }
};
},{"./sparse.js":"../node_modules/d3-selection/src/selection/sparse.js","./index.js":"../node_modules/d3-selection/src/selection/index.js"}],"../node_modules/d3-selection/src/constant.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(x) {
  return function () {
    return x;
  };
}
},{}],"../node_modules/d3-selection/src/selection/data.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _index = require("./index.js");
var _enter = require("./enter.js");
var _constant = _interopRequireDefault(require("../constant.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
    node,
    groupLength = group.length,
    dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter.EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
    node,
    nodeByKeyValue = new Map(),
    groupLength = group.length,
    dataLength = data.length,
    keyValues = new Array(groupLength),
    keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new _enter.EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function _default(value, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex,
    parents = this._parents,
    groups = this._groups;
  if (typeof value !== "function") value = (0, _constant.default)(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
      group = groups[j],
      groupLength = group.length,
      data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
      dataLength = data.length,
      enterGroup = enter[j] = new Array(dataLength),
      updateGroup = update[j] = new Array(dataLength),
      exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }
  update = new _index.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isn’t worried about “live” collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// don’t; we’d rather avoid a gratuitous copy.)
function arraylike(data) {
  return _typeof(data) === "object" && "length" in data ? data // Array, TypedArray, NodeList, array-like
  : Array.from(data); // Map, Set, iterable, string, or anything else
}
},{"./index.js":"../node_modules/d3-selection/src/selection/index.js","./enter.js":"../node_modules/d3-selection/src/selection/enter.js","../constant.js":"../node_modules/d3-selection/src/constant.js"}],"../node_modules/d3-selection/src/selection/exit.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _sparse = _interopRequireDefault(require("./sparse.js"));
var _index = require("./index.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default() {
  return new _index.Selection(this._exit || this._groups.map(_sparse.default), this._parents);
}
},{"./sparse.js":"../node_modules/d3-selection/src/selection/sparse.js","./index.js":"../node_modules/d3-selection/src/selection/index.js"}],"../node_modules/d3-selection/src/selection/join.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(onenter, onupdate, onexit) {
  var enter = this.enter(),
    update = this,
    exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove();else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
},{}],"../node_modules/d3-selection/src/selection/merge.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _index = require("./index.js");
function _default(context) {
  var selection = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new _index.Selection(merges, this._parents);
}
},{"./index.js":"../node_modules/d3-selection/src/selection/index.js"}],"../node_modules/d3-selection/src/selection/order.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
},{}],"../node_modules/d3-selection/src/selection/sort.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _index = require("./index.js");
function _default(compare) {
  if (!compare) compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new _index.Selection(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
},{"./index.js":"../node_modules/d3-selection/src/selection/index.js"}],"../node_modules/d3-selection/src/selection/call.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
},{}],"../node_modules/d3-selection/src/selection/nodes.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default() {
  return Array.from(this);
}
},{}],"../node_modules/d3-selection/src/selection/node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
}
},{}],"../node_modules/d3-selection/src/selection/size.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _default() {
  var size = 0;
  var _iterator = _createForOfIteratorHelper(this),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var node = _step.value;
      ++size;
    } // eslint-disable-line no-unused-vars
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return size;
}
},{}],"../node_modules/d3-selection/src/selection/empty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default() {
  return !this.node();
}
},{}],"../node_modules/d3-selection/src/selection/each.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}
},{}],"../node_modules/d3-selection/src/selection/attr.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _namespace = _interopRequireDefault(require("../namespace.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function attrRemove(name) {
  return function () {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function () {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function () {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function _default(name, value) {
  var fullname = (0, _namespace.default)(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}
},{"../namespace.js":"../node_modules/d3-selection/src/namespace.js"}],"../node_modules/d3-selection/src/window.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView // node is a Node
  || node.document && node // node is a Window
  || node.defaultView; // node is a Document
}
},{}],"../node_modules/d3-selection/src/selection/style.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.styleValue = styleValue;
var _window = _interopRequireDefault(require("../window.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function styleRemove(name) {
  return function () {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function () {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);
  };
}
function _default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || (0, _window.default)(node).getComputedStyle(node, null).getPropertyValue(name);
}
},{"../window.js":"../node_modules/d3-selection/src/window.js"}],"../node_modules/d3-selection/src/selection/property.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function propertyRemove(name) {
  return function () {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function () {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];else this[name] = v;
  };
}
function _default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
},{}],"../node_modules/d3-selection/src/selection/classed.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function add(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function remove(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function contains(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node),
    i = -1,
    n = names.length;
  while (++i < n) list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node),
    i = -1,
    n = names.length;
  while (++i < n) list.remove(names[i]);
}
function classedTrue(names) {
  return function () {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function () {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function () {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function _default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()),
      i = -1,
      n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
},{}],"../node_modules/d3-selection/src/selection/text.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function () {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function _default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}
},{}],"../node_modules/d3-selection/src/selection/html.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function () {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function _default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
},{}],"../node_modules/d3-selection/src/selection/raise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function _default() {
  return this.each(raise);
}
},{}],"../node_modules/d3-selection/src/selection/lower.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function _default() {
  return this.each(lower);
}
},{}],"../node_modules/d3-selection/src/selection/append.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _creator = _interopRequireDefault(require("../creator.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(name) {
  var create = typeof name === "function" ? name : (0, _creator.default)(name);
  return this.select(function () {
    return this.appendChild(create.apply(this, arguments));
  });
}
},{"../creator.js":"../node_modules/d3-selection/src/creator.js"}],"../node_modules/d3-selection/src/selection/insert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _creator = _interopRequireDefault(require("../creator.js"));
var _selector = _interopRequireDefault(require("../selector.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function constantNull() {
  return null;
}
function _default(name, before) {
  var create = typeof name === "function" ? name : (0, _creator.default)(name),
    select = before == null ? constantNull : typeof before === "function" ? before : (0, _selector.default)(before);
  return this.select(function () {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}
},{"../creator.js":"../node_modules/d3-selection/src/creator.js","../selector.js":"../node_modules/d3-selection/src/selector.js"}],"../node_modules/d3-selection/src/selection/remove.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function _default() {
  return this.each(remove);
}
},{}],"../node_modules/d3-selection/src/selection/clone.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function selection_cloneShallow() {
  var clone = this.cloneNode(false),
    parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true),
    parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function _default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
},{}],"../node_modules/d3-selection/src/selection/datum.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
},{}],"../node_modules/d3-selection/src/selection/on.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function contextListener(listener) {
  return function (event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
      i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {
      type: t,
      name: name
    };
  });
}
function onRemove(typename) {
  return function () {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;else delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function () {
    var on = this.__on,
      o,
      listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {
      type: typename.type,
      name: typename.name,
      value: value,
      listener: listener,
      options: options
    };
    if (!on) this.__on = [o];else on.push(o);
  };
}
function _default(typename, value, options) {
  var typenames = parseTypenames(typename + ""),
    i,
    n = typenames.length,
    t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}
},{}],"../node_modules/d3-selection/src/selection/dispatch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _window = _interopRequireDefault(require("../window.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function dispatchEvent(node, type, params) {
  var window = (0, _window.default)(node),
    event = window.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function () {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function () {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function _default(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}
},{"../window.js":"../node_modules/d3-selection/src/window.js"}],"../node_modules/d3-selection/src/selection/iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _callee;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
var _marked = /*#__PURE__*/_regeneratorRuntime().mark(_callee);
function _callee() {
  var groups, j, m, group, i, n, node;
  return _regeneratorRuntime().wrap(function _callee$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        groups = this._groups, j = 0, m = groups.length;
      case 1:
        if (!(j < m)) {
          _context.next = 13;
          break;
        }
        group = groups[j], i = 0, n = group.length;
      case 3:
        if (!(i < n)) {
          _context.next = 10;
          break;
        }
        if (!(node = group[i])) {
          _context.next = 7;
          break;
        }
        _context.next = 7;
        return node;
      case 7:
        ++i;
        _context.next = 3;
        break;
      case 10:
        ++j;
        _context.next = 1;
        break;
      case 13:
      case "end":
        return _context.stop();
    }
  }, _marked, this);
}
},{}],"../node_modules/d3-selection/src/selection/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Selection = Selection;
exports.root = exports.default = void 0;
var _select = _interopRequireDefault(require("./select.js"));
var _selectAll = _interopRequireDefault(require("./selectAll.js"));
var _selectChild = _interopRequireDefault(require("./selectChild.js"));
var _selectChildren = _interopRequireDefault(require("./selectChildren.js"));
var _filter = _interopRequireDefault(require("./filter.js"));
var _data = _interopRequireDefault(require("./data.js"));
var _enter = _interopRequireDefault(require("./enter.js"));
var _exit = _interopRequireDefault(require("./exit.js"));
var _join = _interopRequireDefault(require("./join.js"));
var _merge = _interopRequireDefault(require("./merge.js"));
var _order = _interopRequireDefault(require("./order.js"));
var _sort = _interopRequireDefault(require("./sort.js"));
var _call = _interopRequireDefault(require("./call.js"));
var _nodes = _interopRequireDefault(require("./nodes.js"));
var _node = _interopRequireDefault(require("./node.js"));
var _size = _interopRequireDefault(require("./size.js"));
var _empty = _interopRequireDefault(require("./empty.js"));
var _each = _interopRequireDefault(require("./each.js"));
var _attr = _interopRequireDefault(require("./attr.js"));
var _style = _interopRequireDefault(require("./style.js"));
var _property = _interopRequireDefault(require("./property.js"));
var _classed = _interopRequireDefault(require("./classed.js"));
var _text = _interopRequireDefault(require("./text.js"));
var _html = _interopRequireDefault(require("./html.js"));
var _raise = _interopRequireDefault(require("./raise.js"));
var _lower = _interopRequireDefault(require("./lower.js"));
var _append = _interopRequireDefault(require("./append.js"));
var _insert = _interopRequireDefault(require("./insert.js"));
var _remove = _interopRequireDefault(require("./remove.js"));
var _clone = _interopRequireDefault(require("./clone.js"));
var _datum = _interopRequireDefault(require("./datum.js"));
var _on = _interopRequireDefault(require("./on.js"));
var _dispatch = _interopRequireDefault(require("./dispatch.js"));
var _iterator = _interopRequireDefault(require("./iterator.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var root = exports.root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = _defineProperty({
  constructor: Selection,
  select: _select.default,
  selectAll: _selectAll.default,
  selectChild: _selectChild.default,
  selectChildren: _selectChildren.default,
  filter: _filter.default,
  data: _data.default,
  enter: _enter.default,
  exit: _exit.default,
  join: _join.default,
  merge: _merge.default,
  selection: selection_selection,
  order: _order.default,
  sort: _sort.default,
  call: _call.default,
  nodes: _nodes.default,
  node: _node.default,
  size: _size.default,
  empty: _empty.default,
  each: _each.default,
  attr: _attr.default,
  style: _style.default,
  property: _property.default,
  classed: _classed.default,
  text: _text.default,
  html: _html.default,
  raise: _raise.default,
  lower: _lower.default,
  append: _append.default,
  insert: _insert.default,
  remove: _remove.default,
  clone: _clone.default,
  datum: _datum.default,
  on: _on.default,
  dispatch: _dispatch.default
}, Symbol.iterator, _iterator.default);
var _default = exports.default = selection;
},{"./select.js":"../node_modules/d3-selection/src/selection/select.js","./selectAll.js":"../node_modules/d3-selection/src/selection/selectAll.js","./selectChild.js":"../node_modules/d3-selection/src/selection/selectChild.js","./selectChildren.js":"../node_modules/d3-selection/src/selection/selectChildren.js","./filter.js":"../node_modules/d3-selection/src/selection/filter.js","./data.js":"../node_modules/d3-selection/src/selection/data.js","./enter.js":"../node_modules/d3-selection/src/selection/enter.js","./exit.js":"../node_modules/d3-selection/src/selection/exit.js","./join.js":"../node_modules/d3-selection/src/selection/join.js","./merge.js":"../node_modules/d3-selection/src/selection/merge.js","./order.js":"../node_modules/d3-selection/src/selection/order.js","./sort.js":"../node_modules/d3-selection/src/selection/sort.js","./call.js":"../node_modules/d3-selection/src/selection/call.js","./nodes.js":"../node_modules/d3-selection/src/selection/nodes.js","./node.js":"../node_modules/d3-selection/src/selection/node.js","./size.js":"../node_modules/d3-selection/src/selection/size.js","./empty.js":"../node_modules/d3-selection/src/selection/empty.js","./each.js":"../node_modules/d3-selection/src/selection/each.js","./attr.js":"../node_modules/d3-selection/src/selection/attr.js","./style.js":"../node_modules/d3-selection/src/selection/style.js","./property.js":"../node_modules/d3-selection/src/selection/property.js","./classed.js":"../node_modules/d3-selection/src/selection/classed.js","./text.js":"../node_modules/d3-selection/src/selection/text.js","./html.js":"../node_modules/d3-selection/src/selection/html.js","./raise.js":"../node_modules/d3-selection/src/selection/raise.js","./lower.js":"../node_modules/d3-selection/src/selection/lower.js","./append.js":"../node_modules/d3-selection/src/selection/append.js","./insert.js":"../node_modules/d3-selection/src/selection/insert.js","./remove.js":"../node_modules/d3-selection/src/selection/remove.js","./clone.js":"../node_modules/d3-selection/src/selection/clone.js","./datum.js":"../node_modules/d3-selection/src/selection/datum.js","./on.js":"../node_modules/d3-selection/src/selection/on.js","./dispatch.js":"../node_modules/d3-selection/src/selection/dispatch.js","./iterator.js":"../node_modules/d3-selection/src/selection/iterator.js"}],"../node_modules/d3-selection/src/select.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _index = require("./selection/index.js");
function _default(selector) {
  return typeof selector === "string" ? new _index.Selection([[document.querySelector(selector)]], [document.documentElement]) : new _index.Selection([[selector]], _index.root);
}
},{"./selection/index.js":"../node_modules/d3-selection/src/selection/index.js"}],"../node_modules/d3-selection/src/create.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _creator = _interopRequireDefault(require("./creator.js"));
var _select = _interopRequireDefault(require("./select.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(name) {
  return (0, _select.default)((0, _creator.default)(name).call(document.documentElement));
}
},{"./creator.js":"../node_modules/d3-selection/src/creator.js","./select.js":"../node_modules/d3-selection/src/select.js"}],"../node_modules/d3-selection/src/local.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = local;
var nextId = 0;
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
Local.prototype = local.prototype = {
  constructor: Local,
  get: function get(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function set(node, value) {
    return node[this._] = value;
  },
  remove: function remove(node) {
    return this._ in node && delete node[this._];
  },
  toString: function toString() {
    return this._;
  }
};
},{}],"../node_modules/d3-selection/src/sourceEvent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(event) {
  var sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}
},{}],"../node_modules/d3-selection/src/pointer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _sourceEvent = _interopRequireDefault(require("./sourceEvent.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(event, node) {
  event = (0, _sourceEvent.default)(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
},{"./sourceEvent.js":"../node_modules/d3-selection/src/sourceEvent.js"}],"../node_modules/d3-selection/src/pointers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _pointer = _interopRequireDefault(require("./pointer.js"));
var _sourceEvent = _interopRequireDefault(require("./sourceEvent.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(events, node) {
  if (events.target) {
    // i.e., instanceof Event, not TouchList or iterable
    events = (0, _sourceEvent.default)(events);
    if (node === undefined) node = events.currentTarget;
    events = events.touches || [events];
  }
  return Array.from(events, function (event) {
    return (0, _pointer.default)(event, node);
  });
}
},{"./pointer.js":"../node_modules/d3-selection/src/pointer.js","./sourceEvent.js":"../node_modules/d3-selection/src/sourceEvent.js"}],"../node_modules/d3-selection/src/selectAll.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _array = _interopRequireDefault(require("./array.js"));
var _index = require("./selection/index.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(selector) {
  return typeof selector === "string" ? new _index.Selection([document.querySelectorAll(selector)], [document.documentElement]) : new _index.Selection([(0, _array.default)(selector)], _index.root);
}
},{"./array.js":"../node_modules/d3-selection/src/array.js","./selection/index.js":"../node_modules/d3-selection/src/selection/index.js"}],"../node_modules/d3-selection/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "create", {
  enumerable: true,
  get: function () {
    return _create.default;
  }
});
Object.defineProperty(exports, "creator", {
  enumerable: true,
  get: function () {
    return _creator.default;
  }
});
Object.defineProperty(exports, "local", {
  enumerable: true,
  get: function () {
    return _local.default;
  }
});
Object.defineProperty(exports, "matcher", {
  enumerable: true,
  get: function () {
    return _matcher.default;
  }
});
Object.defineProperty(exports, "namespace", {
  enumerable: true,
  get: function () {
    return _namespace.default;
  }
});
Object.defineProperty(exports, "namespaces", {
  enumerable: true,
  get: function () {
    return _namespaces.default;
  }
});
Object.defineProperty(exports, "pointer", {
  enumerable: true,
  get: function () {
    return _pointer.default;
  }
});
Object.defineProperty(exports, "pointers", {
  enumerable: true,
  get: function () {
    return _pointers.default;
  }
});
Object.defineProperty(exports, "select", {
  enumerable: true,
  get: function () {
    return _select.default;
  }
});
Object.defineProperty(exports, "selectAll", {
  enumerable: true,
  get: function () {
    return _selectAll.default;
  }
});
Object.defineProperty(exports, "selection", {
  enumerable: true,
  get: function () {
    return _index.default;
  }
});
Object.defineProperty(exports, "selector", {
  enumerable: true,
  get: function () {
    return _selector.default;
  }
});
Object.defineProperty(exports, "selectorAll", {
  enumerable: true,
  get: function () {
    return _selectorAll.default;
  }
});
Object.defineProperty(exports, "style", {
  enumerable: true,
  get: function () {
    return _style.styleValue;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _window.default;
  }
});
var _create = _interopRequireDefault(require("./create.js"));
var _creator = _interopRequireDefault(require("./creator.js"));
var _local = _interopRequireDefault(require("./local.js"));
var _matcher = _interopRequireDefault(require("./matcher.js"));
var _namespace = _interopRequireDefault(require("./namespace.js"));
var _namespaces = _interopRequireDefault(require("./namespaces.js"));
var _pointer = _interopRequireDefault(require("./pointer.js"));
var _pointers = _interopRequireDefault(require("./pointers.js"));
var _select = _interopRequireDefault(require("./select.js"));
var _selectAll = _interopRequireDefault(require("./selectAll.js"));
var _index = _interopRequireDefault(require("./selection/index.js"));
var _selector = _interopRequireDefault(require("./selector.js"));
var _selectorAll = _interopRequireDefault(require("./selectorAll.js"));
var _style = require("./selection/style.js");
var _window = _interopRequireDefault(require("./window.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./create.js":"../node_modules/d3-selection/src/create.js","./creator.js":"../node_modules/d3-selection/src/creator.js","./local.js":"../node_modules/d3-selection/src/local.js","./matcher.js":"../node_modules/d3-selection/src/matcher.js","./namespace.js":"../node_modules/d3-selection/src/namespace.js","./namespaces.js":"../node_modules/d3-selection/src/namespaces.js","./pointer.js":"../node_modules/d3-selection/src/pointer.js","./pointers.js":"../node_modules/d3-selection/src/pointers.js","./select.js":"../node_modules/d3-selection/src/select.js","./selectAll.js":"../node_modules/d3-selection/src/selectAll.js","./selection/index.js":"../node_modules/d3-selection/src/selection/index.js","./selector.js":"../node_modules/d3-selection/src/selector.js","./selectorAll.js":"../node_modules/d3-selection/src/selectorAll.js","./selection/style.js":"../node_modules/d3-selection/src/selection/style.js","./window.js":"../node_modules/d3-selection/src/window.js"}],"../node_modules/d3-dispatch/src/dispatch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var noop = {
  value: function value() {}
};
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
      i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {
      type: t,
      name: name
    };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function on(typename, callback) {
    var _ = this._,
      T = parseTypenames(typename + "", _),
      t,
      i = -1,
      n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function copy() {
    var copy = {},
      _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function call(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function apply(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};
function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({
    name: name,
    value: callback
  });
  return type;
}
var _default = exports.default = dispatch;
},{}],"../node_modules/d3-dispatch/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "dispatch", {
  enumerable: true,
  get: function () {
    return _dispatch.default;
  }
});
var _dispatch = _interopRequireDefault(require("./dispatch.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./dispatch.js":"../node_modules/d3-dispatch/src/dispatch.js"}],"../node_modules/d3-timer/src/timer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Timer = Timer;
exports.now = now;
exports.timer = timer;
exports.timerFlush = timerFlush;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var frame = 0,
  // is an animation frame pending?
  timeout = 0,
  // is a timeout pending?
  interval = 0,
  // are any timers active?
  pokeDelay = 1000,
  // how frequently we check for clock skew
  taskHead,
  taskTail,
  clockLast = 0,
  clockNow = 0,
  clockSkew = 0,
  clock = (typeof performance === "undefined" ? "undefined" : _typeof(performance)) === "object" && performance.now ? performance : Date,
  setFrame = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
    setTimeout(f, 17);
  };
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function restart(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function stop() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead,
    e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now = clock.now(),
    delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}
function nap() {
  var t0,
    t1 = taskHead,
    t2,
    time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
},{}],"../node_modules/d3-timer/src/timeout.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _timer = require("./timer.js");
function _default(callback, delay, time) {
  var t = new _timer.Timer();
  delay = delay == null ? 0 : +delay;
  t.restart(function (elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}
},{"./timer.js":"../node_modules/d3-timer/src/timer.js"}],"../node_modules/d3-timer/src/interval.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _timer = require("./timer.js");
function _default(callback, delay, time) {
  var t = new _timer.Timer(),
    total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  t._restart = t.restart;
  t.restart = function (callback, delay, time) {
    delay = +delay, time = time == null ? (0, _timer.now)() : +time;
    t._restart(function tick(elapsed) {
      elapsed += total;
      t._restart(tick, total += delay, time);
      callback(elapsed);
    }, delay, time);
  };
  t.restart(callback, delay, time);
  return t;
}
},{"./timer.js":"../node_modules/d3-timer/src/timer.js"}],"../node_modules/d3-timer/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "interval", {
  enumerable: true,
  get: function () {
    return _interval.default;
  }
});
Object.defineProperty(exports, "now", {
  enumerable: true,
  get: function () {
    return _timer.now;
  }
});
Object.defineProperty(exports, "timeout", {
  enumerable: true,
  get: function () {
    return _timeout.default;
  }
});
Object.defineProperty(exports, "timer", {
  enumerable: true,
  get: function () {
    return _timer.timer;
  }
});
Object.defineProperty(exports, "timerFlush", {
  enumerable: true,
  get: function () {
    return _timer.timerFlush;
  }
});
var _timer = require("./timer.js");
var _timeout = _interopRequireDefault(require("./timeout.js"));
var _interval = _interopRequireDefault(require("./interval.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./timer.js":"../node_modules/d3-timer/src/timer.js","./timeout.js":"../node_modules/d3-timer/src/timeout.js","./interval.js":"../node_modules/d3-timer/src/interval.js"}],"../node_modules/d3-transition/src/transition/schedule.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.STARTING = exports.STARTED = exports.SCHEDULED = exports.RUNNING = exports.ENDING = exports.ENDED = exports.CREATED = void 0;
exports.default = _default;
exports.get = get;
exports.init = init;
exports.set = set;
var _d3Dispatch = require("d3-dispatch");
var _d3Timer = require("d3-timer");
var emptyOn = (0, _d3Dispatch.dispatch)("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = exports.CREATED = 0;
var SCHEDULED = exports.SCHEDULED = 1;
var STARTING = exports.STARTING = 2;
var STARTED = exports.STARTED = 3;
var RUNNING = exports.RUNNING = 4;
var ENDING = exports.ENDING = 5;
var ENDED = exports.ENDED = 6;
function _default(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index,
    // For context during callback.
    group: group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}
function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}
function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}
function create(node, id, self) {
  var schedules = node.__transition,
    tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = (0, _d3Timer.timer)(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }
  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return (0, _d3Timer.timeout)(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    (0, _d3Timer.timeout)(function () {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
      i = -1,
      n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}
},{"d3-dispatch":"../node_modules/d3-dispatch/src/index.js","d3-timer":"../node_modules/d3-timer/src/index.js"}],"../node_modules/d3-transition/src/interrupt.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _schedule = require("./transition/schedule.js");
function _default(node, name) {
  var schedules = node.__transition,
    schedule,
    active,
    empty = true,
    i;
  if (!schedules) return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty = false;
      continue;
    }
    active = schedule.state > _schedule.STARTING && schedule.state < _schedule.ENDING;
    schedule.state = _schedule.ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty) delete node.__transition;
}
},{"./transition/schedule.js":"../node_modules/d3-transition/src/transition/schedule.js"}],"../node_modules/d3-transition/src/selection/interrupt.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _interrupt = _interopRequireDefault(require("../interrupt.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(name) {
  return this.each(function () {
    (0, _interrupt.default)(this, name);
  });
}
},{"../interrupt.js":"../node_modules/d3-transition/src/interrupt.js"}],"../node_modules/d3-color/src/define.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.extend = extend;
function _default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
},{}],"../node_modules/d3-color/src/color.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Color = Color;
exports.Rgb = Rgb;
exports.darker = exports.brighter = void 0;
exports.default = color;
exports.hsl = hsl;
exports.hslConvert = hslConvert;
exports.rgb = rgb;
exports.rgbConvert = rgbConvert;
var _define = _interopRequireWildcard(require("./define.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function Color() {}
var _darker = exports.darker = 0.7;
var _brighter = exports.brighter = 1 / _darker;
var reI = "\\s*([+-]?\\d+)\\s*",
  reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
  reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
  reHex = /^#([0-9a-f]{3,8})$/,
  reRgbInteger = new RegExp("^rgb\\(".concat(reI, ",").concat(reI, ",").concat(reI, "\\)$")),
  reRgbPercent = new RegExp("^rgb\\(".concat(reP, ",").concat(reP, ",").concat(reP, "\\)$")),
  reRgbaInteger = new RegExp("^rgba\\(".concat(reI, ",").concat(reI, ",").concat(reI, ",").concat(reN, "\\)$")),
  reRgbaPercent = new RegExp("^rgba\\(".concat(reP, ",").concat(reP, ",").concat(reP, ",").concat(reN, "\\)$")),
  reHslPercent = new RegExp("^hsl\\(".concat(reN, ",").concat(reP, ",").concat(reP, "\\)$")),
  reHslaPercent = new RegExp("^hsla\\(".concat(reN, ",").concat(reP, ",").concat(reP, ",").concat(reN, "\\)$"));
var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};
(0, _define.default)(Color, color, {
  copy: function copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
  : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
  : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
  : l === 4 ? rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
  : null // invalid hex
  ) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
  : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
  : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
  : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
  : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
  : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
  : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
  : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
(0, _define.default)(Rgb, rgb, (0, _define.extend)(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function rgb() {
    return this;
  },
  clamp: function clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable: function displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#".concat(hex(this.r)).concat(hex(this.g)).concat(hex(this.b));
}
function rgb_formatHex8() {
  return "#".concat(hex(this.r)).concat(hex(this.g)).concat(hex(this.b)).concat(hex((isNaN(this.opacity) ? 1 : this.opacity) * 255));
}
function rgb_formatRgb() {
  var a = clampa(this.opacity);
  return "".concat(a === 1 ? "rgb(" : "rgba(").concat(clampi(this.r), ", ").concat(clampi(this.g), ", ").concat(clampi(this.b)).concat(a === 1 ? ")" : ", ".concat(a, ")"));
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
    g = o.g / 255,
    b = o.b / 255,
    min = Math.min(r, g, b),
    max = Math.max(r, g, b),
    h = NaN,
    s = max - min,
    l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
(0, _define.default)(Hsl, hsl, (0, _define.extend)(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
      s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
      l = this.l,
      m2 = l + (l < 0.5 ? l : 1 - l) * s,
      m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  clamp: function clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable: function displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl: function formatHsl() {
    var a = clampa(this.opacity);
    return "".concat(a === 1 ? "hsl(" : "hsla(").concat(clamph(this.h), ", ").concat(clampt(this.s) * 100, "%, ").concat(clampt(this.l) * 100, "%").concat(a === 1 ? ")" : ", ".concat(a, ")"));
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
},{"./define.js":"../node_modules/d3-color/src/define.js"}],"../node_modules/d3-color/src/math.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.radians = exports.degrees = void 0;
var radians = exports.radians = Math.PI / 180;
var degrees = exports.degrees = 180 / Math.PI;
},{}],"../node_modules/d3-color/src/lab.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Hcl = Hcl;
exports.Lab = Lab;
exports.default = lab;
exports.gray = gray;
exports.hcl = hcl;
exports.lch = lch;
var _define = _interopRequireWildcard(require("./define.js"));
var _color = require("./color.js");
var _math = require("./math.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
// https://observablehq.com/@mbostock/lab-and-rgb
var K = 18,
  Xn = 0.96422,
  Yn = 1,
  Zn = 0.82521,
  t0 = 4 / 29,
  t1 = 6 / 29,
  t2 = 3 * t1 * t1,
  t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color.Rgb)) o = (0, _color.rgbConvert)(o);
  var r = rgb2lrgb(o.r),
    g = rgb2lrgb(o.g),
    b = rgb2lrgb(o.b),
    y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn),
    x,
    z;
  if (r === g && g === b) x = z = y;else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}
function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
(0, _define.default)(Lab, lab, (0, _define.extend)(_color.Color, {
  brighter: function brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function rgb() {
    var y = (this.l + 16) / 116,
      x = isNaN(this.a) ? y : y + this.a / 500,
      z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color.Rgb(lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z), lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z), this.opacity);
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math.degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math.radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
(0, _define.default)(Hcl, hcl, (0, _define.extend)(_color.Color, {
  brighter: function brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function rgb() {
    return hcl2lab(this).rgb();
  }
}));
},{"./define.js":"../node_modules/d3-color/src/define.js","./color.js":"../node_modules/d3-color/src/color.js","./math.js":"../node_modules/d3-color/src/math.js"}],"../node_modules/d3-color/src/cubehelix.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cubehelix = Cubehelix;
exports.default = cubehelix;
var _define = _interopRequireWildcard(require("./define.js"));
var _color = require("./color.js");
var _math = require("./math.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var A = -0.14861,
  B = +1.78277,
  C = -0.29227,
  D = -0.90649,
  E = +1.97294,
  ED = E * D,
  EB = E * B,
  BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color.Rgb)) o = (0, _color.rgbConvert)(o);
  var r = o.r / 255,
    g = o.g / 255,
    b = o.b / 255,
    l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
    bl = b - l,
    k = (E * (g - l) - C * bl) / D,
    s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)),
    // NaN if l=0 or l=1
    h = s ? Math.atan2(k, bl) * _math.degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
(0, _define.default)(Cubehelix, cubehelix, (0, _define.extend)(_color.Color, {
  brighter: function brighter(k) {
    k = k == null ? _color.brighter : Math.pow(_color.brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _color.darker : Math.pow(_color.darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math.radians,
      l = +this.l,
      a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
      cosh = Math.cos(h),
      sinh = Math.sin(h);
    return new _color.Rgb(255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
  }
}));
},{"./define.js":"../node_modules/d3-color/src/define.js","./color.js":"../node_modules/d3-color/src/color.js","./math.js":"../node_modules/d3-color/src/math.js"}],"../node_modules/d3-color/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "color", {
  enumerable: true,
  get: function () {
    return _color.default;
  }
});
Object.defineProperty(exports, "cubehelix", {
  enumerable: true,
  get: function () {
    return _cubehelix.default;
  }
});
Object.defineProperty(exports, "gray", {
  enumerable: true,
  get: function () {
    return _lab.gray;
  }
});
Object.defineProperty(exports, "hcl", {
  enumerable: true,
  get: function () {
    return _lab.hcl;
  }
});
Object.defineProperty(exports, "hsl", {
  enumerable: true,
  get: function () {
    return _color.hsl;
  }
});
Object.defineProperty(exports, "lab", {
  enumerable: true,
  get: function () {
    return _lab.default;
  }
});
Object.defineProperty(exports, "lch", {
  enumerable: true,
  get: function () {
    return _lab.lch;
  }
});
Object.defineProperty(exports, "rgb", {
  enumerable: true,
  get: function () {
    return _color.rgb;
  }
});
var _color = _interopRequireWildcard(require("./color.js"));
var _lab = _interopRequireWildcard(require("./lab.js"));
var _cubehelix = _interopRequireDefault(require("./cubehelix.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
},{"./color.js":"../node_modules/d3-color/src/color.js","./lab.js":"../node_modules/d3-color/src/lab.js","./cubehelix.js":"../node_modules/d3-color/src/cubehelix.js"}],"../node_modules/d3-interpolate/src/basis.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.basis = basis;
exports.default = _default;
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1,
    t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function _default(values) {
  var n = values.length - 1;
  return function (t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
      v1 = values[i],
      v2 = values[i + 1],
      v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
      v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}
},{}],"../node_modules/d3-interpolate/src/basisClosed.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _basis = require("./basis.js");
function _default(values) {
  var n = values.length;
  return function (t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
      v0 = values[(i + n - 1) % n],
      v1 = values[i % n],
      v2 = values[(i + 1) % n],
      v3 = values[(i + 2) % n];
    return (0, _basis.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}
},{"./basis.js":"../node_modules/d3-interpolate/src/basis.js"}],"../node_modules/d3-interpolate/src/constant.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = exports.default = function _default(x) {
  return function () {
    return x;
  };
};
},{}],"../node_modules/d3-interpolate/src/color.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = nogamma;
exports.gamma = gamma;
exports.hue = hue;
var _constant = _interopRequireDefault(require("./constant.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function linear(a, d) {
  return function (t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0, _constant.default)(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function (a, b) {
    return b - a ? exponential(a, b, y) : (0, _constant.default)(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0, _constant.default)(isNaN(a) ? b : a);
}
},{"./constant.js":"../node_modules/d3-interpolate/src/constant.js"}],"../node_modules/d3-interpolate/src/rgb.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rgbBasisClosed = exports.rgbBasis = exports.default = void 0;
var _d3Color = require("d3-color");
var _basis = _interopRequireDefault(require("./basis.js"));
var _basisClosed = _interopRequireDefault(require("./basisClosed.js"));
var _color = _interopRequireWildcard(require("./color.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports.default = function rgbGamma(y) {
  var color = (0, _color.gamma)(y);
  function rgb(start, end) {
    var r = color((start = (0, _d3Color.rgb)(start)).r, (end = (0, _d3Color.rgb)(end)).r),
      g = color(start.g, end.g),
      b = color(start.b, end.b),
      opacity = (0, _color.default)(start.opacity, end.opacity);
    return function (t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb.gamma = rgbGamma;
  return rgb;
}(1);
function rgbSpline(spline) {
  return function (colors) {
    var n = colors.length,
      r = new Array(n),
      g = new Array(n),
      b = new Array(n),
      i,
      color;
    for (i = 0; i < n; ++i) {
      color = (0, _d3Color.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function (t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}
var rgbBasis = exports.rgbBasis = rgbSpline(_basis.default);
var rgbBasisClosed = exports.rgbBasisClosed = rgbSpline(_basisClosed.default);
},{"d3-color":"../node_modules/d3-color/src/index.js","./basis.js":"../node_modules/d3-interpolate/src/basis.js","./basisClosed.js":"../node_modules/d3-interpolate/src/basisClosed.js","./color.js":"../node_modules/d3-interpolate/src/color.js"}],"../node_modules/d3-interpolate/src/numberArray.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.isNumberArray = isNumberArray;
function _default(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
    c = b.slice(),
    i;
  return function (t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
},{}],"../node_modules/d3-interpolate/src/array.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.genericArray = genericArray;
var _value = _interopRequireDefault(require("./value.js"));
var _numberArray = _interopRequireWildcard(require("./numberArray.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(a, b) {
  return ((0, _numberArray.isNumberArray)(b) ? _numberArray.default : genericArray)(a, b);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0,
    na = a ? Math.min(nb, a.length) : 0,
    x = new Array(na),
    c = new Array(nb),
    i;
  for (i = 0; i < na; ++i) x[i] = (0, _value.default)(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];
  return function (t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}
},{"./value.js":"../node_modules/d3-interpolate/src/value.js","./numberArray.js":"../node_modules/d3-interpolate/src/numberArray.js"}],"../node_modules/d3-interpolate/src/date.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(a, b) {
  var d = new Date();
  return a = +a, b = +b, function (t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}
},{}],"../node_modules/d3-interpolate/src/number.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(a, b) {
  return a = +a, b = +b, function (t) {
    return a * (1 - t) + b * t;
  };
}
},{}],"../node_modules/d3-interpolate/src/object.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _value = _interopRequireDefault(require("./value.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _default(a, b) {
  var i = {},
    c = {},
    k;
  if (a === null || _typeof(a) !== "object") a = {};
  if (b === null || _typeof(b) !== "object") b = {};
  for (k in b) {
    if (k in a) {
      i[k] = (0, _value.default)(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function (t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}
},{"./value.js":"../node_modules/d3-interpolate/src/value.js"}],"../node_modules/d3-interpolate/src/string.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _number = _interopRequireDefault(require("./number.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
  reB = new RegExp(reA.source, "g");
function zero(b) {
  return function () {
    return b;
  };
}
function one(b) {
  return function (t) {
    return b(t) + "";
  };
}
function _default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0,
    // scan index for next number in b
    am,
    // current match in a
    bm,
    // current match in b
    bs,
    // string preceding current number in b, if any
    i = -1,
    // index in s
    s = [],
    // string constants and placeholders
    q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else {
      // interpolate non-matching numbers
      s[++i] = null;
      q.push({
        i: i,
        x: (0, _number.default)(am, bm)
      });
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
    for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
    return s.join("");
  });
}
},{"./number.js":"../node_modules/d3-interpolate/src/number.js"}],"../node_modules/d3-interpolate/src/value.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _d3Color = require("d3-color");
var _rgb = _interopRequireDefault(require("./rgb.js"));
var _array = require("./array.js");
var _date = _interopRequireDefault(require("./date.js"));
var _number = _interopRequireDefault(require("./number.js"));
var _object = _interopRequireDefault(require("./object.js"));
var _string = _interopRequireDefault(require("./string.js"));
var _constant = _interopRequireDefault(require("./constant.js"));
var _numberArray = _interopRequireWildcard(require("./numberArray.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _default(a, b) {
  var t = _typeof(b),
    c;
  return b == null || t === "boolean" ? (0, _constant.default)(b) : (t === "number" ? _number.default : t === "string" ? (c = (0, _d3Color.color)(b)) ? (b = c, _rgb.default) : _string.default : b instanceof _d3Color.color ? _rgb.default : b instanceof Date ? _date.default : (0, _numberArray.isNumberArray)(b) ? _numberArray.default : Array.isArray(b) ? _array.genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object.default : _number.default)(a, b);
}
},{"d3-color":"../node_modules/d3-color/src/index.js","./rgb.js":"../node_modules/d3-interpolate/src/rgb.js","./array.js":"../node_modules/d3-interpolate/src/array.js","./date.js":"../node_modules/d3-interpolate/src/date.js","./number.js":"../node_modules/d3-interpolate/src/number.js","./object.js":"../node_modules/d3-interpolate/src/object.js","./string.js":"../node_modules/d3-interpolate/src/string.js","./constant.js":"../node_modules/d3-interpolate/src/constant.js","./numberArray.js":"../node_modules/d3-interpolate/src/numberArray.js"}],"../node_modules/d3-interpolate/src/discrete.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(range) {
  var n = range.length;
  return function (t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
},{}],"../node_modules/d3-interpolate/src/hue.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _color = require("./color.js");
function _default(a, b) {
  var i = (0, _color.hue)(+a, +b);
  return function (t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}
},{"./color.js":"../node_modules/d3-interpolate/src/color.js"}],"../node_modules/d3-interpolate/src/round.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(a, b) {
  return a = +a, b = +b, function (t) {
    return Math.round(a * (1 - t) + b * t);
  };
}
},{}],"../node_modules/d3-interpolate/src/transform/decompose.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.identity = void 0;
var degrees = 180 / Math.PI;
var identity = exports.identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function _default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}
},{}],"../node_modules/d3-interpolate/src/transform/parse.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseCss = parseCss;
exports.parseSvg = parseSvg;
var _decompose = _interopRequireWildcard(require("./decompose.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  var m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose.identity : (0, _decompose.default)(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null) return _decompose.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose.identity;
  value = value.matrix;
  return (0, _decompose.default)(value.a, value.b, value.c, value.d, value.e, value.f);
}
},{"./decompose.js":"../node_modules/d3-interpolate/src/transform/decompose.js"}],"../node_modules/d3-interpolate/src/transform/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interpolateTransformSvg = exports.interpolateTransformCss = void 0;
var _number = _interopRequireDefault(require("../number.js"));
var _parse = require("./parse.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({
        i: i - 4,
        x: (0, _number.default)(xa, xb)
      }, {
        i: i - 2,
        x: (0, _number.default)(ya, yb)
      });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path
      q.push({
        i: s.push(pop(s) + "rotate(", null, degParen) - 2,
        x: (0, _number.default)(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({
        i: s.push(pop(s) + "skewX(", null, degParen) - 2,
        x: (0, _number.default)(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: (0, _number.default)(xa, xb)
      }, {
        i: i - 2,
        x: (0, _number.default)(ya, yb)
      });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function (a, b) {
    var s = [],
      // string constants and placeholders
      q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function (t) {
      var i = -1,
        n = q.length,
        o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = exports.interpolateTransformCss = interpolateTransform(_parse.parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = exports.interpolateTransformSvg = interpolateTransform(_parse.parseSvg, ", ", ")", ")");
},{"../number.js":"../node_modules/d3-interpolate/src/number.js","./parse.js":"../node_modules/d3-interpolate/src/transform/parse.js"}],"../node_modules/d3-interpolate/src/zoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var epsilon2 = 1e-12;
function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
var _default = exports.default = function zoomRho(rho, rho2, rho4) {
  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0],
      uy0 = p0[1],
      w0 = p0[2],
      ux1 = p1[0],
      uy1 = p1[1],
      w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function i(t) {
        return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
      };
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function i(t) {
        var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];
      };
    }
    i.duration = S * 1000 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function (_) {
    var _1 = Math.max(1e-3, +_),
      _2 = _1 * _1,
      _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);
},{}],"../node_modules/d3-interpolate/src/hsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hslLong = exports.default = void 0;
var _d3Color = require("d3-color");
var _color = _interopRequireWildcard(require("./color.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function hsl(hue) {
  return function (start, end) {
    var h = hue((start = (0, _d3Color.hsl)(start)).h, (end = (0, _d3Color.hsl)(end)).h),
      s = (0, _color.default)(start.s, end.s),
      l = (0, _color.default)(start.l, end.l),
      opacity = (0, _color.default)(start.opacity, end.opacity);
    return function (t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var _default = exports.default = hsl(_color.hue);
var hslLong = exports.hslLong = hsl(_color.default);
},{"d3-color":"../node_modules/d3-color/src/index.js","./color.js":"../node_modules/d3-interpolate/src/color.js"}],"../node_modules/d3-interpolate/src/lab.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = lab;
var _d3Color = require("d3-color");
var _color = _interopRequireDefault(require("./color.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function lab(start, end) {
  var l = (0, _color.default)((start = (0, _d3Color.lab)(start)).l, (end = (0, _d3Color.lab)(end)).l),
    a = (0, _color.default)(start.a, end.a),
    b = (0, _color.default)(start.b, end.b),
    opacity = (0, _color.default)(start.opacity, end.opacity);
  return function (t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}
},{"d3-color":"../node_modules/d3-color/src/index.js","./color.js":"../node_modules/d3-interpolate/src/color.js"}],"../node_modules/d3-interpolate/src/hcl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hclLong = exports.default = void 0;
var _d3Color = require("d3-color");
var _color = _interopRequireWildcard(require("./color.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function hcl(hue) {
  return function (start, end) {
    var h = hue((start = (0, _d3Color.hcl)(start)).h, (end = (0, _d3Color.hcl)(end)).h),
      c = (0, _color.default)(start.c, end.c),
      l = (0, _color.default)(start.l, end.l),
      opacity = (0, _color.default)(start.opacity, end.opacity);
    return function (t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var _default = exports.default = hcl(_color.hue);
var hclLong = exports.hclLong = hcl(_color.default);
},{"d3-color":"../node_modules/d3-color/src/index.js","./color.js":"../node_modules/d3-interpolate/src/color.js"}],"../node_modules/d3-interpolate/src/cubehelix.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.cubehelixLong = void 0;
var _d3Color = require("d3-color");
var _color = _interopRequireWildcard(require("./color.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function cubehelix(hue) {
  return function cubehelixGamma(y) {
    y = +y;
    function cubehelix(start, end) {
      var h = hue((start = (0, _d3Color.cubehelix)(start)).h, (end = (0, _d3Color.cubehelix)(end)).h),
        s = (0, _color.default)(start.s, end.s),
        l = (0, _color.default)(start.l, end.l),
        opacity = (0, _color.default)(start.opacity, end.opacity);
      return function (t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix.gamma = cubehelixGamma;
    return cubehelix;
  }(1);
}
var _default = exports.default = cubehelix(_color.hue);
var cubehelixLong = exports.cubehelixLong = cubehelix(_color.default);
},{"d3-color":"../node_modules/d3-color/src/index.js","./color.js":"../node_modules/d3-interpolate/src/color.js"}],"../node_modules/d3-interpolate/src/piecewise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = piecewise;
var _value = _interopRequireDefault(require("./value.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = _value.default;
  var i = 0,
    n = values.length - 1,
    v = values[0],
    I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function (t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}
},{"./value.js":"../node_modules/d3-interpolate/src/value.js"}],"../node_modules/d3-interpolate/src/quantize.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}
},{}],"../node_modules/d3-interpolate/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "interpolate", {
  enumerable: true,
  get: function () {
    return _value.default;
  }
});
Object.defineProperty(exports, "interpolateArray", {
  enumerable: true,
  get: function () {
    return _array.default;
  }
});
Object.defineProperty(exports, "interpolateBasis", {
  enumerable: true,
  get: function () {
    return _basis.default;
  }
});
Object.defineProperty(exports, "interpolateBasisClosed", {
  enumerable: true,
  get: function () {
    return _basisClosed.default;
  }
});
Object.defineProperty(exports, "interpolateCubehelix", {
  enumerable: true,
  get: function () {
    return _cubehelix.default;
  }
});
Object.defineProperty(exports, "interpolateCubehelixLong", {
  enumerable: true,
  get: function () {
    return _cubehelix.cubehelixLong;
  }
});
Object.defineProperty(exports, "interpolateDate", {
  enumerable: true,
  get: function () {
    return _date.default;
  }
});
Object.defineProperty(exports, "interpolateDiscrete", {
  enumerable: true,
  get: function () {
    return _discrete.default;
  }
});
Object.defineProperty(exports, "interpolateHcl", {
  enumerable: true,
  get: function () {
    return _hcl.default;
  }
});
Object.defineProperty(exports, "interpolateHclLong", {
  enumerable: true,
  get: function () {
    return _hcl.hclLong;
  }
});
Object.defineProperty(exports, "interpolateHsl", {
  enumerable: true,
  get: function () {
    return _hsl.default;
  }
});
Object.defineProperty(exports, "interpolateHslLong", {
  enumerable: true,
  get: function () {
    return _hsl.hslLong;
  }
});
Object.defineProperty(exports, "interpolateHue", {
  enumerable: true,
  get: function () {
    return _hue.default;
  }
});
Object.defineProperty(exports, "interpolateLab", {
  enumerable: true,
  get: function () {
    return _lab.default;
  }
});
Object.defineProperty(exports, "interpolateNumber", {
  enumerable: true,
  get: function () {
    return _number.default;
  }
});
Object.defineProperty(exports, "interpolateNumberArray", {
  enumerable: true,
  get: function () {
    return _numberArray.default;
  }
});
Object.defineProperty(exports, "interpolateObject", {
  enumerable: true,
  get: function () {
    return _object.default;
  }
});
Object.defineProperty(exports, "interpolateRgb", {
  enumerable: true,
  get: function () {
    return _rgb.default;
  }
});
Object.defineProperty(exports, "interpolateRgbBasis", {
  enumerable: true,
  get: function () {
    return _rgb.rgbBasis;
  }
});
Object.defineProperty(exports, "interpolateRgbBasisClosed", {
  enumerable: true,
  get: function () {
    return _rgb.rgbBasisClosed;
  }
});
Object.defineProperty(exports, "interpolateRound", {
  enumerable: true,
  get: function () {
    return _round.default;
  }
});
Object.defineProperty(exports, "interpolateString", {
  enumerable: true,
  get: function () {
    return _string.default;
  }
});
Object.defineProperty(exports, "interpolateTransformCss", {
  enumerable: true,
  get: function () {
    return _index.interpolateTransformCss;
  }
});
Object.defineProperty(exports, "interpolateTransformSvg", {
  enumerable: true,
  get: function () {
    return _index.interpolateTransformSvg;
  }
});
Object.defineProperty(exports, "interpolateZoom", {
  enumerable: true,
  get: function () {
    return _zoom.default;
  }
});
Object.defineProperty(exports, "piecewise", {
  enumerable: true,
  get: function () {
    return _piecewise.default;
  }
});
Object.defineProperty(exports, "quantize", {
  enumerable: true,
  get: function () {
    return _quantize.default;
  }
});
var _value = _interopRequireDefault(require("./value.js"));
var _array = _interopRequireDefault(require("./array.js"));
var _basis = _interopRequireDefault(require("./basis.js"));
var _basisClosed = _interopRequireDefault(require("./basisClosed.js"));
var _date = _interopRequireDefault(require("./date.js"));
var _discrete = _interopRequireDefault(require("./discrete.js"));
var _hue = _interopRequireDefault(require("./hue.js"));
var _number = _interopRequireDefault(require("./number.js"));
var _numberArray = _interopRequireDefault(require("./numberArray.js"));
var _object = _interopRequireDefault(require("./object.js"));
var _round = _interopRequireDefault(require("./round.js"));
var _string = _interopRequireDefault(require("./string.js"));
var _index = require("./transform/index.js");
var _zoom = _interopRequireDefault(require("./zoom.js"));
var _rgb = _interopRequireWildcard(require("./rgb.js"));
var _hsl = _interopRequireWildcard(require("./hsl.js"));
var _lab = _interopRequireDefault(require("./lab.js"));
var _hcl = _interopRequireWildcard(require("./hcl.js"));
var _cubehelix = _interopRequireWildcard(require("./cubehelix.js"));
var _piecewise = _interopRequireDefault(require("./piecewise.js"));
var _quantize = _interopRequireDefault(require("./quantize.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./value.js":"../node_modules/d3-interpolate/src/value.js","./array.js":"../node_modules/d3-interpolate/src/array.js","./basis.js":"../node_modules/d3-interpolate/src/basis.js","./basisClosed.js":"../node_modules/d3-interpolate/src/basisClosed.js","./date.js":"../node_modules/d3-interpolate/src/date.js","./discrete.js":"../node_modules/d3-interpolate/src/discrete.js","./hue.js":"../node_modules/d3-interpolate/src/hue.js","./number.js":"../node_modules/d3-interpolate/src/number.js","./numberArray.js":"../node_modules/d3-interpolate/src/numberArray.js","./object.js":"../node_modules/d3-interpolate/src/object.js","./round.js":"../node_modules/d3-interpolate/src/round.js","./string.js":"../node_modules/d3-interpolate/src/string.js","./transform/index.js":"../node_modules/d3-interpolate/src/transform/index.js","./zoom.js":"../node_modules/d3-interpolate/src/zoom.js","./rgb.js":"../node_modules/d3-interpolate/src/rgb.js","./hsl.js":"../node_modules/d3-interpolate/src/hsl.js","./lab.js":"../node_modules/d3-interpolate/src/lab.js","./hcl.js":"../node_modules/d3-interpolate/src/hcl.js","./cubehelix.js":"../node_modules/d3-interpolate/src/cubehelix.js","./piecewise.js":"../node_modules/d3-interpolate/src/piecewise.js","./quantize.js":"../node_modules/d3-interpolate/src/quantize.js"}],"../node_modules/d3-transition/src/transition/tween.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.tweenValue = tweenValue;
var _schedule = require("./schedule.js");
function tweenRemove(id, name) {
  var tween0, tween1;
  return function () {
    var schedule = (0, _schedule.set)(this, id),
      tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function () {
    var schedule = (0, _schedule.set)(this, id),
      tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {
          name: name,
          value: value
        }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function _default(name, value) {
  var id = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = (0, _schedule.get)(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}
function tweenValue(transition, name, value) {
  var id = transition._id;
  transition.each(function () {
    var schedule = (0, _schedule.set)(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function (node) {
    return (0, _schedule.get)(node, id).value[name];
  };
}
},{"./schedule.js":"../node_modules/d3-transition/src/transition/schedule.js"}],"../node_modules/d3-transition/src/transition/interpolate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _d3Color = require("d3-color");
var _d3Interpolate = require("d3-interpolate");
function _default(a, b) {
  var c;
  return (typeof b === "number" ? _d3Interpolate.interpolateNumber : b instanceof _d3Color.color ? _d3Interpolate.interpolateRgb : (c = (0, _d3Color.color)(b)) ? (b = c, _d3Interpolate.interpolateRgb) : _d3Interpolate.interpolateString)(a, b);
}
},{"d3-color":"../node_modules/d3-color/src/index.js","d3-interpolate":"../node_modules/d3-interpolate/src/index.js"}],"../node_modules/d3-transition/src/transition/attr.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _d3Interpolate = require("d3-interpolate");
var _d3Selection = require("d3-selection");
var _tween = require("./tween.js");
var _interpolate = _interopRequireDefault(require("./interpolate.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function attrRemove(name) {
  return function () {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, interpolate, value1) {
  var string00,
    string1 = value1 + "",
    interpolate0;
  return function () {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate, value1) {
  var string00,
    string1 = value1 + "",
    interpolate0;
  return function () {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function () {
    var string0,
      value1 = value(this),
      string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function () {
    var string0,
      value1 = value(this),
      string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function _default(name, value) {
  var fullname = (0, _d3Selection.namespace)(name),
    i = fullname === "transform" ? _d3Interpolate.interpolateTransformSvg : _interpolate.default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, (0, _tween.tweenValue)(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}
},{"d3-interpolate":"../node_modules/d3-interpolate/src/index.js","d3-selection":"../node_modules/d3-selection/src/index.js","./tween.js":"../node_modules/d3-transition/src/transition/tween.js","./interpolate.js":"../node_modules/d3-transition/src/transition/interpolate.js"}],"../node_modules/d3-transition/src/transition/attrTween.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _d3Selection = require("d3-selection");
function attrInterpolate(name, i) {
  return function (t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function (t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function _default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = (0, _d3Selection.namespace)(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
},{"d3-selection":"../node_modules/d3-selection/src/index.js"}],"../node_modules/d3-transition/src/transition/delay.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _schedule = require("./schedule.js");
function delayFunction(id, value) {
  return function () {
    (0, _schedule.init)(this, id).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id, value) {
  return value = +value, function () {
    (0, _schedule.init)(this, id).delay = value;
  };
}
function _default(value) {
  var id = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id, value)) : (0, _schedule.get)(this.node(), id).delay;
}
},{"./schedule.js":"../node_modules/d3-transition/src/transition/schedule.js"}],"../node_modules/d3-transition/src/transition/duration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _schedule = require("./schedule.js");
function durationFunction(id, value) {
  return function () {
    (0, _schedule.set)(this, id).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id, value) {
  return value = +value, function () {
    (0, _schedule.set)(this, id).duration = value;
  };
}
function _default(value) {
  var id = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id, value)) : (0, _schedule.get)(this.node(), id).duration;
}
},{"./schedule.js":"../node_modules/d3-transition/src/transition/schedule.js"}],"../node_modules/d3-transition/src/transition/ease.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _schedule = require("./schedule.js");
function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error();
  return function () {
    (0, _schedule.set)(this, id).ease = value;
  };
}
function _default(value) {
  var id = this._id;
  return arguments.length ? this.each(easeConstant(id, value)) : (0, _schedule.get)(this.node(), id).ease;
}
},{"./schedule.js":"../node_modules/d3-transition/src/transition/schedule.js"}],"../node_modules/d3-transition/src/transition/easeVarying.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _schedule = require("./schedule.js");
function easeVarying(id, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error();
    (0, _schedule.set)(this, id).ease = v;
  };
}
function _default(value) {
  if (typeof value !== "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}
},{"./schedule.js":"../node_modules/d3-transition/src/transition/schedule.js"}],"../node_modules/d3-transition/src/transition/filter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _d3Selection = require("d3-selection");
var _index = require("./index.js");
function _default(match) {
  if (typeof match !== "function") match = (0, _d3Selection.matcher)(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new _index.Transition(subgroups, this._parents, this._name, this._id);
}
},{"d3-selection":"../node_modules/d3-selection/src/index.js","./index.js":"../node_modules/d3-transition/src/transition/index.js"}],"../node_modules/d3-transition/src/transition/merge.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _index = require("./index.js");
function _default(transition) {
  if (transition._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new _index.Transition(merges, this._parents, this._name, this._id);
}
},{"./index.js":"../node_modules/d3-transition/src/transition/index.js"}],"../node_modules/d3-transition/src/transition/on.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _schedule = require("./schedule.js");
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function (t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id, name, listener) {
  var on0,
    on1,
    sit = start(name) ? _schedule.init : _schedule.set;
  return function () {
    var schedule = sit(this, id),
      on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function _default(name, listener) {
  var id = this._id;
  return arguments.length < 2 ? (0, _schedule.get)(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));
}
},{"./schedule.js":"../node_modules/d3-transition/src/transition/schedule.js"}],"../node_modules/d3-transition/src/transition/remove.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function removeFunction(id) {
  return function () {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}
function _default() {
  return this.on("end.remove", removeFunction(this._id));
}
},{}],"../node_modules/d3-transition/src/transition/select.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _d3Selection = require("d3-selection");
var _index = require("./index.js");
var _schedule = _interopRequireWildcard(require("./schedule.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _default(select) {
  var name = this._name,
    id = this._id;
  if (typeof select !== "function") select = (0, _d3Selection.selector)(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        (0, _schedule.default)(subgroup[i], name, id, i, subgroup, (0, _schedule.get)(node, id));
      }
    }
  }
  return new _index.Transition(subgroups, this._parents, name, id);
}
},{"d3-selection":"../node_modules/d3-selection/src/index.js","./index.js":"../node_modules/d3-transition/src/transition/index.js","./schedule.js":"../node_modules/d3-transition/src/transition/schedule.js"}],"../node_modules/d3-transition/src/transition/selectAll.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _d3Selection = require("d3-selection");
var _index = require("./index.js");
var _schedule = _interopRequireWildcard(require("./schedule.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _default(select) {
  var name = this._name,
    id = this._id;
  if (typeof select !== "function") select = (0, _d3Selection.selectorAll)(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = (0, _schedule.get)(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            (0, _schedule.default)(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }
  return new _index.Transition(subgroups, parents, name, id);
}
},{"d3-selection":"../node_modules/d3-selection/src/index.js","./index.js":"../node_modules/d3-transition/src/transition/index.js","./schedule.js":"../node_modules/d3-transition/src/transition/schedule.js"}],"../node_modules/d3-transition/src/transition/selection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _d3Selection = require("d3-selection");
var Selection = _d3Selection.selection.prototype.constructor;
function _default() {
  return new Selection(this._groups, this._parents);
}
},{"d3-selection":"../node_modules/d3-selection/src/index.js"}],"../node_modules/d3-transition/src/transition/style.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _d3Interpolate = require("d3-interpolate");
var _d3Selection = require("d3-selection");
var _schedule = require("./schedule.js");
var _tween = require("./tween.js");
var _interpolate = _interopRequireDefault(require("./interpolate.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function () {
    var string0 = (0, _d3Selection.style)(this, name),
      string1 = (this.style.removeProperty(name), (0, _d3Selection.style)(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove(name) {
  return function () {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, interpolate, value1) {
  var string00,
    string1 = value1 + "",
    interpolate0;
  return function () {
    var string0 = (0, _d3Selection.style)(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function () {
    var string0 = (0, _d3Selection.style)(this, name),
      value1 = value(this),
      string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), (0, _d3Selection.style)(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id, name) {
  var on0,
    on1,
    listener0,
    key = "style." + name,
    event = "end." + key,
    remove;
  return function () {
    var schedule = (0, _schedule.set)(this, id),
      on = schedule.on,
      listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function _default(name, value, priority) {
  var i = (name += "") === "transform" ? _d3Interpolate.interpolateTransformCss : _interpolate.default;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i, (0, _tween.tweenValue)(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i, value), priority).on("end.style." + name, null);
}
},{"d3-interpolate":"../node_modules/d3-interpolate/src/index.js","d3-selection":"../node_modules/d3-selection/src/index.js","./schedule.js":"../node_modules/d3-transition/src/transition/schedule.js","./tween.js":"../node_modules/d3-transition/src/transition/tween.js","./interpolate.js":"../node_modules/d3-transition/src/transition/interpolate.js"}],"../node_modules/d3-transition/src/transition/styleTween.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function styleInterpolate(name, i, priority) {
  return function (t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function _default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}
},{}],"../node_modules/d3-transition/src/transition/text.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _tween = require("./tween.js");
function textConstant(value) {
  return function () {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function () {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function _default(value) {
  return this.tween("text", typeof value === "function" ? textFunction((0, _tween.tweenValue)(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}
},{"./tween.js":"../node_modules/d3-transition/src/transition/tween.js"}],"../node_modules/d3-transition/src/transition/textTween.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function textInterpolate(i) {
  return function (t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function _default(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, textTween(value));
}
},{}],"../node_modules/d3-transition/src/transition/transition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _index = require("./index.js");
var _schedule = _interopRequireWildcard(require("./schedule.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _default() {
  var name = this._name,
    id0 = this._id,
    id1 = (0, _index.newId)();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = (0, _schedule.get)(node, id0);
        (0, _schedule.default)(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }
  return new _index.Transition(groups, this._parents, name, id1);
}
},{"./index.js":"../node_modules/d3-transition/src/transition/index.js","./schedule.js":"../node_modules/d3-transition/src/transition/schedule.js"}],"../node_modules/d3-transition/src/transition/end.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _schedule = require("./schedule.js");
function _default() {
  var on0,
    on1,
    that = this,
    id = that._id,
    size = that.size();
  return new Promise(function (resolve, reject) {
    var cancel = {
        value: reject
      },
      end = {
        value: function value() {
          if (--size === 0) resolve();
        }
      };
    that.each(function () {
      var schedule = (0, _schedule.set)(this, id),
        on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}
},{"./schedule.js":"../node_modules/d3-transition/src/transition/schedule.js"}],"../node_modules/d3-transition/src/transition/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transition = Transition;
exports.default = transition;
exports.newId = newId;
var _d3Selection = require("d3-selection");
var _attr = _interopRequireDefault(require("./attr.js"));
var _attrTween = _interopRequireDefault(require("./attrTween.js"));
var _delay = _interopRequireDefault(require("./delay.js"));
var _duration = _interopRequireDefault(require("./duration.js"));
var _ease = _interopRequireDefault(require("./ease.js"));
var _easeVarying = _interopRequireDefault(require("./easeVarying.js"));
var _filter = _interopRequireDefault(require("./filter.js"));
var _merge = _interopRequireDefault(require("./merge.js"));
var _on = _interopRequireDefault(require("./on.js"));
var _remove = _interopRequireDefault(require("./remove.js"));
var _select = _interopRequireDefault(require("./select.js"));
var _selectAll = _interopRequireDefault(require("./selectAll.js"));
var _selection = _interopRequireDefault(require("./selection.js"));
var _style = _interopRequireDefault(require("./style.js"));
var _styleTween = _interopRequireDefault(require("./styleTween.js"));
var _text = _interopRequireDefault(require("./text.js"));
var _textTween = _interopRequireDefault(require("./textTween.js"));
var _transition = _interopRequireDefault(require("./transition.js"));
var _tween = _interopRequireDefault(require("./tween.js"));
var _end = _interopRequireDefault(require("./end.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var id = 0;
function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}
function transition(name) {
  return (0, _d3Selection.selection)().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = _d3Selection.selection.prototype;
Transition.prototype = transition.prototype = _defineProperty({
  constructor: Transition,
  select: _select.default,
  selectAll: _selectAll.default,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter.default,
  merge: _merge.default,
  selection: _selection.default,
  transition: _transition.default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on.default,
  attr: _attr.default,
  attrTween: _attrTween.default,
  style: _style.default,
  styleTween: _styleTween.default,
  text: _text.default,
  textTween: _textTween.default,
  remove: _remove.default,
  tween: _tween.default,
  delay: _delay.default,
  duration: _duration.default,
  ease: _ease.default,
  easeVarying: _easeVarying.default,
  end: _end.default
}, Symbol.iterator, selection_prototype[Symbol.iterator]);
},{"d3-selection":"../node_modules/d3-selection/src/index.js","./attr.js":"../node_modules/d3-transition/src/transition/attr.js","./attrTween.js":"../node_modules/d3-transition/src/transition/attrTween.js","./delay.js":"../node_modules/d3-transition/src/transition/delay.js","./duration.js":"../node_modules/d3-transition/src/transition/duration.js","./ease.js":"../node_modules/d3-transition/src/transition/ease.js","./easeVarying.js":"../node_modules/d3-transition/src/transition/easeVarying.js","./filter.js":"../node_modules/d3-transition/src/transition/filter.js","./merge.js":"../node_modules/d3-transition/src/transition/merge.js","./on.js":"../node_modules/d3-transition/src/transition/on.js","./remove.js":"../node_modules/d3-transition/src/transition/remove.js","./select.js":"../node_modules/d3-transition/src/transition/select.js","./selectAll.js":"../node_modules/d3-transition/src/transition/selectAll.js","./selection.js":"../node_modules/d3-transition/src/transition/selection.js","./style.js":"../node_modules/d3-transition/src/transition/style.js","./styleTween.js":"../node_modules/d3-transition/src/transition/styleTween.js","./text.js":"../node_modules/d3-transition/src/transition/text.js","./textTween.js":"../node_modules/d3-transition/src/transition/textTween.js","./transition.js":"../node_modules/d3-transition/src/transition/transition.js","./tween.js":"../node_modules/d3-transition/src/transition/tween.js","./end.js":"../node_modules/d3-transition/src/transition/end.js"}],"../node_modules/d3-ease/src/linear.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linear = void 0;
var linear = exports.linear = function linear(t) {
  return +t;
};
},{}],"../node_modules/d3-ease/src/quad.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.quadIn = quadIn;
exports.quadInOut = quadInOut;
exports.quadOut = quadOut;
function quadIn(t) {
  return t * t;
}
function quadOut(t) {
  return t * (2 - t);
}
function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}
},{}],"../node_modules/d3-ease/src/cubic.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cubicIn = cubicIn;
exports.cubicInOut = cubicInOut;
exports.cubicOut = cubicOut;
function cubicIn(t) {
  return t * t * t;
}
function cubicOut(t) {
  return --t * t * t + 1;
}
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
},{}],"../node_modules/d3-ease/src/poly.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polyOut = exports.polyInOut = exports.polyIn = void 0;
var exponent = 3;
var polyIn = exports.polyIn = function custom(e) {
  e = +e;
  function polyIn(t) {
    return Math.pow(t, e);
  }
  polyIn.exponent = custom;
  return polyIn;
}(exponent);
var polyOut = exports.polyOut = function custom(e) {
  e = +e;
  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }
  polyOut.exponent = custom;
  return polyOut;
}(exponent);
var polyInOut = exports.polyInOut = function custom(e) {
  e = +e;
  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }
  polyInOut.exponent = custom;
  return polyInOut;
}(exponent);
},{}],"../node_modules/d3-ease/src/sin.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sinIn = sinIn;
exports.sinInOut = sinInOut;
exports.sinOut = sinOut;
var pi = Math.PI,
  halfPi = pi / 2;
function sinIn(t) {
  return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
}
function sinOut(t) {
  return Math.sin(t * halfPi);
}
function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}
},{}],"../node_modules/d3-ease/src/math.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tpmt = tpmt;
// tpmt is two power minus ten times t scaled to [0,1]
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
}
},{}],"../node_modules/d3-ease/src/exp.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.expIn = expIn;
exports.expInOut = expInOut;
exports.expOut = expOut;
var _math = require("./math.js");
function expIn(t) {
  return (0, _math.tpmt)(1 - +t);
}
function expOut(t) {
  return 1 - (0, _math.tpmt)(t);
}
function expInOut(t) {
  return ((t *= 2) <= 1 ? (0, _math.tpmt)(1 - t) : 2 - (0, _math.tpmt)(t - 1)) / 2;
}
},{"./math.js":"../node_modules/d3-ease/src/math.js"}],"../node_modules/d3-ease/src/circle.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.circleIn = circleIn;
exports.circleInOut = circleInOut;
exports.circleOut = circleOut;
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}
function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}
function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}
},{}],"../node_modules/d3-ease/src/bounce.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bounceIn = bounceIn;
exports.bounceInOut = bounceInOut;
exports.bounceOut = bounceOut;
var b1 = 4 / 11,
  b2 = 6 / 11,
  b3 = 8 / 11,
  b4 = 3 / 4,
  b5 = 9 / 11,
  b6 = 10 / 11,
  b7 = 15 / 16,
  b8 = 21 / 22,
  b9 = 63 / 64,
  b0 = 1 / b1 / b1;
function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}
function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}
function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}
},{}],"../node_modules/d3-ease/src/back.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backOut = exports.backInOut = exports.backIn = void 0;
var overshoot = 1.70158;
var backIn = exports.backIn = function custom(s) {
  s = +s;
  function backIn(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }
  backIn.overshoot = custom;
  return backIn;
}(overshoot);
var backOut = exports.backOut = function custom(s) {
  s = +s;
  function backOut(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }
  backOut.overshoot = custom;
  return backOut;
}(overshoot);
var backInOut = exports.backInOut = function custom(s) {
  s = +s;
  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }
  backInOut.overshoot = custom;
  return backInOut;
}(overshoot);
},{}],"../node_modules/d3-ease/src/elastic.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.elasticOut = exports.elasticInOut = exports.elasticIn = void 0;
var _math = require("./math.js");
var tau = 2 * Math.PI,
  amplitude = 1,
  period = 0.3;
var elasticIn = exports.elasticIn = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticIn(t) {
    return a * (0, _math.tpmt)(- --t) * Math.sin((s - t) / p);
  }
  elasticIn.amplitude = function (a) {
    return custom(a, p * tau);
  };
  elasticIn.period = function (p) {
    return custom(a, p);
  };
  return elasticIn;
}(amplitude, period);
var elasticOut = exports.elasticOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticOut(t) {
    return 1 - a * (0, _math.tpmt)(t = +t) * Math.sin((t + s) / p);
  }
  elasticOut.amplitude = function (a) {
    return custom(a, p * tau);
  };
  elasticOut.period = function (p) {
    return custom(a, p);
  };
  return elasticOut;
}(amplitude, period);
var elasticInOut = exports.elasticInOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0 ? a * (0, _math.tpmt)(-t) * Math.sin((s - t) / p) : 2 - a * (0, _math.tpmt)(t) * Math.sin((s + t) / p)) / 2;
  }
  elasticInOut.amplitude = function (a) {
    return custom(a, p * tau);
  };
  elasticInOut.period = function (p) {
    return custom(a, p);
  };
  return elasticInOut;
}(amplitude, period);
},{"./math.js":"../node_modules/d3-ease/src/math.js"}],"../node_modules/d3-ease/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "easeBack", {
  enumerable: true,
  get: function () {
    return _back.backInOut;
  }
});
Object.defineProperty(exports, "easeBackIn", {
  enumerable: true,
  get: function () {
    return _back.backIn;
  }
});
Object.defineProperty(exports, "easeBackInOut", {
  enumerable: true,
  get: function () {
    return _back.backInOut;
  }
});
Object.defineProperty(exports, "easeBackOut", {
  enumerable: true,
  get: function () {
    return _back.backOut;
  }
});
Object.defineProperty(exports, "easeBounce", {
  enumerable: true,
  get: function () {
    return _bounce.bounceOut;
  }
});
Object.defineProperty(exports, "easeBounceIn", {
  enumerable: true,
  get: function () {
    return _bounce.bounceIn;
  }
});
Object.defineProperty(exports, "easeBounceInOut", {
  enumerable: true,
  get: function () {
    return _bounce.bounceInOut;
  }
});
Object.defineProperty(exports, "easeBounceOut", {
  enumerable: true,
  get: function () {
    return _bounce.bounceOut;
  }
});
Object.defineProperty(exports, "easeCircle", {
  enumerable: true,
  get: function () {
    return _circle.circleInOut;
  }
});
Object.defineProperty(exports, "easeCircleIn", {
  enumerable: true,
  get: function () {
    return _circle.circleIn;
  }
});
Object.defineProperty(exports, "easeCircleInOut", {
  enumerable: true,
  get: function () {
    return _circle.circleInOut;
  }
});
Object.defineProperty(exports, "easeCircleOut", {
  enumerable: true,
  get: function () {
    return _circle.circleOut;
  }
});
Object.defineProperty(exports, "easeCubic", {
  enumerable: true,
  get: function () {
    return _cubic.cubicInOut;
  }
});
Object.defineProperty(exports, "easeCubicIn", {
  enumerable: true,
  get: function () {
    return _cubic.cubicIn;
  }
});
Object.defineProperty(exports, "easeCubicInOut", {
  enumerable: true,
  get: function () {
    return _cubic.cubicInOut;
  }
});
Object.defineProperty(exports, "easeCubicOut", {
  enumerable: true,
  get: function () {
    return _cubic.cubicOut;
  }
});
Object.defineProperty(exports, "easeElastic", {
  enumerable: true,
  get: function () {
    return _elastic.elasticOut;
  }
});
Object.defineProperty(exports, "easeElasticIn", {
  enumerable: true,
  get: function () {
    return _elastic.elasticIn;
  }
});
Object.defineProperty(exports, "easeElasticInOut", {
  enumerable: true,
  get: function () {
    return _elastic.elasticInOut;
  }
});
Object.defineProperty(exports, "easeElasticOut", {
  enumerable: true,
  get: function () {
    return _elastic.elasticOut;
  }
});
Object.defineProperty(exports, "easeExp", {
  enumerable: true,
  get: function () {
    return _exp.expInOut;
  }
});
Object.defineProperty(exports, "easeExpIn", {
  enumerable: true,
  get: function () {
    return _exp.expIn;
  }
});
Object.defineProperty(exports, "easeExpInOut", {
  enumerable: true,
  get: function () {
    return _exp.expInOut;
  }
});
Object.defineProperty(exports, "easeExpOut", {
  enumerable: true,
  get: function () {
    return _exp.expOut;
  }
});
Object.defineProperty(exports, "easeLinear", {
  enumerable: true,
  get: function () {
    return _linear.linear;
  }
});
Object.defineProperty(exports, "easePoly", {
  enumerable: true,
  get: function () {
    return _poly.polyInOut;
  }
});
Object.defineProperty(exports, "easePolyIn", {
  enumerable: true,
  get: function () {
    return _poly.polyIn;
  }
});
Object.defineProperty(exports, "easePolyInOut", {
  enumerable: true,
  get: function () {
    return _poly.polyInOut;
  }
});
Object.defineProperty(exports, "easePolyOut", {
  enumerable: true,
  get: function () {
    return _poly.polyOut;
  }
});
Object.defineProperty(exports, "easeQuad", {
  enumerable: true,
  get: function () {
    return _quad.quadInOut;
  }
});
Object.defineProperty(exports, "easeQuadIn", {
  enumerable: true,
  get: function () {
    return _quad.quadIn;
  }
});
Object.defineProperty(exports, "easeQuadInOut", {
  enumerable: true,
  get: function () {
    return _quad.quadInOut;
  }
});
Object.defineProperty(exports, "easeQuadOut", {
  enumerable: true,
  get: function () {
    return _quad.quadOut;
  }
});
Object.defineProperty(exports, "easeSin", {
  enumerable: true,
  get: function () {
    return _sin.sinInOut;
  }
});
Object.defineProperty(exports, "easeSinIn", {
  enumerable: true,
  get: function () {
    return _sin.sinIn;
  }
});
Object.defineProperty(exports, "easeSinInOut", {
  enumerable: true,
  get: function () {
    return _sin.sinInOut;
  }
});
Object.defineProperty(exports, "easeSinOut", {
  enumerable: true,
  get: function () {
    return _sin.sinOut;
  }
});
var _linear = require("./linear.js");
var _quad = require("./quad.js");
var _cubic = require("./cubic.js");
var _poly = require("./poly.js");
var _sin = require("./sin.js");
var _exp = require("./exp.js");
var _circle = require("./circle.js");
var _bounce = require("./bounce.js");
var _back = require("./back.js");
var _elastic = require("./elastic.js");
},{"./linear.js":"../node_modules/d3-ease/src/linear.js","./quad.js":"../node_modules/d3-ease/src/quad.js","./cubic.js":"../node_modules/d3-ease/src/cubic.js","./poly.js":"../node_modules/d3-ease/src/poly.js","./sin.js":"../node_modules/d3-ease/src/sin.js","./exp.js":"../node_modules/d3-ease/src/exp.js","./circle.js":"../node_modules/d3-ease/src/circle.js","./bounce.js":"../node_modules/d3-ease/src/bounce.js","./back.js":"../node_modules/d3-ease/src/back.js","./elastic.js":"../node_modules/d3-ease/src/elastic.js"}],"../node_modules/d3-transition/src/selection/transition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _index = require("../transition/index.js");
var _schedule = _interopRequireDefault(require("../transition/schedule.js"));
var _d3Ease = require("d3-ease");
var _d3Timer = require("d3-timer");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: _d3Ease.easeCubicInOut
};
function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error("transition ".concat(id, " not found"));
    }
  }
  return timing;
}
function _default(name) {
  var id, timing;
  if (name instanceof _index.Transition) {
    id = name._id, name = name._name;
  } else {
    id = (0, _index.newId)(), (timing = defaultTiming).time = (0, _d3Timer.now)(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        (0, _schedule.default)(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }
  return new _index.Transition(groups, this._parents, name, id);
}
},{"../transition/index.js":"../node_modules/d3-transition/src/transition/index.js","../transition/schedule.js":"../node_modules/d3-transition/src/transition/schedule.js","d3-ease":"../node_modules/d3-ease/src/index.js","d3-timer":"../node_modules/d3-timer/src/index.js"}],"../node_modules/d3-transition/src/selection/index.js":[function(require,module,exports) {
"use strict";

var _d3Selection = require("d3-selection");
var _interrupt = _interopRequireDefault(require("./interrupt.js"));
var _transition = _interopRequireDefault(require("./transition.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
_d3Selection.selection.prototype.interrupt = _interrupt.default;
_d3Selection.selection.prototype.transition = _transition.default;
},{"d3-selection":"../node_modules/d3-selection/src/index.js","./interrupt.js":"../node_modules/d3-transition/src/selection/interrupt.js","./transition.js":"../node_modules/d3-transition/src/selection/transition.js"}],"../node_modules/d3-transition/src/active.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _index = require("./transition/index.js");
var _schedule = require("./transition/schedule.js");
var root = [null];
function _default(node, name) {
  var schedules = node.__transition,
    schedule,
    i;
  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _schedule.SCHEDULED && schedule.name === name) {
        return new _index.Transition([[node]], root, name, +i);
      }
    }
  }
  return null;
}
},{"./transition/index.js":"../node_modules/d3-transition/src/transition/index.js","./transition/schedule.js":"../node_modules/d3-transition/src/transition/schedule.js"}],"../node_modules/d3-transition/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "active", {
  enumerable: true,
  get: function () {
    return _active.default;
  }
});
Object.defineProperty(exports, "interrupt", {
  enumerable: true,
  get: function () {
    return _interrupt.default;
  }
});
Object.defineProperty(exports, "transition", {
  enumerable: true,
  get: function () {
    return _index2.default;
  }
});
require("./selection/index.js");
var _index2 = _interopRequireDefault(require("./transition/index.js"));
var _active = _interopRequireDefault(require("./active.js"));
var _interrupt = _interopRequireDefault(require("./interrupt.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./selection/index.js":"../node_modules/d3-transition/src/selection/index.js","./transition/index.js":"../node_modules/d3-transition/src/transition/index.js","./active.js":"../node_modules/d3-transition/src/active.js","./interrupt.js":"../node_modules/d3-transition/src/interrupt.js"}],"../node_modules/regl/dist/regl.js":[function(require,module,exports) {
var define;
var global = arguments[3];
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.createREGL = factory());
}(this, (function () { 'use strict';

var isTypedArray = function (x) {
  return (
    x instanceof Uint8Array ||
    x instanceof Uint16Array ||
    x instanceof Uint32Array ||
    x instanceof Int8Array ||
    x instanceof Int16Array ||
    x instanceof Int32Array ||
    x instanceof Float32Array ||
    x instanceof Float64Array ||
    x instanceof Uint8ClampedArray
  )
}

var extend = function (base, opts) {
  var keys = Object.keys(opts)
  for (var i = 0; i < keys.length; ++i) {
    base[keys[i]] = opts[keys[i]]
  }
  return base
}

// Error checking and parameter validation.
//
// Statements for the form `check.someProcedure(...)` get removed by
// a browserify transform for optimized/minified bundles.
//
/* globals atob */
var endl = '\n'

// only used for extracting shader names.  if atob not present, then errors
// will be slightly crappier
function decodeB64 (str) {
  if (typeof atob !== 'undefined') {
    return atob(str)
  }
  return 'base64:' + str
}

function raise (message) {
  var error = new Error('(regl) ' + message)
  console.error(error)
  throw error
}

function check (pred, message) {
  if (!pred) {
    raise(message)
  }
}

function encolon (message) {
  if (message) {
    return ': ' + message
  }
  return ''
}

function checkParameter (param, possibilities, message) {
  if (!(param in possibilities)) {
    raise('unknown parameter (' + param + ')' + encolon(message) +
          '. possible values: ' + Object.keys(possibilities).join())
  }
}

function checkIsTypedArray (data, message) {
  if (!isTypedArray(data)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. must be a typed array')
  }
}

function standardTypeEh (value, type) {
  switch (type) {
    case 'number': return typeof value === 'number'
    case 'object': return typeof value === 'object'
    case 'string': return typeof value === 'string'
    case 'boolean': return typeof value === 'boolean'
    case 'function': return typeof value === 'function'
    case 'undefined': return typeof value === 'undefined'
    case 'symbol': return typeof value === 'symbol'
  }
}

function checkTypeOf (value, type, message) {
  if (!standardTypeEh(value, type)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value))
  }
}

function checkNonNegativeInt (value, message) {
  if (!((value >= 0) &&
        ((value | 0) === value))) {
    raise('invalid parameter type, (' + value + ')' + encolon(message) +
          '. must be a nonnegative integer')
  }
}

function checkOneOf (value, list, message) {
  if (list.indexOf(value) < 0) {
    raise('invalid value' + encolon(message) + '. must be one of: ' + list)
  }
}

var constructorKeys = [
  'gl',
  'canvas',
  'container',
  'attributes',
  'pixelRatio',
  'extensions',
  'optionalExtensions',
  'profile',
  'onDone'
]

function checkConstructor (obj) {
  Object.keys(obj).forEach(function (key) {
    if (constructorKeys.indexOf(key) < 0) {
      raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys)
    }
  })
}

function leftPad (str, n) {
  str = str + ''
  while (str.length < n) {
    str = ' ' + str
  }
  return str
}

function ShaderFile () {
  this.name = 'unknown'
  this.lines = []
  this.index = {}
  this.hasErrors = false
}

function ShaderLine (number, line) {
  this.number = number
  this.line = line
  this.errors = []
}

function ShaderError (fileNumber, lineNumber, message) {
  this.file = fileNumber
  this.line = lineNumber
  this.message = message
}

function guessCommand () {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function guessCallSite () {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function parseSource (source, command) {
  var lines = source.split('\n')
  var lineNumber = 1
  var fileNumber = 0
  var files = {
    unknown: new ShaderFile(),
    0: new ShaderFile()
  }
  files.unknown.name = files[0].name = command || guessCommand()
  files.unknown.lines.push(new ShaderLine(0, ''))
  for (var i = 0; i < lines.length; ++i) {
    var line = lines[i]
    var parts = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(line)
    if (parts) {
      switch (parts[1]) {
        case 'line':
          var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2])
          if (lineNumberInfo) {
            lineNumber = lineNumberInfo[1] | 0
            if (lineNumberInfo[2]) {
              fileNumber = lineNumberInfo[2] | 0
              if (!(fileNumber in files)) {
                files[fileNumber] = new ShaderFile()
              }
            }
          }
          break
        case 'define':
          var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2])
          if (nameInfo) {
            files[fileNumber].name = (nameInfo[1]
              ? decodeB64(nameInfo[2])
              : nameInfo[2])
          }
          break
      }
    }
    files[fileNumber].lines.push(new ShaderLine(lineNumber++, line))
  }
  Object.keys(files).forEach(function (fileNumber) {
    var file = files[fileNumber]
    file.lines.forEach(function (line) {
      file.index[line.number] = line
    })
  })
  return files
}

function parseErrorLog (errLog) {
  var result = []
  errLog.split('\n').forEach(function (errMsg) {
    if (errMsg.length < 5) {
      return
    }
    var parts = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(errMsg)
    if (parts) {
      result.push(new ShaderError(
        parts[1] | 0,
        parts[2] | 0,
        parts[3].trim()))
    } else if (errMsg.length > 0) {
      result.push(new ShaderError('unknown', 0, errMsg))
    }
  })
  return result
}

function annotateFiles (files, errors) {
  errors.forEach(function (error) {
    var file = files[error.file]
    if (file) {
      var line = file.index[error.line]
      if (line) {
        line.errors.push(error)
        file.hasErrors = true
        return
      }
    }
    files.unknown.hasErrors = true
    files.unknown.lines[0].errors.push(error)
  })
}

function checkShaderError (gl, shader, source, type, command) {
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(shader)
    var typeName = type === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex'
    checkCommandType(source, 'string', typeName + ' shader source must be a string', command)
    var files = parseSource(source, command)
    var errors = parseErrorLog(errLog)
    annotateFiles(files, errors)

    Object.keys(files).forEach(function (fileNumber) {
      var file = files[fileNumber]
      if (!file.hasErrors) {
        return
      }

      var strings = ['']
      var styles = ['']

      function push (str, style) {
        strings.push(str)
        styles.push(style || '')
      }

      push('file number ' + fileNumber + ': ' + file.name + '\n', 'color:red;text-decoration:underline;font-weight:bold')

      file.lines.forEach(function (line) {
        if (line.errors.length > 0) {
          push(leftPad(line.number, 4) + '|  ', 'background-color:yellow; font-weight:bold')
          push(line.line + endl, 'color:red; background-color:yellow; font-weight:bold')

          // try to guess token
          var offset = 0
          line.errors.forEach(function (error) {
            var message = error.message
            var token = /^\s*'(.*)'\s*:\s*(.*)$/.exec(message)
            if (token) {
              var tokenPat = token[1]
              message = token[2]
              switch (tokenPat) {
                case 'assign':
                  tokenPat = '='
                  break
              }
              offset = Math.max(line.line.indexOf(tokenPat, offset), 0)
            } else {
              offset = 0
            }

            push(leftPad('| ', 6))
            push(leftPad('^^^', offset + 3) + endl, 'font-weight:bold')
            push(leftPad('| ', 6))
            push(message + endl, 'font-weight:bold')
          })
          push(leftPad('| ', 6) + endl)
        } else {
          push(leftPad(line.number, 4) + '|  ')
          push(line.line + endl, 'color:red')
        }
      })
      if (typeof document !== 'undefined' && !window.chrome) {
        styles[0] = strings.join('%c')
        console.log.apply(console, styles)
      } else {
        console.log(strings.join(''))
      }
    })

    check.raise('Error compiling ' + typeName + ' shader, ' + files[0].name)
  }
}

function checkLinkError (gl, program, fragShader, vertShader, command) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var errLog = gl.getProgramInfoLog(program)
    var fragParse = parseSource(fragShader, command)
    var vertParse = parseSource(vertShader, command)

    var header = 'Error linking program with vertex shader, "' +
      vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"'

    if (typeof document !== 'undefined') {
      console.log('%c' + header + endl + '%c' + errLog,
        'color:red;text-decoration:underline;font-weight:bold',
        'color:red')
    } else {
      console.log(header + endl + errLog)
    }
    check.raise(header)
  }
}

function saveCommandRef (object) {
  object._commandRef = guessCommand()
}

function saveDrawCommandInfo (opts, uniforms, attributes, stringStore) {
  saveCommandRef(opts)

  function id (str) {
    if (str) {
      return stringStore.id(str)
    }
    return 0
  }
  opts._fragId = id(opts.static.frag)
  opts._vertId = id(opts.static.vert)

  function addProps (dict, set) {
    Object.keys(set).forEach(function (u) {
      dict[stringStore.id(u)] = true
    })
  }

  var uniformSet = opts._uniformSet = {}
  addProps(uniformSet, uniforms.static)
  addProps(uniformSet, uniforms.dynamic)

  var attributeSet = opts._attributeSet = {}
  addProps(attributeSet, attributes.static)
  addProps(attributeSet, attributes.dynamic)

  opts._hasCount = (
    'count' in opts.static ||
    'count' in opts.dynamic ||
    'elements' in opts.static ||
    'elements' in opts.dynamic)
}

function commandRaise (message, command) {
  var callSite = guessCallSite()
  raise(message +
    ' in command ' + (command || guessCommand()) +
    (callSite === 'unknown' ? '' : ' called from ' + callSite))
}

function checkCommand (pred, message, command) {
  if (!pred) {
    commandRaise(message, command || guessCommand())
  }
}

function checkParameterCommand (param, possibilities, message, command) {
  if (!(param in possibilities)) {
    commandRaise(
      'unknown parameter (' + param + ')' + encolon(message) +
      '. possible values: ' + Object.keys(possibilities).join(),
      command || guessCommand())
  }
}

function checkCommandType (value, type, message, command) {
  if (!standardTypeEh(value, type)) {
    commandRaise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value),
      command || guessCommand())
  }
}

function checkOptional (block) {
  block()
}

function checkFramebufferFormat (attachment, texFormats, rbFormats) {
  if (attachment.texture) {
    checkOneOf(
      attachment.texture._texture.internalformat,
      texFormats,
      'unsupported texture format for attachment')
  } else {
    checkOneOf(
      attachment.renderbuffer._renderbuffer.format,
      rbFormats,
      'unsupported renderbuffer format for attachment')
  }
}

var GL_CLAMP_TO_EDGE = 0x812F

var GL_NEAREST = 0x2600
var GL_NEAREST_MIPMAP_NEAREST = 0x2700
var GL_LINEAR_MIPMAP_NEAREST = 0x2701
var GL_NEAREST_MIPMAP_LINEAR = 0x2702
var GL_LINEAR_MIPMAP_LINEAR = 0x2703

var GL_BYTE = 5120
var GL_UNSIGNED_BYTE = 5121
var GL_SHORT = 5122
var GL_UNSIGNED_SHORT = 5123
var GL_INT = 5124
var GL_UNSIGNED_INT = 5125
var GL_FLOAT = 5126

var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL = 0x84FA

var GL_HALF_FLOAT_OES = 0x8D61

var TYPE_SIZE = {}

TYPE_SIZE[GL_BYTE] =
TYPE_SIZE[GL_UNSIGNED_BYTE] = 1

TYPE_SIZE[GL_SHORT] =
TYPE_SIZE[GL_UNSIGNED_SHORT] =
TYPE_SIZE[GL_HALF_FLOAT_OES] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] =
TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2

TYPE_SIZE[GL_INT] =
TYPE_SIZE[GL_UNSIGNED_INT] =
TYPE_SIZE[GL_FLOAT] =
TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4

function pixelSize (type, channels) {
  if (type === GL_UNSIGNED_SHORT_5_5_5_1 ||
      type === GL_UNSIGNED_SHORT_4_4_4_4 ||
      type === GL_UNSIGNED_SHORT_5_6_5) {
    return 2
  } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
    return 4
  } else {
    return TYPE_SIZE[type] * channels
  }
}

function isPow2 (v) {
  return !(v & (v - 1)) && (!!v)
}

function checkTexture2D (info, mipData, limits) {
  var i
  var w = mipData.width
  var h = mipData.height
  var c = mipData.channels

  // Check texture shape
  check(w > 0 && w <= limits.maxTextureSize &&
        h > 0 && h <= limits.maxTextureSize,
  'invalid texture shape')

  // check wrap mode
  if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
    check(isPow2(w) && isPow2(h),
      'incompatible wrap mode for texture, both width and height must be power of 2')
  }

  if (mipData.mipmask === 1) {
    if (w !== 1 && h !== 1) {
      check(
        info.minFilter !== GL_NEAREST_MIPMAP_NEAREST &&
        info.minFilter !== GL_NEAREST_MIPMAP_LINEAR &&
        info.minFilter !== GL_LINEAR_MIPMAP_NEAREST &&
        info.minFilter !== GL_LINEAR_MIPMAP_LINEAR,
        'min filter requires mipmap')
    }
  } else {
    // texture must be power of 2
    check(isPow2(w) && isPow2(h),
      'texture must be a square power of 2 to support mipmapping')
    check(mipData.mipmask === (w << 1) - 1,
      'missing or incomplete mipmap data')
  }

  if (mipData.type === GL_FLOAT) {
    if (limits.extensions.indexOf('oes_texture_float_linear') < 0) {
      check(info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST,
        'filter not supported, must enable oes_texture_float_linear')
    }
    check(!info.genMipmaps,
      'mipmap generation not supported with float textures')
  }

  // check image complete
  var mipimages = mipData.images
  for (i = 0; i < 16; ++i) {
    if (mipimages[i]) {
      var mw = w >> i
      var mh = h >> i
      check(mipData.mipmask & (1 << i), 'missing mipmap data')

      var img = mipimages[i]

      check(
        img.width === mw &&
        img.height === mh,
        'invalid shape for mip images')

      check(
        img.format === mipData.format &&
        img.internalformat === mipData.internalformat &&
        img.type === mipData.type,
        'incompatible type for mip image')

      if (img.compressed) {
        // TODO: check size for compressed images
      } else if (img.data) {
        // check(img.data.byteLength === mw * mh *
        // Math.max(pixelSize(img.type, c), img.unpackAlignment),
        var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment
        check(img.data.byteLength === rowSize * mh,
          'invalid data for image, buffer size is inconsistent with image format')
      } else if (img.element) {
        // TODO: check element can be loaded
      } else if (img.copy) {
        // TODO: check compatible format and type
      }
    } else if (!info.genMipmaps) {
      check((mipData.mipmask & (1 << i)) === 0, 'extra mipmap data')
    }
  }

  if (mipData.compressed) {
    check(!info.genMipmaps,
      'mipmap generation for compressed images not supported')
  }
}

function checkTextureCube (texture, info, faces, limits) {
  var w = texture.width
  var h = texture.height
  var c = texture.channels

  // Check texture shape
  check(
    w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize,
    'invalid texture shape')
  check(
    w === h,
    'cube map must be square')
  check(
    info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE,
    'wrap mode not supported by cube map')

  for (var i = 0; i < faces.length; ++i) {
    var face = faces[i]
    check(
      face.width === w && face.height === h,
      'inconsistent cube map face shape')

    if (info.genMipmaps) {
      check(!face.compressed,
        'can not generate mipmap for compressed textures')
      check(face.mipmask === 1,
        'can not specify mipmaps and generate mipmaps')
    } else {
      // TODO: check mip and filter mode
    }

    var mipmaps = face.images
    for (var j = 0; j < 16; ++j) {
      var img = mipmaps[j]
      if (img) {
        var mw = w >> j
        var mh = h >> j
        check(face.mipmask & (1 << j), 'missing mipmap data')
        check(
          img.width === mw &&
          img.height === mh,
          'invalid shape for mip images')
        check(
          img.format === texture.format &&
          img.internalformat === texture.internalformat &&
          img.type === texture.type,
          'incompatible type for mip image')

        if (img.compressed) {
          // TODO: check size for compressed images
        } else if (img.data) {
          check(img.data.byteLength === mw * mh *
            Math.max(pixelSize(img.type, c), img.unpackAlignment),
          'invalid data for image, buffer size is inconsistent with image format')
        } else if (img.element) {
          // TODO: check element can be loaded
        } else if (img.copy) {
          // TODO: check compatible format and type
        }
      }
    }
  }
}

var check$1 = extend(check, {
  optional: checkOptional,
  raise: raise,
  commandRaise: commandRaise,
  command: checkCommand,
  parameter: checkParameter,
  commandParameter: checkParameterCommand,
  constructor: checkConstructor,
  type: checkTypeOf,
  commandType: checkCommandType,
  isTypedArray: checkIsTypedArray,
  nni: checkNonNegativeInt,
  oneOf: checkOneOf,
  shaderError: checkShaderError,
  linkError: checkLinkError,
  callSite: guessCallSite,
  saveCommandRef: saveCommandRef,
  saveDrawInfo: saveDrawCommandInfo,
  framebufferFormat: checkFramebufferFormat,
  guessCommand: guessCommand,
  texture2D: checkTexture2D,
  textureCube: checkTextureCube
});

var VARIABLE_COUNTER = 0

var DYN_FUNC = 0
var DYN_CONSTANT = 5
var DYN_ARRAY = 6

function DynamicVariable (type, data) {
  this.id = (VARIABLE_COUNTER++)
  this.type = type
  this.data = data
}

function escapeStr (str) {
  return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
}

function splitParts (str) {
  if (str.length === 0) {
    return []
  }

  var firstChar = str.charAt(0)
  var lastChar = str.charAt(str.length - 1)

  if (str.length > 1 &&
      firstChar === lastChar &&
      (firstChar === '"' || firstChar === "'")) {
    return ['"' + escapeStr(str.substr(1, str.length - 2)) + '"']
  }

  var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str)
  if (parts) {
    return (
      splitParts(str.substr(0, parts.index))
        .concat(splitParts(parts[1]))
        .concat(splitParts(str.substr(parts.index + parts[0].length)))
    )
  }

  var subparts = str.split('.')
  if (subparts.length === 1) {
    return ['"' + escapeStr(str) + '"']
  }

  var result = []
  for (var i = 0; i < subparts.length; ++i) {
    result = result.concat(splitParts(subparts[i]))
  }
  return result
}

function toAccessorString (str) {
  return '[' + splitParts(str).join('][') + ']'
}

function defineDynamic (type, data) {
  return new DynamicVariable(type, toAccessorString(data + ''))
}

function isDynamic (x) {
  return (typeof x === 'function' && !x._reglType) || (x instanceof DynamicVariable)
}

function unbox (x, path) {
  if (typeof x === 'function') {
    return new DynamicVariable(DYN_FUNC, x)
  } else if (typeof x === 'number' || typeof x === 'boolean') {
    return new DynamicVariable(DYN_CONSTANT, x)
  } else if (Array.isArray(x)) {
    return new DynamicVariable(DYN_ARRAY, x.map(function (y, i) { return unbox(y, path + '[' + i + ']') }))
  } else if (x instanceof DynamicVariable) {
    return x
  }
  check$1(false, 'invalid option type in uniform ' + path)
}

var dynamic = {
  DynamicVariable: DynamicVariable,
  define: defineDynamic,
  isDynamic: isDynamic,
  unbox: unbox,
  accessor: toAccessorString
};

/* globals requestAnimationFrame, cancelAnimationFrame */
var raf = {
  next: typeof requestAnimationFrame === 'function'
    ? function (cb) { return requestAnimationFrame(cb) }
    : function (cb) { return setTimeout(cb, 16) },
  cancel: typeof cancelAnimationFrame === 'function'
    ? function (raf) { return cancelAnimationFrame(raf) }
    : clearTimeout
};

/* globals performance */
var clock = (typeof performance !== 'undefined' && performance.now)
    ? function () { return performance.now() }
    : function () { return +(new Date()) };

function createStringStore () {
  var stringIds = { '': 0 }
  var stringValues = ['']
  return {
    id: function (str) {
      var result = stringIds[str]
      if (result) {
        return result
      }
      result = stringIds[str] = stringValues.length
      stringValues.push(str)
      return result
    },

    str: function (id) {
      return stringValues[id]
    }
  }
}

// Context and canvas creation helper functions
function createCanvas (element, onDone, pixelRatio) {
  var canvas = document.createElement('canvas')
  extend(canvas.style, {
    border: 0,
    margin: 0,
    padding: 0,
    top: 0,
    left: 0,
    width: '100%',
    height: '100%'
  })
  element.appendChild(canvas)

  if (element === document.body) {
    canvas.style.position = 'absolute'
    extend(element.style, {
      margin: 0,
      padding: 0
    })
  }

  function resize () {
    var w = window.innerWidth
    var h = window.innerHeight
    if (element !== document.body) {
      var bounds = canvas.getBoundingClientRect()
      w = bounds.right - bounds.left
      h = bounds.bottom - bounds.top
    }
    canvas.width = pixelRatio * w
    canvas.height = pixelRatio * h
  }

  var resizeObserver
  if (element !== document.body && typeof ResizeObserver === 'function') {
    // ignore 'ResizeObserver' is not defined
    // eslint-disable-next-line
    resizeObserver = new ResizeObserver(function () {
      // setTimeout to avoid flicker
      setTimeout(resize)
    })
    resizeObserver.observe(element)
  } else {
    window.addEventListener('resize', resize, false)
  }

  function onDestroy () {
    if (resizeObserver) {
      resizeObserver.disconnect()
    } else {
      window.removeEventListener('resize', resize)
    }
    element.removeChild(canvas)
  }

  resize()

  return {
    canvas: canvas,
    onDestroy: onDestroy
  }
}

function createContext (canvas, contextAttributes) {
  function get (name) {
    try {
      return canvas.getContext(name, contextAttributes)
    } catch (e) {
      return null
    }
  }
  return (
    get('webgl') ||
    get('experimental-webgl') ||
    get('webgl-experimental')
  )
}

function isHTMLElement (obj) {
  return (
    typeof obj.nodeName === 'string' &&
    typeof obj.appendChild === 'function' &&
    typeof obj.getBoundingClientRect === 'function'
  )
}

function isWebGLContext (obj) {
  return (
    typeof obj.drawArrays === 'function' ||
    typeof obj.drawElements === 'function'
  )
}

function parseExtensions (input) {
  if (typeof input === 'string') {
    return input.split()
  }
  check$1(Array.isArray(input), 'invalid extension array')
  return input
}

function getElement (desc) {
  if (typeof desc === 'string') {
    check$1(typeof document !== 'undefined', 'not supported outside of DOM')
    return document.querySelector(desc)
  }
  return desc
}

function parseArgs (args_) {
  var args = args_ || {}
  var element, container, canvas, gl
  var contextAttributes = {}
  var extensions = []
  var optionalExtensions = []
  var pixelRatio = (typeof window === 'undefined' ? 1 : window.devicePixelRatio)
  var profile = false
  var onDone = function (err) {
    if (err) {
      check$1.raise(err)
    }
  }
  var onDestroy = function () {}
  if (typeof args === 'string') {
    check$1(
      typeof document !== 'undefined',
      'selector queries only supported in DOM enviroments')
    element = document.querySelector(args)
    check$1(element, 'invalid query string for element')
  } else if (typeof args === 'object') {
    if (isHTMLElement(args)) {
      element = args
    } else if (isWebGLContext(args)) {
      gl = args
      canvas = gl.canvas
    } else {
      check$1.constructor(args)
      if ('gl' in args) {
        gl = args.gl
      } else if ('canvas' in args) {
        canvas = getElement(args.canvas)
      } else if ('container' in args) {
        container = getElement(args.container)
      }
      if ('attributes' in args) {
        contextAttributes = args.attributes
        check$1.type(contextAttributes, 'object', 'invalid context attributes')
      }
      if ('extensions' in args) {
        extensions = parseExtensions(args.extensions)
      }
      if ('optionalExtensions' in args) {
        optionalExtensions = parseExtensions(args.optionalExtensions)
      }
      if ('onDone' in args) {
        check$1.type(
          args.onDone, 'function',
          'invalid or missing onDone callback')
        onDone = args.onDone
      }
      if ('profile' in args) {
        profile = !!args.profile
      }
      if ('pixelRatio' in args) {
        pixelRatio = +args.pixelRatio
        check$1(pixelRatio > 0, 'invalid pixel ratio')
      }
    }
  } else {
    check$1.raise('invalid arguments to regl')
  }

  if (element) {
    if (element.nodeName.toLowerCase() === 'canvas') {
      canvas = element
    } else {
      container = element
    }
  }

  if (!gl) {
    if (!canvas) {
      check$1(
        typeof document !== 'undefined',
        'must manually specify webgl context outside of DOM environments')
      var result = createCanvas(container || document.body, onDone, pixelRatio)
      if (!result) {
        return null
      }
      canvas = result.canvas
      onDestroy = result.onDestroy
    }
    // workaround for chromium bug, premultiplied alpha value is platform dependent
    if (contextAttributes.premultipliedAlpha === undefined) contextAttributes.premultipliedAlpha = true
    gl = createContext(canvas, contextAttributes)
  }

  if (!gl) {
    onDestroy()
    onDone('webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org')
    return null
  }

  return {
    gl: gl,
    canvas: canvas,
    container: container,
    extensions: extensions,
    optionalExtensions: optionalExtensions,
    pixelRatio: pixelRatio,
    profile: profile,
    onDone: onDone,
    onDestroy: onDestroy
  }
}

function createExtensionCache (gl, config) {
  var extensions = {}

  function tryLoadExtension (name_) {
    check$1.type(name_, 'string', 'extension name must be string')
    var name = name_.toLowerCase()
    var ext
    try {
      ext = extensions[name] = gl.getExtension(name)
    } catch (e) {}
    return !!ext
  }

  for (var i = 0; i < config.extensions.length; ++i) {
    var name = config.extensions[i]
    if (!tryLoadExtension(name)) {
      config.onDestroy()
      config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser')
      return null
    }
  }

  config.optionalExtensions.forEach(tryLoadExtension)

  return {
    extensions: extensions,
    restore: function () {
      Object.keys(extensions).forEach(function (name) {
        if (extensions[name] && !tryLoadExtension(name)) {
          throw new Error('(regl): error restoring extension ' + name)
        }
      })
    }
  }
}

function loop (n, f) {
  var result = Array(n)
  for (var i = 0; i < n; ++i) {
    result[i] = f(i)
  }
  return result
}

var GL_BYTE$1 = 5120
var GL_UNSIGNED_BYTE$2 = 5121
var GL_SHORT$1 = 5122
var GL_UNSIGNED_SHORT$1 = 5123
var GL_INT$1 = 5124
var GL_UNSIGNED_INT$1 = 5125
var GL_FLOAT$2 = 5126

function nextPow16 (v) {
  for (var i = 16; i <= (1 << 28); i *= 16) {
    if (v <= i) {
      return i
    }
  }
  return 0
}

function log2 (v) {
  var r, shift
  r = (v > 0xFFFF) << 4
  v >>>= r
  shift = (v > 0xFF) << 3
  v >>>= shift; r |= shift
  shift = (v > 0xF) << 2
  v >>>= shift; r |= shift
  shift = (v > 0x3) << 1
  v >>>= shift; r |= shift
  return r | (v >> 1)
}

function createPool () {
  var bufferPool = loop(8, function () {
    return []
  })

  function alloc (n) {
    var sz = nextPow16(n)
    var bin = bufferPool[log2(sz) >> 2]
    if (bin.length > 0) {
      return bin.pop()
    }
    return new ArrayBuffer(sz)
  }

  function free (buf) {
    bufferPool[log2(buf.byteLength) >> 2].push(buf)
  }

  function allocType (type, n) {
    var result = null
    switch (type) {
      case GL_BYTE$1:
        result = new Int8Array(alloc(n), 0, n)
        break
      case GL_UNSIGNED_BYTE$2:
        result = new Uint8Array(alloc(n), 0, n)
        break
      case GL_SHORT$1:
        result = new Int16Array(alloc(2 * n), 0, n)
        break
      case GL_UNSIGNED_SHORT$1:
        result = new Uint16Array(alloc(2 * n), 0, n)
        break
      case GL_INT$1:
        result = new Int32Array(alloc(4 * n), 0, n)
        break
      case GL_UNSIGNED_INT$1:
        result = new Uint32Array(alloc(4 * n), 0, n)
        break
      case GL_FLOAT$2:
        result = new Float32Array(alloc(4 * n), 0, n)
        break
      default:
        return null
    }
    if (result.length !== n) {
      return result.subarray(0, n)
    }
    return result
  }

  function freeType (array) {
    free(array.buffer)
  }

  return {
    alloc: alloc,
    free: free,
    allocType: allocType,
    freeType: freeType
  }
}

var pool = createPool()

// zero pool for initial zero data
pool.zero = createPool()

var GL_SUBPIXEL_BITS = 0x0D50
var GL_RED_BITS = 0x0D52
var GL_GREEN_BITS = 0x0D53
var GL_BLUE_BITS = 0x0D54
var GL_ALPHA_BITS = 0x0D55
var GL_DEPTH_BITS = 0x0D56
var GL_STENCIL_BITS = 0x0D57

var GL_ALIASED_POINT_SIZE_RANGE = 0x846D
var GL_ALIASED_LINE_WIDTH_RANGE = 0x846E

var GL_MAX_TEXTURE_SIZE = 0x0D33
var GL_MAX_VIEWPORT_DIMS = 0x0D3A
var GL_MAX_VERTEX_ATTRIBS = 0x8869
var GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB
var GL_MAX_VARYING_VECTORS = 0x8DFC
var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D
var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C
var GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872
var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD
var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C
var GL_MAX_RENDERBUFFER_SIZE = 0x84E8

var GL_VENDOR = 0x1F00
var GL_RENDERER = 0x1F01
var GL_VERSION = 0x1F02
var GL_SHADING_LANGUAGE_VERSION = 0x8B8C

var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF

var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF
var GL_MAX_DRAW_BUFFERS_WEBGL = 0x8824

var GL_TEXTURE_2D = 0x0DE1
var GL_TEXTURE_CUBE_MAP = 0x8513
var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515
var GL_TEXTURE0 = 0x84C0
var GL_RGBA = 0x1908
var GL_FLOAT$1 = 0x1406
var GL_UNSIGNED_BYTE$1 = 0x1401
var GL_FRAMEBUFFER = 0x8D40
var GL_FRAMEBUFFER_COMPLETE = 0x8CD5
var GL_COLOR_ATTACHMENT0 = 0x8CE0
var GL_COLOR_BUFFER_BIT$1 = 0x4000

var wrapLimits = function (gl, extensions) {
  var maxAnisotropic = 1
  if (extensions.ext_texture_filter_anisotropic) {
    maxAnisotropic = gl.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT)
  }

  var maxDrawbuffers = 1
  var maxColorAttachments = 1
  if (extensions.webgl_draw_buffers) {
    maxDrawbuffers = gl.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL)
    maxColorAttachments = gl.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL)
  }

  // detect if reading float textures is available (Safari doesn't support)
  var readFloat = !!extensions.oes_texture_float
  if (readFloat) {
    var readFloatTexture = gl.createTexture()
    gl.bindTexture(GL_TEXTURE_2D, readFloatTexture)
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT$1, null)

    var fbo = gl.createFramebuffer()
    gl.bindFramebuffer(GL_FRAMEBUFFER, fbo)
    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0)
    gl.bindTexture(GL_TEXTURE_2D, null)

    if (gl.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE) readFloat = false

    else {
      gl.viewport(0, 0, 1, 1)
      gl.clearColor(1.0, 0.0, 0.0, 1.0)
      gl.clear(GL_COLOR_BUFFER_BIT$1)
      var pixels = pool.allocType(GL_FLOAT$1, 4)
      gl.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT$1, pixels)

      if (gl.getError()) readFloat = false
      else {
        gl.deleteFramebuffer(fbo)
        gl.deleteTexture(readFloatTexture)

        readFloat = pixels[0] === 1.0
      }

      pool.freeType(pixels)
    }
  }

  // detect non power of two cube textures support (IE doesn't support)
  var isIE = typeof navigator !== 'undefined' && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent))

  var npotTextureCube = true

  if (!isIE) {
    var cubeTexture = gl.createTexture()
    var data = pool.allocType(GL_UNSIGNED_BYTE$1, 36)
    gl.activeTexture(GL_TEXTURE0)
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture)
    gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE$1, data)
    pool.freeType(data)
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, null)
    gl.deleteTexture(cubeTexture)
    npotTextureCube = !gl.getError()
  }

  return {
    // drawing buffer bit depth
    colorBits: [
      gl.getParameter(GL_RED_BITS),
      gl.getParameter(GL_GREEN_BITS),
      gl.getParameter(GL_BLUE_BITS),
      gl.getParameter(GL_ALPHA_BITS)
    ],
    depthBits: gl.getParameter(GL_DEPTH_BITS),
    stencilBits: gl.getParameter(GL_STENCIL_BITS),
    subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),

    // supported extensions
    extensions: Object.keys(extensions).filter(function (ext) {
      return !!extensions[ext]
    }),

    // max aniso samples
    maxAnisotropic: maxAnisotropic,

    // max draw buffers
    maxDrawbuffers: maxDrawbuffers,
    maxColorAttachments: maxColorAttachments,

    // point and line size ranges
    pointSizeDims: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
    lineWidthDims: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
    maxViewportDims: gl.getParameter(GL_MAX_VIEWPORT_DIMS),
    maxCombinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
    maxCubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
    maxRenderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),
    maxTextureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
    maxTextureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),
    maxAttributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),
    maxVertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
    maxVertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    maxVaryingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),
    maxFragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),

    // vendor info
    glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),
    renderer: gl.getParameter(GL_RENDERER),
    vendor: gl.getParameter(GL_VENDOR),
    version: gl.getParameter(GL_VERSION),

    // quirks
    readFloat: readFloat,
    npotTextureCube: npotTextureCube
  }
}

function isNDArrayLike (obj) {
  return (
    !!obj &&
    typeof obj === 'object' &&
    Array.isArray(obj.shape) &&
    Array.isArray(obj.stride) &&
    typeof obj.offset === 'number' &&
    obj.shape.length === obj.stride.length &&
    (Array.isArray(obj.data) ||
      isTypedArray(obj.data)))
}

var values = function (obj) {
  return Object.keys(obj).map(function (key) { return obj[key] })
}

var flattenUtils = {
  shape: arrayShape$1,
  flatten: flattenArray
};

function flatten1D (array, nx, out) {
  for (var i = 0; i < nx; ++i) {
    out[i] = array[i]
  }
}

function flatten2D (array, nx, ny, out) {
  var ptr = 0
  for (var i = 0; i < nx; ++i) {
    var row = array[i]
    for (var j = 0; j < ny; ++j) {
      out[ptr++] = row[j]
    }
  }
}

function flatten3D (array, nx, ny, nz, out, ptr_) {
  var ptr = ptr_
  for (var i = 0; i < nx; ++i) {
    var row = array[i]
    for (var j = 0; j < ny; ++j) {
      var col = row[j]
      for (var k = 0; k < nz; ++k) {
        out[ptr++] = col[k]
      }
    }
  }
}

function flattenRec (array, shape, level, out, ptr) {
  var stride = 1
  for (var i = level + 1; i < shape.length; ++i) {
    stride *= shape[i]
  }
  var n = shape[level]
  if (shape.length - level === 4) {
    var nx = shape[level + 1]
    var ny = shape[level + 2]
    var nz = shape[level + 3]
    for (i = 0; i < n; ++i) {
      flatten3D(array[i], nx, ny, nz, out, ptr)
      ptr += stride
    }
  } else {
    for (i = 0; i < n; ++i) {
      flattenRec(array[i], shape, level + 1, out, ptr)
      ptr += stride
    }
  }
}

function flattenArray (array, shape, type, out_) {
  var sz = 1
  if (shape.length) {
    for (var i = 0; i < shape.length; ++i) {
      sz *= shape[i]
    }
  } else {
    sz = 0
  }
  var out = out_ || pool.allocType(type, sz)
  switch (shape.length) {
    case 0:
      break
    case 1:
      flatten1D(array, shape[0], out)
      break
    case 2:
      flatten2D(array, shape[0], shape[1], out)
      break
    case 3:
      flatten3D(array, shape[0], shape[1], shape[2], out, 0)
      break
    default:
      flattenRec(array, shape, 0, out, 0)
  }
  return out
}

function arrayShape$1 (array_) {
  var shape = []
  for (var array = array_; array.length; array = array[0]) {
    shape.push(array.length)
  }
  return shape
}

var arrayTypes =  {
	"[object Int8Array]": 5120,
	"[object Int16Array]": 5122,
	"[object Int32Array]": 5124,
	"[object Uint8Array]": 5121,
	"[object Uint8ClampedArray]": 5121,
	"[object Uint16Array]": 5123,
	"[object Uint32Array]": 5125,
	"[object Float32Array]": 5126,
	"[object Float64Array]": 5121,
	"[object ArrayBuffer]": 5121
};

var int8 = 5120;
var int16 = 5122;
var int32 = 5124;
var uint8 = 5121;
var uint16 = 5123;
var uint32 = 5125;
var float = 5126;
var float32 = 5126;
var glTypes = {
	int8: int8,
	int16: int16,
	int32: int32,
	uint8: uint8,
	uint16: uint16,
	uint32: uint32,
	float: float,
	float32: float32
};

var dynamic$1 = 35048;
var stream = 35040;
var usageTypes = {
	dynamic: dynamic$1,
	stream: stream,
	"static": 35044
};

var arrayFlatten = flattenUtils.flatten
var arrayShape = flattenUtils.shape

var GL_STATIC_DRAW = 0x88E4
var GL_STREAM_DRAW = 0x88E0

var GL_UNSIGNED_BYTE$3 = 5121
var GL_FLOAT$3 = 5126

var DTYPES_SIZES = []
DTYPES_SIZES[5120] = 1 // int8
DTYPES_SIZES[5122] = 2 // int16
DTYPES_SIZES[5124] = 4 // int32
DTYPES_SIZES[5121] = 1 // uint8
DTYPES_SIZES[5123] = 2 // uint16
DTYPES_SIZES[5125] = 4 // uint32
DTYPES_SIZES[5126] = 4 // float32

function typedArrayCode (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function copyArray (out, inp) {
  for (var i = 0; i < inp.length; ++i) {
    out[i] = inp[i]
  }
}

function transpose (
  result, data, shapeX, shapeY, strideX, strideY, offset) {
  var ptr = 0
  for (var i = 0; i < shapeX; ++i) {
    for (var j = 0; j < shapeY; ++j) {
      result[ptr++] = data[strideX * i + strideY * j + offset]
    }
  }
}

function wrapBufferState (gl, stats, config, destroyBuffer) {
  var bufferCount = 0
  var bufferSet = {}

  function REGLBuffer (type) {
    this.id = bufferCount++
    this.buffer = gl.createBuffer()
    this.type = type
    this.usage = GL_STATIC_DRAW
    this.byteLength = 0
    this.dimension = 1
    this.dtype = GL_UNSIGNED_BYTE$3

    this.persistentData = null

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  REGLBuffer.prototype.bind = function () {
    gl.bindBuffer(this.type, this.buffer)
  }

  REGLBuffer.prototype.destroy = function () {
    destroy(this)
  }

  var streamPool = []

  function createStream (type, data) {
    var buffer = streamPool.pop()
    if (!buffer) {
      buffer = new REGLBuffer(type)
    }
    buffer.bind()
    initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false)
    return buffer
  }

  function destroyStream (stream$$1) {
    streamPool.push(stream$$1)
  }

  function initBufferFromTypedArray (buffer, data, usage) {
    buffer.byteLength = data.byteLength
    gl.bufferData(buffer.type, data, usage)
  }

  function initBufferFromData (buffer, data, usage, dtype, dimension, persist) {
    var shape
    buffer.usage = usage
    if (Array.isArray(data)) {
      buffer.dtype = dtype || GL_FLOAT$3
      if (data.length > 0) {
        var flatData
        if (Array.isArray(data[0])) {
          shape = arrayShape(data)
          var dim = 1
          for (var i = 1; i < shape.length; ++i) {
            dim *= shape[i]
          }
          buffer.dimension = dim
          flatData = arrayFlatten(data, shape, buffer.dtype)
          initBufferFromTypedArray(buffer, flatData, usage)
          if (persist) {
            buffer.persistentData = flatData
          } else {
            pool.freeType(flatData)
          }
        } else if (typeof data[0] === 'number') {
          buffer.dimension = dimension
          var typedData = pool.allocType(buffer.dtype, data.length)
          copyArray(typedData, data)
          initBufferFromTypedArray(buffer, typedData, usage)
          if (persist) {
            buffer.persistentData = typedData
          } else {
            pool.freeType(typedData)
          }
        } else if (isTypedArray(data[0])) {
          buffer.dimension = data[0].length
          buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$3
          flatData = arrayFlatten(
            data,
            [data.length, data[0].length],
            buffer.dtype)
          initBufferFromTypedArray(buffer, flatData, usage)
          if (persist) {
            buffer.persistentData = flatData
          } else {
            pool.freeType(flatData)
          }
        } else {
          check$1.raise('invalid buffer data')
        }
      }
    } else if (isTypedArray(data)) {
      buffer.dtype = dtype || typedArrayCode(data)
      buffer.dimension = dimension
      initBufferFromTypedArray(buffer, data, usage)
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer))
      }
    } else if (isNDArrayLike(data)) {
      shape = data.shape
      var stride = data.stride
      var offset = data.offset

      var shapeX = 0
      var shapeY = 0
      var strideX = 0
      var strideY = 0
      if (shape.length === 1) {
        shapeX = shape[0]
        shapeY = 1
        strideX = stride[0]
        strideY = 0
      } else if (shape.length === 2) {
        shapeX = shape[0]
        shapeY = shape[1]
        strideX = stride[0]
        strideY = stride[1]
      } else {
        check$1.raise('invalid shape')
      }

      buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$3
      buffer.dimension = shapeY

      var transposeData = pool.allocType(buffer.dtype, shapeX * shapeY)
      transpose(transposeData,
        data.data,
        shapeX, shapeY,
        strideX, strideY,
        offset)
      initBufferFromTypedArray(buffer, transposeData, usage)
      if (persist) {
        buffer.persistentData = transposeData
      } else {
        pool.freeType(transposeData)
      }
    } else if (data instanceof ArrayBuffer) {
      buffer.dtype = GL_UNSIGNED_BYTE$3
      buffer.dimension = dimension
      initBufferFromTypedArray(buffer, data, usage)
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data))
      }
    } else {
      check$1.raise('invalid buffer data')
    }
  }

  function destroy (buffer) {
    stats.bufferCount--

    // remove attribute link
    destroyBuffer(buffer)

    var handle = buffer.buffer
    check$1(handle, 'buffer must not be deleted already')
    gl.deleteBuffer(handle)
    buffer.buffer = null
    delete bufferSet[buffer.id]
  }

  function createBuffer (options, type, deferInit, persistent) {
    stats.bufferCount++

    var buffer = new REGLBuffer(type)
    bufferSet[buffer.id] = buffer

    function reglBuffer (options) {
      var usage = GL_STATIC_DRAW
      var data = null
      var byteLength = 0
      var dtype = 0
      var dimension = 1
      if (Array.isArray(options) ||
          isTypedArray(options) ||
          isNDArrayLike(options) ||
          options instanceof ArrayBuffer) {
        data = options
      } else if (typeof options === 'number') {
        byteLength = options | 0
      } else if (options) {
        check$1.type(
          options, 'object',
          'buffer arguments must be an object, a number or an array')

        if ('data' in options) {
          check$1(
            data === null ||
            Array.isArray(data) ||
            isTypedArray(data) ||
            isNDArrayLike(data),
            'invalid data for buffer')
          data = options.data
        }

        if ('usage' in options) {
          check$1.parameter(options.usage, usageTypes, 'invalid buffer usage')
          usage = usageTypes[options.usage]
        }

        if ('type' in options) {
          check$1.parameter(options.type, glTypes, 'invalid buffer type')
          dtype = glTypes[options.type]
        }

        if ('dimension' in options) {
          check$1.type(options.dimension, 'number', 'invalid dimension')
          dimension = options.dimension | 0
        }

        if ('length' in options) {
          check$1.nni(byteLength, 'buffer length must be a nonnegative integer')
          byteLength = options.length | 0
        }
      }

      buffer.bind()
      if (!data) {
        // #475
        if (byteLength) gl.bufferData(buffer.type, byteLength, usage)
        buffer.dtype = dtype || GL_UNSIGNED_BYTE$3
        buffer.usage = usage
        buffer.dimension = dimension
        buffer.byteLength = byteLength
      } else {
        initBufferFromData(buffer, data, usage, dtype, dimension, persistent)
      }

      if (config.profile) {
        buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype]
      }

      return reglBuffer
    }

    function setSubData (data, offset) {
      check$1(offset + data.byteLength <= buffer.byteLength,
        'invalid buffer subdata call, buffer is too small. ' + ' Can\'t write data of size ' + data.byteLength + ' starting from offset ' + offset + ' to a buffer of size ' + buffer.byteLength)

      gl.bufferSubData(buffer.type, offset, data)
    }

    function subdata (data, offset_) {
      var offset = (offset_ || 0) | 0
      var shape
      buffer.bind()
      if (isTypedArray(data) || data instanceof ArrayBuffer) {
        setSubData(data, offset)
      } else if (Array.isArray(data)) {
        if (data.length > 0) {
          if (typeof data[0] === 'number') {
            var converted = pool.allocType(buffer.dtype, data.length)
            copyArray(converted, data)
            setSubData(converted, offset)
            pool.freeType(converted)
          } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {
            shape = arrayShape(data)
            var flatData = arrayFlatten(data, shape, buffer.dtype)
            setSubData(flatData, offset)
            pool.freeType(flatData)
          } else {
            check$1.raise('invalid buffer data')
          }
        }
      } else if (isNDArrayLike(data)) {
        shape = data.shape
        var stride = data.stride

        var shapeX = 0
        var shapeY = 0
        var strideX = 0
        var strideY = 0
        if (shape.length === 1) {
          shapeX = shape[0]
          shapeY = 1
          strideX = stride[0]
          strideY = 0
        } else if (shape.length === 2) {
          shapeX = shape[0]
          shapeY = shape[1]
          strideX = stride[0]
          strideY = stride[1]
        } else {
          check$1.raise('invalid shape')
        }
        var dtype = Array.isArray(data.data)
          ? buffer.dtype
          : typedArrayCode(data.data)

        var transposeData = pool.allocType(dtype, shapeX * shapeY)
        transpose(transposeData,
          data.data,
          shapeX, shapeY,
          strideX, strideY,
          data.offset)
        setSubData(transposeData, offset)
        pool.freeType(transposeData)
      } else {
        check$1.raise('invalid data for buffer subdata')
      }
      return reglBuffer
    }

    if (!deferInit) {
      reglBuffer(options)
    }

    reglBuffer._reglType = 'buffer'
    reglBuffer._buffer = buffer
    reglBuffer.subdata = subdata
    if (config.profile) {
      reglBuffer.stats = buffer.stats
    }
    reglBuffer.destroy = function () { destroy(buffer) }

    return reglBuffer
  }

  function restoreBuffers () {
    values(bufferSet).forEach(function (buffer) {
      buffer.buffer = gl.createBuffer()
      gl.bindBuffer(buffer.type, buffer.buffer)
      gl.bufferData(
        buffer.type, buffer.persistentData || buffer.byteLength, buffer.usage)
    })
  }

  if (config.profile) {
    stats.getTotalBufferSize = function () {
      var total = 0
      // TODO: Right now, the streams are not part of the total count.
      Object.keys(bufferSet).forEach(function (key) {
        total += bufferSet[key].stats.size
      })
      return total
    }
  }

  return {
    create: createBuffer,

    createStream: createStream,
    destroyStream: destroyStream,

    clear: function () {
      values(bufferSet).forEach(destroy)
      streamPool.forEach(destroy)
    },

    getBuffer: function (wrapper) {
      if (wrapper && wrapper._buffer instanceof REGLBuffer) {
        return wrapper._buffer
      }
      return null
    },

    restore: restoreBuffers,

    _initBuffer: initBufferFromData
  }
}

var points = 0;
var point = 0;
var lines = 1;
var line = 1;
var triangles = 4;
var triangle = 4;
var primTypes = {
	points: points,
	point: point,
	lines: lines,
	line: line,
	triangles: triangles,
	triangle: triangle,
	"line loop": 2,
	"line strip": 3,
	"triangle strip": 5,
	"triangle fan": 6
};

var GL_POINTS = 0
var GL_LINES = 1
var GL_TRIANGLES = 4

var GL_BYTE$2 = 5120
var GL_UNSIGNED_BYTE$4 = 5121
var GL_SHORT$2 = 5122
var GL_UNSIGNED_SHORT$2 = 5123
var GL_INT$2 = 5124
var GL_UNSIGNED_INT$2 = 5125

var GL_ELEMENT_ARRAY_BUFFER = 34963

var GL_STREAM_DRAW$1 = 0x88E0
var GL_STATIC_DRAW$1 = 0x88E4

function wrapElementsState (gl, extensions, bufferState, stats) {
  var elementSet = {}
  var elementCount = 0

  var elementTypes = {
    'uint8': GL_UNSIGNED_BYTE$4,
    'uint16': GL_UNSIGNED_SHORT$2
  }

  if (extensions.oes_element_index_uint) {
    elementTypes.uint32 = GL_UNSIGNED_INT$2
  }

  function REGLElementBuffer (buffer) {
    this.id = elementCount++
    elementSet[this.id] = this
    this.buffer = buffer
    this.primType = GL_TRIANGLES
    this.vertCount = 0
    this.type = 0
  }

  REGLElementBuffer.prototype.bind = function () {
    this.buffer.bind()
  }

  var bufferPool = []

  function createElementStream (data) {
    var result = bufferPool.pop()
    if (!result) {
      result = new REGLElementBuffer(bufferState.create(
        null,
        GL_ELEMENT_ARRAY_BUFFER,
        true,
        false)._buffer)
    }
    initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0)
    return result
  }

  function destroyElementStream (elements) {
    bufferPool.push(elements)
  }

  function initElements (
    elements,
    data,
    usage,
    prim,
    count,
    byteLength,
    type) {
    elements.buffer.bind()
    var dtype
    if (data) {
      var predictedType = type
      if (!type && (
        !isTypedArray(data) ||
         (isNDArrayLike(data) && !isTypedArray(data.data)))) {
        predictedType = extensions.oes_element_index_uint
          ? GL_UNSIGNED_INT$2
          : GL_UNSIGNED_SHORT$2
      }
      bufferState._initBuffer(
        elements.buffer,
        data,
        usage,
        predictedType,
        3)
    } else {
      gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage)
      elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$4
      elements.buffer.usage = usage
      elements.buffer.dimension = 3
      elements.buffer.byteLength = byteLength
    }

    dtype = type
    if (!type) {
      switch (elements.buffer.dtype) {
        case GL_UNSIGNED_BYTE$4:
        case GL_BYTE$2:
          dtype = GL_UNSIGNED_BYTE$4
          break

        case GL_UNSIGNED_SHORT$2:
        case GL_SHORT$2:
          dtype = GL_UNSIGNED_SHORT$2
          break

        case GL_UNSIGNED_INT$2:
        case GL_INT$2:
          dtype = GL_UNSIGNED_INT$2
          break

        default:
          check$1.raise('unsupported type for element array')
      }
      elements.buffer.dtype = dtype
    }
    elements.type = dtype

    // Check oes_element_index_uint extension
    check$1(
      dtype !== GL_UNSIGNED_INT$2 ||
      !!extensions.oes_element_index_uint,
      '32 bit element buffers not supported, enable oes_element_index_uint first')

    // try to guess default primitive type and arguments
    var vertCount = count
    if (vertCount < 0) {
      vertCount = elements.buffer.byteLength
      if (dtype === GL_UNSIGNED_SHORT$2) {
        vertCount >>= 1
      } else if (dtype === GL_UNSIGNED_INT$2) {
        vertCount >>= 2
      }
    }
    elements.vertCount = vertCount

    // try to guess primitive type from cell dimension
    var primType = prim
    if (prim < 0) {
      primType = GL_TRIANGLES
      var dimension = elements.buffer.dimension
      if (dimension === 1) primType = GL_POINTS
      if (dimension === 2) primType = GL_LINES
      if (dimension === 3) primType = GL_TRIANGLES
    }
    elements.primType = primType
  }

  function destroyElements (elements) {
    stats.elementsCount--

    check$1(elements.buffer !== null, 'must not double destroy elements')
    delete elementSet[elements.id]
    elements.buffer.destroy()
    elements.buffer = null
  }

  function createElements (options, persistent) {
    var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true)
    var elements = new REGLElementBuffer(buffer._buffer)
    stats.elementsCount++

    function reglElements (options) {
      if (!options) {
        buffer()
        elements.primType = GL_TRIANGLES
        elements.vertCount = 0
        elements.type = GL_UNSIGNED_BYTE$4
      } else if (typeof options === 'number') {
        buffer(options)
        elements.primType = GL_TRIANGLES
        elements.vertCount = options | 0
        elements.type = GL_UNSIGNED_BYTE$4
      } else {
        var data = null
        var usage = GL_STATIC_DRAW$1
        var primType = -1
        var vertCount = -1
        var byteLength = 0
        var dtype = 0
        if (Array.isArray(options) ||
            isTypedArray(options) ||
            isNDArrayLike(options)) {
          data = options
        } else {
          check$1.type(options, 'object', 'invalid arguments for elements')
          if ('data' in options) {
            data = options.data
            check$1(
              Array.isArray(data) ||
                isTypedArray(data) ||
                isNDArrayLike(data),
              'invalid data for element buffer')
          }
          if ('usage' in options) {
            check$1.parameter(
              options.usage,
              usageTypes,
              'invalid element buffer usage')
            usage = usageTypes[options.usage]
          }
          if ('primitive' in options) {
            check$1.parameter(
              options.primitive,
              primTypes,
              'invalid element buffer primitive')
            primType = primTypes[options.primitive]
          }
          if ('count' in options) {
            check$1(
              typeof options.count === 'number' && options.count >= 0,
              'invalid vertex count for elements')
            vertCount = options.count | 0
          }
          if ('type' in options) {
            check$1.parameter(
              options.type,
              elementTypes,
              'invalid buffer type')
            dtype = elementTypes[options.type]
          }
          if ('length' in options) {
            byteLength = options.length | 0
          } else {
            byteLength = vertCount
            if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
              byteLength *= 2
            } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
              byteLength *= 4
            }
          }
        }
        initElements(
          elements,
          data,
          usage,
          primType,
          vertCount,
          byteLength,
          dtype)
      }

      return reglElements
    }

    reglElements(options)

    reglElements._reglType = 'elements'
    reglElements._elements = elements
    reglElements.subdata = function (data, offset) {
      buffer.subdata(data, offset)
      return reglElements
    }
    reglElements.destroy = function () {
      destroyElements(elements)
    }

    return reglElements
  }

  return {
    create: createElements,
    createStream: createElementStream,
    destroyStream: destroyElementStream,
    getElements: function (elements) {
      if (typeof elements === 'function' &&
          elements._elements instanceof REGLElementBuffer) {
        return elements._elements
      }
      return null
    },
    clear: function () {
      values(elementSet).forEach(destroyElements)
    }
  }
}

var FLOAT = new Float32Array(1)
var INT = new Uint32Array(FLOAT.buffer)

var GL_UNSIGNED_SHORT$4 = 5123

function convertToHalfFloat (array) {
  var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length)

  for (var i = 0; i < array.length; ++i) {
    if (isNaN(array[i])) {
      ushorts[i] = 0xffff
    } else if (array[i] === Infinity) {
      ushorts[i] = 0x7c00
    } else if (array[i] === -Infinity) {
      ushorts[i] = 0xfc00
    } else {
      FLOAT[0] = array[i]
      var x = INT[0]

      var sgn = (x >>> 31) << 15
      var exp = ((x << 1) >>> 24) - 127
      var frac = (x >> 13) & ((1 << 10) - 1)

      if (exp < -24) {
        // round non-representable denormals to 0
        ushorts[i] = sgn
      } else if (exp < -14) {
        // handle denormals
        var s = -14 - exp
        ushorts[i] = sgn + ((frac + (1 << 10)) >> s)
      } else if (exp > 15) {
        // round overflow to +/- Infinity
        ushorts[i] = sgn + 0x7c00
      } else {
        // otherwise convert directly
        ushorts[i] = sgn + ((exp + 15) << 10) + frac
      }
    }
  }

  return ushorts
}

function isArrayLike (s) {
  return Array.isArray(s) || isTypedArray(s)
}

var isPow2$1 = function (v) {
  return !(v & (v - 1)) && (!!v)
}

var GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3

var GL_TEXTURE_2D$1 = 0x0DE1
var GL_TEXTURE_CUBE_MAP$1 = 0x8513
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 0x8515

var GL_RGBA$1 = 0x1908
var GL_ALPHA = 0x1906
var GL_RGB = 0x1907
var GL_LUMINANCE = 0x1909
var GL_LUMINANCE_ALPHA = 0x190A

var GL_RGBA4 = 0x8056
var GL_RGB5_A1 = 0x8057
var GL_RGB565 = 0x8D62

var GL_UNSIGNED_SHORT_4_4_4_4$1 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1$1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5$1 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL$1 = 0x84FA

var GL_DEPTH_COMPONENT = 0x1902
var GL_DEPTH_STENCIL = 0x84F9

var GL_SRGB_EXT = 0x8C40
var GL_SRGB_ALPHA_EXT = 0x8C42

var GL_HALF_FLOAT_OES$1 = 0x8D61

var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0
var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1
var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2
var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3

var GL_COMPRESSED_RGB_ATC_WEBGL = 0x8C92
var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93
var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE

var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00
var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01
var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02
var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03

var GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64

var GL_UNSIGNED_BYTE$5 = 0x1401
var GL_UNSIGNED_SHORT$3 = 0x1403
var GL_UNSIGNED_INT$3 = 0x1405
var GL_FLOAT$4 = 0x1406

var GL_TEXTURE_WRAP_S = 0x2802
var GL_TEXTURE_WRAP_T = 0x2803

var GL_REPEAT = 0x2901
var GL_CLAMP_TO_EDGE$1 = 0x812F
var GL_MIRRORED_REPEAT = 0x8370

var GL_TEXTURE_MAG_FILTER = 0x2800
var GL_TEXTURE_MIN_FILTER = 0x2801

var GL_NEAREST$1 = 0x2600
var GL_LINEAR = 0x2601
var GL_NEAREST_MIPMAP_NEAREST$1 = 0x2700
var GL_LINEAR_MIPMAP_NEAREST$1 = 0x2701
var GL_NEAREST_MIPMAP_LINEAR$1 = 0x2702
var GL_LINEAR_MIPMAP_LINEAR$1 = 0x2703

var GL_GENERATE_MIPMAP_HINT = 0x8192
var GL_DONT_CARE = 0x1100
var GL_FASTEST = 0x1101
var GL_NICEST = 0x1102

var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE

var GL_UNPACK_ALIGNMENT = 0x0CF5
var GL_UNPACK_FLIP_Y_WEBGL = 0x9240
var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241
var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243

var GL_BROWSER_DEFAULT_WEBGL = 0x9244

var GL_TEXTURE0$1 = 0x84C0

var MIPMAP_FILTERS = [
  GL_NEAREST_MIPMAP_NEAREST$1,
  GL_NEAREST_MIPMAP_LINEAR$1,
  GL_LINEAR_MIPMAP_NEAREST$1,
  GL_LINEAR_MIPMAP_LINEAR$1
]

var CHANNELS_FORMAT = [
  0,
  GL_LUMINANCE,
  GL_LUMINANCE_ALPHA,
  GL_RGB,
  GL_RGBA$1
]

var FORMAT_CHANNELS = {}
FORMAT_CHANNELS[GL_LUMINANCE] =
FORMAT_CHANNELS[GL_ALPHA] =
FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1
FORMAT_CHANNELS[GL_DEPTH_STENCIL] =
FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2
FORMAT_CHANNELS[GL_RGB] =
FORMAT_CHANNELS[GL_SRGB_EXT] = 3
FORMAT_CHANNELS[GL_RGBA$1] =
FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4

function objectName (str) {
  return '[object ' + str + ']'
}

var CANVAS_CLASS = objectName('HTMLCanvasElement')
var OFFSCREENCANVAS_CLASS = objectName('OffscreenCanvas')
var CONTEXT2D_CLASS = objectName('CanvasRenderingContext2D')
var BITMAP_CLASS = objectName('ImageBitmap')
var IMAGE_CLASS = objectName('HTMLImageElement')
var VIDEO_CLASS = objectName('HTMLVideoElement')

var PIXEL_CLASSES = Object.keys(arrayTypes).concat([
  CANVAS_CLASS,
  OFFSCREENCANVAS_CLASS,
  CONTEXT2D_CLASS,
  BITMAP_CLASS,
  IMAGE_CLASS,
  VIDEO_CLASS
])

// for every texture type, store
// the size in bytes.
var TYPE_SIZES = []
TYPE_SIZES[GL_UNSIGNED_BYTE$5] = 1
TYPE_SIZES[GL_FLOAT$4] = 4
TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2

TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2
TYPE_SIZES[GL_UNSIGNED_INT$3] = 4

var FORMAT_SIZES_SPECIAL = []
FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2
FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2
FORMAT_SIZES_SPECIAL[GL_RGB565] = 2
FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5

function isNumericArray (arr) {
  return (
    Array.isArray(arr) &&
    (arr.length === 0 ||
    typeof arr[0] === 'number'))
}

function isRectArray (arr) {
  if (!Array.isArray(arr)) {
    return false
  }
  var width = arr.length
  if (width === 0 || !isArrayLike(arr[0])) {
    return false
  }
  return true
}

function classString (x) {
  return Object.prototype.toString.call(x)
}

function isCanvasElement (object) {
  return classString(object) === CANVAS_CLASS
}

function isOffscreenCanvas (object) {
  return classString(object) === OFFSCREENCANVAS_CLASS
}

function isContext2D (object) {
  return classString(object) === CONTEXT2D_CLASS
}

function isBitmap (object) {
  return classString(object) === BITMAP_CLASS
}

function isImageElement (object) {
  return classString(object) === IMAGE_CLASS
}

function isVideoElement (object) {
  return classString(object) === VIDEO_CLASS
}

function isPixelData (object) {
  if (!object) {
    return false
  }
  var className = classString(object)
  if (PIXEL_CLASSES.indexOf(className) >= 0) {
    return true
  }
  return (
    isNumericArray(object) ||
    isRectArray(object) ||
    isNDArrayLike(object))
}

function typedArrayCode$1 (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function convertData (result, data) {
  var n = data.length
  switch (result.type) {
    case GL_UNSIGNED_BYTE$5:
    case GL_UNSIGNED_SHORT$3:
    case GL_UNSIGNED_INT$3:
    case GL_FLOAT$4:
      var converted = pool.allocType(result.type, n)
      converted.set(data)
      result.data = converted
      break

    case GL_HALF_FLOAT_OES$1:
      result.data = convertToHalfFloat(data)
      break

    default:
      check$1.raise('unsupported texture type, must specify a typed array')
  }
}

function preConvert (image, n) {
  return pool.allocType(
    image.type === GL_HALF_FLOAT_OES$1
      ? GL_FLOAT$4
      : image.type, n)
}

function postConvert (image, data) {
  if (image.type === GL_HALF_FLOAT_OES$1) {
    image.data = convertToHalfFloat(data)
    pool.freeType(data)
  } else {
    image.data = data
  }
}

function transposeData (image, array, strideX, strideY, strideC, offset) {
  var w = image.width
  var h = image.height
  var c = image.channels
  var n = w * h * c
  var data = preConvert(image, n)

  var p = 0
  for (var i = 0; i < h; ++i) {
    for (var j = 0; j < w; ++j) {
      for (var k = 0; k < c; ++k) {
        data[p++] = array[strideX * j + strideY * i + strideC * k + offset]
      }
    }
  }

  postConvert(image, data)
}

function getTextureSize (format, type, width, height, isMipmap, isCube) {
  var s
  if (typeof FORMAT_SIZES_SPECIAL[format] !== 'undefined') {
    // we have a special array for dealing with weird color formats such as RGB5A1
    s = FORMAT_SIZES_SPECIAL[format]
  } else {
    s = FORMAT_CHANNELS[format] * TYPE_SIZES[type]
  }

  if (isCube) {
    s *= 6
  }

  if (isMipmap) {
    // compute the total size of all the mipmaps.
    var total = 0

    var w = width
    while (w >= 1) {
      // we can only use mipmaps on a square image,
      // so we can simply use the width and ignore the height:
      total += s * w * w
      w /= 2
    }
    return total
  } else {
    return s * width * height
  }
}

function createTextureSet (
  gl, extensions, limits, reglPoll, contextState, stats, config) {
  // -------------------------------------------------------
  // Initialize constants and parameter tables here
  // -------------------------------------------------------
  var mipmapHint = {
    "don't care": GL_DONT_CARE,
    'dont care': GL_DONT_CARE,
    'nice': GL_NICEST,
    'fast': GL_FASTEST
  }

  var wrapModes = {
    'repeat': GL_REPEAT,
    'clamp': GL_CLAMP_TO_EDGE$1,
    'mirror': GL_MIRRORED_REPEAT
  }

  var magFilters = {
    'nearest': GL_NEAREST$1,
    'linear': GL_LINEAR
  }

  var minFilters = extend({
    'mipmap': GL_LINEAR_MIPMAP_LINEAR$1,
    'nearest mipmap nearest': GL_NEAREST_MIPMAP_NEAREST$1,
    'linear mipmap nearest': GL_LINEAR_MIPMAP_NEAREST$1,
    'nearest mipmap linear': GL_NEAREST_MIPMAP_LINEAR$1,
    'linear mipmap linear': GL_LINEAR_MIPMAP_LINEAR$1
  }, magFilters)

  var colorSpace = {
    'none': 0,
    'browser': GL_BROWSER_DEFAULT_WEBGL
  }

  var textureTypes = {
    'uint8': GL_UNSIGNED_BYTE$5,
    'rgba4': GL_UNSIGNED_SHORT_4_4_4_4$1,
    'rgb565': GL_UNSIGNED_SHORT_5_6_5$1,
    'rgb5 a1': GL_UNSIGNED_SHORT_5_5_5_1$1
  }

  var textureFormats = {
    'alpha': GL_ALPHA,
    'luminance': GL_LUMINANCE,
    'luminance alpha': GL_LUMINANCE_ALPHA,
    'rgb': GL_RGB,
    'rgba': GL_RGBA$1,
    'rgba4': GL_RGBA4,
    'rgb5 a1': GL_RGB5_A1,
    'rgb565': GL_RGB565
  }

  var compressedTextureFormats = {}

  if (extensions.ext_srgb) {
    textureFormats.srgb = GL_SRGB_EXT
    textureFormats.srgba = GL_SRGB_ALPHA_EXT
  }

  if (extensions.oes_texture_float) {
    textureTypes.float32 = textureTypes.float = GL_FLOAT$4
  }

  if (extensions.oes_texture_half_float) {
    textureTypes['float16'] = textureTypes['half float'] = GL_HALF_FLOAT_OES$1
  }

  if (extensions.webgl_depth_texture) {
    extend(textureFormats, {
      'depth': GL_DEPTH_COMPONENT,
      'depth stencil': GL_DEPTH_STENCIL
    })

    extend(textureTypes, {
      'uint16': GL_UNSIGNED_SHORT$3,
      'uint32': GL_UNSIGNED_INT$3,
      'depth stencil': GL_UNSIGNED_INT_24_8_WEBGL$1
    })
  }

  if (extensions.webgl_compressed_texture_s3tc) {
    extend(compressedTextureFormats, {
      'rgb s3tc dxt1': GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
      'rgba s3tc dxt1': GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
      'rgba s3tc dxt3': GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
      'rgba s3tc dxt5': GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
    })
  }

  if (extensions.webgl_compressed_texture_atc) {
    extend(compressedTextureFormats, {
      'rgb atc': GL_COMPRESSED_RGB_ATC_WEBGL,
      'rgba atc explicit alpha': GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
      'rgba atc interpolated alpha': GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
    })
  }

  if (extensions.webgl_compressed_texture_pvrtc) {
    extend(compressedTextureFormats, {
      'rgb pvrtc 4bppv1': GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
      'rgb pvrtc 2bppv1': GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
      'rgba pvrtc 4bppv1': GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
      'rgba pvrtc 2bppv1': GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
    })
  }

  if (extensions.webgl_compressed_texture_etc1) {
    compressedTextureFormats['rgb etc1'] = GL_COMPRESSED_RGB_ETC1_WEBGL
  }

  // Copy over all texture formats
  var supportedCompressedFormats = Array.prototype.slice.call(
    gl.getParameter(GL_COMPRESSED_TEXTURE_FORMATS))
  Object.keys(compressedTextureFormats).forEach(function (name) {
    var format = compressedTextureFormats[name]
    if (supportedCompressedFormats.indexOf(format) >= 0) {
      textureFormats[name] = format
    }
  })

  var supportedFormats = Object.keys(textureFormats)
  limits.textureFormats = supportedFormats

  // associate with every format string its
  // corresponding GL-value.
  var textureFormatsInvert = []
  Object.keys(textureFormats).forEach(function (key) {
    var val = textureFormats[key]
    textureFormatsInvert[val] = key
  })

  // associate with every type string its
  // corresponding GL-value.
  var textureTypesInvert = []
  Object.keys(textureTypes).forEach(function (key) {
    var val = textureTypes[key]
    textureTypesInvert[val] = key
  })

  var magFiltersInvert = []
  Object.keys(magFilters).forEach(function (key) {
    var val = magFilters[key]
    magFiltersInvert[val] = key
  })

  var minFiltersInvert = []
  Object.keys(minFilters).forEach(function (key) {
    var val = minFilters[key]
    minFiltersInvert[val] = key
  })

  var wrapModesInvert = []
  Object.keys(wrapModes).forEach(function (key) {
    var val = wrapModes[key]
    wrapModesInvert[val] = key
  })

  // colorFormats[] gives the format (channels) associated to an
  // internalformat
  var colorFormats = supportedFormats.reduce(function (color, key) {
    var glenum = textureFormats[key]
    if (glenum === GL_LUMINANCE ||
        glenum === GL_ALPHA ||
        glenum === GL_LUMINANCE ||
        glenum === GL_LUMINANCE_ALPHA ||
        glenum === GL_DEPTH_COMPONENT ||
        glenum === GL_DEPTH_STENCIL ||
        (extensions.ext_srgb &&
                (glenum === GL_SRGB_EXT ||
                 glenum === GL_SRGB_ALPHA_EXT))) {
      color[glenum] = glenum
    } else if (glenum === GL_RGB5_A1 || key.indexOf('rgba') >= 0) {
      color[glenum] = GL_RGBA$1
    } else {
      color[glenum] = GL_RGB
    }
    return color
  }, {})

  function TexFlags () {
    // format info
    this.internalformat = GL_RGBA$1
    this.format = GL_RGBA$1
    this.type = GL_UNSIGNED_BYTE$5
    this.compressed = false

    // pixel storage
    this.premultiplyAlpha = false
    this.flipY = false
    this.unpackAlignment = 1
    this.colorSpace = GL_BROWSER_DEFAULT_WEBGL

    // shape info
    this.width = 0
    this.height = 0
    this.channels = 0
  }

  function copyFlags (result, other) {
    result.internalformat = other.internalformat
    result.format = other.format
    result.type = other.type
    result.compressed = other.compressed

    result.premultiplyAlpha = other.premultiplyAlpha
    result.flipY = other.flipY
    result.unpackAlignment = other.unpackAlignment
    result.colorSpace = other.colorSpace

    result.width = other.width
    result.height = other.height
    result.channels = other.channels
  }

  function parseFlags (flags, options) {
    if (typeof options !== 'object' || !options) {
      return
    }

    if ('premultiplyAlpha' in options) {
      check$1.type(options.premultiplyAlpha, 'boolean',
        'invalid premultiplyAlpha')
      flags.premultiplyAlpha = options.premultiplyAlpha
    }

    if ('flipY' in options) {
      check$1.type(options.flipY, 'boolean',
        'invalid texture flip')
      flags.flipY = options.flipY
    }

    if ('alignment' in options) {
      check$1.oneOf(options.alignment, [1, 2, 4, 8],
        'invalid texture unpack alignment')
      flags.unpackAlignment = options.alignment
    }

    if ('colorSpace' in options) {
      check$1.parameter(options.colorSpace, colorSpace,
        'invalid colorSpace')
      flags.colorSpace = colorSpace[options.colorSpace]
    }

    if ('type' in options) {
      var type = options.type
      check$1(extensions.oes_texture_float ||
        !(type === 'float' || type === 'float32'),
      'you must enable the OES_texture_float extension in order to use floating point textures.')
      check$1(extensions.oes_texture_half_float ||
        !(type === 'half float' || type === 'float16'),
      'you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures.')
      check$1(extensions.webgl_depth_texture ||
        !(type === 'uint16' || type === 'uint32' || type === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.')
      check$1.parameter(type, textureTypes,
        'invalid texture type')
      flags.type = textureTypes[type]
    }

    var w = flags.width
    var h = flags.height
    var c = flags.channels
    var hasChannels = false
    if ('shape' in options) {
      check$1(Array.isArray(options.shape) && options.shape.length >= 2,
        'shape must be an array')
      w = options.shape[0]
      h = options.shape[1]
      if (options.shape.length === 3) {
        c = options.shape[2]
        check$1(c > 0 && c <= 4, 'invalid number of channels')
        hasChannels = true
      }
      check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width')
      check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height')
    } else {
      if ('radius' in options) {
        w = h = options.radius
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid radius')
      }
      if ('width' in options) {
        w = options.width
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width')
      }
      if ('height' in options) {
        h = options.height
        check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height')
      }
      if ('channels' in options) {
        c = options.channels
        check$1(c > 0 && c <= 4, 'invalid number of channels')
        hasChannels = true
      }
    }
    flags.width = w | 0
    flags.height = h | 0
    flags.channels = c | 0

    var hasFormat = false
    if ('format' in options) {
      var formatStr = options.format
      check$1(extensions.webgl_depth_texture ||
        !(formatStr === 'depth' || formatStr === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.')
      check$1.parameter(formatStr, textureFormats,
        'invalid texture format')
      var internalformat = flags.internalformat = textureFormats[formatStr]
      flags.format = colorFormats[internalformat]
      if (formatStr in textureTypes) {
        if (!('type' in options)) {
          flags.type = textureTypes[formatStr]
        }
      }
      if (formatStr in compressedTextureFormats) {
        flags.compressed = true
      }
      hasFormat = true
    }

    // Reconcile channels and format
    if (!hasChannels && hasFormat) {
      flags.channels = FORMAT_CHANNELS[flags.format]
    } else if (hasChannels && !hasFormat) {
      if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
        flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels]
      }
    } else if (hasFormat && hasChannels) {
      check$1(
        flags.channels === FORMAT_CHANNELS[flags.format],
        'number of channels inconsistent with specified format')
    }
  }

  function setFlags (flags) {
    gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY)
    gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha)
    gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace)
    gl.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment)
  }

  // -------------------------------------------------------
  // Tex image data
  // -------------------------------------------------------
  function TexImage () {
    TexFlags.call(this)

    this.xOffset = 0
    this.yOffset = 0

    // data
    this.data = null
    this.needsFree = false

    // html element
    this.element = null

    // copyTexImage info
    this.needsCopy = false
  }

  function parseImage (image, options) {
    var data = null
    if (isPixelData(options)) {
      data = options
    } else if (options) {
      check$1.type(options, 'object', 'invalid pixel data type')
      parseFlags(image, options)
      if ('x' in options) {
        image.xOffset = options.x | 0
      }
      if ('y' in options) {
        image.yOffset = options.y | 0
      }
      if (isPixelData(options.data)) {
        data = options.data
      }
    }

    check$1(
      !image.compressed ||
      data instanceof Uint8Array,
      'compressed texture data must be stored in a uint8array')

    if (options.copy) {
      check$1(!data, 'can not specify copy and data field for the same texture')
      var viewW = contextState.viewportWidth
      var viewH = contextState.viewportHeight
      image.width = image.width || (viewW - image.xOffset)
      image.height = image.height || (viewH - image.yOffset)
      image.needsCopy = true
      check$1(image.xOffset >= 0 && image.xOffset < viewW &&
            image.yOffset >= 0 && image.yOffset < viewH &&
            image.width > 0 && image.width <= viewW &&
            image.height > 0 && image.height <= viewH,
      'copy texture read out of bounds')
    } else if (!data) {
      image.width = image.width || 1
      image.height = image.height || 1
      image.channels = image.channels || 4
    } else if (isTypedArray(data)) {
      image.channels = image.channels || 4
      image.data = data
      if (!('type' in options) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(data)
      }
    } else if (isNumericArray(data)) {
      image.channels = image.channels || 4
      convertData(image, data)
      image.alignment = 1
      image.needsFree = true
    } else if (isNDArrayLike(data)) {
      var array = data.data
      if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(array)
      }
      var shape = data.shape
      var stride = data.stride
      var shapeX, shapeY, shapeC, strideX, strideY, strideC
      if (shape.length === 3) {
        shapeC = shape[2]
        strideC = stride[2]
      } else {
        check$1(shape.length === 2, 'invalid ndarray pixel data, must be 2 or 3D')
        shapeC = 1
        strideC = 1
      }
      shapeX = shape[0]
      shapeY = shape[1]
      strideX = stride[0]
      strideY = stride[1]
      image.alignment = 1
      image.width = shapeX
      image.height = shapeY
      image.channels = shapeC
      image.format = image.internalformat = CHANNELS_FORMAT[shapeC]
      image.needsFree = true
      transposeData(image, array, strideX, strideY, strideC, data.offset)
    } else if (isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {
      if (isCanvasElement(data) || isOffscreenCanvas(data)) {
        image.element = data
      } else {
        image.element = data.canvas
      }
      image.width = image.element.width
      image.height = image.element.height
      image.channels = 4
    } else if (isBitmap(data)) {
      image.element = data
      image.width = data.width
      image.height = data.height
      image.channels = 4
    } else if (isImageElement(data)) {
      image.element = data
      image.width = data.naturalWidth
      image.height = data.naturalHeight
      image.channels = 4
    } else if (isVideoElement(data)) {
      image.element = data
      image.width = data.videoWidth
      image.height = data.videoHeight
      image.channels = 4
    } else if (isRectArray(data)) {
      var w = image.width || data[0].length
      var h = image.height || data.length
      var c = image.channels
      if (isArrayLike(data[0][0])) {
        c = c || data[0][0].length
      } else {
        c = c || 1
      }
      var arrayShape = flattenUtils.shape(data)
      var n = 1
      for (var dd = 0; dd < arrayShape.length; ++dd) {
        n *= arrayShape[dd]
      }
      var allocData = preConvert(image, n)
      flattenUtils.flatten(data, arrayShape, '', allocData)
      postConvert(image, allocData)
      image.alignment = 1
      image.width = w
      image.height = h
      image.channels = c
      image.format = image.internalformat = CHANNELS_FORMAT[c]
      image.needsFree = true
    }

    if (image.type === GL_FLOAT$4) {
      check$1(limits.extensions.indexOf('oes_texture_float') >= 0,
        'oes_texture_float extension not enabled')
    } else if (image.type === GL_HALF_FLOAT_OES$1) {
      check$1(limits.extensions.indexOf('oes_texture_half_float') >= 0,
        'oes_texture_half_float extension not enabled')
    }

    // do compressed texture  validation here.
  }

  function setImage (info, target, miplevel) {
    var element = info.element
    var data = info.data
    var internalformat = info.internalformat
    var format = info.format
    var type = info.type
    var width = info.width
    var height = info.height

    setFlags(info)

    if (element) {
      gl.texImage2D(target, miplevel, format, format, type, element)
    } else if (info.compressed) {
      gl.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data)
    } else if (info.needsCopy) {
      reglPoll()
      gl.copyTexImage2D(
        target, miplevel, format, info.xOffset, info.yOffset, width, height, 0)
    } else {
      gl.texImage2D(target, miplevel, format, width, height, 0, format, type, data || null)
    }
  }

  function setSubImage (info, target, x, y, miplevel) {
    var element = info.element
    var data = info.data
    var internalformat = info.internalformat
    var format = info.format
    var type = info.type
    var width = info.width
    var height = info.height

    setFlags(info)

    if (element) {
      gl.texSubImage2D(
        target, miplevel, x, y, format, type, element)
    } else if (info.compressed) {
      gl.compressedTexSubImage2D(
        target, miplevel, x, y, internalformat, width, height, data)
    } else if (info.needsCopy) {
      reglPoll()
      gl.copyTexSubImage2D(
        target, miplevel, x, y, info.xOffset, info.yOffset, width, height)
    } else {
      gl.texSubImage2D(
        target, miplevel, x, y, width, height, format, type, data)
    }
  }

  // texImage pool
  var imagePool = []

  function allocImage () {
    return imagePool.pop() || new TexImage()
  }

  function freeImage (image) {
    if (image.needsFree) {
      pool.freeType(image.data)
    }
    TexImage.call(image)
    imagePool.push(image)
  }

  // -------------------------------------------------------
  // Mip map
  // -------------------------------------------------------
  function MipMap () {
    TexFlags.call(this)

    this.genMipmaps = false
    this.mipmapHint = GL_DONT_CARE
    this.mipmask = 0
    this.images = Array(16)
  }

  function parseMipMapFromShape (mipmap, width, height) {
    var img = mipmap.images[0] = allocImage()
    mipmap.mipmask = 1
    img.width = mipmap.width = width
    img.height = mipmap.height = height
    img.channels = mipmap.channels = 4
  }

  function parseMipMapFromObject (mipmap, options) {
    var imgData = null
    if (isPixelData(options)) {
      imgData = mipmap.images[0] = allocImage()
      copyFlags(imgData, mipmap)
      parseImage(imgData, options)
      mipmap.mipmask = 1
    } else {
      parseFlags(mipmap, options)
      if (Array.isArray(options.mipmap)) {
        var mipData = options.mipmap
        for (var i = 0; i < mipData.length; ++i) {
          imgData = mipmap.images[i] = allocImage()
          copyFlags(imgData, mipmap)
          imgData.width >>= i
          imgData.height >>= i
          parseImage(imgData, mipData[i])
          mipmap.mipmask |= (1 << i)
        }
      } else {
        imgData = mipmap.images[0] = allocImage()
        copyFlags(imgData, mipmap)
        parseImage(imgData, options)
        mipmap.mipmask = 1
      }
    }
    copyFlags(mipmap, mipmap.images[0])

    // For textures of the compressed format WEBGL_compressed_texture_s3tc
    // we must have that
    //
    // "When level equals zero width and height must be a multiple of 4.
    // When level is greater than 0 width and height must be 0, 1, 2 or a multiple of 4. "
    //
    // but we do not yet support having multiple mipmap levels for compressed textures,
    // so we only test for level zero.

    if (
      mipmap.compressed &&
      (
        mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
      )
    ) {
      check$1(mipmap.width % 4 === 0 && mipmap.height % 4 === 0,
        'for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4')
    }
  }

  function setMipMap (mipmap, target) {
    var images = mipmap.images
    for (var i = 0; i < images.length; ++i) {
      if (!images[i]) {
        return
      }
      setImage(images[i], target, i)
    }
  }

  var mipPool = []

  function allocMipMap () {
    var result = mipPool.pop() || new MipMap()
    TexFlags.call(result)
    result.mipmask = 0
    for (var i = 0; i < 16; ++i) {
      result.images[i] = null
    }
    return result
  }

  function freeMipMap (mipmap) {
    var images = mipmap.images
    for (var i = 0; i < images.length; ++i) {
      if (images[i]) {
        freeImage(images[i])
      }
      images[i] = null
    }
    mipPool.push(mipmap)
  }

  // -------------------------------------------------------
  // Tex info
  // -------------------------------------------------------
  function TexInfo () {
    this.minFilter = GL_NEAREST$1
    this.magFilter = GL_NEAREST$1

    this.wrapS = GL_CLAMP_TO_EDGE$1
    this.wrapT = GL_CLAMP_TO_EDGE$1

    this.anisotropic = 1

    this.genMipmaps = false
    this.mipmapHint = GL_DONT_CARE
  }

  function parseTexInfo (info, options) {
    if ('min' in options) {
      var minFilter = options.min
      check$1.parameter(minFilter, minFilters)
      info.minFilter = minFilters[minFilter]
      if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !('faces' in options)) {
        info.genMipmaps = true
      }
    }

    if ('mag' in options) {
      var magFilter = options.mag
      check$1.parameter(magFilter, magFilters)
      info.magFilter = magFilters[magFilter]
    }

    var wrapS = info.wrapS
    var wrapT = info.wrapT
    if ('wrap' in options) {
      var wrap = options.wrap
      if (typeof wrap === 'string') {
        check$1.parameter(wrap, wrapModes)
        wrapS = wrapT = wrapModes[wrap]
      } else if (Array.isArray(wrap)) {
        check$1.parameter(wrap[0], wrapModes)
        check$1.parameter(wrap[1], wrapModes)
        wrapS = wrapModes[wrap[0]]
        wrapT = wrapModes[wrap[1]]
      }
    } else {
      if ('wrapS' in options) {
        var optWrapS = options.wrapS
        check$1.parameter(optWrapS, wrapModes)
        wrapS = wrapModes[optWrapS]
      }
      if ('wrapT' in options) {
        var optWrapT = options.wrapT
        check$1.parameter(optWrapT, wrapModes)
        wrapT = wrapModes[optWrapT]
      }
    }
    info.wrapS = wrapS
    info.wrapT = wrapT

    if ('anisotropic' in options) {
      var anisotropic = options.anisotropic
      check$1(typeof anisotropic === 'number' &&
         anisotropic >= 1 && anisotropic <= limits.maxAnisotropic,
      'aniso samples must be between 1 and ')
      info.anisotropic = options.anisotropic
    }

    if ('mipmap' in options) {
      var hasMipMap = false
      switch (typeof options.mipmap) {
        case 'string':
          check$1.parameter(options.mipmap, mipmapHint,
            'invalid mipmap hint')
          info.mipmapHint = mipmapHint[options.mipmap]
          info.genMipmaps = true
          hasMipMap = true
          break

        case 'boolean':
          hasMipMap = info.genMipmaps = options.mipmap
          break

        case 'object':
          check$1(Array.isArray(options.mipmap), 'invalid mipmap type')
          info.genMipmaps = false
          hasMipMap = true
          break

        default:
          check$1.raise('invalid mipmap type')
      }
      if (hasMipMap && !('min' in options)) {
        info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1
      }
    }
  }

  function setTexInfo (info, target) {
    gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter)
    gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter)
    gl.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS)
    gl.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT)
    if (extensions.ext_texture_filter_anisotropic) {
      gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic)
    }
    if (info.genMipmaps) {
      gl.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint)
      gl.generateMipmap(target)
    }
  }

  // -------------------------------------------------------
  // Full texture object
  // -------------------------------------------------------
  var textureCount = 0
  var textureSet = {}
  var numTexUnits = limits.maxTextureUnits
  var textureUnits = Array(numTexUnits).map(function () {
    return null
  })

  function REGLTexture (target) {
    TexFlags.call(this)
    this.mipmask = 0
    this.internalformat = GL_RGBA$1

    this.id = textureCount++

    this.refCount = 1

    this.target = target
    this.texture = gl.createTexture()

    this.unit = -1
    this.bindCount = 0

    this.texInfo = new TexInfo()

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  function tempBind (texture) {
    gl.activeTexture(GL_TEXTURE0$1)
    gl.bindTexture(texture.target, texture.texture)
  }

  function tempRestore () {
    var prev = textureUnits[0]
    if (prev) {
      gl.bindTexture(prev.target, prev.texture)
    } else {
      gl.bindTexture(GL_TEXTURE_2D$1, null)
    }
  }

  function destroy (texture) {
    var handle = texture.texture
    check$1(handle, 'must not double destroy texture')
    var unit = texture.unit
    var target = texture.target
    if (unit >= 0) {
      gl.activeTexture(GL_TEXTURE0$1 + unit)
      gl.bindTexture(target, null)
      textureUnits[unit] = null
    }
    gl.deleteTexture(handle)
    texture.texture = null
    texture.params = null
    texture.pixels = null
    texture.refCount = 0
    delete textureSet[texture.id]
    stats.textureCount--
  }

  extend(REGLTexture.prototype, {
    bind: function () {
      var texture = this
      texture.bindCount += 1
      var unit = texture.unit
      if (unit < 0) {
        for (var i = 0; i < numTexUnits; ++i) {
          var other = textureUnits[i]
          if (other) {
            if (other.bindCount > 0) {
              continue
            }
            other.unit = -1
          }
          textureUnits[i] = texture
          unit = i
          break
        }
        if (unit >= numTexUnits) {
          check$1.raise('insufficient number of texture units')
        }
        if (config.profile && stats.maxTextureUnits < (unit + 1)) {
          stats.maxTextureUnits = unit + 1 // +1, since the units are zero-based
        }
        texture.unit = unit
        gl.activeTexture(GL_TEXTURE0$1 + unit)
        gl.bindTexture(texture.target, texture.texture)
      }
      return unit
    },

    unbind: function () {
      this.bindCount -= 1
    },

    decRef: function () {
      if (--this.refCount <= 0) {
        destroy(this)
      }
    }
  })

  function createTexture2D (a, b) {
    var texture = new REGLTexture(GL_TEXTURE_2D$1)
    textureSet[texture.id] = texture
    stats.textureCount++

    function reglTexture2D (a, b) {
      var texInfo = texture.texInfo
      TexInfo.call(texInfo)
      var mipData = allocMipMap()

      if (typeof a === 'number') {
        if (typeof b === 'number') {
          parseMipMapFromShape(mipData, a | 0, b | 0)
        } else {
          parseMipMapFromShape(mipData, a | 0, a | 0)
        }
      } else if (a) {
        check$1.type(a, 'object', 'invalid arguments to regl.texture')
        parseTexInfo(texInfo, a)
        parseMipMapFromObject(mipData, a)
      } else {
        // empty textures get assigned a default shape of 1x1
        parseMipMapFromShape(mipData, 1, 1)
      }

      if (texInfo.genMipmaps) {
        mipData.mipmask = (mipData.width << 1) - 1
      }
      texture.mipmask = mipData.mipmask

      copyFlags(texture, mipData)

      check$1.texture2D(texInfo, mipData, limits)
      texture.internalformat = mipData.internalformat

      reglTexture2D.width = mipData.width
      reglTexture2D.height = mipData.height

      tempBind(texture)
      setMipMap(mipData, GL_TEXTURE_2D$1)
      setTexInfo(texInfo, GL_TEXTURE_2D$1)
      tempRestore()

      freeMipMap(mipData)

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          mipData.width,
          mipData.height,
          texInfo.genMipmaps,
          false)
      }
      reglTexture2D.format = textureFormatsInvert[texture.internalformat]
      reglTexture2D.type = textureTypesInvert[texture.type]

      reglTexture2D.mag = magFiltersInvert[texInfo.magFilter]
      reglTexture2D.min = minFiltersInvert[texInfo.minFilter]

      reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS]
      reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT]

      return reglTexture2D
    }

    function subimage (image, x_, y_, level_) {
      check$1(!!image, 'must specify image data')

      var x = x_ | 0
      var y = y_ | 0
      var level = level_ | 0

      var imageData = allocImage()
      copyFlags(imageData, texture)
      imageData.width = 0
      imageData.height = 0
      parseImage(imageData, image)
      imageData.width = imageData.width || ((texture.width >> level) - x)
      imageData.height = imageData.height || ((texture.height >> level) - y)

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage')
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds')
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data')
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data')

      tempBind(texture)
      setSubImage(imageData, GL_TEXTURE_2D$1, x, y, level)
      tempRestore()

      freeImage(imageData)

      return reglTexture2D
    }

    function resize (w_, h_) {
      var w = w_ | 0
      var h = (h_ | 0) || w
      if (w === texture.width && h === texture.height) {
        return reglTexture2D
      }

      reglTexture2D.width = texture.width = w
      reglTexture2D.height = texture.height = h

      tempBind(texture)

      for (var i = 0; texture.mipmask >> i; ++i) {
        var _w = w >> i
        var _h = h >> i
        if (!_w || !_h) break
        gl.texImage2D(
          GL_TEXTURE_2D$1,
          i,
          texture.format,
          _w,
          _h,
          0,
          texture.format,
          texture.type,
          null)
      }
      tempRestore()

      // also, recompute the texture size.
      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          w,
          h,
          false,
          false)
      }

      return reglTexture2D
    }

    reglTexture2D(a, b)

    reglTexture2D.subimage = subimage
    reglTexture2D.resize = resize
    reglTexture2D._reglType = 'texture2d'
    reglTexture2D._texture = texture
    if (config.profile) {
      reglTexture2D.stats = texture.stats
    }
    reglTexture2D.destroy = function () {
      texture.decRef()
    }

    return reglTexture2D
  }

  function createTextureCube (a0, a1, a2, a3, a4, a5) {
    var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1)
    textureSet[texture.id] = texture
    stats.cubeCount++

    var faces = new Array(6)

    function reglTextureCube (a0, a1, a2, a3, a4, a5) {
      var i
      var texInfo = texture.texInfo
      TexInfo.call(texInfo)
      for (i = 0; i < 6; ++i) {
        faces[i] = allocMipMap()
      }

      if (typeof a0 === 'number' || !a0) {
        var s = (a0 | 0) || 1
        for (i = 0; i < 6; ++i) {
          parseMipMapFromShape(faces[i], s, s)
        }
      } else if (typeof a0 === 'object') {
        if (a1) {
          parseMipMapFromObject(faces[0], a0)
          parseMipMapFromObject(faces[1], a1)
          parseMipMapFromObject(faces[2], a2)
          parseMipMapFromObject(faces[3], a3)
          parseMipMapFromObject(faces[4], a4)
          parseMipMapFromObject(faces[5], a5)
        } else {
          parseTexInfo(texInfo, a0)
          parseFlags(texture, a0)
          if ('faces' in a0) {
            var faceInput = a0.faces
            check$1(Array.isArray(faceInput) && faceInput.length === 6,
              'cube faces must be a length 6 array')
            for (i = 0; i < 6; ++i) {
              check$1(typeof faceInput[i] === 'object' && !!faceInput[i],
                'invalid input for cube map face')
              copyFlags(faces[i], texture)
              parseMipMapFromObject(faces[i], faceInput[i])
            }
          } else {
            for (i = 0; i < 6; ++i) {
              parseMipMapFromObject(faces[i], a0)
            }
          }
        }
      } else {
        check$1.raise('invalid arguments to cube map')
      }

      copyFlags(texture, faces[0])
      check$1.optional(function () {
        if (!limits.npotTextureCube) {
          check$1(isPow2$1(texture.width) && isPow2$1(texture.height), 'your browser does not support non power or two texture dimensions')
        }
      })

      if (texInfo.genMipmaps) {
        texture.mipmask = (faces[0].width << 1) - 1
      } else {
        texture.mipmask = faces[0].mipmask
      }

      check$1.textureCube(texture, texInfo, faces, limits)
      texture.internalformat = faces[0].internalformat

      reglTextureCube.width = faces[0].width
      reglTextureCube.height = faces[0].height

      tempBind(texture)
      for (i = 0; i < 6; ++i) {
        setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i)
      }
      setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1)
      tempRestore()

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          texInfo.genMipmaps,
          true)
      }

      reglTextureCube.format = textureFormatsInvert[texture.internalformat]
      reglTextureCube.type = textureTypesInvert[texture.type]

      reglTextureCube.mag = magFiltersInvert[texInfo.magFilter]
      reglTextureCube.min = minFiltersInvert[texInfo.minFilter]

      reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS]
      reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT]

      for (i = 0; i < 6; ++i) {
        freeMipMap(faces[i])
      }

      return reglTextureCube
    }

    function subimage (face, image, x_, y_, level_) {
      check$1(!!image, 'must specify image data')
      check$1(typeof face === 'number' && face === (face | 0) &&
        face >= 0 && face < 6, 'invalid face')

      var x = x_ | 0
      var y = y_ | 0
      var level = level_ | 0

      var imageData = allocImage()
      copyFlags(imageData, texture)
      imageData.width = 0
      imageData.height = 0
      parseImage(imageData, image)
      imageData.width = imageData.width || ((texture.width >> level) - x)
      imageData.height = imageData.height || ((texture.height >> level) - y)

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage')
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds')
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data')
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data')

      tempBind(texture)
      setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x, y, level)
      tempRestore()

      freeImage(imageData)

      return reglTextureCube
    }

    function resize (radius_) {
      var radius = radius_ | 0
      if (radius === texture.width) {
        return
      }

      reglTextureCube.width = texture.width = radius
      reglTextureCube.height = texture.height = radius

      tempBind(texture)
      for (var i = 0; i < 6; ++i) {
        for (var j = 0; texture.mipmask >> j; ++j) {
          gl.texImage2D(
            GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i,
            j,
            texture.format,
            radius >> j,
            radius >> j,
            0,
            texture.format,
            texture.type,
            null)
        }
      }
      tempRestore()

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          false,
          true)
      }

      return reglTextureCube
    }

    reglTextureCube(a0, a1, a2, a3, a4, a5)

    reglTextureCube.subimage = subimage
    reglTextureCube.resize = resize
    reglTextureCube._reglType = 'textureCube'
    reglTextureCube._texture = texture
    if (config.profile) {
      reglTextureCube.stats = texture.stats
    }
    reglTextureCube.destroy = function () {
      texture.decRef()
    }

    return reglTextureCube
  }

  // Called when regl is destroyed
  function destroyTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      gl.activeTexture(GL_TEXTURE0$1 + i)
      gl.bindTexture(GL_TEXTURE_2D$1, null)
      textureUnits[i] = null
    }
    values(textureSet).forEach(destroy)

    stats.cubeCount = 0
    stats.textureCount = 0
  }

  if (config.profile) {
    stats.getTotalTextureSize = function () {
      var total = 0
      Object.keys(textureSet).forEach(function (key) {
        total += textureSet[key].stats.size
      })
      return total
    }
  }

  function restoreTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i]
      if (tex) {
        tex.bindCount = 0
        tex.unit = -1
        textureUnits[i] = null
      }
    }

    values(textureSet).forEach(function (texture) {
      texture.texture = gl.createTexture()
      gl.bindTexture(texture.target, texture.texture)
      for (var i = 0; i < 32; ++i) {
        if ((texture.mipmask & (1 << i)) === 0) {
          continue
        }
        if (texture.target === GL_TEXTURE_2D$1) {
          gl.texImage2D(GL_TEXTURE_2D$1,
            i,
            texture.internalformat,
            texture.width >> i,
            texture.height >> i,
            0,
            texture.internalformat,
            texture.type,
            null)
        } else {
          for (var j = 0; j < 6; ++j) {
            gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j,
              i,
              texture.internalformat,
              texture.width >> i,
              texture.height >> i,
              0,
              texture.internalformat,
              texture.type,
              null)
          }
        }
      }
      setTexInfo(texture.texInfo, texture.target)
    })
  }

  function refreshTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i]
      if (tex) {
        tex.bindCount = 0
        tex.unit = -1
        textureUnits[i] = null
      }
      gl.activeTexture(GL_TEXTURE0$1 + i)
      gl.bindTexture(GL_TEXTURE_2D$1, null)
      gl.bindTexture(GL_TEXTURE_CUBE_MAP$1, null)
    }
  }

  return {
    create2D: createTexture2D,
    createCube: createTextureCube,
    clear: destroyTextures,
    getTexture: function (wrapper) {
      return null
    },
    restore: restoreTextures,
    refresh: refreshTextures
  }
}

var GL_RENDERBUFFER = 0x8D41

var GL_RGBA4$1 = 0x8056
var GL_RGB5_A1$1 = 0x8057
var GL_RGB565$1 = 0x8D62
var GL_DEPTH_COMPONENT16 = 0x81A5
var GL_STENCIL_INDEX8 = 0x8D48
var GL_DEPTH_STENCIL$1 = 0x84F9

var GL_SRGB8_ALPHA8_EXT = 0x8C43

var GL_RGBA32F_EXT = 0x8814

var GL_RGBA16F_EXT = 0x881A
var GL_RGB16F_EXT = 0x881B

var FORMAT_SIZES = []

FORMAT_SIZES[GL_RGBA4$1] = 2
FORMAT_SIZES[GL_RGB5_A1$1] = 2
FORMAT_SIZES[GL_RGB565$1] = 2

FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2
FORMAT_SIZES[GL_STENCIL_INDEX8] = 1
FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4

FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4
FORMAT_SIZES[GL_RGBA32F_EXT] = 16
FORMAT_SIZES[GL_RGBA16F_EXT] = 8
FORMAT_SIZES[GL_RGB16F_EXT] = 6

function getRenderbufferSize (format, width, height) {
  return FORMAT_SIZES[format] * width * height
}

var wrapRenderbuffers = function (gl, extensions, limits, stats, config) {
  var formatTypes = {
    'rgba4': GL_RGBA4$1,
    'rgb565': GL_RGB565$1,
    'rgb5 a1': GL_RGB5_A1$1,
    'depth': GL_DEPTH_COMPONENT16,
    'stencil': GL_STENCIL_INDEX8,
    'depth stencil': GL_DEPTH_STENCIL$1
  }

  if (extensions.ext_srgb) {
    formatTypes['srgba'] = GL_SRGB8_ALPHA8_EXT
  }

  if (extensions.ext_color_buffer_half_float) {
    formatTypes['rgba16f'] = GL_RGBA16F_EXT
    formatTypes['rgb16f'] = GL_RGB16F_EXT
  }

  if (extensions.webgl_color_buffer_float) {
    formatTypes['rgba32f'] = GL_RGBA32F_EXT
  }

  var formatTypesInvert = []
  Object.keys(formatTypes).forEach(function (key) {
    var val = formatTypes[key]
    formatTypesInvert[val] = key
  })

  var renderbufferCount = 0
  var renderbufferSet = {}

  function REGLRenderbuffer (renderbuffer) {
    this.id = renderbufferCount++
    this.refCount = 1

    this.renderbuffer = renderbuffer

    this.format = GL_RGBA4$1
    this.width = 0
    this.height = 0

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  REGLRenderbuffer.prototype.decRef = function () {
    if (--this.refCount <= 0) {
      destroy(this)
    }
  }

  function destroy (rb) {
    var handle = rb.renderbuffer
    check$1(handle, 'must not double destroy renderbuffer')
    gl.bindRenderbuffer(GL_RENDERBUFFER, null)
    gl.deleteRenderbuffer(handle)
    rb.renderbuffer = null
    rb.refCount = 0
    delete renderbufferSet[rb.id]
    stats.renderbufferCount--
  }

  function createRenderbuffer (a, b) {
    var renderbuffer = new REGLRenderbuffer(gl.createRenderbuffer())
    renderbufferSet[renderbuffer.id] = renderbuffer
    stats.renderbufferCount++

    function reglRenderbuffer (a, b) {
      var w = 0
      var h = 0
      var format = GL_RGBA4$1

      if (typeof a === 'object' && a) {
        var options = a
        if ('shape' in options) {
          var shape = options.shape
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid renderbuffer shape')
          w = shape[0] | 0
          h = shape[1] | 0
        } else {
          if ('radius' in options) {
            w = h = options.radius | 0
          }
          if ('width' in options) {
            w = options.width | 0
          }
          if ('height' in options) {
            h = options.height | 0
          }
        }
        if ('format' in options) {
          check$1.parameter(options.format, formatTypes,
            'invalid renderbuffer format')
          format = formatTypes[options.format]
        }
      } else if (typeof a === 'number') {
        w = a | 0
        if (typeof b === 'number') {
          h = b | 0
        } else {
          h = w
        }
      } else if (!a) {
        w = h = 1
      } else {
        check$1.raise('invalid arguments to renderbuffer constructor')
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size')

      if (w === renderbuffer.width &&
          h === renderbuffer.height &&
          format === renderbuffer.format) {
        return
      }

      reglRenderbuffer.width = renderbuffer.width = w
      reglRenderbuffer.height = renderbuffer.height = h
      renderbuffer.format = format

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, format, w, h)

      check$1(
        gl.getError() === 0,
        'invalid render buffer format')

      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height)
      }
      reglRenderbuffer.format = formatTypesInvert[renderbuffer.format]

      return reglRenderbuffer
    }

    function resize (w_, h_) {
      var w = w_ | 0
      var h = (h_ | 0) || w

      if (w === renderbuffer.width && h === renderbuffer.height) {
        return reglRenderbuffer
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size')

      reglRenderbuffer.width = renderbuffer.width = w
      reglRenderbuffer.height = renderbuffer.height = h

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h)

      check$1(
        gl.getError() === 0,
        'invalid render buffer format')

      // also, recompute size.
      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(
          renderbuffer.format, renderbuffer.width, renderbuffer.height)
      }

      return reglRenderbuffer
    }

    reglRenderbuffer(a, b)

    reglRenderbuffer.resize = resize
    reglRenderbuffer._reglType = 'renderbuffer'
    reglRenderbuffer._renderbuffer = renderbuffer
    if (config.profile) {
      reglRenderbuffer.stats = renderbuffer.stats
    }
    reglRenderbuffer.destroy = function () {
      renderbuffer.decRef()
    }

    return reglRenderbuffer
  }

  if (config.profile) {
    stats.getTotalRenderbufferSize = function () {
      var total = 0
      Object.keys(renderbufferSet).forEach(function (key) {
        total += renderbufferSet[key].stats.size
      })
      return total
    }
  }

  function restoreRenderbuffers () {
    values(renderbufferSet).forEach(function (rb) {
      rb.renderbuffer = gl.createRenderbuffer()
      gl.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height)
    })
    gl.bindRenderbuffer(GL_RENDERBUFFER, null)
  }

  return {
    create: createRenderbuffer,
    clear: function () {
      values(renderbufferSet).forEach(destroy)
    },
    restore: restoreRenderbuffers
  }
}

// We store these constants so that the minifier can inline them
var GL_FRAMEBUFFER$1 = 0x8D40
var GL_RENDERBUFFER$1 = 0x8D41

var GL_TEXTURE_2D$2 = 0x0DE1
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 0x8515

var GL_COLOR_ATTACHMENT0$1 = 0x8CE0
var GL_DEPTH_ATTACHMENT = 0x8D00
var GL_STENCIL_ATTACHMENT = 0x8D20
var GL_DEPTH_STENCIL_ATTACHMENT = 0x821A

var GL_FRAMEBUFFER_COMPLETE$1 = 0x8CD5
var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6
var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7
var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9
var GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD

var GL_HALF_FLOAT_OES$2 = 0x8D61
var GL_UNSIGNED_BYTE$6 = 0x1401
var GL_FLOAT$5 = 0x1406

var GL_RGB$1 = 0x1907
var GL_RGBA$2 = 0x1908

var GL_DEPTH_COMPONENT$1 = 0x1902

var colorTextureFormatEnums = [
  GL_RGB$1,
  GL_RGBA$2
]

// for every texture format, store
// the number of channels
var textureFormatChannels = []
textureFormatChannels[GL_RGBA$2] = 4
textureFormatChannels[GL_RGB$1] = 3

// for every texture type, store
// the size in bytes.
var textureTypeSizes = []
textureTypeSizes[GL_UNSIGNED_BYTE$6] = 1
textureTypeSizes[GL_FLOAT$5] = 4
textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2

var GL_RGBA4$2 = 0x8056
var GL_RGB5_A1$2 = 0x8057
var GL_RGB565$2 = 0x8D62
var GL_DEPTH_COMPONENT16$1 = 0x81A5
var GL_STENCIL_INDEX8$1 = 0x8D48
var GL_DEPTH_STENCIL$2 = 0x84F9

var GL_SRGB8_ALPHA8_EXT$1 = 0x8C43

var GL_RGBA32F_EXT$1 = 0x8814

var GL_RGBA16F_EXT$1 = 0x881A
var GL_RGB16F_EXT$1 = 0x881B

var colorRenderbufferFormatEnums = [
  GL_RGBA4$2,
  GL_RGB5_A1$2,
  GL_RGB565$2,
  GL_SRGB8_ALPHA8_EXT$1,
  GL_RGBA16F_EXT$1,
  GL_RGB16F_EXT$1,
  GL_RGBA32F_EXT$1
]

var statusCode = {}
statusCode[GL_FRAMEBUFFER_COMPLETE$1] = 'complete'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = 'incomplete attachment'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = 'incomplete dimensions'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = 'incomplete, missing attachment'
statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = 'unsupported'

function wrapFBOState (
  gl,
  extensions,
  limits,
  textureState,
  renderbufferState,
  stats) {
  var framebufferState = {
    cur: null,
    next: null,
    dirty: false,
    setFBO: null
  }

  var colorTextureFormats = ['rgba']
  var colorRenderbufferFormats = ['rgba4', 'rgb565', 'rgb5 a1']

  if (extensions.ext_srgb) {
    colorRenderbufferFormats.push('srgba')
  }

  if (extensions.ext_color_buffer_half_float) {
    colorRenderbufferFormats.push('rgba16f', 'rgb16f')
  }

  if (extensions.webgl_color_buffer_float) {
    colorRenderbufferFormats.push('rgba32f')
  }

  var colorTypes = ['uint8']
  if (extensions.oes_texture_half_float) {
    colorTypes.push('half float', 'float16')
  }
  if (extensions.oes_texture_float) {
    colorTypes.push('float', 'float32')
  }

  function FramebufferAttachment (target, texture, renderbuffer) {
    this.target = target
    this.texture = texture
    this.renderbuffer = renderbuffer

    var w = 0
    var h = 0
    if (texture) {
      w = texture.width
      h = texture.height
    } else if (renderbuffer) {
      w = renderbuffer.width
      h = renderbuffer.height
    }
    this.width = w
    this.height = h
  }

  function decRef (attachment) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture._texture.decRef()
      }
      if (attachment.renderbuffer) {
        attachment.renderbuffer._renderbuffer.decRef()
      }
    }
  }

  function incRefAndCheckShape (attachment, width, height) {
    if (!attachment) {
      return
    }
    if (attachment.texture) {
      var texture = attachment.texture._texture
      var tw = Math.max(1, texture.width)
      var th = Math.max(1, texture.height)
      check$1(tw === width && th === height,
        'inconsistent width/height for supplied texture')
      texture.refCount += 1
    } else {
      var renderbuffer = attachment.renderbuffer._renderbuffer
      check$1(
        renderbuffer.width === width && renderbuffer.height === height,
        'inconsistent width/height for renderbuffer')
      renderbuffer.refCount += 1
    }
  }

  function attach (location, attachment) {
    if (attachment) {
      if (attachment.texture) {
        gl.framebufferTexture2D(
          GL_FRAMEBUFFER$1,
          location,
          attachment.target,
          attachment.texture._texture.texture,
          0)
      } else {
        gl.framebufferRenderbuffer(
          GL_FRAMEBUFFER$1,
          location,
          GL_RENDERBUFFER$1,
          attachment.renderbuffer._renderbuffer.renderbuffer)
      }
    }
  }

  function parseAttachment (attachment) {
    var target = GL_TEXTURE_2D$2
    var texture = null
    var renderbuffer = null

    var data = attachment
    if (typeof attachment === 'object') {
      data = attachment.data
      if ('target' in attachment) {
        target = attachment.target | 0
      }
    }

    check$1.type(data, 'function', 'invalid attachment data')

    var type = data._reglType
    if (type === 'texture2d') {
      texture = data
      check$1(target === GL_TEXTURE_2D$2)
    } else if (type === 'textureCube') {
      texture = data
      check$1(
        target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 &&
        target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + 6,
        'invalid cube map target')
    } else if (type === 'renderbuffer') {
      renderbuffer = data
      target = GL_RENDERBUFFER$1
    } else {
      check$1.raise('invalid regl object for attachment')
    }

    return new FramebufferAttachment(target, texture, renderbuffer)
  }

  function allocAttachment (
    width,
    height,
    isTexture,
    format,
    type) {
    if (isTexture) {
      var texture = textureState.create2D({
        width: width,
        height: height,
        format: format,
        type: type
      })
      texture._texture.refCount = 0
      return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null)
    } else {
      var rb = renderbufferState.create({
        width: width,
        height: height,
        format: format
      })
      rb._renderbuffer.refCount = 0
      return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb)
    }
  }

  function unwrapAttachment (attachment) {
    return attachment && (attachment.texture || attachment.renderbuffer)
  }

  function resizeAttachment (attachment, w, h) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture.resize(w, h)
      } else if (attachment.renderbuffer) {
        attachment.renderbuffer.resize(w, h)
      }
      attachment.width = w
      attachment.height = h
    }
  }

  var framebufferCount = 0
  var framebufferSet = {}

  function REGLFramebuffer () {
    this.id = framebufferCount++
    framebufferSet[this.id] = this

    this.framebuffer = gl.createFramebuffer()
    this.width = 0
    this.height = 0

    this.colorAttachments = []
    this.depthAttachment = null
    this.stencilAttachment = null
    this.depthStencilAttachment = null
  }

  function decFBORefs (framebuffer) {
    framebuffer.colorAttachments.forEach(decRef)
    decRef(framebuffer.depthAttachment)
    decRef(framebuffer.stencilAttachment)
    decRef(framebuffer.depthStencilAttachment)
  }

  function destroy (framebuffer) {
    var handle = framebuffer.framebuffer
    check$1(handle, 'must not double destroy framebuffer')
    gl.deleteFramebuffer(handle)
    framebuffer.framebuffer = null
    stats.framebufferCount--
    delete framebufferSet[framebuffer.id]
  }

  function updateFramebuffer (framebuffer) {
    var i

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer)
    var colorAttachments = framebuffer.colorAttachments
    for (i = 0; i < colorAttachments.length; ++i) {
      attach(GL_COLOR_ATTACHMENT0$1 + i, colorAttachments[i])
    }
    for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {
      gl.framebufferTexture2D(
        GL_FRAMEBUFFER$1,
        GL_COLOR_ATTACHMENT0$1 + i,
        GL_TEXTURE_2D$2,
        null,
        0)
    }

    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)

    attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment)
    attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment)
    attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment)

    // Check status code
    var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER$1)
    if (!gl.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {
      check$1.raise('framebuffer configuration not supported, status = ' +
        statusCode[status])
    }

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null)
    framebufferState.cur = framebufferState.next

    // FIXME: Clear error code here.  This is a work around for a bug in
    // headless-gl
    gl.getError()
  }

  function createFBO (a0, a1) {
    var framebuffer = new REGLFramebuffer()
    stats.framebufferCount++

    function reglFramebuffer (a, b) {
      var i

      check$1(framebufferState.next !== framebuffer,
        'can not update framebuffer which is currently in use')

      var width = 0
      var height = 0

      var needsDepth = true
      var needsStencil = true

      var colorBuffer = null
      var colorTexture = true
      var colorFormat = 'rgba'
      var colorType = 'uint8'
      var colorCount = 1

      var depthBuffer = null
      var stencilBuffer = null
      var depthStencilBuffer = null
      var depthStencilTexture = false

      if (typeof a === 'number') {
        width = a | 0
        height = (b | 0) || width
      } else if (!a) {
        width = height = 1
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer')
        var options = a

        if ('shape' in options) {
          var shape = options.shape
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer')
          width = shape[0]
          height = shape[1]
        } else {
          if ('radius' in options) {
            width = height = options.radius
          }
          if ('width' in options) {
            width = options.width
          }
          if ('height' in options) {
            height = options.height
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported')
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0
            check$1(colorCount > 0, 'invalid color buffer count')
          }

          if ('colorTexture' in options) {
            colorTexture = !!options.colorTexture
            colorFormat = 'rgba4'
          }

          if ('colorType' in options) {
            colorType = options.colorType
            if (!colorTexture) {
              if (colorType === 'half float' || colorType === 'float16') {
                check$1(extensions.ext_color_buffer_half_float,
                  'you must enable EXT_color_buffer_half_float to use 16-bit render buffers')
                colorFormat = 'rgba16f'
              } else if (colorType === 'float' || colorType === 'float32') {
                check$1(extensions.webgl_color_buffer_float,
                  'you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers')
                colorFormat = 'rgba32f'
              }
            } else {
              check$1(extensions.oes_texture_float ||
                !(colorType === 'float' || colorType === 'float32'),
              'you must enable OES_texture_float in order to use floating point framebuffer objects')
              check$1(extensions.oes_texture_half_float ||
                !(colorType === 'half float' || colorType === 'float16'),
              'you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects')
            }
            check$1.oneOf(colorType, colorTypes, 'invalid color type')
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat
            if (colorTextureFormats.indexOf(colorFormat) >= 0) {
              colorTexture = true
            } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
              colorTexture = false
            } else {
              check$1.optional(function () {
                if (colorTexture) {
                  check$1.oneOf(
                    options.colorFormat, colorTextureFormats,
                    'invalid color format for texture')
                } else {
                  check$1.oneOf(
                    options.colorFormat, colorRenderbufferFormats,
                    'invalid color format for renderbuffer')
                }
              })
            }
          }
        }

        if ('depthTexture' in options || 'depthStencilTexture' in options) {
          depthStencilTexture = !!(options.depthTexture ||
            options.depthStencilTexture)
          check$1(!depthStencilTexture || extensions.webgl_depth_texture,
            'webgl_depth_texture extension not supported')
        }

        if ('depth' in options) {
          if (typeof options.depth === 'boolean') {
            needsDepth = options.depth
          } else {
            depthBuffer = options.depth
            needsStencil = false
          }
        }

        if ('stencil' in options) {
          if (typeof options.stencil === 'boolean') {
            needsStencil = options.stencil
          } else {
            stencilBuffer = options.stencil
            needsDepth = false
          }
        }

        if ('depthStencil' in options) {
          if (typeof options.depthStencil === 'boolean') {
            needsDepth = needsStencil = options.depthStencil
          } else {
            depthStencilBuffer = options.depthStencil
            needsDepth = false
            needsStencil = false
          }
        }
      }

      // parse attachments
      var colorAttachments = null
      var depthAttachment = null
      var stencilAttachment = null
      var depthStencilAttachment = null

      // Set up color attachments
      if (Array.isArray(colorBuffer)) {
        colorAttachments = colorBuffer.map(parseAttachment)
      } else if (colorBuffer) {
        colorAttachments = [parseAttachment(colorBuffer)]
      } else {
        colorAttachments = new Array(colorCount)
        for (i = 0; i < colorCount; ++i) {
          colorAttachments[i] = allocAttachment(
            width,
            height,
            colorTexture,
            colorFormat,
            colorType)
        }
      }

      check$1(extensions.webgl_draw_buffers || colorAttachments.length <= 1,
        'you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers.')
      check$1(colorAttachments.length <= limits.maxColorAttachments,
        'too many color attachments, not supported')

      width = width || colorAttachments[0].width
      height = height || colorAttachments[0].height

      if (depthBuffer) {
        depthAttachment = parseAttachment(depthBuffer)
      } else if (needsDepth && !needsStencil) {
        depthAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth',
          'uint32')
      }

      if (stencilBuffer) {
        stencilAttachment = parseAttachment(stencilBuffer)
      } else if (needsStencil && !needsDepth) {
        stencilAttachment = allocAttachment(
          width,
          height,
          false,
          'stencil',
          'uint8')
      }

      if (depthStencilBuffer) {
        depthStencilAttachment = parseAttachment(depthStencilBuffer)
      } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
        depthStencilAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth stencil',
          'depth stencil')
      }

      check$1(
        (!!depthBuffer) + (!!stencilBuffer) + (!!depthStencilBuffer) <= 1,
        'invalid framebuffer configuration, can specify exactly one depth/stencil attachment')

      var commonColorAttachmentSize = null

      for (i = 0; i < colorAttachments.length; ++i) {
        incRefAndCheckShape(colorAttachments[i], width, height)
        check$1(!colorAttachments[i] ||
          (colorAttachments[i].texture &&
            colorTextureFormatEnums.indexOf(colorAttachments[i].texture._texture.format) >= 0) ||
          (colorAttachments[i].renderbuffer &&
            colorRenderbufferFormatEnums.indexOf(colorAttachments[i].renderbuffer._renderbuffer.format) >= 0),
        'framebuffer color attachment ' + i + ' is invalid')

        if (colorAttachments[i] && colorAttachments[i].texture) {
          var colorAttachmentSize =
              textureFormatChannels[colorAttachments[i].texture._texture.format] *
              textureTypeSizes[colorAttachments[i].texture._texture.type]

          if (commonColorAttachmentSize === null) {
            commonColorAttachmentSize = colorAttachmentSize
          } else {
            // We need to make sure that all color attachments have the same number of bitplanes
            // (that is, the same numer of bits per pixel)
            // This is required by the GLES2.0 standard. See the beginning of Chapter 4 in that document.
            check$1(commonColorAttachmentSize === colorAttachmentSize,
              'all color attachments much have the same number of bits per pixel.')
          }
        }
      }
      incRefAndCheckShape(depthAttachment, width, height)
      check$1(!depthAttachment ||
        (depthAttachment.texture &&
          depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1) ||
        (depthAttachment.renderbuffer &&
          depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1),
      'invalid depth attachment for framebuffer object')
      incRefAndCheckShape(stencilAttachment, width, height)
      check$1(!stencilAttachment ||
        (stencilAttachment.renderbuffer &&
          stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1),
      'invalid stencil attachment for framebuffer object')
      incRefAndCheckShape(depthStencilAttachment, width, height)
      check$1(!depthStencilAttachment ||
        (depthStencilAttachment.texture &&
          depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2) ||
        (depthStencilAttachment.renderbuffer &&
          depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2),
      'invalid depth-stencil attachment for framebuffer object')

      // decrement references
      decFBORefs(framebuffer)

      framebuffer.width = width
      framebuffer.height = height

      framebuffer.colorAttachments = colorAttachments
      framebuffer.depthAttachment = depthAttachment
      framebuffer.stencilAttachment = stencilAttachment
      framebuffer.depthStencilAttachment = depthStencilAttachment

      reglFramebuffer.color = colorAttachments.map(unwrapAttachment)
      reglFramebuffer.depth = unwrapAttachment(depthAttachment)
      reglFramebuffer.stencil = unwrapAttachment(stencilAttachment)
      reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment)

      reglFramebuffer.width = framebuffer.width
      reglFramebuffer.height = framebuffer.height

      updateFramebuffer(framebuffer)

      return reglFramebuffer
    }

    function resize (w_, h_) {
      check$1(framebufferState.next !== framebuffer,
        'can not resize a framebuffer which is currently in use')

      var w = Math.max(w_ | 0, 1)
      var h = Math.max((h_ | 0) || w, 1)
      if (w === framebuffer.width && h === framebuffer.height) {
        return reglFramebuffer
      }

      // resize all buffers
      var colorAttachments = framebuffer.colorAttachments
      for (var i = 0; i < colorAttachments.length; ++i) {
        resizeAttachment(colorAttachments[i], w, h)
      }
      resizeAttachment(framebuffer.depthAttachment, w, h)
      resizeAttachment(framebuffer.stencilAttachment, w, h)
      resizeAttachment(framebuffer.depthStencilAttachment, w, h)

      framebuffer.width = reglFramebuffer.width = w
      framebuffer.height = reglFramebuffer.height = h

      updateFramebuffer(framebuffer)

      return reglFramebuffer
    }

    reglFramebuffer(a0, a1)

    return extend(reglFramebuffer, {
      resize: resize,
      _reglType: 'framebuffer',
      _framebuffer: framebuffer,
      destroy: function () {
        destroy(framebuffer)
        decFBORefs(framebuffer)
      },
      use: function (block) {
        framebufferState.setFBO({
          framebuffer: reglFramebuffer
        }, block)
      }
    })
  }

  function createCubeFBO (options) {
    var faces = Array(6)

    function reglFramebufferCube (a) {
      var i

      check$1(faces.indexOf(framebufferState.next) < 0,
        'can not update framebuffer which is currently in use')

      var params = {
        color: null
      }

      var radius = 0

      var colorBuffer = null
      var colorFormat = 'rgba'
      var colorType = 'uint8'
      var colorCount = 1

      if (typeof a === 'number') {
        radius = a | 0
      } else if (!a) {
        radius = 1
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer')
        var options = a

        if ('shape' in options) {
          var shape = options.shape
          check$1(
            Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer')
          check$1(
            shape[0] === shape[1],
            'cube framebuffer must be square')
          radius = shape[0]
        } else {
          if ('radius' in options) {
            radius = options.radius | 0
          }
          if ('width' in options) {
            radius = options.width | 0
            if ('height' in options) {
              check$1(options.height === radius, 'must be square')
            }
          } else if ('height' in options) {
            radius = options.height | 0
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported')
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0
            check$1(colorCount > 0, 'invalid color buffer count')
          }

          if ('colorType' in options) {
            check$1.oneOf(
              options.colorType, colorTypes,
              'invalid color type')
            colorType = options.colorType
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat
            check$1.oneOf(
              options.colorFormat, colorTextureFormats,
              'invalid color format for texture')
          }
        }

        if ('depth' in options) {
          params.depth = options.depth
        }

        if ('stencil' in options) {
          params.stencil = options.stencil
        }

        if ('depthStencil' in options) {
          params.depthStencil = options.depthStencil
        }
      }

      var colorCubes
      if (colorBuffer) {
        if (Array.isArray(colorBuffer)) {
          colorCubes = []
          for (i = 0; i < colorBuffer.length; ++i) {
            colorCubes[i] = colorBuffer[i]
          }
        } else {
          colorCubes = [ colorBuffer ]
        }
      } else {
        colorCubes = Array(colorCount)
        var cubeMapParams = {
          radius: radius,
          format: colorFormat,
          type: colorType
        }
        for (i = 0; i < colorCount; ++i) {
          colorCubes[i] = textureState.createCube(cubeMapParams)
        }
      }

      // Check color cubes
      params.color = Array(colorCubes.length)
      for (i = 0; i < colorCubes.length; ++i) {
        var cube = colorCubes[i]
        check$1(
          typeof cube === 'function' && cube._reglType === 'textureCube',
          'invalid cube map')
        radius = radius || cube.width
        check$1(
          cube.width === radius && cube.height === radius,
          'invalid cube map shape')
        params.color[i] = {
          target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,
          data: colorCubes[i]
        }
      }

      for (i = 0; i < 6; ++i) {
        for (var j = 0; j < colorCubes.length; ++j) {
          params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i
        }
        // reuse depth-stencil attachments across all cube maps
        if (i > 0) {
          params.depth = faces[0].depth
          params.stencil = faces[0].stencil
          params.depthStencil = faces[0].depthStencil
        }
        if (faces[i]) {
          (faces[i])(params)
        } else {
          faces[i] = createFBO(params)
        }
      }

      return extend(reglFramebufferCube, {
        width: radius,
        height: radius,
        color: colorCubes
      })
    }

    function resize (radius_) {
      var i
      var radius = radius_ | 0
      check$1(radius > 0 && radius <= limits.maxCubeMapSize,
        'invalid radius for cube fbo')

      if (radius === reglFramebufferCube.width) {
        return reglFramebufferCube
      }

      var colors = reglFramebufferCube.color
      for (i = 0; i < colors.length; ++i) {
        colors[i].resize(radius)
      }

      for (i = 0; i < 6; ++i) {
        faces[i].resize(radius)
      }

      reglFramebufferCube.width = reglFramebufferCube.height = radius

      return reglFramebufferCube
    }

    reglFramebufferCube(options)

    return extend(reglFramebufferCube, {
      faces: faces,
      resize: resize,
      _reglType: 'framebufferCube',
      destroy: function () {
        faces.forEach(function (f) {
          f.destroy()
        })
      }
    })
  }

  function restoreFramebuffers () {
    framebufferState.cur = null
    framebufferState.next = null
    framebufferState.dirty = true
    values(framebufferSet).forEach(function (fb) {
      fb.framebuffer = gl.createFramebuffer()
      updateFramebuffer(fb)
    })
  }

  return extend(framebufferState, {
    getFramebuffer: function (object) {
      if (typeof object === 'function' && object._reglType === 'framebuffer') {
        var fbo = object._framebuffer
        if (fbo instanceof REGLFramebuffer) {
          return fbo
        }
      }
      return null
    },
    create: createFBO,
    createCube: createCubeFBO,
    clear: function () {
      values(framebufferSet).forEach(destroy)
    },
    restore: restoreFramebuffers
  })
}

var GL_FLOAT$6 = 5126
var GL_ARRAY_BUFFER$1 = 34962
var GL_ELEMENT_ARRAY_BUFFER$1 = 34963

var VAO_OPTIONS = [
  'attributes',
  'elements',
  'offset',
  'count',
  'primitive',
  'instances'
]

function AttributeRecord () {
  this.state = 0

  this.x = 0.0
  this.y = 0.0
  this.z = 0.0
  this.w = 0.0

  this.buffer = null
  this.size = 0
  this.normalized = false
  this.type = GL_FLOAT$6
  this.offset = 0
  this.stride = 0
  this.divisor = 0
}

function wrapAttributeState (
  gl,
  extensions,
  limits,
  stats,
  bufferState,
  elementState,
  drawState) {
  var NUM_ATTRIBUTES = limits.maxAttributes
  var attributeBindings = new Array(NUM_ATTRIBUTES)
  for (var i = 0; i < NUM_ATTRIBUTES; ++i) {
    attributeBindings[i] = new AttributeRecord()
  }
  var vaoCount = 0
  var vaoSet = {}

  var state = {
    Record: AttributeRecord,
    scope: {},
    state: attributeBindings,
    currentVAO: null,
    targetVAO: null,
    restore: extVAO() ? restoreVAO : function () {},
    createVAO: createVAO,
    getVAO: getVAO,
    destroyBuffer: destroyBuffer,
    setVAO: extVAO() ? setVAOEXT : setVAOEmulated,
    clear: extVAO() ? destroyVAOEXT : function () {}
  }

  function destroyBuffer (buffer) {
    for (var i = 0; i < attributeBindings.length; ++i) {
      var record = attributeBindings[i]
      if (record.buffer === buffer) {
        gl.disableVertexAttribArray(i)
        record.buffer = null
      }
    }
  }

  function extVAO () {
    return extensions.oes_vertex_array_object
  }

  function extInstanced () {
    return extensions.angle_instanced_arrays
  }

  function getVAO (vao) {
    if (typeof vao === 'function' && vao._vao) {
      return vao._vao
    }
    return null
  }

  function setVAOEXT (vao) {
    if (vao === state.currentVAO) {
      return
    }
    var ext = extVAO()
    if (vao) {
      ext.bindVertexArrayOES(vao.vao)
    } else {
      ext.bindVertexArrayOES(null)
    }
    state.currentVAO = vao
  }

  function setVAOEmulated (vao) {
    if (vao === state.currentVAO) {
      return
    }
    if (vao) {
      vao.bindAttrs()
    } else {
      var exti = extInstanced()
      for (var i = 0; i < attributeBindings.length; ++i) {
        var binding = attributeBindings[i]
        if (binding.buffer) {
          gl.enableVertexAttribArray(i)
          binding.buffer.bind()
          gl.vertexAttribPointer(i, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset)
          if (exti && binding.divisor) {
            exti.vertexAttribDivisorANGLE(i, binding.divisor)
          }
        } else {
          gl.disableVertexAttribArray(i)
          gl.vertexAttrib4f(i, binding.x, binding.y, binding.z, binding.w)
        }
      }
      if (drawState.elements) {
        gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, drawState.elements.buffer.buffer)
      } else {
        gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, null)
      }
    }
    state.currentVAO = vao
  }

  function destroyVAOEXT () {
    values(vaoSet).forEach(function (vao) {
      vao.destroy()
    })
  }

  function REGLVAO () {
    this.id = ++vaoCount
    this.attributes = []
    this.elements = null
    this.ownsElements = false
    this.count = 0
    this.offset = 0
    this.instances = -1
    this.primitive = 4
    var extension = extVAO()
    if (extension) {
      this.vao = extension.createVertexArrayOES()
    } else {
      this.vao = null
    }
    vaoSet[this.id] = this
    this.buffers = []
  }

  REGLVAO.prototype.bindAttrs = function () {
    var exti = extInstanced()
    var attributes = this.attributes
    for (var i = 0; i < attributes.length; ++i) {
      var attr = attributes[i]
      if (attr.buffer) {
        gl.enableVertexAttribArray(i)
        gl.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer)
        gl.vertexAttribPointer(i, attr.size, attr.type, attr.normalized, attr.stride, attr.offset)
        if (exti && attr.divisor) {
          exti.vertexAttribDivisorANGLE(i, attr.divisor)
        }
      } else {
        gl.disableVertexAttribArray(i)
        gl.vertexAttrib4f(i, attr.x, attr.y, attr.z, attr.w)
      }
    }
    for (var j = attributes.length; j < NUM_ATTRIBUTES; ++j) {
      gl.disableVertexAttribArray(j)
    }
    var elements = elementState.getElements(this.elements)
    if (elements) {
      gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, elements.buffer.buffer)
    } else {
      gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, null)
    }
  }

  REGLVAO.prototype.refresh = function () {
    var ext = extVAO()
    if (ext) {
      ext.bindVertexArrayOES(this.vao)
      this.bindAttrs()
      state.currentVAO = null
      ext.bindVertexArrayOES(null)
    }
  }

  REGLVAO.prototype.destroy = function () {
    if (this.vao) {
      var extension = extVAO()
      if (this === state.currentVAO) {
        state.currentVAO = null
        extension.bindVertexArrayOES(null)
      }
      extension.deleteVertexArrayOES(this.vao)
      this.vao = null
    }
    if (this.ownsElements) {
      this.elements.destroy()
      this.elements = null
      this.ownsElements = false
    }
    if (vaoSet[this.id]) {
      delete vaoSet[this.id]
      stats.vaoCount -= 1
    }
  }

  function restoreVAO () {
    var ext = extVAO()
    if (ext) {
      values(vaoSet).forEach(function (vao) {
        vao.refresh()
      })
    }
  }

  function createVAO (_attr) {
    var vao = new REGLVAO()
    stats.vaoCount += 1

    function updateVAO (options) {
      var attributes
      if (Array.isArray(options)) {
        attributes = options
        if (vao.elements && vao.ownsElements) {
          vao.elements.destroy()
        }
        vao.elements = null
        vao.ownsElements = false
        vao.offset = 0
        vao.count = 0
        vao.instances = -1
        vao.primitive = 4
      } else {
        check$1(typeof options === 'object', 'invalid arguments for create vao')
        check$1('attributes' in options, 'must specify attributes for vao')
        if (options.elements) {
          var elements = options.elements
          if (vao.ownsElements) {
            if (typeof elements === 'function' && elements._reglType === 'elements') {
              vao.elements.destroy()
              vao.ownsElements = false
            } else {
              vao.elements(elements)
              vao.ownsElements = false
            }
          } else if (elementState.getElements(options.elements)) {
            vao.elements = options.elements
            vao.ownsElements = false
          } else {
            vao.elements = elementState.create(options.elements)
            vao.ownsElements = true
          }
        } else {
          vao.elements = null
          vao.ownsElements = false
        }
        attributes = options.attributes

        // set default vao
        vao.offset = 0
        vao.count = -1
        vao.instances = -1
        vao.primitive = 4

        // copy element properties
        if (vao.elements) {
          vao.count = vao.elements._elements.vertCount
          vao.primitive = vao.elements._elements.primType
        }

        if ('offset' in options) {
          vao.offset = options.offset | 0
        }
        if ('count' in options) {
          vao.count = options.count | 0
        }
        if ('instances' in options) {
          vao.instances = options.instances | 0
        }
        if ('primitive' in options) {
          check$1(options.primitive in primTypes, 'bad primitive type: ' + options.primitive)
          vao.primitive = primTypes[options.primitive]
        }

        check$1.optional(() => {
          var keys = Object.keys(options)
          for (var i = 0; i < keys.length; ++i) {
            check$1(VAO_OPTIONS.indexOf(keys[i]) >= 0, 'invalid option for vao: "' + keys[i] + '" valid options are ' + VAO_OPTIONS)
          }
        })
        check$1(Array.isArray(attributes), 'attributes must be an array')
      }

      check$1(attributes.length < NUM_ATTRIBUTES, 'too many attributes')
      check$1(attributes.length > 0, 'must specify at least one attribute')

      var bufUpdated = {}
      var nattributes = vao.attributes
      nattributes.length = attributes.length
      for (var i = 0; i < attributes.length; ++i) {
        var spec = attributes[i]
        var rec = nattributes[i] = new AttributeRecord()
        var data = spec.data || spec
        if (Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data)) {
          var buf
          if (vao.buffers[i]) {
            buf = vao.buffers[i]
            if (isTypedArray(data) && buf._buffer.byteLength >= data.byteLength) {
              buf.subdata(data)
            } else {
              buf.destroy()
              vao.buffers[i] = null
            }
          }
          if (!vao.buffers[i]) {
            buf = vao.buffers[i] = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true)
          }
          rec.buffer = bufferState.getBuffer(buf)
          rec.size = rec.buffer.dimension | 0
          rec.normalized = false
          rec.type = rec.buffer.dtype
          rec.offset = 0
          rec.stride = 0
          rec.divisor = 0
          rec.state = 1
          bufUpdated[i] = 1
        } else if (bufferState.getBuffer(spec)) {
          rec.buffer = bufferState.getBuffer(spec)
          rec.size = rec.buffer.dimension | 0
          rec.normalized = false
          rec.type = rec.buffer.dtype
          rec.offset = 0
          rec.stride = 0
          rec.divisor = 0
          rec.state = 1
        } else if (bufferState.getBuffer(spec.buffer)) {
          rec.buffer = bufferState.getBuffer(spec.buffer)
          rec.size = ((+spec.size) || rec.buffer.dimension) | 0
          rec.normalized = !!spec.normalized || false
          if ('type' in spec) {
            check$1.parameter(spec.type, glTypes, 'invalid buffer type')
            rec.type = glTypes[spec.type]
          } else {
            rec.type = rec.buffer.dtype
          }
          rec.offset = (spec.offset || 0) | 0
          rec.stride = (spec.stride || 0) | 0
          rec.divisor = (spec.divisor || 0) | 0
          rec.state = 1

          check$1(rec.size >= 1 && rec.size <= 4, 'size must be between 1 and 4')
          check$1(rec.offset >= 0, 'invalid offset')
          check$1(rec.stride >= 0 && rec.stride <= 255, 'stride must be between 0 and 255')
          check$1(rec.divisor >= 0, 'divisor must be positive')
          check$1(!rec.divisor || !!extensions.angle_instanced_arrays, 'ANGLE_instanced_arrays must be enabled to use divisor')
        } else if ('x' in spec) {
          check$1(i > 0, 'first attribute must not be a constant')
          rec.x = +spec.x || 0
          rec.y = +spec.y || 0
          rec.z = +spec.z || 0
          rec.w = +spec.w || 0
          rec.state = 2
        } else {
          check$1(false, 'invalid attribute spec for location ' + i)
        }
      }

      // retire unused buffers
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (!bufUpdated[j] && vao.buffers[j]) {
          vao.buffers[j].destroy()
          vao.buffers[j] = null
        }
      }

      vao.refresh()
      return updateVAO
    }

    updateVAO.destroy = function () {
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (vao.buffers[j]) {
          vao.buffers[j].destroy()
        }
      }
      vao.buffers.length = 0

      if (vao.ownsElements) {
        vao.elements.destroy()
        vao.elements = null
        vao.ownsElements = false
      }

      vao.destroy()
    }

    updateVAO._vao = vao
    updateVAO._reglType = 'vao'

    return updateVAO(_attr)
  }

  return state
}

var GL_FRAGMENT_SHADER = 35632
var GL_VERTEX_SHADER = 35633

var GL_ACTIVE_UNIFORMS = 0x8B86
var GL_ACTIVE_ATTRIBUTES = 0x8B89

function wrapShaderState (gl, stringStore, stats, config) {
  // ===================================================
  // glsl compilation and linking
  // ===================================================
  var fragShaders = {}
  var vertShaders = {}

  function ActiveInfo (name, id, location, info) {
    this.name = name
    this.id = id
    this.location = location
    this.info = info
  }

  function insertActiveInfo (list, info) {
    for (var i = 0; i < list.length; ++i) {
      if (list[i].id === info.id) {
        list[i].location = info.location
        return
      }
    }
    list.push(info)
  }

  function getShader (type, id, command) {
    var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders
    var shader = cache[id]

    if (!shader) {
      var source = stringStore.str(id)
      shader = gl.createShader(type)
      gl.shaderSource(shader, source)
      gl.compileShader(shader)
      check$1.shaderError(gl, shader, source, type, command)
      cache[id] = shader
    }

    return shader
  }

  // ===================================================
  // program linking
  // ===================================================
  var programCache = {}
  var programList = []

  var PROGRAM_COUNTER = 0

  function REGLProgram (fragId, vertId) {
    this.id = PROGRAM_COUNTER++
    this.fragId = fragId
    this.vertId = vertId
    this.program = null
    this.uniforms = []
    this.attributes = []
    this.refCount = 1

    if (config.profile) {
      this.stats = {
        uniformsCount: 0,
        attributesCount: 0
      }
    }
  }

  function linkProgram (desc, command, attributeLocations) {
    var i, info

    // -------------------------------
    // compile & link
    // -------------------------------
    var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId)
    var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId)

    var program = desc.program = gl.createProgram()
    gl.attachShader(program, fragShader)
    gl.attachShader(program, vertShader)
    if (attributeLocations) {
      for (i = 0; i < attributeLocations.length; ++i) {
        var binding = attributeLocations[i]
        gl.bindAttribLocation(program, binding[0], binding[1])
      }
    }

    gl.linkProgram(program)
    check$1.linkError(
      gl,
      program,
      stringStore.str(desc.fragId),
      stringStore.str(desc.vertId),
      command)

    // -------------------------------
    // grab uniforms
    // -------------------------------
    var numUniforms = gl.getProgramParameter(program, GL_ACTIVE_UNIFORMS)
    if (config.profile) {
      desc.stats.uniformsCount = numUniforms
    }
    var uniforms = desc.uniforms
    for (i = 0; i < numUniforms; ++i) {
      info = gl.getActiveUniform(program, i)
      if (info) {
        if (info.size > 1) {
          for (var j = 0; j < info.size; ++j) {
            var name = info.name.replace('[0]', '[' + j + ']')
            insertActiveInfo(uniforms, new ActiveInfo(
              name,
              stringStore.id(name),
              gl.getUniformLocation(program, name),
              info))
          }
        }
        var uniName = info.name
        if (info.size > 1) {
          uniName = uniName.replace('[0]', '')
        }
        insertActiveInfo(uniforms, new ActiveInfo(
          uniName,
          stringStore.id(uniName),
          gl.getUniformLocation(program, uniName),
          info))
      }
    }

    // -------------------------------
    // grab attributes
    // -------------------------------
    var numAttributes = gl.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES)
    if (config.profile) {
      desc.stats.attributesCount = numAttributes
    }

    var attributes = desc.attributes
    for (i = 0; i < numAttributes; ++i) {
      info = gl.getActiveAttrib(program, i)
      if (info) {
        insertActiveInfo(attributes, new ActiveInfo(
          info.name,
          stringStore.id(info.name),
          gl.getAttribLocation(program, info.name),
          info))
      }
    }
  }

  if (config.profile) {
    stats.getMaxUniformsCount = function () {
      var m = 0
      programList.forEach(function (desc) {
        if (desc.stats.uniformsCount > m) {
          m = desc.stats.uniformsCount
        }
      })
      return m
    }

    stats.getMaxAttributesCount = function () {
      var m = 0
      programList.forEach(function (desc) {
        if (desc.stats.attributesCount > m) {
          m = desc.stats.attributesCount
        }
      })
      return m
    }
  }

  function restoreShaders () {
    fragShaders = {}
    vertShaders = {}
    for (var i = 0; i < programList.length; ++i) {
      linkProgram(programList[i], null, programList[i].attributes.map(function (info) {
        return [info.location, info.name]
      }))
    }
  }

  return {
    clear: function () {
      var deleteShader = gl.deleteShader.bind(gl)
      values(fragShaders).forEach(deleteShader)
      fragShaders = {}
      values(vertShaders).forEach(deleteShader)
      vertShaders = {}

      programList.forEach(function (desc) {
        gl.deleteProgram(desc.program)
      })
      programList.length = 0
      programCache = {}

      stats.shaderCount = 0
    },

    program: function (vertId, fragId, command, attribLocations) {
      check$1.command(vertId >= 0, 'missing vertex shader', command)
      check$1.command(fragId >= 0, 'missing fragment shader', command)

      var cache = programCache[fragId]
      if (!cache) {
        cache = programCache[fragId] = {}
      }
      var prevProgram = cache[vertId]
      if (prevProgram) {
        prevProgram.refCount++
        if (!attribLocations) {
          return prevProgram
        }
      }
      var program = new REGLProgram(fragId, vertId)
      stats.shaderCount++
      linkProgram(program, command, attribLocations)
      if (!prevProgram) {
        cache[vertId] = program
      }
      programList.push(program)
      return extend(program, {
        destroy: function () {
          program.refCount--
          if (program.refCount <= 0) {
            gl.deleteProgram(program.program)
            var idx = programList.indexOf(program)
            programList.splice(idx, 1)
            stats.shaderCount--
          }
          // no program is linked to this vert anymore
          if (cache[program.vertId].refCount <= 0) {
            gl.deleteShader(vertShaders[program.vertId])
            delete vertShaders[program.vertId]
            delete programCache[program.fragId][program.vertId]
          }
          // no program is linked to this frag anymore
          if (!Object.keys(programCache[program.fragId]).length) {
            gl.deleteShader(fragShaders[program.fragId])
            delete fragShaders[program.fragId]
            delete programCache[program.fragId]
          }
        }
      })
    },

    restore: restoreShaders,

    shader: getShader,

    frag: -1,
    vert: -1
  }
}

var GL_RGBA$3 = 6408
var GL_UNSIGNED_BYTE$7 = 5121
var GL_PACK_ALIGNMENT = 0x0D05
var GL_FLOAT$7 = 0x1406 // 5126

function wrapReadPixels (
  gl,
  framebufferState,
  reglPoll,
  context,
  glAttributes,
  extensions,
  limits) {
  function readPixelsImpl (input) {
    var type
    if (framebufferState.next === null) {
      check$1(
        glAttributes.preserveDrawingBuffer,
        'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer')
      type = GL_UNSIGNED_BYTE$7
    } else {
      check$1(
        framebufferState.next.colorAttachments[0].texture !== null,
        'You cannot read from a renderbuffer')
      type = framebufferState.next.colorAttachments[0].texture._texture.type

      check$1.optional(function () {
        if (extensions.oes_texture_float) {
          check$1(
            type === GL_UNSIGNED_BYTE$7 || type === GL_FLOAT$7,
            'Reading from a framebuffer is only allowed for the types \'uint8\' and \'float\'')

          if (type === GL_FLOAT$7) {
            check$1(limits.readFloat, 'Reading \'float\' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float')
          }
        } else {
          check$1(
            type === GL_UNSIGNED_BYTE$7,
            'Reading from a framebuffer is only allowed for the type \'uint8\'')
        }
      })
    }

    var x = 0
    var y = 0
    var width = context.framebufferWidth
    var height = context.framebufferHeight
    var data = null

    if (isTypedArray(input)) {
      data = input
    } else if (input) {
      check$1.type(input, 'object', 'invalid arguments to regl.read()')
      x = input.x | 0
      y = input.y | 0
      check$1(
        x >= 0 && x < context.framebufferWidth,
        'invalid x offset for regl.read')
      check$1(
        y >= 0 && y < context.framebufferHeight,
        'invalid y offset for regl.read')
      width = (input.width || (context.framebufferWidth - x)) | 0
      height = (input.height || (context.framebufferHeight - y)) | 0
      data = input.data || null
    }

    // sanity check input.data
    if (data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        check$1(
          data instanceof Uint8Array,
          'buffer must be \'Uint8Array\' when reading from a framebuffer of type \'uint8\'')
      } else if (type === GL_FLOAT$7) {
        check$1(
          data instanceof Float32Array,
          'buffer must be \'Float32Array\' when reading from a framebuffer of type \'float\'')
      }
    }

    check$1(
      width > 0 && width + x <= context.framebufferWidth,
      'invalid width for read pixels')
    check$1(
      height > 0 && height + y <= context.framebufferHeight,
      'invalid height for read pixels')

    // Update WebGL state
    reglPoll()

    // Compute size
    var size = width * height * 4

    // Allocate data
    if (!data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        data = new Uint8Array(size)
      } else if (type === GL_FLOAT$7) {
        data = data || new Float32Array(size)
      }
    }

    // Type check
    check$1.isTypedArray(data, 'data buffer for regl.read() must be a typedarray')
    check$1(data.byteLength >= size, 'data buffer for regl.read() too small')

    // Run read pixels
    gl.pixelStorei(GL_PACK_ALIGNMENT, 4)
    gl.readPixels(x, y, width, height, GL_RGBA$3,
      type,
      data)

    return data
  }

  function readPixelsFBO (options) {
    var result
    framebufferState.setFBO({
      framebuffer: options.framebuffer
    }, function () {
      result = readPixelsImpl(options)
    })
    return result
  }

  function readPixels (options) {
    if (!options || !('framebuffer' in options)) {
      return readPixelsImpl(options)
    } else {
      return readPixelsFBO(options)
    }
  }

  return readPixels
}

function slice (x) {
  return Array.prototype.slice.call(x)
}

function join (x) {
  return slice(x).join('')
}

function createEnvironment () {
  // Unique variable id counter
  var varCounter = 0

  // Linked values are passed from this scope into the generated code block
  // Calling link() passes a value into the generated scope and returns
  // the variable name which it is bound to
  var linkedNames = []
  var linkedValues = []
  function link (value) {
    for (var i = 0; i < linkedValues.length; ++i) {
      if (linkedValues[i] === value) {
        return linkedNames[i]
      }
    }

    var name = 'g' + (varCounter++)
    linkedNames.push(name)
    linkedValues.push(value)
    return name
  }

  // create a code block
  function block () {
    var code = []
    function push () {
      code.push.apply(code, slice(arguments))
    }

    var vars = []
    function def () {
      var name = 'v' + (varCounter++)
      vars.push(name)

      if (arguments.length > 0) {
        code.push(name, '=')
        code.push.apply(code, slice(arguments))
        code.push(';')
      }

      return name
    }

    return extend(push, {
      def: def,
      toString: function () {
        return join([
          (vars.length > 0 ? 'var ' + vars.join(',') + ';' : ''),
          join(code)
        ])
      }
    })
  }

  function scope () {
    var entry = block()
    var exit = block()

    var entryToString = entry.toString
    var exitToString = exit.toString

    function save (object, prop) {
      exit(object, prop, '=', entry.def(object, prop), ';')
    }

    return extend(function () {
      entry.apply(entry, slice(arguments))
    }, {
      def: entry.def,
      entry: entry,
      exit: exit,
      save: save,
      set: function (object, prop, value) {
        save(object, prop)
        entry(object, prop, '=', value, ';')
      },
      toString: function () {
        return entryToString() + exitToString()
      }
    })
  }

  function conditional () {
    var pred = join(arguments)
    var thenBlock = scope()
    var elseBlock = scope()

    var thenToString = thenBlock.toString
    var elseToString = elseBlock.toString

    return extend(thenBlock, {
      then: function () {
        thenBlock.apply(thenBlock, slice(arguments))
        return this
      },
      else: function () {
        elseBlock.apply(elseBlock, slice(arguments))
        return this
      },
      toString: function () {
        var elseClause = elseToString()
        if (elseClause) {
          elseClause = 'else{' + elseClause + '}'
        }
        return join([
          'if(', pred, '){',
          thenToString(),
          '}', elseClause
        ])
      }
    })
  }

  // procedure list
  var globalBlock = block()
  var procedures = {}
  function proc (name, count) {
    var args = []
    function arg () {
      var name = 'a' + args.length
      args.push(name)
      return name
    }

    count = count || 0
    for (var i = 0; i < count; ++i) {
      arg()
    }

    var body = scope()
    var bodyToString = body.toString

    var result = procedures[name] = extend(body, {
      arg: arg,
      toString: function () {
        return join([
          'function(', args.join(), '){',
          bodyToString(),
          '}'
        ])
      }
    })

    return result
  }

  function compile () {
    var code = ['"use strict";',
      globalBlock,
      'return {']
    Object.keys(procedures).forEach(function (name) {
      code.push('"', name, '":', procedures[name].toString(), ',')
    })
    code.push('}')
    var src = join(code)
      .replace(/;/g, ';\n')
      .replace(/}/g, '}\n')
      .replace(/{/g, '{\n')
    var proc = Function.apply(null, linkedNames.concat(src))
    return proc.apply(null, linkedValues)
  }

  return {
    global: globalBlock,
    link: link,
    block: block,
    proc: proc,
    scope: scope,
    cond: conditional,
    compile: compile
  }
}

// "cute" names for vector components
var CUTE_COMPONENTS = 'xyzw'.split('')

var GL_UNSIGNED_BYTE$8 = 5121

var ATTRIB_STATE_POINTER = 1
var ATTRIB_STATE_CONSTANT = 2

var DYN_FUNC$1 = 0
var DYN_PROP$1 = 1
var DYN_CONTEXT$1 = 2
var DYN_STATE$1 = 3
var DYN_THUNK = 4
var DYN_CONSTANT$1 = 5
var DYN_ARRAY$1 = 6

var S_DITHER = 'dither'
var S_BLEND_ENABLE = 'blend.enable'
var S_BLEND_COLOR = 'blend.color'
var S_BLEND_EQUATION = 'blend.equation'
var S_BLEND_FUNC = 'blend.func'
var S_DEPTH_ENABLE = 'depth.enable'
var S_DEPTH_FUNC = 'depth.func'
var S_DEPTH_RANGE = 'depth.range'
var S_DEPTH_MASK = 'depth.mask'
var S_COLOR_MASK = 'colorMask'
var S_CULL_ENABLE = 'cull.enable'
var S_CULL_FACE = 'cull.face'
var S_FRONT_FACE = 'frontFace'
var S_LINE_WIDTH = 'lineWidth'
var S_POLYGON_OFFSET_ENABLE = 'polygonOffset.enable'
var S_POLYGON_OFFSET_OFFSET = 'polygonOffset.offset'
var S_SAMPLE_ALPHA = 'sample.alpha'
var S_SAMPLE_ENABLE = 'sample.enable'
var S_SAMPLE_COVERAGE = 'sample.coverage'
var S_STENCIL_ENABLE = 'stencil.enable'
var S_STENCIL_MASK = 'stencil.mask'
var S_STENCIL_FUNC = 'stencil.func'
var S_STENCIL_OPFRONT = 'stencil.opFront'
var S_STENCIL_OPBACK = 'stencil.opBack'
var S_SCISSOR_ENABLE = 'scissor.enable'
var S_SCISSOR_BOX = 'scissor.box'
var S_VIEWPORT = 'viewport'

var S_PROFILE = 'profile'

var S_FRAMEBUFFER = 'framebuffer'
var S_VERT = 'vert'
var S_FRAG = 'frag'
var S_ELEMENTS = 'elements'
var S_PRIMITIVE = 'primitive'
var S_COUNT = 'count'
var S_OFFSET = 'offset'
var S_INSTANCES = 'instances'
var S_VAO = 'vao'

var SUFFIX_WIDTH = 'Width'
var SUFFIX_HEIGHT = 'Height'

var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH
var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT
var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH
var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT
var S_DRAWINGBUFFER = 'drawingBuffer'
var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH
var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT

var NESTED_OPTIONS = [
  S_BLEND_FUNC,
  S_BLEND_EQUATION,
  S_STENCIL_FUNC,
  S_STENCIL_OPFRONT,
  S_STENCIL_OPBACK,
  S_SAMPLE_COVERAGE,
  S_VIEWPORT,
  S_SCISSOR_BOX,
  S_POLYGON_OFFSET_OFFSET
]

var GL_ARRAY_BUFFER$2 = 34962
var GL_ELEMENT_ARRAY_BUFFER$2 = 34963

var GL_FRAGMENT_SHADER$1 = 35632
var GL_VERTEX_SHADER$1 = 35633

var GL_TEXTURE_2D$3 = 0x0DE1
var GL_TEXTURE_CUBE_MAP$2 = 0x8513

var GL_CULL_FACE = 0x0B44
var GL_BLEND = 0x0BE2
var GL_DITHER = 0x0BD0
var GL_STENCIL_TEST = 0x0B90
var GL_DEPTH_TEST = 0x0B71
var GL_SCISSOR_TEST = 0x0C11
var GL_POLYGON_OFFSET_FILL = 0x8037
var GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E
var GL_SAMPLE_COVERAGE = 0x80A0

var GL_FLOAT$8 = 5126
var GL_FLOAT_VEC2 = 35664
var GL_FLOAT_VEC3 = 35665
var GL_FLOAT_VEC4 = 35666
var GL_INT$3 = 5124
var GL_INT_VEC2 = 35667
var GL_INT_VEC3 = 35668
var GL_INT_VEC4 = 35669
var GL_BOOL = 35670
var GL_BOOL_VEC2 = 35671
var GL_BOOL_VEC3 = 35672
var GL_BOOL_VEC4 = 35673
var GL_FLOAT_MAT2 = 35674
var GL_FLOAT_MAT3 = 35675
var GL_FLOAT_MAT4 = 35676
var GL_SAMPLER_2D = 35678
var GL_SAMPLER_CUBE = 35680

var GL_TRIANGLES$1 = 4

var GL_FRONT = 1028
var GL_BACK = 1029
var GL_CW = 0x0900
var GL_CCW = 0x0901
var GL_MIN_EXT = 0x8007
var GL_MAX_EXT = 0x8008
var GL_ALWAYS = 519
var GL_KEEP = 7680
var GL_ZERO = 0
var GL_ONE = 1
var GL_FUNC_ADD = 0x8006
var GL_LESS = 513

var GL_FRAMEBUFFER$2 = 0x8D40
var GL_COLOR_ATTACHMENT0$2 = 0x8CE0

var blendFuncs = {
  '0': 0,
  '1': 1,
  'zero': 0,
  'one': 1,
  'src color': 768,
  'one minus src color': 769,
  'src alpha': 770,
  'one minus src alpha': 771,
  'dst color': 774,
  'one minus dst color': 775,
  'dst alpha': 772,
  'one minus dst alpha': 773,
  'constant color': 32769,
  'one minus constant color': 32770,
  'constant alpha': 32771,
  'one minus constant alpha': 32772,
  'src alpha saturate': 776
}

// There are invalid values for srcRGB and dstRGB. See:
// https://www.khronos.org/registry/webgl/specs/1.0/#6.13
// https://github.com/KhronosGroup/WebGL/blob/0d3201f5f7ec3c0060bc1f04077461541f1987b9/conformance-suites/1.0.3/conformance/misc/webgl-specific.html#L56
var invalidBlendCombinations = [
  'constant color, constant alpha',
  'one minus constant color, constant alpha',
  'constant color, one minus constant alpha',
  'one minus constant color, one minus constant alpha',
  'constant alpha, constant color',
  'constant alpha, one minus constant color',
  'one minus constant alpha, constant color',
  'one minus constant alpha, one minus constant color'
]

var compareFuncs = {
  'never': 512,
  'less': 513,
  '<': 513,
  'equal': 514,
  '=': 514,
  '==': 514,
  '===': 514,
  'lequal': 515,
  '<=': 515,
  'greater': 516,
  '>': 516,
  'notequal': 517,
  '!=': 517,
  '!==': 517,
  'gequal': 518,
  '>=': 518,
  'always': 519
}

var stencilOps = {
  '0': 0,
  'zero': 0,
  'keep': 7680,
  'replace': 7681,
  'increment': 7682,
  'decrement': 7683,
  'increment wrap': 34055,
  'decrement wrap': 34056,
  'invert': 5386
}

var shaderType = {
  'frag': GL_FRAGMENT_SHADER$1,
  'vert': GL_VERTEX_SHADER$1
}

var orientationType = {
  'cw': GL_CW,
  'ccw': GL_CCW
}

function isBufferArgs (x) {
  return Array.isArray(x) ||
    isTypedArray(x) ||
    isNDArrayLike(x)
}

// Make sure viewport is processed first
function sortState (state) {
  return state.sort(function (a, b) {
    if (a === S_VIEWPORT) {
      return -1
    } else if (b === S_VIEWPORT) {
      return 1
    }
    return (a < b) ? -1 : 1
  })
}

function Declaration (thisDep, contextDep, propDep, append) {
  this.thisDep = thisDep
  this.contextDep = contextDep
  this.propDep = propDep
  this.append = append
}

function isStatic (decl) {
  return decl && !(decl.thisDep || decl.contextDep || decl.propDep)
}

function createStaticDecl (append) {
  return new Declaration(false, false, false, append)
}

function createDynamicDecl (dyn, append) {
  var type = dyn.type
  if (type === DYN_FUNC$1) {
    var numArgs = dyn.data.length
    return new Declaration(
      true,
      numArgs >= 1,
      numArgs >= 2,
      append)
  } else if (type === DYN_THUNK) {
    var data = dyn.data
    return new Declaration(
      data.thisDep,
      data.contextDep,
      data.propDep,
      append)
  } else if (type === DYN_CONSTANT$1) {
    return new Declaration(
      false,
      false,
      false,
      append)
  } else if (type === DYN_ARRAY$1) {
    var thisDep = false
    var contextDep = false
    var propDep = false
    for (var i = 0; i < dyn.data.length; ++i) {
      var subDyn = dyn.data[i]
      if (subDyn.type === DYN_PROP$1) {
        propDep = true
      } else if (subDyn.type === DYN_CONTEXT$1) {
        contextDep = true
      } else if (subDyn.type === DYN_STATE$1) {
        thisDep = true
      } else if (subDyn.type === DYN_FUNC$1) {
        thisDep = true
        var subArgs = subDyn.data
        if (subArgs >= 1) {
          contextDep = true
        }
        if (subArgs >= 2) {
          propDep = true
        }
      } else if (subDyn.type === DYN_THUNK) {
        thisDep = thisDep || subDyn.data.thisDep
        contextDep = contextDep || subDyn.data.contextDep
        propDep = propDep || subDyn.data.propDep
      }
    }
    return new Declaration(
      thisDep,
      contextDep,
      propDep,
      append)
  } else {
    return new Declaration(
      type === DYN_STATE$1,
      type === DYN_CONTEXT$1,
      type === DYN_PROP$1,
      append)
  }
}

var SCOPE_DECL = new Declaration(false, false, false, function () {})

function reglCore (
  gl,
  stringStore,
  extensions,
  limits,
  bufferState,
  elementState,
  textureState,
  framebufferState,
  uniformState,
  attributeState,
  shaderState,
  drawState,
  contextState,
  timer,
  config) {
  var AttributeRecord = attributeState.Record

  var blendEquations = {
    'add': 32774,
    'subtract': 32778,
    'reverse subtract': 32779
  }
  if (extensions.ext_blend_minmax) {
    blendEquations.min = GL_MIN_EXT
    blendEquations.max = GL_MAX_EXT
  }

  var extInstancing = extensions.angle_instanced_arrays
  var extDrawBuffers = extensions.webgl_draw_buffers
  var extVertexArrays = extensions.oes_vertex_array_object

  // ===================================================
  // ===================================================
  // WEBGL STATE
  // ===================================================
  // ===================================================
  var currentState = {
    dirty: true,
    profile: config.profile
  }
  var nextState = {}
  var GL_STATE_NAMES = []
  var GL_FLAGS = {}
  var GL_VARIABLES = {}

  function propName (name) {
    return name.replace('.', '_')
  }

  function stateFlag (sname, cap, init) {
    var name = propName(sname)
    GL_STATE_NAMES.push(sname)
    nextState[name] = currentState[name] = !!init
    GL_FLAGS[name] = cap
  }

  function stateVariable (sname, func, init) {
    var name = propName(sname)
    GL_STATE_NAMES.push(sname)
    if (Array.isArray(init)) {
      currentState[name] = init.slice()
      nextState[name] = init.slice()
    } else {
      currentState[name] = nextState[name] = init
    }
    GL_VARIABLES[name] = func
  }

  // Dithering
  stateFlag(S_DITHER, GL_DITHER)

  // Blending
  stateFlag(S_BLEND_ENABLE, GL_BLEND)
  stateVariable(S_BLEND_COLOR, 'blendColor', [0, 0, 0, 0])
  stateVariable(S_BLEND_EQUATION, 'blendEquationSeparate',
    [GL_FUNC_ADD, GL_FUNC_ADD])
  stateVariable(S_BLEND_FUNC, 'blendFuncSeparate',
    [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO])

  // Depth
  stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true)
  stateVariable(S_DEPTH_FUNC, 'depthFunc', GL_LESS)
  stateVariable(S_DEPTH_RANGE, 'depthRange', [0, 1])
  stateVariable(S_DEPTH_MASK, 'depthMask', true)

  // Color mask
  stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true])

  // Face culling
  stateFlag(S_CULL_ENABLE, GL_CULL_FACE)
  stateVariable(S_CULL_FACE, 'cullFace', GL_BACK)

  // Front face orientation
  stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW)

  // Line width
  stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1)

  // Polygon offset
  stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL)
  stateVariable(S_POLYGON_OFFSET_OFFSET, 'polygonOffset', [0, 0])

  // Sample coverage
  stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE)
  stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE)
  stateVariable(S_SAMPLE_COVERAGE, 'sampleCoverage', [1, false])

  // Stencil
  stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST)
  stateVariable(S_STENCIL_MASK, 'stencilMask', -1)
  stateVariable(S_STENCIL_FUNC, 'stencilFunc', [GL_ALWAYS, 0, -1])
  stateVariable(S_STENCIL_OPFRONT, 'stencilOpSeparate',
    [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP])
  stateVariable(S_STENCIL_OPBACK, 'stencilOpSeparate',
    [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP])

  // Scissor
  stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST)
  stateVariable(S_SCISSOR_BOX, 'scissor',
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight])

  // Viewport
  stateVariable(S_VIEWPORT, S_VIEWPORT,
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight])

  // ===================================================
  // ===================================================
  // ENVIRONMENT
  // ===================================================
  // ===================================================
  var sharedState = {
    gl: gl,
    context: contextState,
    strings: stringStore,
    next: nextState,
    current: currentState,
    draw: drawState,
    elements: elementState,
    buffer: bufferState,
    shader: shaderState,
    attributes: attributeState.state,
    vao: attributeState,
    uniforms: uniformState,
    framebuffer: framebufferState,
    extensions: extensions,

    timer: timer,
    isBufferArgs: isBufferArgs
  }

  var sharedConstants = {
    primTypes: primTypes,
    compareFuncs: compareFuncs,
    blendFuncs: blendFuncs,
    blendEquations: blendEquations,
    stencilOps: stencilOps,
    glTypes: glTypes,
    orientationType: orientationType
  }

  check$1.optional(function () {
    sharedState.isArrayLike = isArrayLike
  })

  if (extDrawBuffers) {
    sharedConstants.backBuffer = [GL_BACK]
    sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {
      if (i === 0) {
        return [0]
      }
      return loop(i, function (j) {
        return GL_COLOR_ATTACHMENT0$2 + j
      })
    })
  }

  var drawCallCounter = 0
  function createREGLEnvironment () {
    var env = createEnvironment()
    var link = env.link
    var global = env.global
    env.id = drawCallCounter++

    env.batchId = '0'

    // link shared state
    var SHARED = link(sharedState)
    var shared = env.shared = {
      props: 'a0'
    }
    Object.keys(sharedState).forEach(function (prop) {
      shared[prop] = global.def(SHARED, '.', prop)
    })

    // Inject runtime assertion stuff for debug builds
    check$1.optional(function () {
      env.CHECK = link(check$1)
      env.commandStr = check$1.guessCommand()
      env.command = link(env.commandStr)
      env.assert = function (block, pred, message) {
        block(
          'if(!(', pred, '))',
          this.CHECK, '.commandRaise(', link(message), ',', this.command, ');')
      }

      sharedConstants.invalidBlendCombinations = invalidBlendCombinations
    })

    // Copy GL state variables over
    var nextVars = env.next = {}
    var currentVars = env.current = {}
    Object.keys(GL_VARIABLES).forEach(function (variable) {
      if (Array.isArray(currentState[variable])) {
        nextVars[variable] = global.def(shared.next, '.', variable)
        currentVars[variable] = global.def(shared.current, '.', variable)
      }
    })

    // Initialize shared constants
    var constants = env.constants = {}
    Object.keys(sharedConstants).forEach(function (name) {
      constants[name] = global.def(JSON.stringify(sharedConstants[name]))
    })

    // Helper function for calling a block
    env.invoke = function (block, x) {
      switch (x.type) {
        case DYN_FUNC$1:
          var argList = [
            'this',
            shared.context,
            shared.props,
            env.batchId
          ]
          return block.def(
            link(x.data), '.call(',
            argList.slice(0, Math.max(x.data.length + 1, 4)),
            ')')
        case DYN_PROP$1:
          return block.def(shared.props, x.data)
        case DYN_CONTEXT$1:
          return block.def(shared.context, x.data)
        case DYN_STATE$1:
          return block.def('this', x.data)
        case DYN_THUNK:
          x.data.append(env, block)
          return x.data.ref
        case DYN_CONSTANT$1:
          return x.data.toString()
        case DYN_ARRAY$1:
          return x.data.map(function (y) {
            return env.invoke(block, y)
          })
      }
    }

    env.attribCache = {}

    var scopeAttribs = {}
    env.scopeAttrib = function (name) {
      var id = stringStore.id(name)
      if (id in scopeAttribs) {
        return scopeAttribs[id]
      }
      var binding = attributeState.scope[id]
      if (!binding) {
        binding = attributeState.scope[id] = new AttributeRecord()
      }
      var result = scopeAttribs[id] = link(binding)
      return result
    }

    return env
  }

  // ===================================================
  // ===================================================
  // PARSING
  // ===================================================
  // ===================================================
  function parseProfile (options) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    var profileEnable
    if (S_PROFILE in staticOptions) {
      var value = !!staticOptions[S_PROFILE]
      profileEnable = createStaticDecl(function (env, scope) {
        return value
      })
      profileEnable.enable = value
    } else if (S_PROFILE in dynamicOptions) {
      var dyn = dynamicOptions[S_PROFILE]
      profileEnable = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    }

    return profileEnable
  }

  function parseFramebuffer (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    if (S_FRAMEBUFFER in staticOptions) {
      var framebuffer = staticOptions[S_FRAMEBUFFER]
      if (framebuffer) {
        framebuffer = framebufferState.getFramebuffer(framebuffer)
        check$1.command(framebuffer, 'invalid framebuffer object')
        return createStaticDecl(function (env, block) {
          var FRAMEBUFFER = env.link(framebuffer)
          var shared = env.shared
          block.set(
            shared.framebuffer,
            '.next',
            FRAMEBUFFER)
          var CONTEXT = shared.context
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            FRAMEBUFFER + '.width')
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            FRAMEBUFFER + '.height')
          return FRAMEBUFFER
        })
      } else {
        return createStaticDecl(function (env, scope) {
          var shared = env.shared
          scope.set(
            shared.framebuffer,
            '.next',
            'null')
          var CONTEXT = shared.context
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH)
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT)
          return 'null'
        })
      }
    } else if (S_FRAMEBUFFER in dynamicOptions) {
      var dyn = dynamicOptions[S_FRAMEBUFFER]
      return createDynamicDecl(dyn, function (env, scope) {
        var FRAMEBUFFER_FUNC = env.invoke(scope, dyn)
        var shared = env.shared
        var FRAMEBUFFER_STATE = shared.framebuffer
        var FRAMEBUFFER = scope.def(
          FRAMEBUFFER_STATE, '.getFramebuffer(', FRAMEBUFFER_FUNC, ')')

        check$1.optional(function () {
          env.assert(scope,
            '!' + FRAMEBUFFER_FUNC + '||' + FRAMEBUFFER,
            'invalid framebuffer object')
        })

        scope.set(
          FRAMEBUFFER_STATE,
          '.next',
          FRAMEBUFFER)
        var CONTEXT = shared.context
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_WIDTH,
          FRAMEBUFFER + '?' + FRAMEBUFFER + '.width:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH)
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_HEIGHT,
          FRAMEBUFFER +
          '?' + FRAMEBUFFER + '.height:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT)
        return FRAMEBUFFER
      })
    } else {
      return null
    }
  }

  function parseViewportScissor (options, framebuffer, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseBox (param) {
      if (param in staticOptions) {
        var box = staticOptions[param]
        check$1.commandType(box, 'object', 'invalid ' + param, env.commandStr)

        var isStatic = true
        var x = box.x | 0
        var y = box.y | 0
        var w, h
        if ('width' in box) {
          w = box.width | 0
          check$1.command(w >= 0, 'invalid ' + param, env.commandStr)
        } else {
          isStatic = false
        }
        if ('height' in box) {
          h = box.height | 0
          check$1.command(h >= 0, 'invalid ' + param, env.commandStr)
        } else {
          isStatic = false
        }

        return new Declaration(
          !isStatic && framebuffer && framebuffer.thisDep,
          !isStatic && framebuffer && framebuffer.contextDep,
          !isStatic && framebuffer && framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context
            var BOX_W = w
            if (!('width' in box)) {
              BOX_W = scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', x)
            }
            var BOX_H = h
            if (!('height' in box)) {
              BOX_H = scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', y)
            }
            return [x, y, BOX_W, BOX_H]
          })
      } else if (param in dynamicOptions) {
        var dynBox = dynamicOptions[param]
        var result = createDynamicDecl(dynBox, function (env, scope) {
          var BOX = env.invoke(scope, dynBox)

          check$1.optional(function () {
            env.assert(scope,
              BOX + '&&typeof ' + BOX + '==="object"',
              'invalid ' + param)
          })

          var CONTEXT = env.shared.context
          var BOX_X = scope.def(BOX, '.x|0')
          var BOX_Y = scope.def(BOX, '.y|0')
          var BOX_W = scope.def(
            '"width" in ', BOX, '?', BOX, '.width|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', BOX_X, ')')
          var BOX_H = scope.def(
            '"height" in ', BOX, '?', BOX, '.height|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', BOX_Y, ')')

          check$1.optional(function () {
            env.assert(scope,
              BOX_W + '>=0&&' +
              BOX_H + '>=0',
              'invalid ' + param)
          })

          return [BOX_X, BOX_Y, BOX_W, BOX_H]
        })
        if (framebuffer) {
          result.thisDep = result.thisDep || framebuffer.thisDep
          result.contextDep = result.contextDep || framebuffer.contextDep
          result.propDep = result.propDep || framebuffer.propDep
        }
        return result
      } else if (framebuffer) {
        return new Declaration(
          framebuffer.thisDep,
          framebuffer.contextDep,
          framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context
            return [
              0, 0,
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH),
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT)]
          })
      } else {
        return null
      }
    }

    var viewport = parseBox(S_VIEWPORT)

    if (viewport) {
      var prevViewport = viewport
      viewport = new Declaration(
        viewport.thisDep,
        viewport.contextDep,
        viewport.propDep,
        function (env, scope) {
          var VIEWPORT = prevViewport.append(env, scope)
          var CONTEXT = env.shared.context
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_WIDTH,
            VIEWPORT[2])
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_HEIGHT,
            VIEWPORT[3])
          return VIEWPORT
        })
    }

    return {
      viewport: viewport,
      scissor_box: parseBox(S_SCISSOR_BOX)
    }
  }

  function parseAttribLocations (options, attributes) {
    var staticOptions = options.static
    var staticProgram =
      typeof staticOptions[S_FRAG] === 'string' &&
      typeof staticOptions[S_VERT] === 'string'
    if (staticProgram) {
      if (Object.keys(attributes.dynamic).length > 0) {
        return null
      }
      var staticAttributes = attributes.static
      var sAttributes = Object.keys(staticAttributes)
      if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === 'number') {
        var bindings = []
        for (var i = 0; i < sAttributes.length; ++i) {
          check$1(typeof staticAttributes[sAttributes[i]] === 'number', 'must specify all vertex attribute locations when using vaos')
          bindings.push([staticAttributes[sAttributes[i]] | 0, sAttributes[i]])
        }
        return bindings
      }
    }
    return null
  }

  function parseProgram (options, env, attribLocations) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseShader (name) {
      if (name in staticOptions) {
        var id = stringStore.id(staticOptions[name])
        check$1.optional(function () {
          shaderState.shader(shaderType[name], id, check$1.guessCommand())
        })
        var result = createStaticDecl(function () {
          return id
        })
        result.id = id
        return result
      } else if (name in dynamicOptions) {
        var dyn = dynamicOptions[name]
        return createDynamicDecl(dyn, function (env, scope) {
          var str = env.invoke(scope, dyn)
          var id = scope.def(env.shared.strings, '.id(', str, ')')
          check$1.optional(function () {
            scope(
              env.shared.shader, '.shader(',
              shaderType[name], ',',
              id, ',',
              env.command, ');')
          })
          return id
        })
      }
      return null
    }

    var frag = parseShader(S_FRAG)
    var vert = parseShader(S_VERT)

    var program = null
    var progVar
    if (isStatic(frag) && isStatic(vert)) {
      program = shaderState.program(vert.id, frag.id, null, attribLocations)
      progVar = createStaticDecl(function (env, scope) {
        return env.link(program)
      })
    } else {
      progVar = new Declaration(
        (frag && frag.thisDep) || (vert && vert.thisDep),
        (frag && frag.contextDep) || (vert && vert.contextDep),
        (frag && frag.propDep) || (vert && vert.propDep),
        function (env, scope) {
          var SHADER_STATE = env.shared.shader
          var fragId
          if (frag) {
            fragId = frag.append(env, scope)
          } else {
            fragId = scope.def(SHADER_STATE, '.', S_FRAG)
          }
          var vertId
          if (vert) {
            vertId = vert.append(env, scope)
          } else {
            vertId = scope.def(SHADER_STATE, '.', S_VERT)
          }
          var progDef = SHADER_STATE + '.program(' + vertId + ',' + fragId
          check$1.optional(function () {
            progDef += ',' + env.command
          })
          return scope.def(progDef + ')')
        })
    }

    return {
      frag: frag,
      vert: vert,
      progVar: progVar,
      program: program
    }
  }

  function parseDraw (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    // TODO: should use VAO to get default values for offset properties
    // should move vao parse into here and out of the old stuff

    var staticDraw = {}
    var vaoActive = false

    function parseVAO () {
      if (S_VAO in staticOptions) {
        var vao = staticOptions[S_VAO]
        if (vao !== null && attributeState.getVAO(vao) === null) {
          vao = attributeState.createVAO(vao)
        }

        vaoActive = true
        staticDraw.vao = vao

        return createStaticDecl(function (env) {
          var vaoRef = attributeState.getVAO(vao)
          if (vaoRef) {
            return env.link(vaoRef)
          } else {
            return 'null'
          }
        })
      } else if (S_VAO in dynamicOptions) {
        vaoActive = true
        var dyn = dynamicOptions[S_VAO]
        return createDynamicDecl(dyn, function (env, scope) {
          var vaoRef = env.invoke(scope, dyn)
          return scope.def(env.shared.vao + '.getVAO(' + vaoRef + ')')
        })
      }
      return null
    }

    var vao = parseVAO()

    var elementsActive = false

    function parseElements () {
      if (S_ELEMENTS in staticOptions) {
        var elements = staticOptions[S_ELEMENTS]
        staticDraw.elements = elements
        if (isBufferArgs(elements)) {
          var e = staticDraw.elements = elementState.create(elements, true)
          elements = elementState.getElements(e)
          elementsActive = true
        } else if (elements) {
          elements = elementState.getElements(elements)
          elementsActive = true
          check$1.command(elements, 'invalid elements', env.commandStr)
        }

        var result = createStaticDecl(function (env, scope) {
          if (elements) {
            var result = env.link(elements)
            env.ELEMENTS = result
            return result
          }
          env.ELEMENTS = null
          return null
        })
        result.value = elements
        return result
      } else if (S_ELEMENTS in dynamicOptions) {
        elementsActive = true

        var dyn = dynamicOptions[S_ELEMENTS]
        return createDynamicDecl(dyn, function (env, scope) {
          var shared = env.shared

          var IS_BUFFER_ARGS = shared.isBufferArgs
          var ELEMENT_STATE = shared.elements

          var elementDefn = env.invoke(scope, dyn)
          var elements = scope.def('null')
          var elementStream = scope.def(IS_BUFFER_ARGS, '(', elementDefn, ')')

          var ifte = env.cond(elementStream)
            .then(elements, '=', ELEMENT_STATE, '.createStream(', elementDefn, ');')
            .else(elements, '=', ELEMENT_STATE, '.getElements(', elementDefn, ');')

          check$1.optional(function () {
            env.assert(ifte.else,
              '!' + elementDefn + '||' + elements,
              'invalid elements')
          })

          scope.entry(ifte)
          scope.exit(
            env.cond(elementStream)
              .then(ELEMENT_STATE, '.destroyStream(', elements, ');'))

          env.ELEMENTS = elements

          return elements
        })
      } else if (vaoActive) {
        return new Declaration(
          vao.thisDep,
          vao.contextDep,
          vao.propDep,
          function (env, scope) {
            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.elements + '.getElements(' + env.shared.vao + '.currentVAO.elements):null')
          })
      }
      return null
    }

    var elements = parseElements()

    function parsePrimitive () {
      if (S_PRIMITIVE in staticOptions) {
        var primitive = staticOptions[S_PRIMITIVE]
        staticDraw.primitive = primitive
        check$1.commandParameter(primitive, primTypes, 'invalid primitve', env.commandStr)
        return createStaticDecl(function (env, scope) {
          return primTypes[primitive]
        })
      } else if (S_PRIMITIVE in dynamicOptions) {
        var dynPrimitive = dynamicOptions[S_PRIMITIVE]
        return createDynamicDecl(dynPrimitive, function (env, scope) {
          var PRIM_TYPES = env.constants.primTypes
          var prim = env.invoke(scope, dynPrimitive)
          check$1.optional(function () {
            env.assert(scope,
              prim + ' in ' + PRIM_TYPES,
              'invalid primitive, must be one of ' + Object.keys(primTypes))
          })
          return scope.def(PRIM_TYPES, '[', prim, ']')
        })
      } else if (elementsActive) {
        if (isStatic(elements)) {
          if (elements.value) {
            return createStaticDecl(function (env, scope) {
              return scope.def(env.ELEMENTS, '.primType')
            })
          } else {
            return createStaticDecl(function () {
              return GL_TRIANGLES$1
            })
          }
        } else {
          return new Declaration(
            elements.thisDep,
            elements.contextDep,
            elements.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS
              return scope.def(elements, '?', elements, '.primType:', GL_TRIANGLES$1)
            })
        }
      } else if (vaoActive) {
        return new Declaration(
          vao.thisDep,
          vao.contextDep,
          vao.propDep,
          function (env, scope) {
            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.primitive:' + GL_TRIANGLES$1)
          })
      }
      return null
    }

    function parseParam (param, isOffset) {
      if (param in staticOptions) {
        var value = staticOptions[param] | 0
        if (isOffset) {
          staticDraw.offset = value
        } else {
          staticDraw.instances = value
        }
        check$1.command(!isOffset || value >= 0, 'invalid ' + param, env.commandStr)
        return createStaticDecl(function (env, scope) {
          if (isOffset) {
            env.OFFSET = value
          }
          return value
        })
      } else if (param in dynamicOptions) {
        var dynValue = dynamicOptions[param]
        return createDynamicDecl(dynValue, function (env, scope) {
          var result = env.invoke(scope, dynValue)
          if (isOffset) {
            env.OFFSET = result
            check$1.optional(function () {
              env.assert(scope,
                result + '>=0',
                'invalid ' + param)
            })
          }
          return result
        })
      } else if (isOffset) {
        if (elementsActive) {
          return createStaticDecl(function (env, scope) {
            env.OFFSET = 0
            return 0
          })
        } else if (vaoActive) {
          return new Declaration(
            vao.thisDep,
            vao.contextDep,
            vao.propDep,
            function (env, scope) {
              return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.offset:0')
            })
        }
      } else if (vaoActive) {
        return new Declaration(
          vao.thisDep,
          vao.contextDep,
          vao.propDep,
          function (env, scope) {
            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.instances:-1')
          })
      }
      return null
    }

    var OFFSET = parseParam(S_OFFSET, true)

    function parseVertCount () {
      if (S_COUNT in staticOptions) {
        var count = staticOptions[S_COUNT] | 0
        staticDraw.count = count
        check$1.command(
          typeof count === 'number' && count >= 0, 'invalid vertex count', env.commandStr)
        return createStaticDecl(function () {
          return count
        })
      } else if (S_COUNT in dynamicOptions) {
        var dynCount = dynamicOptions[S_COUNT]
        return createDynamicDecl(dynCount, function (env, scope) {
          var result = env.invoke(scope, dynCount)
          check$1.optional(function () {
            env.assert(scope,
              'typeof ' + result + '==="number"&&' +
              result + '>=0&&' +
              result + '===(' + result + '|0)',
              'invalid vertex count')
          })
          return result
        })
      } else if (elementsActive) {
        if (isStatic(elements)) {
          if (elements) {
            if (OFFSET) {
              return new Declaration(
                OFFSET.thisDep,
                OFFSET.contextDep,
                OFFSET.propDep,
                function (env, scope) {
                  var result = scope.def(
                    env.ELEMENTS, '.vertCount-', env.OFFSET)

                  check$1.optional(function () {
                    env.assert(scope,
                      result + '>=0',
                      'invalid vertex offset/element buffer too small')
                  })

                  return result
                })
            } else {
              return createStaticDecl(function (env, scope) {
                return scope.def(env.ELEMENTS, '.vertCount')
              })
            }
          } else {
            var result = createStaticDecl(function () {
              return -1
            })
            check$1.optional(function () {
              result.MISSING = true
            })
            return result
          }
        } else {
          var variable = new Declaration(
            elements.thisDep || OFFSET.thisDep,
            elements.contextDep || OFFSET.contextDep,
            elements.propDep || OFFSET.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS
              if (env.OFFSET) {
                return scope.def(elements, '?', elements, '.vertCount-',
                  env.OFFSET, ':-1')
              }
              return scope.def(elements, '?', elements, '.vertCount:-1')
            })
          check$1.optional(function () {
            variable.DYNAMIC = true
          })
          return variable
        }
      } else if (vaoActive) {
        var countVariable = new Declaration(
          vao.thisDep,
          vao.contextDep,
          vao.propDep,
          function (env, scope) {
            return scope.def(env.shared.vao, '.currentVAO?', env.shared.vao, '.currentVAO.count:-1')
          })
        return countVariable
      }
      return null
    }

    var primitive = parsePrimitive()
    var count = parseVertCount()
    var instances = parseParam(S_INSTANCES, false)

    return {
      elements: elements,
      primitive: primitive,
      count: count,
      instances: instances,
      offset: OFFSET,
      vao: vao,

      vaoActive: vaoActive,
      elementsActive: elementsActive,

      // static draw props
      static: staticDraw
    }
  }

  function parseGLState (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    var STATE = {}

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop)

      function parseParam (parseStatic, parseDynamic) {
        if (prop in staticOptions) {
          var value = parseStatic(staticOptions[prop])
          STATE[param] = createStaticDecl(function () {
            return value
          })
        } else if (prop in dynamicOptions) {
          var dyn = dynamicOptions[prop]
          STATE[param] = createDynamicDecl(dyn, function (env, scope) {
            return parseDynamic(env, scope, env.invoke(scope, dyn))
          })
        }
      }

      switch (prop) {
        case S_CULL_ENABLE:
        case S_BLEND_ENABLE:
        case S_DITHER:
        case S_STENCIL_ENABLE:
        case S_DEPTH_ENABLE:
        case S_SCISSOR_ENABLE:
        case S_POLYGON_OFFSET_ENABLE:
        case S_SAMPLE_ALPHA:
        case S_SAMPLE_ENABLE:
        case S_DEPTH_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'boolean', prop, env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="boolean"',
                  'invalid flag ' + prop, env.commandStr)
              })
              return value
            })

        case S_DEPTH_FUNC:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, compareFuncs, 'invalid ' + prop, env.commandStr)
              return compareFuncs[value]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs
              check$1.optional(function () {
                env.assert(scope,
                  value + ' in ' + COMPARE_FUNCS,
                  'invalid ' + prop + ', must be one of ' + Object.keys(compareFuncs))
              })
              return scope.def(COMPARE_FUNCS, '[', value, ']')
            })

        case S_DEPTH_RANGE:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 2 &&
                typeof value[0] === 'number' &&
                typeof value[1] === 'number' &&
                value[0] <= value[1],
                'depth range is 2d array',
                env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===2&&' +
                  'typeof ' + value + '[0]==="number"&&' +
                  'typeof ' + value + '[1]==="number"&&' +
                  value + '[0]<=' + value + '[1]',
                  'depth range must be a 2d array')
              })

              var Z_NEAR = scope.def('+', value, '[0]')
              var Z_FAR = scope.def('+', value, '[1]')
              return [Z_NEAR, Z_FAR]
            })

        case S_BLEND_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', 'blend.func', env.commandStr)
              var srcRGB = ('srcRGB' in value ? value.srcRGB : value.src)
              var srcAlpha = ('srcAlpha' in value ? value.srcAlpha : value.src)
              var dstRGB = ('dstRGB' in value ? value.dstRGB : value.dst)
              var dstAlpha = ('dstAlpha' in value ? value.dstAlpha : value.dst)
              check$1.commandParameter(srcRGB, blendFuncs, param + '.srcRGB', env.commandStr)
              check$1.commandParameter(srcAlpha, blendFuncs, param + '.srcAlpha', env.commandStr)
              check$1.commandParameter(dstRGB, blendFuncs, param + '.dstRGB', env.commandStr)
              check$1.commandParameter(dstAlpha, blendFuncs, param + '.dstAlpha', env.commandStr)

              check$1.command(
                (invalidBlendCombinations.indexOf(srcRGB + ', ' + dstRGB) === -1),
                'unallowed blending combination (srcRGB, dstRGB) = (' + srcRGB + ', ' + dstRGB + ')', env.commandStr)

              return [
                blendFuncs[srcRGB],
                blendFuncs[dstRGB],
                blendFuncs[srcAlpha],
                blendFuncs[dstAlpha]
              ]
            },
            function (env, scope, value) {
              var BLEND_FUNCS = env.constants.blendFuncs

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid blend func, must be an object')
              })

              function read (prefix, suffix) {
                var func = scope.def(
                  '"', prefix, suffix, '" in ', value,
                  '?', value, '.', prefix, suffix,
                  ':', value, '.', prefix)

                check$1.optional(function () {
                  env.assert(scope,
                    func + ' in ' + BLEND_FUNCS,
                    'invalid ' + prop + '.' + prefix + suffix + ', must be one of ' + Object.keys(blendFuncs))
                })

                return func
              }

              var srcRGB = read('src', 'RGB')
              var dstRGB = read('dst', 'RGB')

              check$1.optional(function () {
                var INVALID_BLEND_COMBINATIONS = env.constants.invalidBlendCombinations

                env.assert(scope,
                  INVALID_BLEND_COMBINATIONS +
                           '.indexOf(' + srcRGB + '+", "+' + dstRGB + ') === -1 ',
                  'unallowed blending combination for (srcRGB, dstRGB)'
                )
              })

              var SRC_RGB = scope.def(BLEND_FUNCS, '[', srcRGB, ']')
              var SRC_ALPHA = scope.def(BLEND_FUNCS, '[', read('src', 'Alpha'), ']')
              var DST_RGB = scope.def(BLEND_FUNCS, '[', dstRGB, ']')
              var DST_ALPHA = scope.def(BLEND_FUNCS, '[', read('dst', 'Alpha'), ']')

              return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA]
            })

        case S_BLEND_EQUATION:
          return parseParam(
            function (value) {
              if (typeof value === 'string') {
                check$1.commandParameter(value, blendEquations, 'invalid ' + prop, env.commandStr)
                return [
                  blendEquations[value],
                  blendEquations[value]
                ]
              } else if (typeof value === 'object') {
                check$1.commandParameter(
                  value.rgb, blendEquations, prop + '.rgb', env.commandStr)
                check$1.commandParameter(
                  value.alpha, blendEquations, prop + '.alpha', env.commandStr)
                return [
                  blendEquations[value.rgb],
                  blendEquations[value.alpha]
                ]
              } else {
                check$1.commandRaise('invalid blend.equation', env.commandStr)
              }
            },
            function (env, scope, value) {
              var BLEND_EQUATIONS = env.constants.blendEquations

              var RGB = scope.def()
              var ALPHA = scope.def()

              var ifte = env.cond('typeof ', value, '==="string"')

              check$1.optional(function () {
                function checkProp (block, name, value) {
                  env.assert(block,
                    value + ' in ' + BLEND_EQUATIONS,
                    'invalid ' + name + ', must be one of ' + Object.keys(blendEquations))
                }
                checkProp(ifte.then, prop, value)

                env.assert(ifte.else,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
                checkProp(ifte.else, prop + '.rgb', value + '.rgb')
                checkProp(ifte.else, prop + '.alpha', value + '.alpha')
              })

              ifte.then(
                RGB, '=', ALPHA, '=', BLEND_EQUATIONS, '[', value, '];')
              ifte.else(
                RGB, '=', BLEND_EQUATIONS, '[', value, '.rgb];',
                ALPHA, '=', BLEND_EQUATIONS, '[', value, '.alpha];')

              scope(ifte)

              return [RGB, ALPHA]
            })

        case S_BLEND_COLOR:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 4,
                'blend.color must be a 4d array', env.commandStr)
              return loop(4, function (i) {
                return +value[i]
              })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'blend.color must be a 4d array')
              })
              return loop(4, function (i) {
                return scope.def('+', value, '[', i, ']')
              })
            })

        case S_STENCIL_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'number', param, env.commandStr)
              return value | 0
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"',
                  'invalid stencil.mask')
              })
              return scope.def(value, '|0')
            })

        case S_STENCIL_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var cmp = value.cmp || 'keep'
              var ref = value.ref || 0
              var mask = 'mask' in value ? value.mask : -1
              check$1.commandParameter(cmp, compareFuncs, prop + '.cmp', env.commandStr)
              check$1.commandType(ref, 'number', prop + '.ref', env.commandStr)
              check$1.commandType(mask, 'number', prop + '.mask', env.commandStr)
              return [
                compareFuncs[cmp],
                ref,
                mask
              ]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs
              check$1.optional(function () {
                function assert () {
                  env.assert(scope,
                    Array.prototype.join.call(arguments, ''),
                    'invalid stencil.func')
                }
                assert(value + '&&typeof ', value, '==="object"')
                assert('!("cmp" in ', value, ')||(',
                  value, '.cmp in ', COMPARE_FUNCS, ')')
              })
              var cmp = scope.def(
                '"cmp" in ', value,
                '?', COMPARE_FUNCS, '[', value, '.cmp]',
                ':', GL_KEEP)
              var ref = scope.def(value, '.ref|0')
              var mask = scope.def(
                '"mask" in ', value,
                '?', value, '.mask|0:-1')
              return [cmp, ref, mask]
            })

        case S_STENCIL_OPFRONT:
        case S_STENCIL_OPBACK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var fail = value.fail || 'keep'
              var zfail = value.zfail || 'keep'
              var zpass = value.zpass || 'keep'
              check$1.commandParameter(fail, stencilOps, prop + '.fail', env.commandStr)
              check$1.commandParameter(zfail, stencilOps, prop + '.zfail', env.commandStr)
              check$1.commandParameter(zpass, stencilOps, prop + '.zpass', env.commandStr)
              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                stencilOps[fail],
                stencilOps[zfail],
                stencilOps[zpass]
              ]
            },
            function (env, scope, value) {
              var STENCIL_OPS = env.constants.stencilOps

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
              })

              function read (name) {
                check$1.optional(function () {
                  env.assert(scope,
                    '!("' + name + '" in ' + value + ')||' +
                    '(' + value + '.' + name + ' in ' + STENCIL_OPS + ')',
                    'invalid ' + prop + '.' + name + ', must be one of ' + Object.keys(stencilOps))
                })

                return scope.def(
                  '"', name, '" in ', value,
                  '?', STENCIL_OPS, '[', value, '.', name, ']:',
                  GL_KEEP)
              }

              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                read('fail'),
                read('zfail'),
                read('zpass')
              ]
            })

        case S_POLYGON_OFFSET_OFFSET:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var factor = value.factor | 0
              var units = value.units | 0
              check$1.commandType(factor, 'number', param + '.factor', env.commandStr)
              check$1.commandType(units, 'number', param + '.units', env.commandStr)
              return [factor, units]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
              })

              var FACTOR = scope.def(value, '.factor|0')
              var UNITS = scope.def(value, '.units|0')

              return [FACTOR, UNITS]
            })

        case S_CULL_FACE:
          return parseParam(
            function (value) {
              var face = 0
              if (value === 'front') {
                face = GL_FRONT
              } else if (value === 'back') {
                face = GL_BACK
              }
              check$1.command(!!face, param, env.commandStr)
              return face
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="front"||' +
                  value + '==="back"',
                  'invalid cull.face')
              })
              return scope.def(value, '==="front"?', GL_FRONT, ':', GL_BACK)
            })

        case S_LINE_WIDTH:
          return parseParam(
            function (value) {
              check$1.command(
                typeof value === 'number' &&
                value >= limits.lineWidthDims[0] &&
                value <= limits.lineWidthDims[1],
                'invalid line width, must be a positive number between ' +
                limits.lineWidthDims[0] + ' and ' + limits.lineWidthDims[1], env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"&&' +
                  value + '>=' + limits.lineWidthDims[0] + '&&' +
                  value + '<=' + limits.lineWidthDims[1],
                  'invalid line width')
              })

              return value
            })

        case S_FRONT_FACE:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, orientationType, param, env.commandStr)
              return orientationType[value]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="cw"||' +
                  value + '==="ccw"',
                  'invalid frontFace, must be one of cw,ccw')
              })
              return scope.def(value + '==="cw"?' + GL_CW + ':' + GL_CCW)
            })

        case S_COLOR_MASK:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) && value.length === 4,
                'color.mask must be length 4 array', env.commandStr)
              return value.map(function (v) { return !!v })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'invalid color.mask')
              })
              return loop(4, function (i) {
                return '!!' + value + '[' + i + ']'
              })
            })

        case S_SAMPLE_COVERAGE:
          return parseParam(
            function (value) {
              check$1.command(typeof value === 'object' && value, param, env.commandStr)
              var sampleValue = 'value' in value ? value.value : 1
              var sampleInvert = !!value.invert
              check$1.command(
                typeof sampleValue === 'number' &&
                sampleValue >= 0 && sampleValue <= 1,
                'sample.coverage.value must be a number between 0 and 1', env.commandStr)
              return [sampleValue, sampleInvert]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid sample.coverage')
              })
              var VALUE = scope.def(
                '"value" in ', value, '?+', value, '.value:1')
              var INVERT = scope.def('!!', value, '.invert')
              return [VALUE, INVERT]
            })
      }
    })

    return STATE
  }

  function parseUniforms (uniforms, env) {
    var staticUniforms = uniforms.static
    var dynamicUniforms = uniforms.dynamic

    var UNIFORMS = {}

    Object.keys(staticUniforms).forEach(function (name) {
      var value = staticUniforms[name]
      var result
      if (typeof value === 'number' ||
          typeof value === 'boolean') {
        result = createStaticDecl(function () {
          return value
        })
      } else if (typeof value === 'function') {
        var reglType = value._reglType
        if (reglType === 'texture2d' ||
            reglType === 'textureCube') {
          result = createStaticDecl(function (env) {
            return env.link(value)
          })
        } else if (reglType === 'framebuffer' ||
                   reglType === 'framebufferCube') {
          check$1.command(value.color.length > 0,
            'missing color attachment for framebuffer sent to uniform "' + name + '"', env.commandStr)
          result = createStaticDecl(function (env) {
            return env.link(value.color[0])
          })
        } else {
          check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr)
        }
      } else if (isArrayLike(value)) {
        result = createStaticDecl(function (env) {
          var ITEM = env.global.def('[',
            loop(value.length, function (i) {
              check$1.command(
                typeof value[i] === 'number' ||
                typeof value[i] === 'boolean',
                'invalid uniform ' + name, env.commandStr)
              return value[i]
            }), ']')
          return ITEM
        })
      } else {
        check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr)
      }
      result.value = value
      UNIFORMS[name] = result
    })

    Object.keys(dynamicUniforms).forEach(function (key) {
      var dyn = dynamicUniforms[key]
      UNIFORMS[key] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    })

    return UNIFORMS
  }

  function parseAttributes (attributes, env) {
    var staticAttributes = attributes.static
    var dynamicAttributes = attributes.dynamic

    var attributeDefs = {}

    Object.keys(staticAttributes).forEach(function (attribute) {
      var value = staticAttributes[attribute]
      var id = stringStore.id(attribute)

      var record = new AttributeRecord()
      if (isBufferArgs(value)) {
        record.state = ATTRIB_STATE_POINTER
        record.buffer = bufferState.getBuffer(
          bufferState.create(value, GL_ARRAY_BUFFER$2, false, true))
        record.type = 0
      } else {
        var buffer = bufferState.getBuffer(value)
        if (buffer) {
          record.state = ATTRIB_STATE_POINTER
          record.buffer = buffer
          record.type = 0
        } else {
          check$1.command(typeof value === 'object' && value,
            'invalid data for attribute ' + attribute, env.commandStr)
          if ('constant' in value) {
            var constant = value.constant
            record.buffer = 'null'
            record.state = ATTRIB_STATE_CONSTANT
            if (typeof constant === 'number') {
              record.x = constant
            } else {
              check$1.command(
                isArrayLike(constant) &&
                constant.length > 0 &&
                constant.length <= 4,
                'invalid constant for attribute ' + attribute, env.commandStr)
              CUTE_COMPONENTS.forEach(function (c, i) {
                if (i < constant.length) {
                  record[c] = constant[i]
                }
              })
            }
          } else {
            if (isBufferArgs(value.buffer)) {
              buffer = bufferState.getBuffer(
                bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true))
            } else {
              buffer = bufferState.getBuffer(value.buffer)
            }
            check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr)

            var offset = value.offset | 0
            check$1.command(offset >= 0,
              'invalid offset for attribute "' + attribute + '"', env.commandStr)

            var stride = value.stride | 0
            check$1.command(stride >= 0 && stride < 256,
              'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]', env.commandStr)

            var size = value.size | 0
            check$1.command(!('size' in value) || (size > 0 && size <= 4),
              'invalid size for attribute "' + attribute + '", must be 1,2,3,4', env.commandStr)

            var normalized = !!value.normalized

            var type = 0
            if ('type' in value) {
              check$1.commandParameter(
                value.type, glTypes,
                'invalid type for attribute ' + attribute, env.commandStr)
              type = glTypes[value.type]
            }

            var divisor = value.divisor | 0
            check$1.optional(function () {
              if ('divisor' in value) {
                check$1.command(divisor === 0 || extInstancing,
                  'cannot specify divisor for attribute "' + attribute + '", instancing not supported', env.commandStr)
                check$1.command(divisor >= 0,
                  'invalid divisor for attribute "' + attribute + '"', env.commandStr)
              }

              var command = env.commandStr

              var VALID_KEYS = [
                'buffer',
                'offset',
                'divisor',
                'normalized',
                'type',
                'size',
                'stride'
              ]

              Object.keys(value).forEach(function (prop) {
                check$1.command(
                  VALID_KEYS.indexOf(prop) >= 0,
                  'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ')',
                  command)
              })
            })

            record.buffer = buffer
            record.state = ATTRIB_STATE_POINTER
            record.size = size
            record.normalized = normalized
            record.type = type || buffer.dtype
            record.offset = offset
            record.stride = stride
            record.divisor = divisor
          }
        }
      }

      attributeDefs[attribute] = createStaticDecl(function (env, scope) {
        var cache = env.attribCache
        if (id in cache) {
          return cache[id]
        }
        var result = {
          isStream: false
        }
        Object.keys(record).forEach(function (key) {
          result[key] = record[key]
        })
        if (record.buffer) {
          result.buffer = env.link(record.buffer)
          result.type = result.type || (result.buffer + '.dtype')
        }
        cache[id] = result
        return result
      })
    })

    Object.keys(dynamicAttributes).forEach(function (attribute) {
      var dyn = dynamicAttributes[attribute]

      function appendAttributeCode (env, block) {
        var VALUE = env.invoke(block, dyn)

        var shared = env.shared
        var constants = env.constants

        var IS_BUFFER_ARGS = shared.isBufferArgs
        var BUFFER_STATE = shared.buffer

        // Perform validation on attribute
        check$1.optional(function () {
          env.assert(block,
            VALUE + '&&(typeof ' + VALUE + '==="object"||typeof ' +
            VALUE + '==="function")&&(' +
            IS_BUFFER_ARGS + '(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + '.buffer)||' +
            IS_BUFFER_ARGS + '(' + VALUE + '.buffer)||' +
            '("constant" in ' + VALUE +
            '&&(typeof ' + VALUE + '.constant==="number"||' +
            shared.isArrayLike + '(' + VALUE + '.constant))))',
            'invalid dynamic attribute "' + attribute + '"')
        })

        // allocate names for result
        var result = {
          isStream: block.def(false)
        }
        var defaultRecord = new AttributeRecord()
        defaultRecord.state = ATTRIB_STATE_POINTER
        Object.keys(defaultRecord).forEach(function (key) {
          result[key] = block.def('' + defaultRecord[key])
        })

        var BUFFER = result.buffer
        var TYPE = result.type
        block(
          'if(', IS_BUFFER_ARGS, '(', VALUE, ')){',
          result.isStream, '=true;',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, ');',
          TYPE, '=', BUFFER, '.dtype;',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, ');',
          'if(', BUFFER, '){',
          TYPE, '=', BUFFER, '.dtype;',
          '}else if("constant" in ', VALUE, '){',
          result.state, '=', ATTRIB_STATE_CONSTANT, ';',
          'if(typeof ' + VALUE + '.constant === "number"){',
          result[CUTE_COMPONENTS[0]], '=', VALUE, '.constant;',
          CUTE_COMPONENTS.slice(1).map(function (n) {
            return result[n]
          }).join('='), '=0;',
          '}else{',
          CUTE_COMPONENTS.map(function (name, i) {
            return (
              result[name] + '=' + VALUE + '.constant.length>' + i +
              '?' + VALUE + '.constant[' + i + ']:0;'
            )
          }).join(''),
          '}}else{',
          'if(', IS_BUFFER_ARGS, '(', VALUE, '.buffer)){',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, '.buffer);',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, '.buffer);',
          '}',
          TYPE, '="type" in ', VALUE, '?',
          constants.glTypes, '[', VALUE, '.type]:', BUFFER, '.dtype;',
          result.normalized, '=!!', VALUE, '.normalized;')
        function emitReadRecord (name) {
          block(result[name], '=', VALUE, '.', name, '|0;')
        }
        emitReadRecord('size')
        emitReadRecord('offset')
        emitReadRecord('stride')
        emitReadRecord('divisor')

        block('}}')

        block.exit(
          'if(', result.isStream, '){',
          BUFFER_STATE, '.destroyStream(', BUFFER, ');',
          '}')

        return result
      }

      attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode)
    })

    return attributeDefs
  }

  function parseContext (context) {
    var staticContext = context.static
    var dynamicContext = context.dynamic
    var result = {}

    Object.keys(staticContext).forEach(function (name) {
      var value = staticContext[name]
      result[name] = createStaticDecl(function (env, scope) {
        if (typeof value === 'number' || typeof value === 'boolean') {
          return '' + value
        } else {
          return env.link(value)
        }
      })
    })

    Object.keys(dynamicContext).forEach(function (name) {
      var dyn = dynamicContext[name]
      result[name] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    })

    return result
  }

  function parseArguments (options, attributes, uniforms, context, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    check$1.optional(function () {
      var KEY_NAMES = [
        S_FRAMEBUFFER,
        S_VERT,
        S_FRAG,
        S_ELEMENTS,
        S_PRIMITIVE,
        S_OFFSET,
        S_COUNT,
        S_INSTANCES,
        S_PROFILE,
        S_VAO
      ].concat(GL_STATE_NAMES)

      function checkKeys (dict) {
        Object.keys(dict).forEach(function (key) {
          check$1.command(
            KEY_NAMES.indexOf(key) >= 0,
            'unknown parameter "' + key + '"',
            env.commandStr)
        })
      }

      checkKeys(staticOptions)
      checkKeys(dynamicOptions)
    })

    var attribLocations = parseAttribLocations(options, attributes)

    var framebuffer = parseFramebuffer(options, env)
    var viewportAndScissor = parseViewportScissor(options, framebuffer, env)
    var draw = parseDraw(options, env)
    var state = parseGLState(options, env)
    var shader = parseProgram(options, env, attribLocations)

    function copyBox (name) {
      var defn = viewportAndScissor[name]
      if (defn) {
        state[name] = defn
      }
    }
    copyBox(S_VIEWPORT)
    copyBox(propName(S_SCISSOR_BOX))

    var dirty = Object.keys(state).length > 0

    var result = {
      framebuffer: framebuffer,
      draw: draw,
      shader: shader,
      state: state,
      dirty: dirty,
      scopeVAO: null,
      drawVAO: null,
      useVAO: false,
      attributes: {}
    }

    result.profile = parseProfile(options, env)
    result.uniforms = parseUniforms(uniforms, env)
    result.drawVAO = result.scopeVAO = draw.vao
    // special case: check if we can statically allocate a vertex array object for this program
    if (!result.drawVAO &&
      shader.program &&
      !attribLocations &&
      extensions.angle_instanced_arrays &&
      draw.static.elements) {
      var useVAO = true
      var staticBindings = shader.program.attributes.map(function (attr) {
        var binding = attributes.static[attr]
        useVAO = useVAO && !!binding
        return binding
      })
      if (useVAO && staticBindings.length > 0) {
        var vao = attributeState.getVAO(attributeState.createVAO({
          attributes: staticBindings,
          elements: draw.static.elements
        }))
        result.drawVAO = new Declaration(null, null, null, function (env, scope) {
          return env.link(vao)
        })
        result.useVAO = true
      }
    }
    if (attribLocations) {
      result.useVAO = true
    } else {
      result.attributes = parseAttributes(attributes, env)
    }
    result.context = parseContext(context, env)
    return result
  }

  // ===================================================
  // ===================================================
  // COMMON UPDATE FUNCTIONS
  // ===================================================
  // ===================================================
  function emitContext (env, scope, context) {
    var shared = env.shared
    var CONTEXT = shared.context

    var contextEnter = env.scope()

    Object.keys(context).forEach(function (name) {
      scope.save(CONTEXT, '.' + name)
      var defn = context[name]
      var value = defn.append(env, scope)
      if (Array.isArray(value)) {
        contextEnter(CONTEXT, '.', name, '=[', value.join(), '];')
      } else {
        contextEnter(CONTEXT, '.', name, '=', value, ';')
      }
    })

    scope(contextEnter)
  }

  // ===================================================
  // ===================================================
  // COMMON DRAWING FUNCTIONS
  // ===================================================
  // ===================================================
  function emitPollFramebuffer (env, scope, framebuffer, skipCheck) {
    var shared = env.shared

    var GL = shared.gl
    var FRAMEBUFFER_STATE = shared.framebuffer
    var EXT_DRAW_BUFFERS
    if (extDrawBuffers) {
      EXT_DRAW_BUFFERS = scope.def(shared.extensions, '.webgl_draw_buffers')
    }

    var constants = env.constants

    var DRAW_BUFFERS = constants.drawBuffer
    var BACK_BUFFER = constants.backBuffer

    var NEXT
    if (framebuffer) {
      NEXT = framebuffer.append(env, scope)
    } else {
      NEXT = scope.def(FRAMEBUFFER_STATE, '.next')
    }

    if (!skipCheck) {
      scope('if(', NEXT, '!==', FRAMEBUFFER_STATE, '.cur){')
    }
    scope(
      'if(', NEXT, '){',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',', NEXT, '.framebuffer);')
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(',
        DRAW_BUFFERS, '[', NEXT, '.colorAttachments.length]);')
    }
    scope('}else{',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',null);')
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', BACK_BUFFER, ');')
    }
    scope(
      '}',
      FRAMEBUFFER_STATE, '.cur=', NEXT, ';')
    if (!skipCheck) {
      scope('}')
    }
  }

  function emitPollState (env, scope, args) {
    var shared = env.shared

    var GL = shared.gl

    var CURRENT_VARS = env.current
    var NEXT_VARS = env.next
    var CURRENT_STATE = shared.current
    var NEXT_STATE = shared.next

    var block = env.cond(CURRENT_STATE, '.dirty')

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop)
      if (param in args.state) {
        return
      }

      var NEXT, CURRENT
      if (param in NEXT_VARS) {
        NEXT = NEXT_VARS[param]
        CURRENT = CURRENT_VARS[param]
        var parts = loop(currentState[param].length, function (i) {
          return block.def(NEXT, '[', i, ']')
        })
        block(env.cond(parts.map(function (p, i) {
          return p + '!==' + CURRENT + '[' + i + ']'
        }).join('||'))
          .then(
            GL, '.', GL_VARIABLES[param], '(', parts, ');',
            parts.map(function (p, i) {
              return CURRENT + '[' + i + ']=' + p
            }).join(';'), ';'))
      } else {
        NEXT = block.def(NEXT_STATE, '.', param)
        var ifte = env.cond(NEXT, '!==', CURRENT_STATE, '.', param)
        block(ifte)
        if (param in GL_FLAGS) {
          ifte(
            env.cond(NEXT)
              .then(GL, '.enable(', GL_FLAGS[param], ');')
              .else(GL, '.disable(', GL_FLAGS[param], ');'),
            CURRENT_STATE, '.', param, '=', NEXT, ';')
        } else {
          ifte(
            GL, '.', GL_VARIABLES[param], '(', NEXT, ');',
            CURRENT_STATE, '.', param, '=', NEXT, ';')
        }
      }
    })
    if (Object.keys(args.state).length === 0) {
      block(CURRENT_STATE, '.dirty=false;')
    }
    scope(block)
  }

  function emitSetOptions (env, scope, options, filter) {
    var shared = env.shared
    var CURRENT_VARS = env.current
    var CURRENT_STATE = shared.current
    var GL = shared.gl
    sortState(Object.keys(options)).forEach(function (param) {
      var defn = options[param]
      if (filter && !filter(defn)) {
        return
      }
      var variable = defn.append(env, scope)
      if (GL_FLAGS[param]) {
        var flag = GL_FLAGS[param]
        if (isStatic(defn)) {
          if (variable) {
            scope(GL, '.enable(', flag, ');')
          } else {
            scope(GL, '.disable(', flag, ');')
          }
        } else {
          scope(env.cond(variable)
            .then(GL, '.enable(', flag, ');')
            .else(GL, '.disable(', flag, ');'))
        }
        scope(CURRENT_STATE, '.', param, '=', variable, ';')
      } else if (isArrayLike(variable)) {
        var CURRENT = CURRENT_VARS[param]
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          variable.map(function (v, i) {
            return CURRENT + '[' + i + ']=' + v
          }).join(';'), ';')
      } else {
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          CURRENT_STATE, '.', param, '=', variable, ';')
      }
    })
  }

  function injectExtensions (env, scope) {
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays')
    }
  }

  function emitProfile (env, scope, args, useScope, incrementCounter) {
    var shared = env.shared
    var STATS = env.stats
    var CURRENT_STATE = shared.current
    var TIMER = shared.timer
    var profileArg = args.profile

    function perfCounter () {
      if (typeof performance === 'undefined') {
        return 'Date.now()'
      } else {
        return 'performance.now()'
      }
    }

    var CPU_START, QUERY_COUNTER
    function emitProfileStart (block) {
      CPU_START = scope.def()
      block(CPU_START, '=', perfCounter(), ';')
      if (typeof incrementCounter === 'string') {
        block(STATS, '.count+=', incrementCounter, ';')
      } else {
        block(STATS, '.count++;')
      }
      if (timer) {
        if (useScope) {
          QUERY_COUNTER = scope.def()
          block(QUERY_COUNTER, '=', TIMER, '.getNumPendingQueries();')
        } else {
          block(TIMER, '.beginQuery(', STATS, ');')
        }
      }
    }

    function emitProfileEnd (block) {
      block(STATS, '.cpuTime+=', perfCounter(), '-', CPU_START, ';')
      if (timer) {
        if (useScope) {
          block(TIMER, '.pushScopeStats(',
            QUERY_COUNTER, ',',
            TIMER, '.getNumPendingQueries(),',
            STATS, ');')
        } else {
          block(TIMER, '.endQuery();')
        }
      }
    }

    function scopeProfile (value) {
      var prev = scope.def(CURRENT_STATE, '.profile')
      scope(CURRENT_STATE, '.profile=', value, ';')
      scope.exit(CURRENT_STATE, '.profile=', prev, ';')
    }

    var USE_PROFILE
    if (profileArg) {
      if (isStatic(profileArg)) {
        if (profileArg.enable) {
          emitProfileStart(scope)
          emitProfileEnd(scope.exit)
          scopeProfile('true')
        } else {
          scopeProfile('false')
        }
        return
      }
      USE_PROFILE = profileArg.append(env, scope)
      scopeProfile(USE_PROFILE)
    } else {
      USE_PROFILE = scope.def(CURRENT_STATE, '.profile')
    }

    var start = env.block()
    emitProfileStart(start)
    scope('if(', USE_PROFILE, '){', start, '}')
    var end = env.block()
    emitProfileEnd(end)
    scope.exit('if(', USE_PROFILE, '){', end, '}')
  }

  function emitAttributes (env, scope, args, attributes, filter) {
    var shared = env.shared

    function typeLength (x) {
      switch (x) {
        case GL_FLOAT_VEC2:
        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          return 2
        case GL_FLOAT_VEC3:
        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          return 3
        case GL_FLOAT_VEC4:
        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          return 4
        default:
          return 1
      }
    }

    function emitBindAttribute (ATTRIBUTE, size, record) {
      var GL = shared.gl

      var LOCATION = scope.def(ATTRIBUTE, '.location')
      var BINDING = scope.def(shared.attributes, '[', LOCATION, ']')

      var STATE = record.state
      var BUFFER = record.buffer
      var CONST_COMPONENTS = [
        record.x,
        record.y,
        record.z,
        record.w
      ]

      var COMMON_KEYS = [
        'buffer',
        'normalized',
        'offset',
        'stride'
      ]

      function emitBuffer () {
        scope(
          'if(!', BINDING, '.buffer){',
          GL, '.enableVertexAttribArray(', LOCATION, ');}')

        var TYPE = record.type
        var SIZE
        if (!record.size) {
          SIZE = size
        } else {
          SIZE = scope.def(record.size, '||', size)
        }

        scope('if(',
          BINDING, '.type!==', TYPE, '||',
          BINDING, '.size!==', SIZE, '||',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '!==' + record[key]
          }).join('||'),
          '){',
          GL, '.bindBuffer(', GL_ARRAY_BUFFER$2, ',', BUFFER, '.buffer);',
          GL, '.vertexAttribPointer(', [
            LOCATION,
            SIZE,
            TYPE,
            record.normalized,
            record.stride,
            record.offset
          ], ');',
          BINDING, '.type=', TYPE, ';',
          BINDING, '.size=', SIZE, ';',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '=' + record[key] + ';'
          }).join(''),
          '}')

        if (extInstancing) {
          var DIVISOR = record.divisor
          scope(
            'if(', BINDING, '.divisor!==', DIVISOR, '){',
            env.instancing, '.vertexAttribDivisorANGLE(', [LOCATION, DIVISOR], ');',
            BINDING, '.divisor=', DIVISOR, ';}')
        }
      }

      function emitConstant () {
        scope(
          'if(', BINDING, '.buffer){',
          GL, '.disableVertexAttribArray(', LOCATION, ');',
          BINDING, '.buffer=null;',
          '}if(', CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '!==' + CONST_COMPONENTS[i]
          }).join('||'), '){',
          GL, '.vertexAttrib4f(', LOCATION, ',', CONST_COMPONENTS, ');',
          CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '=' + CONST_COMPONENTS[i] + ';'
          }).join(''),
          '}')
      }

      if (STATE === ATTRIB_STATE_POINTER) {
        emitBuffer()
      } else if (STATE === ATTRIB_STATE_CONSTANT) {
        emitConstant()
      } else {
        scope('if(', STATE, '===', ATTRIB_STATE_POINTER, '){')
        emitBuffer()
        scope('}else{')
        emitConstant()
        scope('}')
      }
    }

    attributes.forEach(function (attribute) {
      var name = attribute.name
      var arg = args.attributes[name]
      var record
      if (arg) {
        if (!filter(arg)) {
          return
        }
        record = arg.append(env, scope)
      } else {
        if (!filter(SCOPE_DECL)) {
          return
        }
        var scopeAttrib = env.scopeAttrib(name)
        check$1.optional(function () {
          env.assert(scope,
            scopeAttrib + '.state',
            'missing attribute ' + name)
        })
        record = {}
        Object.keys(new AttributeRecord()).forEach(function (key) {
          record[key] = scope.def(scopeAttrib, '.', key)
        })
      }
      emitBindAttribute(
        env.link(attribute), typeLength(attribute.info.type), record)
    })
  }

  function emitUniforms (env, scope, args, uniforms, filter, isBatchInnerLoop) {
    var shared = env.shared
    var GL = shared.gl

    var definedArrUniforms = {}
    var infix
    for (var i = 0; i < uniforms.length; ++i) {
      var uniform = uniforms[i]
      var name = uniform.name
      var type = uniform.info.type
      var size = uniform.info.size
      var arg = args.uniforms[name]
      if (size > 1) {
        // either foo[n] or foos, avoid define both
        if (!arg) {
          continue
        }
        var arrUniformName = name.replace('[0]', '')
        if (definedArrUniforms[arrUniformName]) {
          continue
        }
        definedArrUniforms[arrUniformName] = 1
      }
      var UNIFORM = env.link(uniform)
      var LOCATION = UNIFORM + '.location'

      var VALUE
      if (arg) {
        if (!filter(arg)) {
          continue
        }
        if (isStatic(arg)) {
          var value = arg.value
          check$1.command(
            value !== null && typeof value !== 'undefined',
            'missing uniform "' + name + '"', env.commandStr)
          if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
            check$1.command(
              typeof value === 'function' &&
              ((type === GL_SAMPLER_2D &&
                (value._reglType === 'texture2d' ||
                value._reglType === 'framebuffer')) ||
              (type === GL_SAMPLER_CUBE &&
                (value._reglType === 'textureCube' ||
                value._reglType === 'framebufferCube'))),
              'invalid texture for uniform ' + name, env.commandStr)
            var TEX_VALUE = env.link(value._texture || value.color[0]._texture)
            scope(GL, '.uniform1i(', LOCATION, ',', TEX_VALUE + '.bind());')
            scope.exit(TEX_VALUE, '.unbind();')
          } else if (
            type === GL_FLOAT_MAT2 ||
            type === GL_FLOAT_MAT3 ||
            type === GL_FLOAT_MAT4) {
            check$1.optional(function () {
              check$1.command(isArrayLike(value),
                'invalid matrix for uniform ' + name, env.commandStr)
              check$1.command(
                (type === GL_FLOAT_MAT2 && value.length === 4) ||
                (type === GL_FLOAT_MAT3 && value.length === 9) ||
                (type === GL_FLOAT_MAT4 && value.length === 16),
                'invalid length for matrix uniform ' + name, env.commandStr)
            })
            var MAT_VALUE = env.global.def('new Float32Array([' +
              Array.prototype.slice.call(value) + '])')
            var dim = 2
            if (type === GL_FLOAT_MAT3) {
              dim = 3
            } else if (type === GL_FLOAT_MAT4) {
              dim = 4
            }
            scope(
              GL, '.uniformMatrix', dim, 'fv(',
              LOCATION, ',false,', MAT_VALUE, ');')
          } else {
            switch (type) {
              case GL_FLOAT$8:
                if (size === 1) {
                  check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr)
                } else {
                  check$1.command(
                    isArrayLike(value) && (value.length === size),
                    'uniform ' + name, env.commandStr)
                }
                infix = '1f'
                break
              case GL_FLOAT_VEC2:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2),
                  'uniform ' + name, env.commandStr)
                infix = '2f'
                break
              case GL_FLOAT_VEC3:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3),
                  'uniform ' + name, env.commandStr)
                infix = '3f'
                break
              case GL_FLOAT_VEC4:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4),
                  'uniform ' + name, env.commandStr)
                infix = '4f'
                break
              case GL_BOOL:
                if (size === 1) {
                  check$1.commandType(value, 'boolean', 'uniform ' + name, env.commandStr)
                } else {
                  check$1.command(
                    isArrayLike(value) && (value.length === size),
                    'uniform ' + name, env.commandStr)
                }
                infix = '1i'
                break
              case GL_INT$3:
                if (size === 1) {
                  check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr)
                } else {
                  check$1.command(
                    isArrayLike(value) && (value.length === size),
                    'uniform ' + name, env.commandStr)
                }
                infix = '1i'
                break
              case GL_BOOL_VEC2:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2),
                  'uniform ' + name, env.commandStr)
                infix = '2i'
                break
              case GL_INT_VEC2:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2),
                  'uniform ' + name, env.commandStr)
                infix = '2i'
                break
              case GL_BOOL_VEC3:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3),
                  'uniform ' + name, env.commandStr)
                infix = '3i'
                break
              case GL_INT_VEC3:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3),
                  'uniform ' + name, env.commandStr)
                infix = '3i'
                break
              case GL_BOOL_VEC4:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4),
                  'uniform ' + name, env.commandStr)
                infix = '4i'
                break
              case GL_INT_VEC4:
                check$1.command(
                  isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4),
                  'uniform ' + name, env.commandStr)
                infix = '4i'
                break
            }
            if (size > 1) {
              infix += 'v'
              value = env.global.def('[' +
              Array.prototype.slice.call(value) + ']')
            } else {
              value = isArrayLike(value) ? Array.prototype.slice.call(value) : value
            }
            scope(GL, '.uniform', infix, '(', LOCATION, ',',
              value,
              ');')
          }
          continue
        } else {
          VALUE = arg.append(env, scope)
        }
      } else {
        if (!filter(SCOPE_DECL)) {
          continue
        }
        VALUE = scope.def(shared.uniforms, '[', stringStore.id(name), ']')
      }

      if (type === GL_SAMPLER_2D) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for textures')
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebuffer"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
      } else if (type === GL_SAMPLER_CUBE) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for cube maps')
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebufferCube"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
      }

      // perform type validation
      check$1.optional(function () {
        function emitCheck (pred, message) {
          env.assert(scope, pred,
            'bad data or missing for uniform "' + name + '".  ' + message)
        }

        function checkType (type, size) {
          if (size === 1) {
            check$1(!Array.isArray(VALUE), 'must not specify an array type for uniform')
          }
          emitCheck(
            'Array.isArray(' + VALUE + ') && typeof ' + VALUE + '[0]===" ' + type + '"' +
            ' || typeof ' + VALUE + '==="' + type + '"',
            'invalid type, expected ' + type)
        }

        function checkVector (n, type, size) {
          if (Array.isArray(VALUE)) {
            check$1(VALUE.length && VALUE.length % n === 0 && VALUE.length <= n * size, 'must have length of ' + (size === 1 ? '' : 'n * ') + n)
          } else {
            emitCheck(
              shared.isArrayLike + '(' + VALUE + ')&&' + VALUE + '.length && ' + VALUE + '.length % ' + n + ' === 0' +
              ' && ' + VALUE + '.length<=' + n * size,
              'invalid vector, should have length of ' + (size === 1 ? '' : 'n * ') + n, env.commandStr)
          }
        }

        function checkTexture (target) {
          check$1(!Array.isArray(VALUE), 'must not specify a value type')
          emitCheck(
            'typeof ' + VALUE + '==="function"&&' +
            VALUE + '._reglType==="texture' +
            (target === GL_TEXTURE_2D$3 ? '2d' : 'Cube') + '"',
            'invalid texture type', env.commandStr)
        }

        switch (type) {
          case GL_INT$3:
            checkType('number', size)
            break
          case GL_INT_VEC2:
            checkVector(2, 'number', size)
            break
          case GL_INT_VEC3:
            checkVector(3, 'number', size)
            break
          case GL_INT_VEC4:
            checkVector(4, 'number', size)
            break
          case GL_FLOAT$8:
            checkType('number', size)
            break
          case GL_FLOAT_VEC2:
            checkVector(2, 'number', size)
            break
          case GL_FLOAT_VEC3:
            checkVector(3, 'number', size)
            break
          case GL_FLOAT_VEC4:
            checkVector(4, 'number', size)
            break
          case GL_BOOL:
            checkType('boolean', size)
            break
          case GL_BOOL_VEC2:
            checkVector(2, 'boolean', size)
            break
          case GL_BOOL_VEC3:
            checkVector(3, 'boolean', size)
            break
          case GL_BOOL_VEC4:
            checkVector(4, 'boolean', size)
            break
          case GL_FLOAT_MAT2:
            checkVector(4, 'number', size)
            break
          case GL_FLOAT_MAT3:
            checkVector(9, 'number', size)
            break
          case GL_FLOAT_MAT4:
            checkVector(16, 'number', size)
            break
          case GL_SAMPLER_2D:
            checkTexture(GL_TEXTURE_2D$3)
            break
          case GL_SAMPLER_CUBE:
            checkTexture(GL_TEXTURE_CUBE_MAP$2)
            break
        }
      })

      var unroll = 1
      switch (type) {
        case GL_SAMPLER_2D:
        case GL_SAMPLER_CUBE:
          var TEX = scope.def(VALUE, '._texture')
          scope(GL, '.uniform1i(', LOCATION, ',', TEX, '.bind());')
          scope.exit(TEX, '.unbind();')
          continue

        case GL_INT$3:
        case GL_BOOL:
          infix = '1i'
          break

        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          infix = '2i'
          unroll = 2
          break

        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          infix = '3i'
          unroll = 3
          break

        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          infix = '4i'
          unroll = 4
          break

        case GL_FLOAT$8:
          infix = '1f'
          break

        case GL_FLOAT_VEC2:
          infix = '2f'
          unroll = 2
          break

        case GL_FLOAT_VEC3:
          infix = '3f'
          unroll = 3
          break

        case GL_FLOAT_VEC4:
          infix = '4f'
          unroll = 4
          break

        case GL_FLOAT_MAT2:
          infix = 'Matrix2fv'
          break

        case GL_FLOAT_MAT3:
          infix = 'Matrix3fv'
          break

        case GL_FLOAT_MAT4:
          infix = 'Matrix4fv'
          break
      }

      if (infix.indexOf('Matrix') === -1 && size > 1) {
        infix += 'v'
        unroll = 1
      }

      if (infix.charAt(0) === 'M') {
        scope(GL, '.uniform', infix, '(', LOCATION, ',')
        var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2)
        var STORAGE = env.global.def('new Float32Array(', matSize, ')')
        if (Array.isArray(VALUE)) {
          scope(
            'false,(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE[i]
            }), ',', STORAGE, ')')
        } else {
          scope(
            'false,(Array.isArray(', VALUE, ')||', VALUE, ' instanceof Float32Array)?', VALUE, ':(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']'
            }), ',', STORAGE, ')')
        }
        scope(');')
      } else if (unroll > 1) {
        var prev = []
        var cur = []
        for (var j = 0; j < unroll; ++j) {
          if (Array.isArray(VALUE)) {
            cur.push(VALUE[j])
          } else {
            cur.push(scope.def(VALUE + '[' + j + ']'))
          }
          if (isBatchInnerLoop) {
            prev.push(scope.def())
          }
        }
        if (isBatchInnerLoop) {
          scope('if(!', env.batchId, '||', prev.map(function (p, i) {
            return p + '!==' + cur[i]
          }).join('||'), '){', prev.map(function (p, i) {
            return p + '=' + cur[i] + ';'
          }).join(''))
        }
        scope(GL, '.uniform', infix, '(', LOCATION, ',', cur.join(','), ');')
        if (isBatchInnerLoop) {
          scope('}')
        }
      } else {
        check$1(!Array.isArray(VALUE), 'uniform value must not be an array')
        if (isBatchInnerLoop) {
          var prevS = scope.def()
          scope('if(!', env.batchId, '||', prevS, '!==', VALUE, '){',
            prevS, '=', VALUE, ';')
        }
        scope(GL, '.uniform', infix, '(', LOCATION, ',', VALUE, ');')
        if (isBatchInnerLoop) {
          scope('}')
        }
      }
    }
  }

  function emitDraw (env, outer, inner, args) {
    var shared = env.shared
    var GL = shared.gl
    var DRAW_STATE = shared.draw

    var drawOptions = args.draw

    function emitElements () {
      var defn = drawOptions.elements
      var ELEMENTS
      var scope = outer
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner
        }
        ELEMENTS = defn.append(env, scope)
        if (drawOptions.elementsActive) {
          scope(
            'if(' + ELEMENTS + ')' +
            GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$2 + ',' + ELEMENTS + '.buffer.buffer);')
        }
      } else {
        ELEMENTS = scope.def()
        scope(
          ELEMENTS, '=', DRAW_STATE, '.', S_ELEMENTS, ';',
          'if(', ELEMENTS, '){',
          GL, '.bindBuffer(', GL_ELEMENT_ARRAY_BUFFER$2, ',', ELEMENTS, '.buffer.buffer);}',
          'else if(', shared.vao, '.currentVAO){',
          ELEMENTS, '=', env.shared.elements + '.getElements(' + shared.vao, '.currentVAO.elements);',
          (!extVertexArrays ? 'if(' + ELEMENTS + ')' + GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$2 + ',' + ELEMENTS + '.buffer.buffer);' : ''),
          '}')
      }
      return ELEMENTS
    }

    function emitCount () {
      var defn = drawOptions.count
      var COUNT
      var scope = outer
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner
        }
        COUNT = defn.append(env, scope)
        check$1.optional(function () {
          if (defn.MISSING) {
            env.assert(outer, 'false', 'missing vertex count')
          }
          if (defn.DYNAMIC) {
            env.assert(scope, COUNT + '>=0', 'missing vertex count')
          }
        })
      } else {
        COUNT = scope.def(DRAW_STATE, '.', S_COUNT)
        check$1.optional(function () {
          env.assert(scope, COUNT + '>=0', 'missing vertex count')
        })
      }
      return COUNT
    }

    var ELEMENTS = emitElements()
    function emitValue (name) {
      var defn = drawOptions[name]
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          return defn.append(env, inner)
        } else {
          return defn.append(env, outer)
        }
      } else {
        return outer.def(DRAW_STATE, '.', name)
      }
    }

    var PRIMITIVE = emitValue(S_PRIMITIVE)
    var OFFSET = emitValue(S_OFFSET)

    var COUNT = emitCount()
    if (typeof COUNT === 'number') {
      if (COUNT === 0) {
        return
      }
    } else {
      inner('if(', COUNT, '){')
      inner.exit('}')
    }

    var INSTANCES, EXT_INSTANCING
    if (extInstancing) {
      INSTANCES = emitValue(S_INSTANCES)
      EXT_INSTANCING = env.instancing
    }

    var ELEMENT_TYPE = ELEMENTS + '.type'

    var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements) && !drawOptions.vaoActive

    function emitInstancing () {
      function drawElements () {
        inner(EXT_INSTANCING, '.drawElementsInstancedANGLE(', [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)',
          INSTANCES
        ], ');')
      }

      function drawArrays () {
        inner(EXT_INSTANCING, '.drawArraysInstancedANGLE(',
          [PRIMITIVE, OFFSET, COUNT, INSTANCES], ');')
      }

      if (ELEMENTS && ELEMENTS !== 'null') {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){')
          drawElements()
          inner('}else{')
          drawArrays()
          inner('}')
        } else {
          drawElements()
        }
      } else {
        drawArrays()
      }
    }

    function emitRegular () {
      function drawElements () {
        inner(GL + '.drawElements(' + [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)'
        ] + ');')
      }

      function drawArrays () {
        inner(GL + '.drawArrays(' + [PRIMITIVE, OFFSET, COUNT] + ');')
      }

      if (ELEMENTS && ELEMENTS !== 'null') {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){')
          drawElements()
          inner('}else{')
          drawArrays()
          inner('}')
        } else {
          drawElements()
        }
      } else {
        drawArrays()
      }
    }

    if (extInstancing && (typeof INSTANCES !== 'number' || INSTANCES >= 0)) {
      if (typeof INSTANCES === 'string') {
        inner('if(', INSTANCES, '>0){')
        emitInstancing()
        inner('}else if(', INSTANCES, '<0){')
        emitRegular()
        inner('}')
      } else {
        emitInstancing()
      }
    } else {
      emitRegular()
    }
  }

  function createBody (emitBody, parentEnv, args, program, count) {
    var env = createREGLEnvironment()
    var scope = env.proc('body', count)
    check$1.optional(function () {
      env.commandStr = parentEnv.commandStr
      env.command = env.link(parentEnv.commandStr)
    })
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays')
    }
    emitBody(env, scope, args, program)
    return env.compile().body
  }

  // ===================================================
  // ===================================================
  // DRAW PROC
  // ===================================================
  // ===================================================
  function emitDrawBody (env, draw, args, program) {
    injectExtensions(env, draw)
    if (args.useVAO) {
      if (args.drawVAO) {
        draw(env.shared.vao, '.setVAO(', args.drawVAO.append(env, draw), ');')
      } else {
        draw(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')
      }
    } else {
      draw(env.shared.vao, '.setVAO(null);')
      emitAttributes(env, draw, args, program.attributes, function () {
        return true
      })
    }
    emitUniforms(env, draw, args, program.uniforms, function () {
      return true
    }, false)
    emitDraw(env, draw, draw, args)
  }

  function emitDrawProc (env, args) {
    var draw = env.proc('draw', 1)

    injectExtensions(env, draw)

    emitContext(env, draw, args.context)
    emitPollFramebuffer(env, draw, args.framebuffer)

    emitPollState(env, draw, args)
    emitSetOptions(env, draw, args.state)

    emitProfile(env, draw, args, false, true)

    var program = args.shader.progVar.append(env, draw)
    draw(env.shared.gl, '.useProgram(', program, '.program);')

    if (args.shader.program) {
      emitDrawBody(env, draw, args, args.shader.program)
    } else {
      draw(env.shared.vao, '.setVAO(null);')
      var drawCache = env.global.def('{}')
      var PROG_ID = draw.def(program, '.id')
      var CACHED_PROC = draw.def(drawCache, '[', PROG_ID, ']')
      draw(
        env.cond(CACHED_PROC)
          .then(CACHED_PROC, '.call(this,a0);')
          .else(
            CACHED_PROC, '=', drawCache, '[', PROG_ID, ']=',
            env.link(function (program) {
              return createBody(emitDrawBody, env, args, program, 1)
            }), '(', program, ');',
            CACHED_PROC, '.call(this,a0);'))
    }

    if (Object.keys(args.state).length > 0) {
      draw(env.shared.current, '.dirty=true;')
    }
    if (env.shared.vao) {
      draw(env.shared.vao, '.setVAO(null);')
    }
  }

  // ===================================================
  // ===================================================
  // BATCH PROC
  // ===================================================
  // ===================================================

  function emitBatchDynamicShaderBody (env, scope, args, program) {
    env.batchId = 'a1'

    injectExtensions(env, scope)

    function all () {
      return true
    }

    emitAttributes(env, scope, args, program.attributes, all)
    emitUniforms(env, scope, args, program.uniforms, all, false)
    emitDraw(env, scope, scope, args)
  }

  function emitBatchBody (env, scope, args, program) {
    injectExtensions(env, scope)

    var contextDynamic = args.contextDep

    var BATCH_ID = scope.def()
    var PROP_LIST = 'a0'
    var NUM_PROPS = 'a1'
    var PROPS = scope.def()
    env.shared.props = PROPS
    env.batchId = BATCH_ID

    var outer = env.scope()
    var inner = env.scope()

    scope(
      outer.entry,
      'for(', BATCH_ID, '=0;', BATCH_ID, '<', NUM_PROPS, ';++', BATCH_ID, '){',
      PROPS, '=', PROP_LIST, '[', BATCH_ID, '];',
      inner,
      '}',
      outer.exit)

    function isInnerDefn (defn) {
      return ((defn.contextDep && contextDynamic) || defn.propDep)
    }

    function isOuterDefn (defn) {
      return !isInnerDefn(defn)
    }

    if (args.needsContext) {
      emitContext(env, inner, args.context)
    }
    if (args.needsFramebuffer) {
      emitPollFramebuffer(env, inner, args.framebuffer)
    }
    emitSetOptions(env, inner, args.state, isInnerDefn)

    if (args.profile && isInnerDefn(args.profile)) {
      emitProfile(env, inner, args, false, true)
    }

    if (!program) {
      var progCache = env.global.def('{}')
      var PROGRAM = args.shader.progVar.append(env, inner)
      var PROG_ID = inner.def(PROGRAM, '.id')
      var CACHED_PROC = inner.def(progCache, '[', PROG_ID, ']')
      inner(
        env.shared.gl, '.useProgram(', PROGRAM, '.program);',
        'if(!', CACHED_PROC, '){',
        CACHED_PROC, '=', progCache, '[', PROG_ID, ']=',
        env.link(function (program) {
          return createBody(
            emitBatchDynamicShaderBody, env, args, program, 2)
        }), '(', PROGRAM, ');}',
        CACHED_PROC, '.call(this,a0[', BATCH_ID, '],', BATCH_ID, ');')
    } else {
      if (args.useVAO) {
        if (args.drawVAO) {
          if (isInnerDefn(args.drawVAO)) {
            // vao is a prop
            inner(env.shared.vao, '.setVAO(', args.drawVAO.append(env, inner), ');')
          } else {
            // vao is invariant
            outer(env.shared.vao, '.setVAO(', args.drawVAO.append(env, outer), ');')
          }
        } else {
          // scoped vao binding
          outer(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')
        }
      } else {
        outer(env.shared.vao, '.setVAO(null);')
        emitAttributes(env, outer, args, program.attributes, isOuterDefn)
        emitAttributes(env, inner, args, program.attributes, isInnerDefn)
      }
      emitUniforms(env, outer, args, program.uniforms, isOuterDefn, false)
      emitUniforms(env, inner, args, program.uniforms, isInnerDefn, true)
      emitDraw(env, outer, inner, args)
    }
  }

  function emitBatchProc (env, args) {
    var batch = env.proc('batch', 2)
    env.batchId = '0'

    injectExtensions(env, batch)

    // Check if any context variables depend on props
    var contextDynamic = false
    var needsContext = true
    Object.keys(args.context).forEach(function (name) {
      contextDynamic = contextDynamic || args.context[name].propDep
    })
    if (!contextDynamic) {
      emitContext(env, batch, args.context)
      needsContext = false
    }

    // framebuffer state affects framebufferWidth/height context vars
    var framebuffer = args.framebuffer
    var needsFramebuffer = false
    if (framebuffer) {
      if (framebuffer.propDep) {
        contextDynamic = needsFramebuffer = true
      } else if (framebuffer.contextDep && contextDynamic) {
        needsFramebuffer = true
      }
      if (!needsFramebuffer) {
        emitPollFramebuffer(env, batch, framebuffer)
      }
    } else {
      emitPollFramebuffer(env, batch, null)
    }

    // viewport is weird because it can affect context vars
    if (args.state.viewport && args.state.viewport.propDep) {
      contextDynamic = true
    }

    function isInnerDefn (defn) {
      return (defn.contextDep && contextDynamic) || defn.propDep
    }

    // set webgl options
    emitPollState(env, batch, args)
    emitSetOptions(env, batch, args.state, function (defn) {
      return !isInnerDefn(defn)
    })

    if (!args.profile || !isInnerDefn(args.profile)) {
      emitProfile(env, batch, args, false, 'a1')
    }

    // Save these values to args so that the batch body routine can use them
    args.contextDep = contextDynamic
    args.needsContext = needsContext
    args.needsFramebuffer = needsFramebuffer

    // determine if shader is dynamic
    var progDefn = args.shader.progVar
    if ((progDefn.contextDep && contextDynamic) || progDefn.propDep) {
      emitBatchBody(
        env,
        batch,
        args,
        null)
    } else {
      var PROGRAM = progDefn.append(env, batch)
      batch(env.shared.gl, '.useProgram(', PROGRAM, '.program);')
      if (args.shader.program) {
        emitBatchBody(
          env,
          batch,
          args,
          args.shader.program)
      } else {
        batch(env.shared.vao, '.setVAO(null);')
        var batchCache = env.global.def('{}')
        var PROG_ID = batch.def(PROGRAM, '.id')
        var CACHED_PROC = batch.def(batchCache, '[', PROG_ID, ']')
        batch(
          env.cond(CACHED_PROC)
            .then(CACHED_PROC, '.call(this,a0,a1);')
            .else(
              CACHED_PROC, '=', batchCache, '[', PROG_ID, ']=',
              env.link(function (program) {
                return createBody(emitBatchBody, env, args, program, 2)
              }), '(', PROGRAM, ');',
              CACHED_PROC, '.call(this,a0,a1);'))
      }
    }

    if (Object.keys(args.state).length > 0) {
      batch(env.shared.current, '.dirty=true;')
    }

    if (env.shared.vao) {
      batch(env.shared.vao, '.setVAO(null);')
    }
  }

  // ===================================================
  // ===================================================
  // SCOPE COMMAND
  // ===================================================
  // ===================================================
  function emitScopeProc (env, args) {
    var scope = env.proc('scope', 3)
    env.batchId = 'a2'

    var shared = env.shared
    var CURRENT_STATE = shared.current

    emitContext(env, scope, args.context)

    if (args.framebuffer) {
      args.framebuffer.append(env, scope)
    }

    sortState(Object.keys(args.state)).forEach(function (name) {
      var defn = args.state[name]
      var value = defn.append(env, scope)
      if (isArrayLike(value)) {
        value.forEach(function (v, i) {
          scope.set(env.next[name], '[' + i + ']', v)
        })
      } else {
        scope.set(shared.next, '.' + name, value)
      }
    })

    emitProfile(env, scope, args, true, true)

    ;[S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(
      function (opt) {
        var variable = args.draw[opt]
        if (!variable) {
          return
        }
        scope.set(shared.draw, '.' + opt, '' + variable.append(env, scope))
      })

    Object.keys(args.uniforms).forEach(function (opt) {
      var value = args.uniforms[opt].append(env, scope)
      if (Array.isArray(value)) {
        value = '[' + value.join() + ']'
      }
      scope.set(
        shared.uniforms,
        '[' + stringStore.id(opt) + ']',
        value)
    })

    Object.keys(args.attributes).forEach(function (name) {
      var record = args.attributes[name].append(env, scope)
      var scopeAttrib = env.scopeAttrib(name)
      Object.keys(new AttributeRecord()).forEach(function (prop) {
        scope.set(scopeAttrib, '.' + prop, record[prop])
      })
    })

    if (args.scopeVAO) {
      scope.set(shared.vao, '.targetVAO', args.scopeVAO.append(env, scope))
    }

    function saveShader (name) {
      var shader = args.shader[name]
      if (shader) {
        scope.set(shared.shader, '.' + name, shader.append(env, scope))
      }
    }
    saveShader(S_VERT)
    saveShader(S_FRAG)

    if (Object.keys(args.state).length > 0) {
      scope(CURRENT_STATE, '.dirty=true;')
      scope.exit(CURRENT_STATE, '.dirty=true;')
    }

    scope('a1(', env.shared.context, ',a0,', env.batchId, ');')
  }

  function isDynamicObject (object) {
    if (typeof object !== 'object' || isArrayLike(object)) {
      return
    }
    var props = Object.keys(object)
    for (var i = 0; i < props.length; ++i) {
      if (dynamic.isDynamic(object[props[i]])) {
        return true
      }
    }
    return false
  }

  function splatObject (env, options, name) {
    var object = options.static[name]
    if (!object || !isDynamicObject(object)) {
      return
    }

    var globals = env.global
    var keys = Object.keys(object)
    var thisDep = false
    var contextDep = false
    var propDep = false
    var objectRef = env.global.def('{}')
    keys.forEach(function (key) {
      var value = object[key]
      if (dynamic.isDynamic(value)) {
        if (typeof value === 'function') {
          value = object[key] = dynamic.unbox(value)
        }
        var deps = createDynamicDecl(value, null)
        thisDep = thisDep || deps.thisDep
        propDep = propDep || deps.propDep
        contextDep = contextDep || deps.contextDep
      } else {
        globals(objectRef, '.', key, '=')
        switch (typeof value) {
          case 'number':
            globals(value)
            break
          case 'string':
            globals('"', value, '"')
            break
          case 'object':
            if (Array.isArray(value)) {
              globals('[', value.join(), ']')
            }
            break
          default:
            globals(env.link(value))
            break
        }
        globals(';')
      }
    })

    function appendBlock (env, block) {
      keys.forEach(function (key) {
        var value = object[key]
        if (!dynamic.isDynamic(value)) {
          return
        }
        var ref = env.invoke(block, value)
        block(objectRef, '.', key, '=', ref, ';')
      })
    }

    options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
      thisDep: thisDep,
      contextDep: contextDep,
      propDep: propDep,
      ref: objectRef,
      append: appendBlock
    })
    delete options.static[name]
  }

  // ===========================================================================
  // ===========================================================================
  // MAIN DRAW COMMAND
  // ===========================================================================
  // ===========================================================================
  function compileCommand (options, attributes, uniforms, context, stats) {
    var env = createREGLEnvironment()

    // link stats, so that we can easily access it in the program.
    env.stats = env.link(stats)

    // splat options and attributes to allow for dynamic nested properties
    Object.keys(attributes.static).forEach(function (key) {
      splatObject(env, attributes, key)
    })
    NESTED_OPTIONS.forEach(function (name) {
      splatObject(env, options, name)
    })

    var args = parseArguments(options, attributes, uniforms, context, env)

    emitDrawProc(env, args)
    emitScopeProc(env, args)
    emitBatchProc(env, args)

    return extend(env.compile(), {
      destroy: function () {
        args.shader.program.destroy()
      }
    })
  }

  // ===========================================================================
  // ===========================================================================
  // POLL / REFRESH
  // ===========================================================================
  // ===========================================================================
  return {
    next: nextState,
    current: currentState,
    procs: (function () {
      var env = createREGLEnvironment()
      var poll = env.proc('poll')
      var refresh = env.proc('refresh')
      var common = env.block()
      poll(common)
      refresh(common)

      var shared = env.shared
      var GL = shared.gl
      var NEXT_STATE = shared.next
      var CURRENT_STATE = shared.current

      common(CURRENT_STATE, '.dirty=false;')

      emitPollFramebuffer(env, poll)
      emitPollFramebuffer(env, refresh, null, true)

      // Refresh updates all attribute state changes
      var INSTANCING
      if (extInstancing) {
        INSTANCING = env.link(extInstancing)
      }

      // update vertex array bindings
      if (extensions.oes_vertex_array_object) {
        refresh(env.link(extensions.oes_vertex_array_object), '.bindVertexArrayOES(null);')
      }
      for (var i = 0; i < limits.maxAttributes; ++i) {
        var BINDING = refresh.def(shared.attributes, '[', i, ']')
        var ifte = env.cond(BINDING, '.buffer')
        ifte.then(
          GL, '.enableVertexAttribArray(', i, ');',
          GL, '.bindBuffer(',
          GL_ARRAY_BUFFER$2, ',',
          BINDING, '.buffer.buffer);',
          GL, '.vertexAttribPointer(',
          i, ',',
          BINDING, '.size,',
          BINDING, '.type,',
          BINDING, '.normalized,',
          BINDING, '.stride,',
          BINDING, '.offset);'
        ).else(
          GL, '.disableVertexAttribArray(', i, ');',
          GL, '.vertexAttrib4f(',
          i, ',',
          BINDING, '.x,',
          BINDING, '.y,',
          BINDING, '.z,',
          BINDING, '.w);',
          BINDING, '.buffer=null;')
        refresh(ifte)
        if (extInstancing) {
          refresh(
            INSTANCING, '.vertexAttribDivisorANGLE(',
            i, ',',
            BINDING, '.divisor);')
        }
      }
      refresh(
        env.shared.vao, '.currentVAO=null;',
        env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')

      Object.keys(GL_FLAGS).forEach(function (flag) {
        var cap = GL_FLAGS[flag]
        var NEXT = common.def(NEXT_STATE, '.', flag)
        var block = env.block()
        block('if(', NEXT, '){',
          GL, '.enable(', cap, ')}else{',
          GL, '.disable(', cap, ')}',
          CURRENT_STATE, '.', flag, '=', NEXT, ';')
        refresh(block)
        poll(
          'if(', NEXT, '!==', CURRENT_STATE, '.', flag, '){',
          block,
          '}')
      })

      Object.keys(GL_VARIABLES).forEach(function (name) {
        var func = GL_VARIABLES[name]
        var init = currentState[name]
        var NEXT, CURRENT
        var block = env.block()
        block(GL, '.', func, '(')
        if (isArrayLike(init)) {
          var n = init.length
          NEXT = env.global.def(NEXT_STATE, '.', name)
          CURRENT = env.global.def(CURRENT_STATE, '.', name)
          block(
            loop(n, function (i) {
              return NEXT + '[' + i + ']'
            }), ');',
            loop(n, function (i) {
              return CURRENT + '[' + i + ']=' + NEXT + '[' + i + '];'
            }).join(''))
          poll(
            'if(', loop(n, function (i) {
              return NEXT + '[' + i + ']!==' + CURRENT + '[' + i + ']'
            }).join('||'), '){',
            block,
            '}')
        } else {
          NEXT = common.def(NEXT_STATE, '.', name)
          CURRENT = common.def(CURRENT_STATE, '.', name)
          block(
            NEXT, ');',
            CURRENT_STATE, '.', name, '=', NEXT, ';')
          poll(
            'if(', NEXT, '!==', CURRENT, '){',
            block,
            '}')
        }
        refresh(block)
      })

      return env.compile()
    })(),
    compile: compileCommand
  }
}

function stats () {
  return {
    vaoCount: 0,
    bufferCount: 0,
    elementsCount: 0,
    framebufferCount: 0,
    shaderCount: 0,
    textureCount: 0,
    cubeCount: 0,
    renderbufferCount: 0,
    maxTextureUnits: 0
  }
}

var GL_QUERY_RESULT_EXT = 0x8866
var GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867
var GL_TIME_ELAPSED_EXT = 0x88BF

var createTimer = function (gl, extensions) {
  if (!extensions.ext_disjoint_timer_query) {
    return null
  }

  // QUERY POOL BEGIN
  var queryPool = []
  function allocQuery () {
    return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT()
  }
  function freeQuery (query) {
    queryPool.push(query)
  }
  // QUERY POOL END

  var pendingQueries = []
  function beginQuery (stats) {
    var query = allocQuery()
    extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query)
    pendingQueries.push(query)
    pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats)
  }

  function endQuery () {
    extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT)
  }

  //
  // Pending stats pool.
  //
  function PendingStats () {
    this.startQueryIndex = -1
    this.endQueryIndex = -1
    this.sum = 0
    this.stats = null
  }
  var pendingStatsPool = []
  function allocPendingStats () {
    return pendingStatsPool.pop() || new PendingStats()
  }
  function freePendingStats (pendingStats) {
    pendingStatsPool.push(pendingStats)
  }
  // Pending stats pool end

  var pendingStats = []
  function pushScopeStats (start, end, stats) {
    var ps = allocPendingStats()
    ps.startQueryIndex = start
    ps.endQueryIndex = end
    ps.sum = 0
    ps.stats = stats
    pendingStats.push(ps)
  }

  // we should call this at the beginning of the frame,
  // in order to update gpuTime
  var timeSum = []
  var queryPtr = []
  function update () {
    var ptr, i

    var n = pendingQueries.length
    if (n === 0) {
      return
    }

    // Reserve space
    queryPtr.length = Math.max(queryPtr.length, n + 1)
    timeSum.length = Math.max(timeSum.length, n + 1)
    timeSum[0] = 0
    queryPtr[0] = 0

    // Update all pending timer queries
    var queryTime = 0
    ptr = 0
    for (i = 0; i < pendingQueries.length; ++i) {
      var query = pendingQueries[i]
      if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
        queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT)
        freeQuery(query)
      } else {
        pendingQueries[ptr++] = query
      }
      timeSum[i + 1] = queryTime
      queryPtr[i + 1] = ptr
    }
    pendingQueries.length = ptr

    // Update all pending stat queries
    ptr = 0
    for (i = 0; i < pendingStats.length; ++i) {
      var stats = pendingStats[i]
      var start = stats.startQueryIndex
      var end = stats.endQueryIndex
      stats.sum += timeSum[end] - timeSum[start]
      var startPtr = queryPtr[start]
      var endPtr = queryPtr[end]
      if (endPtr === startPtr) {
        stats.stats.gpuTime += stats.sum / 1e6
        freePendingStats(stats)
      } else {
        stats.startQueryIndex = startPtr
        stats.endQueryIndex = endPtr
        pendingStats[ptr++] = stats
      }
    }
    pendingStats.length = ptr
  }

  return {
    beginQuery: beginQuery,
    endQuery: endQuery,
    pushScopeStats: pushScopeStats,
    update: update,
    getNumPendingQueries: function () {
      return pendingQueries.length
    },
    clear: function () {
      queryPool.push.apply(queryPool, pendingQueries)
      for (var i = 0; i < queryPool.length; i++) {
        extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i])
      }
      pendingQueries.length = 0
      queryPool.length = 0
    },
    restore: function () {
      pendingQueries.length = 0
      queryPool.length = 0
    }
  }
}

var GL_COLOR_BUFFER_BIT = 16384
var GL_DEPTH_BUFFER_BIT = 256
var GL_STENCIL_BUFFER_BIT = 1024

var GL_ARRAY_BUFFER = 34962

var CONTEXT_LOST_EVENT = 'webglcontextlost'
var CONTEXT_RESTORED_EVENT = 'webglcontextrestored'

var DYN_PROP = 1
var DYN_CONTEXT = 2
var DYN_STATE = 3

function find (haystack, needle) {
  for (var i = 0; i < haystack.length; ++i) {
    if (haystack[i] === needle) {
      return i
    }
  }
  return -1
}

function wrapREGL (args) {
  var config = parseArgs(args)
  if (!config) {
    return null
  }

  var gl = config.gl
  var glAttributes = gl.getContextAttributes()
  var contextLost = gl.isContextLost()

  var extensionState = createExtensionCache(gl, config)
  if (!extensionState) {
    return null
  }

  var stringStore = createStringStore()
  var stats$$1 = stats()
  var extensions = extensionState.extensions
  var timer = createTimer(gl, extensions)

  var START_TIME = clock()
  var WIDTH = gl.drawingBufferWidth
  var HEIGHT = gl.drawingBufferHeight

  var contextState = {
    tick: 0,
    time: 0,
    viewportWidth: WIDTH,
    viewportHeight: HEIGHT,
    framebufferWidth: WIDTH,
    framebufferHeight: HEIGHT,
    drawingBufferWidth: WIDTH,
    drawingBufferHeight: HEIGHT,
    pixelRatio: config.pixelRatio
  }
  var uniformState = {}
  var drawState = {
    elements: null,
    primitive: 4, // GL_TRIANGLES
    count: -1,
    offset: 0,
    instances: -1
  }

  var limits = wrapLimits(gl, extensions)
  var bufferState = wrapBufferState(
    gl,
    stats$$1,
    config,
    destroyBuffer)
  var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1)
  var attributeState = wrapAttributeState(
    gl,
    extensions,
    limits,
    stats$$1,
    bufferState,
    elementState,
    drawState)
  function destroyBuffer (buffer) {
    return attributeState.destroyBuffer(buffer)
  }
  var shaderState = wrapShaderState(gl, stringStore, stats$$1, config)
  var textureState = createTextureSet(
    gl,
    extensions,
    limits,
    function () { core.procs.poll() },
    contextState,
    stats$$1,
    config)
  var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config)
  var framebufferState = wrapFBOState(
    gl,
    extensions,
    limits,
    textureState,
    renderbufferState,
    stats$$1)
  var core = reglCore(
    gl,
    stringStore,
    extensions,
    limits,
    bufferState,
    elementState,
    textureState,
    framebufferState,
    uniformState,
    attributeState,
    shaderState,
    drawState,
    contextState,
    timer,
    config)
  var readPixels = wrapReadPixels(
    gl,
    framebufferState,
    core.procs.poll,
    contextState,
    glAttributes, extensions, limits)

  var nextState = core.next
  var canvas = gl.canvas

  var rafCallbacks = []
  var lossCallbacks = []
  var restoreCallbacks = []
  var destroyCallbacks = [config.onDestroy]

  var activeRAF = null
  function handleRAF () {
    if (rafCallbacks.length === 0) {
      if (timer) {
        timer.update()
      }
      activeRAF = null
      return
    }

    // schedule next animation frame
    activeRAF = raf.next(handleRAF)

    // poll for changes
    poll()

    // fire a callback for all pending rafs
    for (var i = rafCallbacks.length - 1; i >= 0; --i) {
      var cb = rafCallbacks[i]
      if (cb) {
        cb(contextState, null, 0)
      }
    }

    // flush all pending webgl calls
    gl.flush()

    // poll GPU timers *after* gl.flush so we don't delay command dispatch
    if (timer) {
      timer.update()
    }
  }

  function startRAF () {
    if (!activeRAF && rafCallbacks.length > 0) {
      activeRAF = raf.next(handleRAF)
    }
  }

  function stopRAF () {
    if (activeRAF) {
      raf.cancel(handleRAF)
      activeRAF = null
    }
  }

  function handleContextLoss (event) {
    event.preventDefault()

    // set context lost flag
    contextLost = true

    // pause request animation frame
    stopRAF()

    // lose context
    lossCallbacks.forEach(function (cb) {
      cb()
    })
  }

  function handleContextRestored (event) {
    // clear error code
    gl.getError()

    // clear context lost flag
    contextLost = false

    // refresh state
    extensionState.restore()
    shaderState.restore()
    bufferState.restore()
    textureState.restore()
    renderbufferState.restore()
    framebufferState.restore()
    attributeState.restore()
    if (timer) {
      timer.restore()
    }

    // refresh state
    core.procs.refresh()

    // restart RAF
    startRAF()

    // restore context
    restoreCallbacks.forEach(function (cb) {
      cb()
    })
  }

  if (canvas) {
    canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false)
    canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false)
  }

  function destroy () {
    rafCallbacks.length = 0
    stopRAF()

    if (canvas) {
      canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss)
      canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored)
    }

    shaderState.clear()
    framebufferState.clear()
    renderbufferState.clear()
    attributeState.clear()
    textureState.clear()
    elementState.clear()
    bufferState.clear()

    if (timer) {
      timer.clear()
    }

    destroyCallbacks.forEach(function (cb) {
      cb()
    })
  }

  function compileProcedure (options) {
    check$1(!!options, 'invalid args to regl({...})')
    check$1.type(options, 'object', 'invalid args to regl({...})')

    function flattenNestedOptions (options) {
      var result = extend({}, options)
      delete result.uniforms
      delete result.attributes
      delete result.context
      delete result.vao

      if ('stencil' in result && result.stencil.op) {
        result.stencil.opBack = result.stencil.opFront = result.stencil.op
        delete result.stencil.op
      }

      function merge (name) {
        if (name in result) {
          var child = result[name]
          delete result[name]
          Object.keys(child).forEach(function (prop) {
            result[name + '.' + prop] = child[prop]
          })
        }
      }
      merge('blend')
      merge('depth')
      merge('cull')
      merge('stencil')
      merge('polygonOffset')
      merge('scissor')
      merge('sample')

      if ('vao' in options) {
        result.vao = options.vao
      }

      return result
    }

    function separateDynamic (object, useArrays) {
      var staticItems = {}
      var dynamicItems = {}
      Object.keys(object).forEach(function (option) {
        var value = object[option]
        if (dynamic.isDynamic(value)) {
          dynamicItems[option] = dynamic.unbox(value, option)
          return
        } else if (useArrays && Array.isArray(value)) {
          for (var i = 0; i < value.length; ++i) {
            if (dynamic.isDynamic(value[i])) {
              dynamicItems[option] = dynamic.unbox(value, option)
              return
            }
          }
        }
        staticItems[option] = value
      })
      return {
        dynamic: dynamicItems,
        static: staticItems
      }
    }

    // Treat context variables separate from other dynamic variables
    var context = separateDynamic(options.context || {}, true)
    var uniforms = separateDynamic(options.uniforms || {}, true)
    var attributes = separateDynamic(options.attributes || {}, false)
    var opts = separateDynamic(flattenNestedOptions(options), false)

    var stats$$1 = {
      gpuTime: 0.0,
      cpuTime: 0.0,
      count: 0
    }

    var compiled = core.compile(opts, attributes, uniforms, context, stats$$1)

    var draw = compiled.draw
    var batch = compiled.batch
    var scope = compiled.scope

    // FIXME: we should modify code generation for batch commands so this
    // isn't necessary
    var EMPTY_ARRAY = []
    function reserve (count) {
      while (EMPTY_ARRAY.length < count) {
        EMPTY_ARRAY.push(null)
      }
      return EMPTY_ARRAY
    }

    function REGLCommand (args, body) {
      var i
      if (contextLost) {
        check$1.raise('context lost')
      }
      if (typeof args === 'function') {
        return scope.call(this, null, args, 0)
      } else if (typeof body === 'function') {
        if (typeof args === 'number') {
          for (i = 0; i < args; ++i) {
            scope.call(this, null, body, i)
          }
        } else if (Array.isArray(args)) {
          for (i = 0; i < args.length; ++i) {
            scope.call(this, args[i], body, i)
          }
        } else {
          return scope.call(this, args, body, 0)
        }
      } else if (typeof args === 'number') {
        if (args > 0) {
          return batch.call(this, reserve(args | 0), args | 0)
        }
      } else if (Array.isArray(args)) {
        if (args.length) {
          return batch.call(this, args, args.length)
        }
      } else {
        return draw.call(this, args)
      }
    }

    return extend(REGLCommand, {
      stats: stats$$1,
      destroy: function () {
        compiled.destroy()
      }
    })
  }

  var setFBO = framebufferState.setFBO = compileProcedure({
    framebuffer: dynamic.define.call(null, DYN_PROP, 'framebuffer')
  })

  function clearImpl (_, options) {
    var clearFlags = 0
    core.procs.poll()

    var c = options.color
    if (c) {
      gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0)
      clearFlags |= GL_COLOR_BUFFER_BIT
    }
    if ('depth' in options) {
      gl.clearDepth(+options.depth)
      clearFlags |= GL_DEPTH_BUFFER_BIT
    }
    if ('stencil' in options) {
      gl.clearStencil(options.stencil | 0)
      clearFlags |= GL_STENCIL_BUFFER_BIT
    }

    check$1(!!clearFlags, 'called regl.clear with no buffer specified')
    gl.clear(clearFlags)
  }

  function clear (options) {
    check$1(
      typeof options === 'object' && options,
      'regl.clear() takes an object as input')
    if ('framebuffer' in options) {
      if (options.framebuffer &&
          options.framebuffer_reglType === 'framebufferCube') {
        for (var i = 0; i < 6; ++i) {
          setFBO(extend({
            framebuffer: options.framebuffer.faces[i]
          }, options), clearImpl)
        }
      } else {
        setFBO(options, clearImpl)
      }
    } else {
      clearImpl(null, options)
    }
  }

  function frame (cb) {
    check$1.type(cb, 'function', 'regl.frame() callback must be a function')
    rafCallbacks.push(cb)

    function cancel () {
      // FIXME:  should we check something other than equals cb here?
      // what if a user calls frame twice with the same callback...
      //
      var i = find(rafCallbacks, cb)
      check$1(i >= 0, 'cannot cancel a frame twice')
      function pendingCancel () {
        var index = find(rafCallbacks, pendingCancel)
        rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1]
        rafCallbacks.length -= 1
        if (rafCallbacks.length <= 0) {
          stopRAF()
        }
      }
      rafCallbacks[i] = pendingCancel
    }

    startRAF()

    return {
      cancel: cancel
    }
  }

  // poll viewport
  function pollViewport () {
    var viewport = nextState.viewport
    var scissorBox = nextState.scissor_box
    viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0
    contextState.viewportWidth =
      contextState.framebufferWidth =
      contextState.drawingBufferWidth =
      viewport[2] =
      scissorBox[2] = gl.drawingBufferWidth
    contextState.viewportHeight =
      contextState.framebufferHeight =
      contextState.drawingBufferHeight =
      viewport[3] =
      scissorBox[3] = gl.drawingBufferHeight
  }

  function poll () {
    contextState.tick += 1
    contextState.time = now()
    pollViewport()
    core.procs.poll()
  }

  function refresh () {
    textureState.refresh()
    pollViewport()
    core.procs.refresh()
    if (timer) {
      timer.update()
    }
  }

  function now () {
    return (clock() - START_TIME) / 1000.0
  }

  refresh()

  function addListener (event, callback) {
    check$1.type(callback, 'function', 'listener callback must be a function')

    var callbacks
    switch (event) {
      case 'frame':
        return frame(callback)
      case 'lost':
        callbacks = lossCallbacks
        break
      case 'restore':
        callbacks = restoreCallbacks
        break
      case 'destroy':
        callbacks = destroyCallbacks
        break
      default:
        check$1.raise('invalid event, must be one of frame,lost,restore,destroy')
    }

    callbacks.push(callback)
    return {
      cancel: function () {
        for (var i = 0; i < callbacks.length; ++i) {
          if (callbacks[i] === callback) {
            callbacks[i] = callbacks[callbacks.length - 1]
            callbacks.pop()
            return
          }
        }
      }
    }
  }

  var regl = extend(compileProcedure, {
    // Clear current FBO
    clear: clear,

    // Short cuts for dynamic variables
    prop: dynamic.define.bind(null, DYN_PROP),
    context: dynamic.define.bind(null, DYN_CONTEXT),
    this: dynamic.define.bind(null, DYN_STATE),

    // executes an empty draw command
    draw: compileProcedure({}),

    // Resources
    buffer: function (options) {
      return bufferState.create(options, GL_ARRAY_BUFFER, false, false)
    },
    elements: function (options) {
      return elementState.create(options, false)
    },
    texture: textureState.create2D,
    cube: textureState.createCube,
    renderbuffer: renderbufferState.create,
    framebuffer: framebufferState.create,
    framebufferCube: framebufferState.createCube,
    vao: attributeState.createVAO,

    // Expose context attributes
    attributes: glAttributes,

    // Frame rendering
    frame: frame,
    on: addListener,

    // System limits
    limits: limits,
    hasExtension: function (name) {
      return limits.extensions.indexOf(name.toLowerCase()) >= 0
    },

    // Read pixels
    read: readPixels,

    // Destroy regl and all associated resources
    destroy: destroy,

    // Direct GL state manipulation
    _gl: gl,
    _refresh: refresh,

    poll: function () {
      poll()
      if (timer) {
        timer.update()
      }
    },

    // Current time
    now: now,

    // regl Statistics Information
    stats: stats$$1
  })

  config.onDone(null, regl)

  return regl
}

return wrapREGL;

})));


},{}],"../node_modules/d3-array/src/ascending.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ascending;
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
},{}],"../node_modules/d3-array/src/descending.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = descending;
function descending(a, b) {
  return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}
},{}],"../node_modules/d3-array/src/bisector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = bisector;
var _ascending = _interopRequireDefault(require("./ascending.js"));
var _descending = _interopRequireDefault(require("./descending.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function bisector(f) {
  var compare1, compare2, delta;

  // If an accessor is specified, promote it to a comparator. In this case we
  // can test whether the search value is (self-) comparable. We can’t do this
  // for a comparator (except for specific, known comparators) because we can’t
  // tell if the comparator is symmetric, and an asymmetric comparator can’t be
  // used to test whether a single value is comparable.
  if (f.length !== 2) {
    compare1 = _ascending.default;
    compare2 = function compare2(d, x) {
      return (0, _ascending.default)(f(d), x);
    };
    delta = function delta(d, x) {
      return f(d) - x;
    };
  } else {
    compare1 = f === _ascending.default || f === _descending.default ? f : zero;
    compare2 = f;
    delta = f;
  }
  function left(a, x) {
    var lo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var hi = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : a.length;
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        var mid = lo + hi >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a, x) {
    var lo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var hi = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : a.length;
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        var mid = lo + hi >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a, x) {
    var lo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var hi = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : a.length;
    var i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return {
    left: left,
    center: center,
    right: right
  };
}
function zero() {
  return 0;
}
},{"./ascending.js":"../node_modules/d3-array/src/ascending.js","./descending.js":"../node_modules/d3-array/src/descending.js"}],"../node_modules/d3-array/src/number.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = number;
exports.numbers = numbers;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
var _marked = /*#__PURE__*/_regeneratorRuntime().mark(numbers);
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function number(x) {
  return x === null ? NaN : +x;
}
function numbers(values, valueof) {
  var _iterator, _step, value, index, _iterator2, _step2, _value;
  return _regeneratorRuntime().wrap(function numbers$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        if (!(valueof === undefined)) {
          _context.next = 21;
          break;
        }
        _iterator = _createForOfIteratorHelper(values);
        _context.prev = 2;
        _iterator.s();
      case 4:
        if ((_step = _iterator.n()).done) {
          _context.next = 11;
          break;
        }
        value = _step.value;
        if (!(value != null && (value = +value) >= value)) {
          _context.next = 9;
          break;
        }
        _context.next = 9;
        return value;
      case 9:
        _context.next = 4;
        break;
      case 11:
        _context.next = 16;
        break;
      case 13:
        _context.prev = 13;
        _context.t0 = _context["catch"](2);
        _iterator.e(_context.t0);
      case 16:
        _context.prev = 16;
        _iterator.f();
        return _context.finish(16);
      case 19:
        _context.next = 40;
        break;
      case 21:
        index = -1;
        _iterator2 = _createForOfIteratorHelper(values);
        _context.prev = 23;
        _iterator2.s();
      case 25:
        if ((_step2 = _iterator2.n()).done) {
          _context.next = 32;
          break;
        }
        _value = _step2.value;
        if (!((_value = valueof(_value, ++index, values)) != null && (_value = +_value) >= _value)) {
          _context.next = 30;
          break;
        }
        _context.next = 30;
        return _value;
      case 30:
        _context.next = 25;
        break;
      case 32:
        _context.next = 37;
        break;
      case 34:
        _context.prev = 34;
        _context.t1 = _context["catch"](23);
        _iterator2.e(_context.t1);
      case 37:
        _context.prev = 37;
        _iterator2.f();
        return _context.finish(37);
      case 40:
      case "end":
        return _context.stop();
    }
  }, _marked, null, [[2, 13, 16, 19], [23, 34, 37, 40]]);
}
},{}],"../node_modules/d3-array/src/bisect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.bisectRight = exports.bisectLeft = exports.bisectCenter = void 0;
var _ascending = _interopRequireDefault(require("./ascending.js"));
var _bisector = _interopRequireDefault(require("./bisector.js"));
var _number = _interopRequireDefault(require("./number.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var ascendingBisect = (0, _bisector.default)(_ascending.default);
var bisectRight = exports.bisectRight = ascendingBisect.right;
var bisectLeft = exports.bisectLeft = ascendingBisect.left;
var bisectCenter = exports.bisectCenter = (0, _bisector.default)(_number.default).center;
var _default = exports.default = bisectRight;
},{"./ascending.js":"../node_modules/d3-array/src/ascending.js","./bisector.js":"../node_modules/d3-array/src/bisector.js","./number.js":"../node_modules/d3-array/src/number.js"}],"../node_modules/d3-array/src/blur.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.blur = blur;
exports.blurImage = exports.blur2 = void 0;
function blur(values, r) {
  if (!((r = +r) >= 0)) throw new RangeError("invalid r");
  var length = values.length;
  if (!((length = Math.floor(length)) >= 0)) throw new RangeError("invalid length");
  if (!length || !r) return values;
  var blur = blurf(r);
  var temp = values.slice();
  blur(values, temp, 0, length, 1);
  blur(temp, values, 0, length, 1);
  blur(values, temp, 0, length, 1);
  return values;
}
var blur2 = exports.blur2 = Blur2(blurf);
var blurImage = exports.blurImage = Blur2(blurfImage);
function Blur2(blur) {
  return function (data, rx) {
    var ry = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : rx;
    if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
    var values = data.data,
      width = data.width,
      height = data.height;
    if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== undefined ? height : values.length / width)) >= 0)) throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry) return data;
    var blurx = rx && blur(rx);
    var blury = ry && blur(ry);
    var temp = values.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
    } else if (blury) {
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    }
    return data;
  };
}
function blurh(blur, T, S, w, h) {
  for (var y = 0, n = w * h; y < n;) {
    blur(T, S, y, y += w, 1);
  }
}
function blurv(blur, T, S, w, h) {
  for (var x = 0, n = w * h; x < w; ++x) {
    blur(T, S, x, x + n, w);
  }
}
function blurfImage(radius) {
  var blur = blurf(radius);
  return function (T, S, start, stop, step) {
    start <<= 2, stop <<= 2, step <<= 2;
    blur(T, S, start + 0, stop + 0, step);
    blur(T, S, start + 1, stop + 1, step);
    blur(T, S, start + 2, stop + 2, step);
    blur(T, S, start + 3, stop + 3, step);
  };
}

// Given a target array T, a source array S, sets each value T[i] to the average
// of {S[i - r], …, S[i], …, S[i + r]}, where r = ⌊radius⌋, start <= i < stop,
// for each i, i + step, i + 2 * step, etc., and where S[j] is clamped between
// S[start] (inclusive) and S[stop] (exclusive). If the given radius is not an
// integer, S[i - r - 1] and S[i + r + 1] are added to the sum, each weighted
// according to r - ⌊radius⌋.
function blurf(radius) {
  var radius0 = Math.floor(radius);
  if (radius0 === radius) return bluri(radius);
  var t = radius - radius0;
  var w = 2 * radius + 1;
  return function (T, S, start, stop, step) {
    // stop must be aligned!
    if (!((stop -= step) >= start)) return; // inclusive stop
    var sum = radius0 * S[start];
    var s0 = step * radius0;
    var s1 = s0 + step;
    for (var i = start, j = start + s0; i < j; i += step) {
      sum += S[Math.min(stop, i)];
    }
    for (var _i = start, _j = stop; _i <= _j; _i += step) {
      sum += S[Math.min(stop, _i + s0)];
      T[_i] = (sum + t * (S[Math.max(start, _i - s1)] + S[Math.min(stop, _i + s1)])) / w;
      sum -= S[Math.max(start, _i - s0)];
    }
  };
}

// Like blurf, but optimized for integer radius.
function bluri(radius) {
  var w = 2 * radius + 1;
  return function (T, S, start, stop, step) {
    // stop must be aligned!
    if (!((stop -= step) >= start)) return; // inclusive stop
    var sum = radius * S[start];
    var s = step * radius;
    for (var i = start, j = start + s; i < j; i += step) {
      sum += S[Math.min(stop, i)];
    }
    for (var _i2 = start, _j2 = stop; _i2 <= _j2; _i2 += step) {
      sum += S[Math.min(stop, _i2 + s)];
      T[_i2] = sum / w;
      sum -= S[Math.max(start, _i2 - s)];
    }
  };
}
},{}],"../node_modules/d3-array/src/count.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = count;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function count(values, valueof) {
  var count = 0;
  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        if (value != null && (value = +value) >= value) {
          ++count;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;
    var _iterator2 = _createForOfIteratorHelper(values),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;
        if ((_value = valueof(_value, ++index, values)) != null && (_value = +_value) >= _value) {
          ++count;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return count;
}
},{}],"../node_modules/d3-array/src/cross.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cross;
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function length(array) {
  return array.length | 0;
}
function empty(length) {
  return !(length > 0);
}
function arrayify(values) {
  return _typeof(values) !== "object" || "length" in values ? values : Array.from(values);
}
function reducer(reduce) {
  return function (values) {
    return reduce.apply(void 0, _toConsumableArray(values));
  };
}
function cross() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }
  var reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
  values = values.map(arrayify);
  var lengths = values.map(length);
  var j = values.length - 1;
  var index = new Array(j + 1).fill(0);
  var product = [];
  if (j < 0 || lengths.some(empty)) return product;
  while (true) {
    product.push(index.map(function (j, i) {
      return values[i][j];
    }));
    var i = j;
    while (++index[i] === lengths[i]) {
      if (i === 0) return reduce ? product.map(reduce) : product;
      index[i--] = 0;
    }
  }
}
},{}],"../node_modules/d3-array/src/cumsum.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cumsum;
function cumsum(values, valueof) {
  var sum = 0,
    index = 0;
  return Float64Array.from(values, valueof === undefined ? function (v) {
    return sum += +v || 0;
  } : function (v) {
    return sum += +valueof(v, index++, values) || 0;
  });
}
},{}],"../node_modules/d3-array/src/variance.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = variance;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function variance(values, valueof) {
  var count = 0;
  var delta;
  var mean = 0;
  var sum = 0;
  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        if (value != null && (value = +value) >= value) {
          delta = value - mean;
          mean += delta / ++count;
          sum += delta * (value - mean);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;
    var _iterator2 = _createForOfIteratorHelper(values),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;
        if ((_value = valueof(_value, ++index, values)) != null && (_value = +_value) >= _value) {
          delta = _value - mean;
          mean += delta / ++count;
          sum += delta * (_value - mean);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  if (count > 1) return sum / (count - 1);
}
},{}],"../node_modules/d3-array/src/deviation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = deviation;
var _variance = _interopRequireDefault(require("./variance.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function deviation(values, valueof) {
  var v = (0, _variance.default)(values, valueof);
  return v ? Math.sqrt(v) : v;
}
},{"./variance.js":"../node_modules/d3-array/src/variance.js"}],"../node_modules/d3-array/src/extent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extent;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function extent(values, valueof) {
  var min;
  var max;
  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        if (value != null) {
          if (min === undefined) {
            if (value >= value) min = max = value;
          } else {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;
    var _iterator2 = _createForOfIteratorHelper(values),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;
        if ((_value = valueof(_value, ++index, values)) != null) {
          if (min === undefined) {
            if (_value >= _value) min = max = _value;
          } else {
            if (min > _value) min = _value;
            if (max < _value) max = _value;
          }
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return [min, max];
}
},{}],"../node_modules/d3-array/src/fsum.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Adder = void 0;
exports.fcumsum = fcumsum;
exports.fsum = fsum;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
var Adder = exports.Adder = /*#__PURE__*/function () {
  function Adder() {
    _classCallCheck(this, Adder);
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  _createClass(Adder, [{
    key: "add",
    value: function add(x) {
      var p = this._partials;
      var i = 0;
      for (var j = 0; j < this._n && j < 32; j++) {
        var y = p[j],
          hi = x + y,
          lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
        if (lo) p[i++] = lo;
        x = hi;
      }
      p[i] = x;
      this._n = i + 1;
      return this;
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      var p = this._partials;
      var n = this._n,
        x,
        y,
        lo,
        hi = 0;
      if (n > 0) {
        hi = p[--n];
        while (n > 0) {
          x = hi;
          y = p[--n];
          hi = x + y;
          lo = y - (hi - x);
          if (lo) break;
        }
        if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
          y = lo * 2;
          x = hi + y;
          if (y == x - hi) hi = x;
        }
      }
      return hi;
    }
  }]);
  return Adder;
}();
function fsum(values, valueof) {
  var adder = new Adder();
  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        if (value = +value) {
          adder.add(value);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;
    var _iterator2 = _createForOfIteratorHelper(values),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;
        if (_value = +valueof(_value, ++index, values)) {
          adder.add(_value);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return +adder;
}
function fcumsum(values, valueof) {
  var adder = new Adder();
  var index = -1;
  return Float64Array.from(values, valueof === undefined ? function (v) {
    return adder.add(+v || 0);
  } : function (v) {
    return adder.add(+valueof(v, ++index, values) || 0);
  });
}
},{}],"../node_modules/internmap/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InternSet = exports.InternMap = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var InternMap = exports.InternMap = /*#__PURE__*/function (_Map) {
  _inherits(InternMap, _Map);
  function InternMap(entries) {
    var _this;
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : keyof;
    _classCallCheck(this, InternMap);
    _this = _callSuper(this, InternMap);
    Object.defineProperties(_assertThisInitialized(_this), {
      _intern: {
        value: new Map()
      },
      _key: {
        value: key
      }
    });
    if (entries != null) {
      var _iterator = _createForOfIteratorHelper(entries),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
            _key2 = _step$value[0],
            value = _step$value[1];
          _this.set(_key2, value);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    return _this;
  }
  _createClass(InternMap, [{
    key: "get",
    value: function get(key) {
      return _get(_getPrototypeOf(InternMap.prototype), "get", this).call(this, intern_get(this, key));
    }
  }, {
    key: "has",
    value: function has(key) {
      return _get(_getPrototypeOf(InternMap.prototype), "has", this).call(this, intern_get(this, key));
    }
  }, {
    key: "set",
    value: function set(key, value) {
      return _get(_getPrototypeOf(InternMap.prototype), "set", this).call(this, intern_set(this, key), value);
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      return _get(_getPrototypeOf(InternMap.prototype), "delete", this).call(this, intern_delete(this, key));
    }
  }]);
  return InternMap;
}( /*#__PURE__*/_wrapNativeSuper(Map));
var InternSet = exports.InternSet = /*#__PURE__*/function (_Set) {
  _inherits(InternSet, _Set);
  function InternSet(values) {
    var _this2;
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : keyof;
    _classCallCheck(this, InternSet);
    _this2 = _callSuper(this, InternSet);
    Object.defineProperties(_assertThisInitialized(_this2), {
      _intern: {
        value: new Map()
      },
      _key: {
        value: key
      }
    });
    if (values != null) {
      var _iterator2 = _createForOfIteratorHelper(values),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var value = _step2.value;
          _this2.add(value);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    return _this2;
  }
  _createClass(InternSet, [{
    key: "has",
    value: function has(value) {
      return _get(_getPrototypeOf(InternSet.prototype), "has", this).call(this, intern_get(this, value));
    }
  }, {
    key: "add",
    value: function add(value) {
      return _get(_getPrototypeOf(InternSet.prototype), "add", this).call(this, intern_set(this, value));
    }
  }, {
    key: "delete",
    value: function _delete(value) {
      return _get(_getPrototypeOf(InternSet.prototype), "delete", this).call(this, intern_delete(this, value));
    }
  }]);
  return InternSet;
}( /*#__PURE__*/_wrapNativeSuper(Set));
function intern_get(_ref, value) {
  var _intern = _ref._intern,
    _key = _ref._key;
  var key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set(_ref2, value) {
  var _intern = _ref2._intern,
    _key = _ref2._key;
  var key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete(_ref3, value) {
  var _intern = _ref3._intern,
    _key = _ref3._key;
  var key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && _typeof(value) === "object" ? value.valueOf() : value;
}
},{}],"../node_modules/d3-array/src/identity.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = identity;
function identity(x) {
  return x;
}
},{}],"../node_modules/d3-array/src/group.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = group;
exports.flatGroup = flatGroup;
exports.flatRollup = flatRollup;
exports.groups = groups;
exports.index = index;
exports.indexes = indexes;
exports.rollup = rollup;
exports.rollups = rollups;
var _internmap = require("internmap");
var _identity = _interopRequireDefault(require("./identity.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function group(values) {
  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }
  return nest(values, _identity.default, _identity.default, keys);
}
function groups(values) {
  for (var _len2 = arguments.length, keys = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    keys[_key2 - 1] = arguments[_key2];
  }
  return nest(values, Array.from, _identity.default, keys);
}
function flatten(groups, keys) {
  for (var i = 1, n = keys.length; i < n; ++i) {
    groups = groups.flatMap(function (g) {
      return g.pop().map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];
        return [].concat(_toConsumableArray(g), [key, value]);
      });
    });
  }
  return groups;
}
function flatGroup(values) {
  for (var _len3 = arguments.length, keys = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    keys[_key3 - 1] = arguments[_key3];
  }
  return flatten(groups.apply(void 0, [values].concat(keys)), keys);
}
function flatRollup(values, reduce) {
  for (var _len4 = arguments.length, keys = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
    keys[_key4 - 2] = arguments[_key4];
  }
  return flatten(rollups.apply(void 0, [values, reduce].concat(keys)), keys);
}
function rollup(values, reduce) {
  for (var _len5 = arguments.length, keys = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
    keys[_key5 - 2] = arguments[_key5];
  }
  return nest(values, _identity.default, reduce, keys);
}
function rollups(values, reduce) {
  for (var _len6 = arguments.length, keys = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
    keys[_key6 - 2] = arguments[_key6];
  }
  return nest(values, Array.from, reduce, keys);
}
function index(values) {
  for (var _len7 = arguments.length, keys = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
    keys[_key7 - 1] = arguments[_key7];
  }
  return nest(values, _identity.default, unique, keys);
}
function indexes(values) {
  for (var _len8 = arguments.length, keys = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
    keys[_key8 - 1] = arguments[_key8];
  }
  return nest(values, Array.from, unique, keys);
}
function unique(values) {
  if (values.length !== 1) throw new Error("duplicate key");
  return values[0];
}
function nest(values, map, reduce, keys) {
  return function regroup(values, i) {
    if (i >= keys.length) return reduce(values);
    var groups = new _internmap.InternMap();
    var keyof = keys[i++];
    var index = -1;
    var _iterator = _createForOfIteratorHelper(values),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        var key = keyof(value, ++index, values);
        var _group = groups.get(key);
        if (_group) _group.push(value);else groups.set(key, [value]);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _iterator2 = _createForOfIteratorHelper(groups),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _slicedToArray(_step2.value, 2),
          _key9 = _step2$value[0],
          _values = _step2$value[1];
        groups.set(_key9, regroup(_values, i));
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return map(groups);
  }(values, 0);
}
},{"internmap":"../node_modules/internmap/src/index.js","./identity.js":"../node_modules/d3-array/src/identity.js"}],"../node_modules/d3-array/src/permute.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = permute;
function permute(source, keys) {
  return Array.from(keys, function (key) {
    return source[key];
  });
}
},{}],"../node_modules/d3-array/src/sort.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ascendingDefined = ascendingDefined;
exports.compareDefined = compareDefined;
exports.default = sort;
var _ascending = _interopRequireDefault(require("./ascending.js"));
var _permute = _interopRequireDefault(require("./permute.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function sort(values) {
  for (var _len = arguments.length, F = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    F[_key - 1] = arguments[_key];
  }
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values = Array.from(values);
  var _F = F,
    _F2 = _slicedToArray(_F, 1),
    f = _F2[0];
  if (f && f.length !== 2 || F.length > 1) {
    var index = Uint32Array.from(values, function (d, i) {
      return i;
    });
    if (F.length > 1) {
      F = F.map(function (f) {
        return values.map(f);
      });
      index.sort(function (i, j) {
        var _iterator = _createForOfIteratorHelper(F),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _f = _step.value;
            var c = ascendingDefined(_f[i], _f[j]);
            if (c) return c;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    } else {
      f = values.map(f);
      index.sort(function (i, j) {
        return ascendingDefined(f[i], f[j]);
      });
    }
    return (0, _permute.default)(values, index);
  }
  return values.sort(compareDefined(f));
}
function compareDefined() {
  var compare = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _ascending.default;
  if (compare === _ascending.default) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return function (a, b) {
    var x = compare(a, b);
    if (x || x === 0) return x;
    return (compare(b, b) === 0) - (compare(a, a) === 0);
  };
}
function ascendingDefined(a, b) {
  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
}
},{"./ascending.js":"../node_modules/d3-array/src/ascending.js","./permute.js":"../node_modules/d3-array/src/permute.js"}],"../node_modules/d3-array/src/groupSort.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = groupSort;
var _ascending = _interopRequireDefault(require("./ascending.js"));
var _group = _interopRequireWildcard(require("./group.js"));
var _sort = _interopRequireDefault(require("./sort.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function groupSort(values, reduce, key) {
  return (reduce.length !== 2 ? (0, _sort.default)((0, _group.rollup)(values, reduce, key), function (_ref, _ref2) {
    var _ref3 = _slicedToArray(_ref, 2),
      ak = _ref3[0],
      av = _ref3[1];
    var _ref4 = _slicedToArray(_ref2, 2),
      bk = _ref4[0],
      bv = _ref4[1];
    return (0, _ascending.default)(av, bv) || (0, _ascending.default)(ak, bk);
  }) : (0, _sort.default)((0, _group.default)(values, key), function (_ref5, _ref6) {
    var _ref7 = _slicedToArray(_ref5, 2),
      ak = _ref7[0],
      av = _ref7[1];
    var _ref8 = _slicedToArray(_ref6, 2),
      bk = _ref8[0],
      bv = _ref8[1];
    return reduce(av, bv) || (0, _ascending.default)(ak, bk);
  })).map(function (_ref9) {
    var _ref10 = _slicedToArray(_ref9, 1),
      key = _ref10[0];
    return key;
  });
}
},{"./ascending.js":"../node_modules/d3-array/src/ascending.js","./group.js":"../node_modules/d3-array/src/group.js","./sort.js":"../node_modules/d3-array/src/sort.js"}],"../node_modules/d3-array/src/array.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.slice = exports.map = void 0;
var array = Array.prototype;
var slice = exports.slice = array.slice;
var map = exports.map = array.map;
},{}],"../node_modules/d3-array/src/constant.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = constant;
function constant(x) {
  return function () {
    return x;
  };
}
},{}],"../node_modules/d3-array/src/ticks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ticks;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var e10 = Math.sqrt(50),
  e5 = Math.sqrt(10),
  e2 = Math.sqrt(2);
function tickSpec(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
    power = Math.floor(Math.log10(step)),
    error = step / Math.pow(10, power),
    factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  var i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  if (!(count > 0)) return [];
  if (start === stop) return [start];
  var reverse = stop < start,
    _ref = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count),
    _ref2 = _slicedToArray(_ref, 3),
    i1 = _ref2[0],
    i2 = _ref2[1],
    inc = _ref2[2];
  if (!(i2 >= i1)) return [];
  var n = i2 - i1 + 1,
    ticks = new Array(n);
  if (reverse) {
    if (inc < 0) for (var i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;else for (var _i = 0; _i < n; ++_i) ticks[_i] = (i2 - _i) * inc;
  } else {
    if (inc < 0) for (var _i2 = 0; _i2 < n; ++_i2) ticks[_i2] = (i1 + _i2) / -inc;else for (var _i3 = 0; _i3 < n; ++_i3) ticks[_i3] = (i1 + _i3) * inc;
  }
  return ticks;
}
function tickIncrement(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  return tickSpec(start, stop, count)[2];
}
function tickStep(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  var reverse = stop < start,
    inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
},{}],"../node_modules/d3-array/src/nice.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = nice;
var _ticks = require("./ticks.js");
function nice(start, stop, count) {
  var prestep;
  while (true) {
    var step = (0, _ticks.tickIncrement)(start, stop, count);
    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start, stop];
    } else if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}
},{"./ticks.js":"../node_modules/d3-array/src/ticks.js"}],"../node_modules/d3-array/src/threshold/sturges.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = thresholdSturges;
var _count = _interopRequireDefault(require("../count.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function thresholdSturges(values) {
  return Math.max(1, Math.ceil(Math.log((0, _count.default)(values)) / Math.LN2) + 1);
}
},{"../count.js":"../node_modules/d3-array/src/count.js"}],"../node_modules/d3-array/src/bin.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = bin;
var _array = require("./array.js");
var _bisect = _interopRequireDefault(require("./bisect.js"));
var _constant = _interopRequireDefault(require("./constant.js"));
var _extent = _interopRequireDefault(require("./extent.js"));
var _identity = _interopRequireDefault(require("./identity.js"));
var _nice3 = _interopRequireDefault(require("./nice.js"));
var _ticks = _interopRequireWildcard(require("./ticks.js"));
var _sturges = _interopRequireDefault(require("./threshold/sturges.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function bin() {
  var value = _identity.default,
    domain = _extent.default,
    threshold = _sturges.default;
  function histogram(data) {
    if (!Array.isArray(data)) data = Array.from(data);
    var i,
      n = data.length,
      x,
      step,
      values = new Array(n);
    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }
    var xz = domain(values),
      x0 = xz[0],
      x1 = xz[1],
      tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds, and nice the
    // default domain accordingly.
    if (!Array.isArray(tz)) {
      var max = x1,
        tn = +tz;
      if (domain === _extent.default) {
        var _nice = (0, _nice3.default)(x0, x1, tn);
        var _nice2 = _slicedToArray(_nice, 2);
        x0 = _nice2[0];
        x1 = _nice2[1];
      }
      tz = (0, _ticks.default)(x0, x1, tn);

      // If the domain is aligned with the first tick (which it will by
      // default), then we can use quantization rather than bisection to bin
      // values, which is substantially faster.
      if (tz[0] <= x0) step = (0, _ticks.tickIncrement)(x0, x1, tn);

      // If the last threshold is coincident with the domain’s upper bound, the
      // last bin will be zero-width. If the default domain is used, and this
      // last threshold is coincident with the maximum input value, we can
      // extend the niced upper bound by one tick to ensure uniform bin widths;
      // otherwise, we simply remove the last threshold. Note that we don’t
      // coerce values or the domain to numbers, and thus must be careful to
      // compare order (>=) rather than strict equality (===)!
      if (tz[tz.length - 1] >= x1) {
        if (max >= x1 && domain === _extent.default) {
          var _step = (0, _ticks.tickIncrement)(x0, x1, tn);
          if (isFinite(_step)) {
            if (_step > 0) {
              x1 = (Math.floor(x1 / _step) + 1) * _step;
            } else if (_step < 0) {
              x1 = (Math.ceil(x1 * -_step) + 1) / -_step;
            }
          }
        } else {
          tz.pop();
        }
      }
    }

    // Remove any thresholds outside the domain.
    // Be careful not to mutate an array owned by the user!
    var m = tz.length,
      a = 0,
      b = m;
    while (tz[a] <= x0) ++a;
    while (tz[b - 1] > x1) --b;
    if (a || b < m) tz = tz.slice(a, b), m = b - a;
    var bins = new Array(m + 1),
      bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    if (isFinite(step)) {
      if (step > 0) {
        for (i = 0; i < n; ++i) {
          if ((x = values[i]) != null && x0 <= x && x <= x1) {
            bins[Math.min(m, Math.floor((x - x0) / step))].push(data[i]);
          }
        }
      } else if (step < 0) {
        for (i = 0; i < n; ++i) {
          if ((x = values[i]) != null && x0 <= x && x <= x1) {
            var j = Math.floor((x0 - x) * step);
            bins[Math.min(m, j + (tz[j] <= x))].push(data[i]); // handle off-by-one due to rounding
          }
        }
      }
    } else {
      for (i = 0; i < n; ++i) {
        if ((x = values[i]) != null && x0 <= x && x <= x1) {
          bins[(0, _bisect.default)(tz, x, 0, m)].push(data[i]);
        }
      }
    }
    return bins;
  }
  histogram.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0, _constant.default)(_), histogram) : value;
  };
  histogram.domain = function (_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : (0, _constant.default)([_[0], _[1]]), histogram) : domain;
  };
  histogram.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : (0, _constant.default)(Array.isArray(_) ? _array.slice.call(_) : _), histogram) : threshold;
  };
  return histogram;
}
},{"./array.js":"../node_modules/d3-array/src/array.js","./bisect.js":"../node_modules/d3-array/src/bisect.js","./constant.js":"../node_modules/d3-array/src/constant.js","./extent.js":"../node_modules/d3-array/src/extent.js","./identity.js":"../node_modules/d3-array/src/identity.js","./nice.js":"../node_modules/d3-array/src/nice.js","./ticks.js":"../node_modules/d3-array/src/ticks.js","./threshold/sturges.js":"../node_modules/d3-array/src/threshold/sturges.js"}],"../node_modules/d3-array/src/max.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = max;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function max(values, valueof) {
  var max;
  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        if (value != null && (max < value || max === undefined && value >= value)) {
          max = value;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;
    var _iterator2 = _createForOfIteratorHelper(values),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;
        if ((_value = valueof(_value, ++index, values)) != null && (max < _value || max === undefined && _value >= _value)) {
          max = _value;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return max;
}
},{}],"../node_modules/d3-array/src/maxIndex.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = maxIndex;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function maxIndex(values, valueof) {
  var max;
  var maxIndex = -1;
  var index = -1;
  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        ++index;
        if (value != null && (max < value || max === undefined && value >= value)) {
          max = value, maxIndex = index;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var _iterator2 = _createForOfIteratorHelper(values),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;
        if ((_value = valueof(_value, ++index, values)) != null && (max < _value || max === undefined && _value >= _value)) {
          max = _value, maxIndex = index;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return maxIndex;
}
},{}],"../node_modules/d3-array/src/min.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = min;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function min(values, valueof) {
  var min;
  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        if (value != null && (min > value || min === undefined && value >= value)) {
          min = value;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;
    var _iterator2 = _createForOfIteratorHelper(values),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;
        if ((_value = valueof(_value, ++index, values)) != null && (min > _value || min === undefined && _value >= _value)) {
          min = _value;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return min;
}
},{}],"../node_modules/d3-array/src/minIndex.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = minIndex;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function minIndex(values, valueof) {
  var min;
  var minIndex = -1;
  var index = -1;
  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        ++index;
        if (value != null && (min > value || min === undefined && value >= value)) {
          min = value, minIndex = index;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var _iterator2 = _createForOfIteratorHelper(values),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;
        if ((_value = valueof(_value, ++index, values)) != null && (min > _value || min === undefined && _value >= _value)) {
          min = _value, minIndex = index;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return minIndex;
}
},{}],"../node_modules/d3-array/src/quickselect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quickselect;
var _sort = require("./sort.js");
// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k) {
  var left = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var right = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;
  var compare = arguments.length > 4 ? arguments[4] : undefined;
  k = Math.floor(k);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array.length - 1, right));
  if (!(left <= k && k <= right)) return array;
  compare = compare === undefined ? _sort.ascendingDefined : (0, _sort.compareDefined)(compare);
  while (right > left) {
    if (right - left > 600) {
      var n = right - left + 1;
      var m = k - left + 1;
      var z = Math.log(n);
      var s = 0.5 * Math.exp(2 * z / 3);
      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }
    var t = array[k];
    var i = left;
    var j = right;
    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);
    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }
    if (compare(array[left], t) === 0) swap(array, left, j);else ++j, swap(array, j, right);
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
  return array;
}
function swap(array, i, j) {
  var t = array[i];
  array[i] = array[j];
  array[j] = t;
}
},{"./sort.js":"../node_modules/d3-array/src/sort.js"}],"../node_modules/d3-array/src/greatest.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = greatest;
var _ascending = _interopRequireDefault(require("./ascending.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function greatest(values) {
  var compare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _ascending.default;
  var max;
  var defined = false;
  if (compare.length === 1) {
    var maxValue;
    var _iterator = _createForOfIteratorHelper(values),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var element = _step.value;
        var value = compare(element);
        if (defined ? (0, _ascending.default)(value, maxValue) > 0 : (0, _ascending.default)(value, value) === 0) {
          max = element;
          maxValue = value;
          defined = true;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var _iterator2 = _createForOfIteratorHelper(values),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;
        if (defined ? compare(_value, max) > 0 : compare(_value, _value) === 0) {
          max = _value;
          defined = true;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return max;
}
},{"./ascending.js":"../node_modules/d3-array/src/ascending.js"}],"../node_modules/d3-array/src/quantile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quantile;
exports.quantileIndex = quantileIndex;
exports.quantileSorted = quantileSorted;
var _max = _interopRequireDefault(require("./max.js"));
var _maxIndex = _interopRequireDefault(require("./maxIndex.js"));
var _min = _interopRequireDefault(require("./min.js"));
var _minIndex = _interopRequireDefault(require("./minIndex.js"));
var _quickselect = _interopRequireDefault(require("./quickselect.js"));
var _number = _interopRequireWildcard(require("./number.js"));
var _sort = require("./sort.js");
var _greatest = _interopRequireDefault(require("./greatest.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function quantile(values, p, valueof) {
  values = Float64Array.from((0, _number.numbers)(values, valueof));
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return (0, _min.default)(values);
  if (p >= 1) return (0, _max.default)(values);
  var n,
    i = (n - 1) * p,
    i0 = Math.floor(i),
    value0 = (0, _max.default)((0, _quickselect.default)(values, i0).subarray(0, i0 + 1)),
    value1 = (0, _min.default)(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values, p) {
  var valueof = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _number.default;
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
    i = (n - 1) * p,
    i0 = Math.floor(i),
    value0 = +valueof(values[i0], i0, values),
    value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}
function quantileIndex(values, p) {
  var valueof = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _number.default;
  if (isNaN(p = +p)) return;
  numbers = Float64Array.from(values, function (_, i) {
    return (0, _number.default)(valueof(values[i], i, values));
  });
  if (p <= 0) return (0, _minIndex.default)(numbers);
  if (p >= 1) return (0, _maxIndex.default)(numbers);
  var numbers,
    index = Uint32Array.from(values, function (_, i) {
      return i;
    }),
    j = numbers.length - 1,
    i = Math.floor(j * p);
  (0, _quickselect.default)(index, i, 0, j, function (i, j) {
    return (0, _sort.ascendingDefined)(numbers[i], numbers[j]);
  });
  i = (0, _greatest.default)(index.subarray(0, i + 1), function (i) {
    return numbers[i];
  });
  return i >= 0 ? i : -1;
}
},{"./max.js":"../node_modules/d3-array/src/max.js","./maxIndex.js":"../node_modules/d3-array/src/maxIndex.js","./min.js":"../node_modules/d3-array/src/min.js","./minIndex.js":"../node_modules/d3-array/src/minIndex.js","./quickselect.js":"../node_modules/d3-array/src/quickselect.js","./number.js":"../node_modules/d3-array/src/number.js","./sort.js":"../node_modules/d3-array/src/sort.js","./greatest.js":"../node_modules/d3-array/src/greatest.js"}],"../node_modules/d3-array/src/threshold/freedmanDiaconis.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = thresholdFreedmanDiaconis;
var _count = _interopRequireDefault(require("../count.js"));
var _quantile = _interopRequireDefault(require("../quantile.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function thresholdFreedmanDiaconis(values, min, max) {
  var c = (0, _count.default)(values),
    d = (0, _quantile.default)(values, 0.75) - (0, _quantile.default)(values, 0.25);
  return c && d ? Math.ceil((max - min) / (2 * d * Math.pow(c, -1 / 3))) : 1;
}
},{"../count.js":"../node_modules/d3-array/src/count.js","../quantile.js":"../node_modules/d3-array/src/quantile.js"}],"../node_modules/d3-array/src/threshold/scott.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = thresholdScott;
var _count = _interopRequireDefault(require("../count.js"));
var _deviation = _interopRequireDefault(require("../deviation.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function thresholdScott(values, min, max) {
  var c = (0, _count.default)(values),
    d = (0, _deviation.default)(values);
  return c && d ? Math.ceil((max - min) * Math.cbrt(c) / (3.49 * d)) : 1;
}
},{"../count.js":"../node_modules/d3-array/src/count.js","../deviation.js":"../node_modules/d3-array/src/deviation.js"}],"../node_modules/d3-array/src/mean.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mean;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function mean(values, valueof) {
  var count = 0;
  var sum = 0;
  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        if (value != null && (value = +value) >= value) {
          ++count, sum += value;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;
    var _iterator2 = _createForOfIteratorHelper(values),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;
        if ((_value = valueof(_value, ++index, values)) != null && (_value = +_value) >= _value) {
          ++count, sum += _value;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  if (count) return sum / count;
}
},{}],"../node_modules/d3-array/src/median.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = median;
exports.medianIndex = medianIndex;
var _quantile = _interopRequireWildcard(require("./quantile.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function median(values, valueof) {
  return (0, _quantile.default)(values, 0.5, valueof);
}
function medianIndex(values, valueof) {
  return (0, _quantile.quantileIndex)(values, 0.5, valueof);
}
},{"./quantile.js":"../node_modules/d3-array/src/quantile.js"}],"../node_modules/d3-array/src/merge.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = merge;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
var _marked = /*#__PURE__*/_regeneratorRuntime().mark(flatten);
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function flatten(arrays) {
  var _iterator, _step, array;
  return _regeneratorRuntime().wrap(function flatten$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        _iterator = _createForOfIteratorHelper(arrays);
        _context.prev = 1;
        _iterator.s();
      case 3:
        if ((_step = _iterator.n()).done) {
          _context.next = 8;
          break;
        }
        array = _step.value;
        return _context.delegateYield(array, "t0", 6);
      case 6:
        _context.next = 3;
        break;
      case 8:
        _context.next = 13;
        break;
      case 10:
        _context.prev = 10;
        _context.t1 = _context["catch"](1);
        _iterator.e(_context.t1);
      case 13:
        _context.prev = 13;
        _iterator.f();
        return _context.finish(13);
      case 16:
      case "end":
        return _context.stop();
    }
  }, _marked, null, [[1, 10, 13, 16]]);
}
function merge(arrays) {
  return Array.from(flatten(arrays));
}
},{}],"../node_modules/d3-array/src/mode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mode;
var _internmap = require("internmap");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function mode(values, valueof) {
  var counts = new _internmap.InternMap();
  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        if (value != null && value >= value) {
          counts.set(value, (counts.get(value) || 0) + 1);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;
    var _iterator2 = _createForOfIteratorHelper(values),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;
        if ((_value = valueof(_value, ++index, values)) != null && _value >= _value) {
          counts.set(_value, (counts.get(_value) || 0) + 1);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  var modeValue;
  var modeCount = 0;
  var _iterator3 = _createForOfIteratorHelper(counts),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _slicedToArray(_step3.value, 2),
        _value2 = _step3$value[0],
        count = _step3$value[1];
      if (count > modeCount) {
        modeCount = count;
        modeValue = _value2;
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return modeValue;
}
},{"internmap":"../node_modules/internmap/src/index.js"}],"../node_modules/d3-array/src/pairs.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pairs;
exports.pair = pair;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function pairs(values) {
  var pairof = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : pair;
  var pairs = [];
  var previous;
  var first = false;
  var _iterator = _createForOfIteratorHelper(values),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;
      if (first) pairs.push(pairof(previous, value));
      previous = value;
      first = true;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return pairs;
}
function pair(a, b) {
  return [a, b];
}
},{}],"../node_modules/d3-array/src/range.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = range;
function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1,
    n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
    range = new Array(n);
  while (++i < n) {
    range[i] = start + i * step;
  }
  return range;
}
},{}],"../node_modules/d3-array/src/rank.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rank;
var _ascending = _interopRequireDefault(require("./ascending.js"));
var _sort = require("./sort.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function rank(values) {
  var valueof = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _ascending.default;
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  var V = Array.from(values);
  var R = new Float64Array(V.length);
  if (valueof.length !== 2) V = V.map(valueof), valueof = _ascending.default;
  var compareIndex = function compareIndex(i, j) {
    return valueof(V[i], V[j]);
  };
  var k, r;
  values = Uint32Array.from(V, function (_, i) {
    return i;
  });
  // Risky chaining due to Safari 14 https://github.com/d3/d3-array/issues/123
  values.sort(valueof === _ascending.default ? function (i, j) {
    return (0, _sort.ascendingDefined)(V[i], V[j]);
  } : (0, _sort.compareDefined)(compareIndex));
  values.forEach(function (j, i) {
    var c = compareIndex(j, k === undefined ? j : k);
    if (c >= 0) {
      if (k === undefined || c > 0) k = j, r = i;
      R[j] = r;
    } else {
      R[j] = NaN;
    }
  });
  return R;
}
},{"./ascending.js":"../node_modules/d3-array/src/ascending.js","./sort.js":"../node_modules/d3-array/src/sort.js"}],"../node_modules/d3-array/src/least.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = least;
var _ascending = _interopRequireDefault(require("./ascending.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function least(values) {
  var compare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _ascending.default;
  var min;
  var defined = false;
  if (compare.length === 1) {
    var minValue;
    var _iterator = _createForOfIteratorHelper(values),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var element = _step.value;
        var value = compare(element);
        if (defined ? (0, _ascending.default)(value, minValue) < 0 : (0, _ascending.default)(value, value) === 0) {
          min = element;
          minValue = value;
          defined = true;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var _iterator2 = _createForOfIteratorHelper(values),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;
        if (defined ? compare(_value, min) < 0 : compare(_value, _value) === 0) {
          min = _value;
          defined = true;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return min;
}
},{"./ascending.js":"../node_modules/d3-array/src/ascending.js"}],"../node_modules/d3-array/src/leastIndex.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = leastIndex;
var _ascending = _interopRequireDefault(require("./ascending.js"));
var _minIndex = _interopRequireDefault(require("./minIndex.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function leastIndex(values) {
  var compare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _ascending.default;
  if (compare.length === 1) return (0, _minIndex.default)(values, compare);
  var minValue;
  var min = -1;
  var index = -1;
  var _iterator = _createForOfIteratorHelper(values),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;
      ++index;
      if (min < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {
        minValue = value;
        min = index;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return min;
}
},{"./ascending.js":"../node_modules/d3-array/src/ascending.js","./minIndex.js":"../node_modules/d3-array/src/minIndex.js"}],"../node_modules/d3-array/src/greatestIndex.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = greatestIndex;
var _ascending = _interopRequireDefault(require("./ascending.js"));
var _maxIndex = _interopRequireDefault(require("./maxIndex.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function greatestIndex(values) {
  var compare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _ascending.default;
  if (compare.length === 1) return (0, _maxIndex.default)(values, compare);
  var maxValue;
  var max = -1;
  var index = -1;
  var _iterator = _createForOfIteratorHelper(values),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;
      ++index;
      if (max < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {
        maxValue = value;
        max = index;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return max;
}
},{"./ascending.js":"../node_modules/d3-array/src/ascending.js","./maxIndex.js":"../node_modules/d3-array/src/maxIndex.js"}],"../node_modules/d3-array/src/scan.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = scan;
var _leastIndex = _interopRequireDefault(require("./leastIndex.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function scan(values, compare) {
  var index = (0, _leastIndex.default)(values, compare);
  return index < 0 ? undefined : index;
}
},{"./leastIndex.js":"../node_modules/d3-array/src/leastIndex.js"}],"../node_modules/d3-array/src/shuffle.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.shuffler = shuffler;
var _default = exports.default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle(array) {
    var i0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var i1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : array.length;
    var m = i1 - (i0 = +i0);
    while (m) {
      var i = random() * m-- | 0,
        t = array[m + i0];
      array[m + i0] = array[i + i0];
      array[i + i0] = t;
    }
    return array;
  };
}
},{}],"../node_modules/d3-array/src/sum.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sum;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function sum(values, valueof) {
  var sum = 0;
  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        if (value = +value) {
          sum += value;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;
    var _iterator2 = _createForOfIteratorHelper(values),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;
        if (_value = +valueof(_value, ++index, values)) {
          sum += _value;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return sum;
}
},{}],"../node_modules/d3-array/src/transpose.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = transpose;
var _min = _interopRequireDefault(require("./min.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function transpose(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = (0, _min.default)(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
}
function length(d) {
  return d.length;
}
},{"./min.js":"../node_modules/d3-array/src/min.js"}],"../node_modules/d3-array/src/zip.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = zip;
var _transpose = _interopRequireDefault(require("./transpose.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function zip() {
  return (0, _transpose.default)(arguments);
}
},{"./transpose.js":"../node_modules/d3-array/src/transpose.js"}],"../node_modules/d3-array/src/every.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = every;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function every(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  var index = -1;
  var _iterator = _createForOfIteratorHelper(values),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;
      if (!test(value, ++index, values)) {
        return false;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return true;
}
},{}],"../node_modules/d3-array/src/some.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = some;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function some(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  var index = -1;
  var _iterator = _createForOfIteratorHelper(values),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;
      if (test(value, ++index, values)) {
        return true;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return false;
}
},{}],"../node_modules/d3-array/src/filter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = filter;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function filter(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  var array = [];
  var index = -1;
  var _iterator = _createForOfIteratorHelper(values),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;
      if (test(value, ++index, values)) {
        array.push(value);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return array;
}
},{}],"../node_modules/d3-array/src/map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = map;
function map(values, mapper) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
  return Array.from(values, function (value, index) {
    return mapper(value, index, values);
  });
}
},{}],"../node_modules/d3-array/src/reduce.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = reduce;
function reduce(values, reducer, value) {
  if (typeof reducer !== "function") throw new TypeError("reducer is not a function");
  var iterator = values[Symbol.iterator]();
  var done,
    next,
    index = -1;
  if (arguments.length < 3) {
    var _iterator$next = iterator.next();
    done = _iterator$next.done;
    value = _iterator$next.value;
    if (done) return;
    ++index;
  }
  while ((_iterator$next2 = iterator.next(), done = _iterator$next2.done, next = _iterator$next2.value), !done) {
    var _iterator$next2;
    value = reducer(value, next, ++index, values);
  }
  return value;
}
},{}],"../node_modules/d3-array/src/reverse.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = reverse;
function reverse(values) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  return Array.from(values).reverse();
}
},{}],"../node_modules/d3-array/src/difference.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = difference;
var _internmap = require("internmap");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function difference(values) {
  values = new _internmap.InternSet(values);
  for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    others[_key - 1] = arguments[_key];
  }
  for (var _i = 0, _others = others; _i < _others.length; _i++) {
    var other = _others[_i];
    var _iterator = _createForOfIteratorHelper(other),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        values.delete(value);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return values;
}
},{"internmap":"../node_modules/internmap/src/index.js"}],"../node_modules/d3-array/src/disjoint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = disjoint;
var _internmap = require("internmap");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function disjoint(values, other) {
  var iterator = other[Symbol.iterator](),
    set = new _internmap.InternSet();
  var _iterator = _createForOfIteratorHelper(values),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var v = _step.value;
      if (set.has(v)) return false;
      var value = void 0,
        done = void 0;
      while (_iterator$next = iterator.next(), value = _iterator$next.value, done = _iterator$next.done, _iterator$next) {
        var _iterator$next;
        if (done) break;
        if (Object.is(v, value)) return false;
        set.add(value);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return true;
}
},{"internmap":"../node_modules/internmap/src/index.js"}],"../node_modules/d3-array/src/intersection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = intersection;
var _internmap = require("internmap");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function intersection(values) {
  for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    others[_key - 1] = arguments[_key];
  }
  values = new _internmap.InternSet(values);
  others = others.map(set);
  var _iterator = _createForOfIteratorHelper(values),
    _step;
  try {
    out: for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;
      var _iterator2 = _createForOfIteratorHelper(others),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var other = _step2.value;
          if (!other.has(value)) {
            values.delete(value);
            continue out;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return values;
}
function set(values) {
  return values instanceof _internmap.InternSet ? values : new _internmap.InternSet(values);
}
},{"internmap":"../node_modules/internmap/src/index.js"}],"../node_modules/d3-array/src/superset.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = superset;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function superset(values, other) {
  var iterator = values[Symbol.iterator](),
    set = new Set();
  var _iterator = _createForOfIteratorHelper(other),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var o = _step.value;
      var io = intern(o);
      if (set.has(io)) continue;
      var value = void 0,
        done = void 0;
      while (_iterator$next = iterator.next(), value = _iterator$next.value, done = _iterator$next.done, _iterator$next) {
        var _iterator$next;
        if (done) return false;
        var ivalue = intern(value);
        set.add(ivalue);
        if (Object.is(io, ivalue)) break;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return true;
}
function intern(value) {
  return value !== null && _typeof(value) === "object" ? value.valueOf() : value;
}
},{}],"../node_modules/d3-array/src/subset.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = subset;
var _superset = _interopRequireDefault(require("./superset.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function subset(values, other) {
  return (0, _superset.default)(other, values);
}
},{"./superset.js":"../node_modules/d3-array/src/superset.js"}],"../node_modules/d3-array/src/union.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = union;
var _internmap = require("internmap");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function union() {
  var set = new _internmap.InternSet();
  for (var _len = arguments.length, others = new Array(_len), _key = 0; _key < _len; _key++) {
    others[_key] = arguments[_key];
  }
  for (var _i = 0, _others = others; _i < _others.length; _i++) {
    var other = _others[_i];
    var _iterator = _createForOfIteratorHelper(other),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var o = _step.value;
        set.add(o);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return set;
}
},{"internmap":"../node_modules/internmap/src/index.js"}],"../node_modules/d3-array/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Adder", {
  enumerable: true,
  get: function () {
    return _fsum.Adder;
  }
});
Object.defineProperty(exports, "InternMap", {
  enumerable: true,
  get: function () {
    return _internmap.InternMap;
  }
});
Object.defineProperty(exports, "InternSet", {
  enumerable: true,
  get: function () {
    return _internmap.InternSet;
  }
});
Object.defineProperty(exports, "ascending", {
  enumerable: true,
  get: function () {
    return _ascending.default;
  }
});
Object.defineProperty(exports, "bin", {
  enumerable: true,
  get: function () {
    return _bin.default;
  }
});
Object.defineProperty(exports, "bisect", {
  enumerable: true,
  get: function () {
    return _bisect.default;
  }
});
Object.defineProperty(exports, "bisectCenter", {
  enumerable: true,
  get: function () {
    return _bisect.bisectCenter;
  }
});
Object.defineProperty(exports, "bisectLeft", {
  enumerable: true,
  get: function () {
    return _bisect.bisectLeft;
  }
});
Object.defineProperty(exports, "bisectRight", {
  enumerable: true,
  get: function () {
    return _bisect.bisectRight;
  }
});
Object.defineProperty(exports, "bisector", {
  enumerable: true,
  get: function () {
    return _bisector.default;
  }
});
Object.defineProperty(exports, "blur", {
  enumerable: true,
  get: function () {
    return _blur.blur;
  }
});
Object.defineProperty(exports, "blur2", {
  enumerable: true,
  get: function () {
    return _blur.blur2;
  }
});
Object.defineProperty(exports, "blurImage", {
  enumerable: true,
  get: function () {
    return _blur.blurImage;
  }
});
Object.defineProperty(exports, "count", {
  enumerable: true,
  get: function () {
    return _count.default;
  }
});
Object.defineProperty(exports, "cross", {
  enumerable: true,
  get: function () {
    return _cross.default;
  }
});
Object.defineProperty(exports, "cumsum", {
  enumerable: true,
  get: function () {
    return _cumsum.default;
  }
});
Object.defineProperty(exports, "descending", {
  enumerable: true,
  get: function () {
    return _descending.default;
  }
});
Object.defineProperty(exports, "deviation", {
  enumerable: true,
  get: function () {
    return _deviation.default;
  }
});
Object.defineProperty(exports, "difference", {
  enumerable: true,
  get: function () {
    return _difference.default;
  }
});
Object.defineProperty(exports, "disjoint", {
  enumerable: true,
  get: function () {
    return _disjoint.default;
  }
});
Object.defineProperty(exports, "every", {
  enumerable: true,
  get: function () {
    return _every.default;
  }
});
Object.defineProperty(exports, "extent", {
  enumerable: true,
  get: function () {
    return _extent.default;
  }
});
Object.defineProperty(exports, "fcumsum", {
  enumerable: true,
  get: function () {
    return _fsum.fcumsum;
  }
});
Object.defineProperty(exports, "filter", {
  enumerable: true,
  get: function () {
    return _filter.default;
  }
});
Object.defineProperty(exports, "flatGroup", {
  enumerable: true,
  get: function () {
    return _group.flatGroup;
  }
});
Object.defineProperty(exports, "flatRollup", {
  enumerable: true,
  get: function () {
    return _group.flatRollup;
  }
});
Object.defineProperty(exports, "fsum", {
  enumerable: true,
  get: function () {
    return _fsum.fsum;
  }
});
Object.defineProperty(exports, "greatest", {
  enumerable: true,
  get: function () {
    return _greatest.default;
  }
});
Object.defineProperty(exports, "greatestIndex", {
  enumerable: true,
  get: function () {
    return _greatestIndex.default;
  }
});
Object.defineProperty(exports, "group", {
  enumerable: true,
  get: function () {
    return _group.default;
  }
});
Object.defineProperty(exports, "groupSort", {
  enumerable: true,
  get: function () {
    return _groupSort.default;
  }
});
Object.defineProperty(exports, "groups", {
  enumerable: true,
  get: function () {
    return _group.groups;
  }
});
Object.defineProperty(exports, "histogram", {
  enumerable: true,
  get: function () {
    return _bin.default;
  }
});
Object.defineProperty(exports, "index", {
  enumerable: true,
  get: function () {
    return _group.index;
  }
});
Object.defineProperty(exports, "indexes", {
  enumerable: true,
  get: function () {
    return _group.indexes;
  }
});
Object.defineProperty(exports, "intersection", {
  enumerable: true,
  get: function () {
    return _intersection.default;
  }
});
Object.defineProperty(exports, "least", {
  enumerable: true,
  get: function () {
    return _least.default;
  }
});
Object.defineProperty(exports, "leastIndex", {
  enumerable: true,
  get: function () {
    return _leastIndex.default;
  }
});
Object.defineProperty(exports, "map", {
  enumerable: true,
  get: function () {
    return _map.default;
  }
});
Object.defineProperty(exports, "max", {
  enumerable: true,
  get: function () {
    return _max.default;
  }
});
Object.defineProperty(exports, "maxIndex", {
  enumerable: true,
  get: function () {
    return _maxIndex.default;
  }
});
Object.defineProperty(exports, "mean", {
  enumerable: true,
  get: function () {
    return _mean.default;
  }
});
Object.defineProperty(exports, "median", {
  enumerable: true,
  get: function () {
    return _median.default;
  }
});
Object.defineProperty(exports, "medianIndex", {
  enumerable: true,
  get: function () {
    return _median.medianIndex;
  }
});
Object.defineProperty(exports, "merge", {
  enumerable: true,
  get: function () {
    return _merge.default;
  }
});
Object.defineProperty(exports, "min", {
  enumerable: true,
  get: function () {
    return _min.default;
  }
});
Object.defineProperty(exports, "minIndex", {
  enumerable: true,
  get: function () {
    return _minIndex.default;
  }
});
Object.defineProperty(exports, "mode", {
  enumerable: true,
  get: function () {
    return _mode.default;
  }
});
Object.defineProperty(exports, "nice", {
  enumerable: true,
  get: function () {
    return _nice.default;
  }
});
Object.defineProperty(exports, "pairs", {
  enumerable: true,
  get: function () {
    return _pairs.default;
  }
});
Object.defineProperty(exports, "permute", {
  enumerable: true,
  get: function () {
    return _permute.default;
  }
});
Object.defineProperty(exports, "quantile", {
  enumerable: true,
  get: function () {
    return _quantile.default;
  }
});
Object.defineProperty(exports, "quantileIndex", {
  enumerable: true,
  get: function () {
    return _quantile.quantileIndex;
  }
});
Object.defineProperty(exports, "quantileSorted", {
  enumerable: true,
  get: function () {
    return _quantile.quantileSorted;
  }
});
Object.defineProperty(exports, "quickselect", {
  enumerable: true,
  get: function () {
    return _quickselect.default;
  }
});
Object.defineProperty(exports, "range", {
  enumerable: true,
  get: function () {
    return _range.default;
  }
});
Object.defineProperty(exports, "rank", {
  enumerable: true,
  get: function () {
    return _rank.default;
  }
});
Object.defineProperty(exports, "reduce", {
  enumerable: true,
  get: function () {
    return _reduce.default;
  }
});
Object.defineProperty(exports, "reverse", {
  enumerable: true,
  get: function () {
    return _reverse.default;
  }
});
Object.defineProperty(exports, "rollup", {
  enumerable: true,
  get: function () {
    return _group.rollup;
  }
});
Object.defineProperty(exports, "rollups", {
  enumerable: true,
  get: function () {
    return _group.rollups;
  }
});
Object.defineProperty(exports, "scan", {
  enumerable: true,
  get: function () {
    return _scan.default;
  }
});
Object.defineProperty(exports, "shuffle", {
  enumerable: true,
  get: function () {
    return _shuffle.default;
  }
});
Object.defineProperty(exports, "shuffler", {
  enumerable: true,
  get: function () {
    return _shuffle.shuffler;
  }
});
Object.defineProperty(exports, "some", {
  enumerable: true,
  get: function () {
    return _some.default;
  }
});
Object.defineProperty(exports, "sort", {
  enumerable: true,
  get: function () {
    return _sort.default;
  }
});
Object.defineProperty(exports, "subset", {
  enumerable: true,
  get: function () {
    return _subset.default;
  }
});
Object.defineProperty(exports, "sum", {
  enumerable: true,
  get: function () {
    return _sum.default;
  }
});
Object.defineProperty(exports, "superset", {
  enumerable: true,
  get: function () {
    return _superset.default;
  }
});
Object.defineProperty(exports, "thresholdFreedmanDiaconis", {
  enumerable: true,
  get: function () {
    return _freedmanDiaconis.default;
  }
});
Object.defineProperty(exports, "thresholdScott", {
  enumerable: true,
  get: function () {
    return _scott.default;
  }
});
Object.defineProperty(exports, "thresholdSturges", {
  enumerable: true,
  get: function () {
    return _sturges.default;
  }
});
Object.defineProperty(exports, "tickIncrement", {
  enumerable: true,
  get: function () {
    return _ticks.tickIncrement;
  }
});
Object.defineProperty(exports, "tickStep", {
  enumerable: true,
  get: function () {
    return _ticks.tickStep;
  }
});
Object.defineProperty(exports, "ticks", {
  enumerable: true,
  get: function () {
    return _ticks.default;
  }
});
Object.defineProperty(exports, "transpose", {
  enumerable: true,
  get: function () {
    return _transpose.default;
  }
});
Object.defineProperty(exports, "union", {
  enumerable: true,
  get: function () {
    return _union.default;
  }
});
Object.defineProperty(exports, "variance", {
  enumerable: true,
  get: function () {
    return _variance.default;
  }
});
Object.defineProperty(exports, "zip", {
  enumerable: true,
  get: function () {
    return _zip.default;
  }
});
var _bisect = _interopRequireWildcard(require("./bisect.js"));
var _ascending = _interopRequireDefault(require("./ascending.js"));
var _bisector = _interopRequireDefault(require("./bisector.js"));
var _blur = require("./blur.js");
var _count = _interopRequireDefault(require("./count.js"));
var _cross = _interopRequireDefault(require("./cross.js"));
var _cumsum = _interopRequireDefault(require("./cumsum.js"));
var _descending = _interopRequireDefault(require("./descending.js"));
var _deviation = _interopRequireDefault(require("./deviation.js"));
var _extent = _interopRequireDefault(require("./extent.js"));
var _fsum = require("./fsum.js");
var _group = _interopRequireWildcard(require("./group.js"));
var _groupSort = _interopRequireDefault(require("./groupSort.js"));
var _bin = _interopRequireDefault(require("./bin.js"));
var _freedmanDiaconis = _interopRequireDefault(require("./threshold/freedmanDiaconis.js"));
var _scott = _interopRequireDefault(require("./threshold/scott.js"));
var _sturges = _interopRequireDefault(require("./threshold/sturges.js"));
var _max = _interopRequireDefault(require("./max.js"));
var _maxIndex = _interopRequireDefault(require("./maxIndex.js"));
var _mean = _interopRequireDefault(require("./mean.js"));
var _median = _interopRequireWildcard(require("./median.js"));
var _merge = _interopRequireDefault(require("./merge.js"));
var _min = _interopRequireDefault(require("./min.js"));
var _minIndex = _interopRequireDefault(require("./minIndex.js"));
var _mode = _interopRequireDefault(require("./mode.js"));
var _nice = _interopRequireDefault(require("./nice.js"));
var _pairs = _interopRequireDefault(require("./pairs.js"));
var _permute = _interopRequireDefault(require("./permute.js"));
var _quantile = _interopRequireWildcard(require("./quantile.js"));
var _quickselect = _interopRequireDefault(require("./quickselect.js"));
var _range = _interopRequireDefault(require("./range.js"));
var _rank = _interopRequireDefault(require("./rank.js"));
var _least = _interopRequireDefault(require("./least.js"));
var _leastIndex = _interopRequireDefault(require("./leastIndex.js"));
var _greatest = _interopRequireDefault(require("./greatest.js"));
var _greatestIndex = _interopRequireDefault(require("./greatestIndex.js"));
var _scan = _interopRequireDefault(require("./scan.js"));
var _shuffle = _interopRequireWildcard(require("./shuffle.js"));
var _sum = _interopRequireDefault(require("./sum.js"));
var _ticks = _interopRequireWildcard(require("./ticks.js"));
var _transpose = _interopRequireDefault(require("./transpose.js"));
var _variance = _interopRequireDefault(require("./variance.js"));
var _zip = _interopRequireDefault(require("./zip.js"));
var _every = _interopRequireDefault(require("./every.js"));
var _some = _interopRequireDefault(require("./some.js"));
var _filter = _interopRequireDefault(require("./filter.js"));
var _map = _interopRequireDefault(require("./map.js"));
var _reduce = _interopRequireDefault(require("./reduce.js"));
var _reverse = _interopRequireDefault(require("./reverse.js"));
var _sort = _interopRequireDefault(require("./sort.js"));
var _difference = _interopRequireDefault(require("./difference.js"));
var _disjoint = _interopRequireDefault(require("./disjoint.js"));
var _intersection = _interopRequireDefault(require("./intersection.js"));
var _subset = _interopRequireDefault(require("./subset.js"));
var _superset = _interopRequireDefault(require("./superset.js"));
var _union = _interopRequireDefault(require("./union.js"));
var _internmap = require("internmap");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
},{"./bisect.js":"../node_modules/d3-array/src/bisect.js","./ascending.js":"../node_modules/d3-array/src/ascending.js","./bisector.js":"../node_modules/d3-array/src/bisector.js","./blur.js":"../node_modules/d3-array/src/blur.js","./count.js":"../node_modules/d3-array/src/count.js","./cross.js":"../node_modules/d3-array/src/cross.js","./cumsum.js":"../node_modules/d3-array/src/cumsum.js","./descending.js":"../node_modules/d3-array/src/descending.js","./deviation.js":"../node_modules/d3-array/src/deviation.js","./extent.js":"../node_modules/d3-array/src/extent.js","./fsum.js":"../node_modules/d3-array/src/fsum.js","./group.js":"../node_modules/d3-array/src/group.js","./groupSort.js":"../node_modules/d3-array/src/groupSort.js","./bin.js":"../node_modules/d3-array/src/bin.js","./threshold/freedmanDiaconis.js":"../node_modules/d3-array/src/threshold/freedmanDiaconis.js","./threshold/scott.js":"../node_modules/d3-array/src/threshold/scott.js","./threshold/sturges.js":"../node_modules/d3-array/src/threshold/sturges.js","./max.js":"../node_modules/d3-array/src/max.js","./maxIndex.js":"../node_modules/d3-array/src/maxIndex.js","./mean.js":"../node_modules/d3-array/src/mean.js","./median.js":"../node_modules/d3-array/src/median.js","./merge.js":"../node_modules/d3-array/src/merge.js","./min.js":"../node_modules/d3-array/src/min.js","./minIndex.js":"../node_modules/d3-array/src/minIndex.js","./mode.js":"../node_modules/d3-array/src/mode.js","./nice.js":"../node_modules/d3-array/src/nice.js","./pairs.js":"../node_modules/d3-array/src/pairs.js","./permute.js":"../node_modules/d3-array/src/permute.js","./quantile.js":"../node_modules/d3-array/src/quantile.js","./quickselect.js":"../node_modules/d3-array/src/quickselect.js","./range.js":"../node_modules/d3-array/src/range.js","./rank.js":"../node_modules/d3-array/src/rank.js","./least.js":"../node_modules/d3-array/src/least.js","./leastIndex.js":"../node_modules/d3-array/src/leastIndex.js","./greatest.js":"../node_modules/d3-array/src/greatest.js","./greatestIndex.js":"../node_modules/d3-array/src/greatestIndex.js","./scan.js":"../node_modules/d3-array/src/scan.js","./shuffle.js":"../node_modules/d3-array/src/shuffle.js","./sum.js":"../node_modules/d3-array/src/sum.js","./ticks.js":"../node_modules/d3-array/src/ticks.js","./transpose.js":"../node_modules/d3-array/src/transpose.js","./variance.js":"../node_modules/d3-array/src/variance.js","./zip.js":"../node_modules/d3-array/src/zip.js","./every.js":"../node_modules/d3-array/src/every.js","./some.js":"../node_modules/d3-array/src/some.js","./filter.js":"../node_modules/d3-array/src/filter.js","./map.js":"../node_modules/d3-array/src/map.js","./reduce.js":"../node_modules/d3-array/src/reduce.js","./reverse.js":"../node_modules/d3-array/src/reverse.js","./sort.js":"../node_modules/d3-array/src/sort.js","./difference.js":"../node_modules/d3-array/src/difference.js","./disjoint.js":"../node_modules/d3-array/src/disjoint.js","./intersection.js":"../node_modules/d3-array/src/intersection.js","./subset.js":"../node_modules/d3-array/src/subset.js","./superset.js":"../node_modules/d3-array/src/superset.js","./union.js":"../node_modules/d3-array/src/union.js","internmap":"../node_modules/internmap/src/index.js"}],"../node_modules/d3-scale/src/init.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initInterpolator = initInterpolator;
exports.initRange = initRange;
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      {
        if (typeof domain === "function") this.interpolator(domain);else this.range(domain);
        break;
      }
    default:
      {
        this.domain(domain);
        if (typeof interpolator === "function") this.interpolator(interpolator);else this.range(interpolator);
        break;
      }
  }
  return this;
}
},{}],"../node_modules/d3-scale/src/ordinal.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ordinal;
exports.implicit = void 0;
var _d3Array = require("d3-array");
var _init = require("./init.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var implicit = exports.implicit = Symbol("implicit");
function ordinal() {
  var index = new _d3Array.InternMap(),
    domain = [],
    range = [],
    unknown = implicit;
  function scale(d) {
    var i = index.get(d);
    if (i === undefined) {
      if (unknown !== implicit) return unknown;
      index.set(d, i = domain.push(d) - 1);
    }
    return range[i % range.length];
  }
  scale.domain = function (_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new _d3Array.InternMap();
    var _iterator = _createForOfIteratorHelper(_),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        if (index.has(value)) continue;
        index.set(value, domain.push(value) - 1);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return scale;
  };
  scale.range = function (_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };
  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function () {
    return ordinal(domain, range).unknown(unknown);
  };
  _init.initRange.apply(scale, arguments);
  return scale;
}
},{"d3-array":"../node_modules/d3-array/src/index.js","./init.js":"../node_modules/d3-scale/src/init.js"}],"../node_modules/d3-scale/src/band.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = band;
exports.point = point;
var _d3Array = require("d3-array");
var _init = require("./init.js");
var _ordinal = _interopRequireDefault(require("./ordinal.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function band() {
  var scale = (0, _ordinal.default)().unknown(undefined),
    domain = scale.domain,
    ordinalRange = scale.range,
    r0 = 0,
    r1 = 1,
    step,
    bandwidth,
    round = false,
    paddingInner = 0,
    paddingOuter = 0,
    align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n = domain().length,
      reverse = r1 < r0,
      start = reverse ? r1 : r0,
      stop = reverse ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = (0, _d3Array.range)(n).map(function (i) {
      return start + step * i;
    });
    return ordinalRange(reverse ? values.reverse() : values);
  }
  scale.domain = function (_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.range = function (_) {
    var _ref;
    return arguments.length ? ((_ref = _slicedToArray(_, 2), r0 = _ref[0], r1 = _ref[1]), r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function (_) {
    var _ref2;
    return (_ref2 = _slicedToArray(_, 2), r0 = _ref2[0], r1 = _ref2[1]), r0 = +r0, r1 = +r1, round = true, rescale();
  };
  scale.bandwidth = function () {
    return bandwidth;
  };
  scale.step = function () {
    return step;
  };
  scale.round = function (_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };
  scale.padding = function (_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale.paddingInner = function (_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale.paddingOuter = function (_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale.align = function (_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale.copy = function () {
    return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return _init.initRange.apply(rescale(), arguments);
}
function pointish(scale) {
  var copy = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;
  scale.copy = function () {
    return pointish(copy());
  };
  return scale;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}
},{"d3-array":"../node_modules/d3-array/src/index.js","./init.js":"../node_modules/d3-scale/src/init.js","./ordinal.js":"../node_modules/d3-scale/src/ordinal.js"}],"../node_modules/d3-scale/src/constant.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = constants;
function constants(x) {
  return function () {
    return x;
  };
}
},{}],"../node_modules/d3-scale/src/number.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = number;
function number(x) {
  return +x;
}
},{}],"../node_modules/d3-scale/src/continuous.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copy = copy;
exports.default = continuous;
exports.identity = identity;
exports.transformer = transformer;
var _d3Array = require("d3-array");
var _d3Interpolate = require("d3-interpolate");
var _constant = _interopRequireDefault(require("./constant.js"));
var _number = _interopRequireDefault(require("./number.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var unit = [0, 1];
function identity(x) {
  return x;
}
function normalize(a, b) {
  return (b -= a = +a) ? function (x) {
    return (x - a) / b;
  } : (0, _constant.default)(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function (x) {
    return Math.max(a, Math.min(b, x));
  };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0],
    d1 = domain[1],
    r0 = range[0],
    r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function (x) {
    return r0(d0(x));
  };
}
function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
    d = new Array(j),
    r = new Array(j),
    i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }
  return function (x) {
    var i = (0, _d3Array.bisect)(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit,
    range = unit,
    interpolate = _d3Interpolate.interpolate,
    transform,
    untransform,
    unknown,
    clamp = identity,
    piecewise,
    output,
    input;
  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }
  scale.invert = function (y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), _d3Interpolate.interpolateNumber)))(y)));
  };
  scale.domain = function (_) {
    return arguments.length ? (domain = Array.from(_, _number.default), rescale()) : domain.slice();
  };
  scale.range = function (_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };
  scale.rangeRound = function (_) {
    return range = Array.from(_), interpolate = _d3Interpolate.interpolateRound, rescale();
  };
  scale.clamp = function (_) {
    return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
  };
  scale.interpolate = function (_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function (t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity, identity);
}
},{"d3-array":"../node_modules/d3-array/src/index.js","d3-interpolate":"../node_modules/d3-interpolate/src/index.js","./constant.js":"../node_modules/d3-scale/src/constant.js","./number.js":"../node_modules/d3-scale/src/number.js"}],"../node_modules/d3-format/src/formatDecimal.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.formatDecimalParts = formatDecimalParts;
function _default(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i,
    coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1)];
}
},{}],"../node_modules/d3-format/src/exponent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _formatDecimal = require("./formatDecimal.js");
function _default(x) {
  return x = (0, _formatDecimal.formatDecimalParts)(Math.abs(x)), x ? x[1] : NaN;
}
},{"./formatDecimal.js":"../node_modules/d3-format/src/formatDecimal.js"}],"../node_modules/d3-format/src/formatGroup.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(grouping, thousands) {
  return function (value, width) {
    var i = value.length,
      t = [],
      j = 0,
      g = grouping[0],
      length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
},{}],"../node_modules/d3-format/src/formatNumerals.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(numerals) {
  return function (value) {
    return value.replace(/[0-9]/g, function (i) {
      return numerals[+i];
    });
  };
}
},{}],"../node_modules/d3-format/src/formatSpecifier.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormatSpecifier = FormatSpecifier;
exports.default = formatSpecifier;
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function () {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === undefined ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
},{}],"../node_modules/d3-format/src/formatTrim.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function _default(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}
},{}],"../node_modules/d3-format/src/formatPrefixAuto.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.prefixExponent = void 0;
var _formatDecimal = require("./formatDecimal.js");
var prefixExponent;
function _default(x, p) {
  var d = (0, _formatDecimal.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
    exponent = d[1],
    i = exponent - (exports.prefixExponent = prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
    n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + (0, _formatDecimal.formatDecimalParts)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}
},{"./formatDecimal.js":"../node_modules/d3-format/src/formatDecimal.js"}],"../node_modules/d3-format/src/formatRounded.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _formatDecimal = require("./formatDecimal.js");
function _default(x, p) {
  var d = (0, _formatDecimal.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
    exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}
},{"./formatDecimal.js":"../node_modules/d3-format/src/formatDecimal.js"}],"../node_modules/d3-format/src/formatTypes.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _formatDecimal = _interopRequireDefault(require("./formatDecimal.js"));
var _formatPrefixAuto = _interopRequireDefault(require("./formatPrefixAuto.js"));
var _formatRounded = _interopRequireDefault(require("./formatRounded.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports.default = {
  "%": function _(x, p) {
    return (x * 100).toFixed(p);
  },
  "b": function b(x) {
    return Math.round(x).toString(2);
  },
  "c": function c(x) {
    return x + "";
  },
  "d": _formatDecimal.default,
  "e": function e(x, p) {
    return x.toExponential(p);
  },
  "f": function f(x, p) {
    return x.toFixed(p);
  },
  "g": function g(x, p) {
    return x.toPrecision(p);
  },
  "o": function o(x) {
    return Math.round(x).toString(8);
  },
  "p": function p(x, _p) {
    return (0, _formatRounded.default)(x * 100, _p);
  },
  "r": _formatRounded.default,
  "s": _formatPrefixAuto.default,
  "X": function X(x) {
    return Math.round(x).toString(16).toUpperCase();
  },
  "x": function x(_x) {
    return Math.round(_x).toString(16);
  }
};
},{"./formatDecimal.js":"../node_modules/d3-format/src/formatDecimal.js","./formatPrefixAuto.js":"../node_modules/d3-format/src/formatPrefixAuto.js","./formatRounded.js":"../node_modules/d3-format/src/formatRounded.js"}],"../node_modules/d3-format/src/identity.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(x) {
  return x;
}
},{}],"../node_modules/d3-format/src/locale.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _exponent = _interopRequireDefault(require("./exponent.js"));
var _formatGroup = _interopRequireDefault(require("./formatGroup.js"));
var _formatNumerals = _interopRequireDefault(require("./formatNumerals.js"));
var _formatSpecifier = _interopRequireDefault(require("./formatSpecifier.js"));
var _formatTrim = _interopRequireDefault(require("./formatTrim.js"));
var _formatTypes = _interopRequireDefault(require("./formatTypes.js"));
var _formatPrefixAuto = require("./formatPrefixAuto.js");
var _identity = _interopRequireDefault(require("./identity.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var map = Array.prototype.map,
  prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function _default(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity.default : (0, _formatGroup.default)(map.call(locale.grouping, Number), locale.thousands + ""),
    currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
    currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
    decimal = locale.decimal === undefined ? "." : locale.decimal + "",
    numerals = locale.numerals === undefined ? _identity.default : (0, _formatNumerals.default)(map.call(locale.numerals, String)),
    percent = locale.percent === undefined ? "%" : locale.percent + "",
    minus = locale.minus === undefined ? "−" : locale.minus + "",
    nan = locale.nan === undefined ? "NaN" : locale.nan + "";
  function newFormat(specifier) {
    specifier = (0, _formatSpecifier.default)(specifier);
    var fill = specifier.fill,
      align = specifier.align,
      sign = specifier.sign,
      symbol = specifier.symbol,
      zero = specifier.zero,
      width = specifier.width,
      comma = specifier.comma,
      precision = specifier.precision,
      trim = specifier.trim,
      type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes.default[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
      suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes.default[type],
      maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format(value) {
      var valuePrefix = prefix,
        valueSuffix = suffix,
        i,
        n,
        c;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = (0, _formatTrim.default)(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
        padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format.toString = function () {
      return specifier + "";
    };
    return format;
  }
  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0, _formatSpecifier.default)(specifier), specifier.type = "f", specifier)),
      e = Math.max(-8, Math.min(8, Math.floor((0, _exponent.default)(value) / 3))) * 3,
      k = Math.pow(10, -e),
      prefix = prefixes[8 + e / 3];
    return function (value) {
      return f(k * value) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}
},{"./exponent.js":"../node_modules/d3-format/src/exponent.js","./formatGroup.js":"../node_modules/d3-format/src/formatGroup.js","./formatNumerals.js":"../node_modules/d3-format/src/formatNumerals.js","./formatSpecifier.js":"../node_modules/d3-format/src/formatSpecifier.js","./formatTrim.js":"../node_modules/d3-format/src/formatTrim.js","./formatTypes.js":"../node_modules/d3-format/src/formatTypes.js","./formatPrefixAuto.js":"../node_modules/d3-format/src/formatPrefixAuto.js","./identity.js":"../node_modules/d3-format/src/identity.js"}],"../node_modules/d3-format/src/defaultLocale.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defaultLocale;
exports.formatPrefix = exports.format = void 0;
var _locale = _interopRequireDefault(require("./locale.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = (0, _locale.default)(definition);
  exports.format = format = locale.format;
  exports.formatPrefix = formatPrefix = locale.formatPrefix;
  return locale;
}
},{"./locale.js":"../node_modules/d3-format/src/locale.js"}],"../node_modules/d3-format/src/precisionFixed.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _exponent = _interopRequireDefault(require("./exponent.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(step) {
  return Math.max(0, -(0, _exponent.default)(Math.abs(step)));
}
},{"./exponent.js":"../node_modules/d3-format/src/exponent.js"}],"../node_modules/d3-format/src/precisionPrefix.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _exponent = _interopRequireDefault(require("./exponent.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0, _exponent.default)(value) / 3))) * 3 - (0, _exponent.default)(Math.abs(step)));
}
},{"./exponent.js":"../node_modules/d3-format/src/exponent.js"}],"../node_modules/d3-format/src/precisionRound.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _exponent = _interopRequireDefault(require("./exponent.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, (0, _exponent.default)(max) - (0, _exponent.default)(step)) + 1;
}
},{"./exponent.js":"../node_modules/d3-format/src/exponent.js"}],"../node_modules/d3-format/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "FormatSpecifier", {
  enumerable: true,
  get: function () {
    return _formatSpecifier.FormatSpecifier;
  }
});
Object.defineProperty(exports, "format", {
  enumerable: true,
  get: function () {
    return _defaultLocale.format;
  }
});
Object.defineProperty(exports, "formatDefaultLocale", {
  enumerable: true,
  get: function () {
    return _defaultLocale.default;
  }
});
Object.defineProperty(exports, "formatLocale", {
  enumerable: true,
  get: function () {
    return _locale.default;
  }
});
Object.defineProperty(exports, "formatPrefix", {
  enumerable: true,
  get: function () {
    return _defaultLocale.formatPrefix;
  }
});
Object.defineProperty(exports, "formatSpecifier", {
  enumerable: true,
  get: function () {
    return _formatSpecifier.default;
  }
});
Object.defineProperty(exports, "precisionFixed", {
  enumerable: true,
  get: function () {
    return _precisionFixed.default;
  }
});
Object.defineProperty(exports, "precisionPrefix", {
  enumerable: true,
  get: function () {
    return _precisionPrefix.default;
  }
});
Object.defineProperty(exports, "precisionRound", {
  enumerable: true,
  get: function () {
    return _precisionRound.default;
  }
});
var _defaultLocale = _interopRequireWildcard(require("./defaultLocale.js"));
var _locale = _interopRequireDefault(require("./locale.js"));
var _formatSpecifier = _interopRequireWildcard(require("./formatSpecifier.js"));
var _precisionFixed = _interopRequireDefault(require("./precisionFixed.js"));
var _precisionPrefix = _interopRequireDefault(require("./precisionPrefix.js"));
var _precisionRound = _interopRequireDefault(require("./precisionRound.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
},{"./defaultLocale.js":"../node_modules/d3-format/src/defaultLocale.js","./locale.js":"../node_modules/d3-format/src/locale.js","./formatSpecifier.js":"../node_modules/d3-format/src/formatSpecifier.js","./precisionFixed.js":"../node_modules/d3-format/src/precisionFixed.js","./precisionPrefix.js":"../node_modules/d3-format/src/precisionPrefix.js","./precisionRound.js":"../node_modules/d3-format/src/precisionRound.js"}],"../node_modules/d3-scale/src/tickFormat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = tickFormat;
var _d3Array = require("d3-array");
var _d3Format = require("d3-format");
function tickFormat(start, stop, count, specifier) {
  var step = (0, _d3Array.tickStep)(start, stop, count),
    precision;
  specifier = (0, _d3Format.formatSpecifier)(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s":
      {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = (0, _d3Format.precisionPrefix)(step, value))) specifier.precision = precision;
        return (0, _d3Format.formatPrefix)(specifier, value);
      }
    case "":
    case "e":
    case "g":
    case "p":
    case "r":
      {
        if (specifier.precision == null && !isNaN(precision = (0, _d3Format.precisionRound)(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
    case "f":
    case "%":
      {
        if (specifier.precision == null && !isNaN(precision = (0, _d3Format.precisionFixed)(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
  }
  return (0, _d3Format.format)(specifier);
}
},{"d3-array":"../node_modules/d3-array/src/index.js","d3-format":"../node_modules/d3-format/src/index.js"}],"../node_modules/d3-scale/src/linear.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = linear;
exports.linearish = linearish;
var _d3Array = require("d3-array");
var _continuous = _interopRequireWildcard(require("./continuous.js"));
var _init = require("./init.js");
var _tickFormat = _interopRequireDefault(require("./tickFormat.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function (count) {
    var d = domain();
    return (0, _d3Array.ticks)(d[0], d[d.length - 1], count == null ? 10 : count);
  };
  scale.tickFormat = function (count, specifier) {
    var d = domain();
    return (0, _tickFormat.default)(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };
  scale.nice = function (count) {
    if (count == null) count = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = (0, _d3Array.tickIncrement)(start, stop, count);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = (0, _continuous.default)();
  scale.copy = function () {
    return (0, _continuous.copy)(scale, linear());
  };
  _init.initRange.apply(scale, arguments);
  return linearish(scale);
}
},{"d3-array":"../node_modules/d3-array/src/index.js","./continuous.js":"../node_modules/d3-scale/src/continuous.js","./init.js":"../node_modules/d3-scale/src/init.js","./tickFormat.js":"../node_modules/d3-scale/src/tickFormat.js"}],"../node_modules/d3-scale/src/identity.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = identity;
var _linear = require("./linear.js");
var _number = _interopRequireDefault(require("./number.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function identity(domain) {
  var unknown;
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : x;
  }
  scale.invert = scale;
  scale.domain = scale.range = function (_) {
    return arguments.length ? (domain = Array.from(_, _number.default), scale) : domain.slice();
  };
  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function () {
    return identity(domain).unknown(unknown);
  };
  domain = arguments.length ? Array.from(domain, _number.default) : [0, 1];
  return (0, _linear.linearish)(scale);
}
},{"./linear.js":"../node_modules/d3-scale/src/linear.js","./number.js":"../node_modules/d3-scale/src/number.js"}],"../node_modules/d3-scale/src/nice.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = nice;
function nice(domain, interval) {
  domain = domain.slice();
  var i0 = 0,
    i1 = domain.length - 1,
    x0 = domain[i0],
    x1 = domain[i1],
    t;
  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }
  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}
},{}],"../node_modules/d3-scale/src/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = log;
exports.loggish = loggish;
var _d3Array = require("d3-array");
var _d3Format = require("d3-format");
var _nice = _interopRequireDefault(require("./nice.js"));
var _continuous = require("./continuous.js");
var _init = require("./init.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function transformLog(x) {
  return Math.log(x);
}
function transformExp(x) {
  return Math.exp(x);
}
function transformLogn(x) {
  return -Math.log(-x);
}
function transformExpn(x) {
  return -Math.exp(-x);
}
function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {
    return Math.pow(base, x);
  };
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function (x) {
    return Math.log(x) / base;
  });
}
function reflect(f) {
  return function (x, k) {
    return -f(-x, k);
  };
}
function loggish(transform) {
  var scale = transform(transformLog, transformExp);
  var domain = scale.domain;
  var base = 10;
  var logs;
  var pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function (_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };
  scale.domain = function (_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.ticks = function (count) {
    var d = domain();
    var u = d[0];
    var v = d[d.length - 1];
    var r = v < u;
    if (r) {
      var _ref = [v, u];
      u = _ref[0];
      v = _ref[1];
    }
    var i = logs(u);
    var j = logs(v);
    var k;
    var t;
    var n = count == null ? 10 : +count;
    var z = [];
    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k = 1; k < base; ++k) {
          t = i < 0 ? k / pows(-i) : k * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i <= j; ++i) {
        for (k = base - 1; k >= 1; --k) {
          t = i > 0 ? k / pows(-i) : k * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = (0, _d3Array.ticks)(u, v, n);
    } else {
      z = (0, _d3Array.ticks)(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale.tickFormat = function (count, specifier) {
    if (count == null) count = 10;
    if (specifier == null) specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = (0, _d3Format.formatSpecifier)(specifier)).precision == null) specifier.trim = true;
      specifier = (0, _d3Format.format)(specifier);
    }
    if (count === Infinity) return specifier;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function (d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };
  scale.nice = function () {
    return domain((0, _nice.default)(domain(), {
      floor: function floor(x) {
        return pows(Math.floor(logs(x)));
      },
      ceil: function ceil(x) {
        return pows(Math.ceil(logs(x)));
      }
    }));
  };
  return scale;
}
function log() {
  var scale = loggish((0, _continuous.transformer)()).domain([1, 10]);
  scale.copy = function () {
    return (0, _continuous.copy)(scale, log()).base(scale.base());
  };
  _init.initRange.apply(scale, arguments);
  return scale;
}
},{"d3-array":"../node_modules/d3-array/src/index.js","d3-format":"../node_modules/d3-format/src/index.js","./nice.js":"../node_modules/d3-scale/src/nice.js","./continuous.js":"../node_modules/d3-scale/src/continuous.js","./init.js":"../node_modules/d3-scale/src/init.js"}],"../node_modules/d3-scale/src/symlog.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = symlog;
exports.symlogish = symlogish;
var _linear = require("./linear.js");
var _continuous = require("./continuous.js");
var _init = require("./init.js");
function transformSymlog(c) {
  return function (x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}
function transformSymexp(c) {
  return function (x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}
function symlogish(transform) {
  var c = 1,
    scale = transform(transformSymlog(c), transformSymexp(c));
  scale.constant = function (_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };
  return (0, _linear.linearish)(scale);
}
function symlog() {
  var scale = symlogish((0, _continuous.transformer)());
  scale.copy = function () {
    return (0, _continuous.copy)(scale, symlog()).constant(scale.constant());
  };
  return _init.initRange.apply(scale, arguments);
}
},{"./linear.js":"../node_modules/d3-scale/src/linear.js","./continuous.js":"../node_modules/d3-scale/src/continuous.js","./init.js":"../node_modules/d3-scale/src/init.js"}],"../node_modules/d3-scale/src/pow.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pow;
exports.powish = powish;
exports.sqrt = sqrt;
var _linear = require("./linear.js");
var _continuous = require("./continuous.js");
var _init = require("./init.js");
function transformPow(exponent) {
  return function (x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}
function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}
function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}
function powish(transform) {
  var scale = transform(_continuous.identity, _continuous.identity),
    exponent = 1;
  function rescale() {
    return exponent === 1 ? transform(_continuous.identity, _continuous.identity) : exponent === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent), transformPow(1 / exponent));
  }
  scale.exponent = function (_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };
  return (0, _linear.linearish)(scale);
}
function pow() {
  var scale = powish((0, _continuous.transformer)());
  scale.copy = function () {
    return (0, _continuous.copy)(scale, pow()).exponent(scale.exponent());
  };
  _init.initRange.apply(scale, arguments);
  return scale;
}
function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}
},{"./linear.js":"../node_modules/d3-scale/src/linear.js","./continuous.js":"../node_modules/d3-scale/src/continuous.js","./init.js":"../node_modules/d3-scale/src/init.js"}],"../node_modules/d3-scale/src/radial.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = radial;
var _continuous = _interopRequireDefault(require("./continuous.js"));
var _init = require("./init.js");
var _linear = require("./linear.js");
var _number = _interopRequireDefault(require("./number.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function square(x) {
  return Math.sign(x) * x * x;
}
function unsquare(x) {
  return Math.sign(x) * Math.sqrt(Math.abs(x));
}
function radial() {
  var squared = (0, _continuous.default)(),
    range = [0, 1],
    round = false,
    unknown;
  function scale(x) {
    var y = unsquare(squared(x));
    return isNaN(y) ? unknown : round ? Math.round(y) : y;
  }
  scale.invert = function (y) {
    return squared.invert(square(y));
  };
  scale.domain = function (_) {
    return arguments.length ? (squared.domain(_), scale) : squared.domain();
  };
  scale.range = function (_) {
    return arguments.length ? (squared.range((range = Array.from(_, _number.default)).map(square)), scale) : range.slice();
  };
  scale.rangeRound = function (_) {
    return scale.range(_).round(true);
  };
  scale.round = function (_) {
    return arguments.length ? (round = !!_, scale) : round;
  };
  scale.clamp = function (_) {
    return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
  };
  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function () {
    return radial(squared.domain(), range).round(round).clamp(squared.clamp()).unknown(unknown);
  };
  _init.initRange.apply(scale, arguments);
  return (0, _linear.linearish)(scale);
}
},{"./continuous.js":"../node_modules/d3-scale/src/continuous.js","./init.js":"../node_modules/d3-scale/src/init.js","./linear.js":"../node_modules/d3-scale/src/linear.js","./number.js":"../node_modules/d3-scale/src/number.js"}],"../node_modules/d3-scale/src/quantile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quantile;
var _d3Array = require("d3-array");
var _init = require("./init.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function quantile() {
  var domain = [],
    range = [],
    thresholds = [],
    unknown;
  function rescale() {
    var i = 0,
      n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = (0, _d3Array.quantileSorted)(domain, i / n);
    return scale;
  }
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : range[(0, _d3Array.bisect)(thresholds, x)];
  }
  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [i > 0 ? thresholds[i - 1] : domain[0], i < thresholds.length ? thresholds[i] : domain[domain.length - 1]];
  };
  scale.domain = function (_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    var _iterator = _createForOfIteratorHelper(_),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var d = _step.value;
        if (d != null && !isNaN(d = +d)) domain.push(d);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    domain.sort(_d3Array.ascending);
    return rescale();
  };
  scale.range = function (_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };
  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.quantiles = function () {
    return thresholds.slice();
  };
  scale.copy = function () {
    return quantile().domain(domain).range(range).unknown(unknown);
  };
  return _init.initRange.apply(scale, arguments);
}
},{"d3-array":"../node_modules/d3-array/src/index.js","./init.js":"../node_modules/d3-scale/src/init.js"}],"../node_modules/d3-scale/src/quantize.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quantize;
var _d3Array = require("d3-array");
var _linear = require("./linear.js");
var _init = require("./init.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function quantize() {
  var x0 = 0,
    x1 = 1,
    n = 1,
    domain = [0.5],
    range = [0, 1],
    unknown;
  function scale(x) {
    return x != null && x <= x ? range[(0, _d3Array.bisect)(domain, x, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }
  scale.domain = function (_) {
    var _ref;
    return arguments.length ? ((_ref = _slicedToArray(_, 2), x0 = _ref[0], x1 = _ref[1]), x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };
  scale.range = function (_) {
    return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
  };
  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
  };
  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };
  scale.thresholds = function () {
    return domain.slice();
  };
  scale.copy = function () {
    return quantize().domain([x0, x1]).range(range).unknown(unknown);
  };
  return _init.initRange.apply((0, _linear.linearish)(scale), arguments);
}
},{"d3-array":"../node_modules/d3-array/src/index.js","./linear.js":"../node_modules/d3-scale/src/linear.js","./init.js":"../node_modules/d3-scale/src/init.js"}],"../node_modules/d3-scale/src/threshold.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = threshold;
var _d3Array = require("d3-array");
var _init = require("./init.js");
function threshold() {
  var domain = [0.5],
    range = [0, 1],
    unknown,
    n = 1;
  function scale(x) {
    return x != null && x <= x ? range[(0, _d3Array.bisect)(domain, x, 0, n)] : unknown;
  }
  scale.domain = function (_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };
  scale.range = function (_) {
    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };
  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };
  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function () {
    return threshold().domain(domain).range(range).unknown(unknown);
  };
  return _init.initRange.apply(scale, arguments);
}
},{"d3-array":"../node_modules/d3-array/src/index.js","./init.js":"../node_modules/d3-scale/src/init.js"}],"../node_modules/d3-time/src/interval.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timeInterval = timeInterval;
var t0 = new Date(),
  t1 = new Date();
function timeInterval(floori, offseti, count, field) {
  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date() : new Date(+date)), date;
  }
  interval.floor = function (date) {
    return floori(date = new Date(+date)), date;
  };
  interval.ceil = function (date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };
  interval.round = function (date) {
    var d0 = interval(date),
      d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };
  interval.offset = function (date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };
  interval.range = function (start, stop, step) {
    var range = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    var previous;
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start); while (previous < start && start < stop);
    return range;
  };
  interval.filter = function (test) {
    return timeInterval(function (date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function (date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };
  if (count) {
    interval.count = function (start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };
    interval.every = function (step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function (d) {
        return field(d) % step === 0;
      } : function (d) {
        return interval.count(0, d) % step === 0;
      });
    };
  }
  return interval;
}
},{}],"../node_modules/d3-time/src/millisecond.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.milliseconds = exports.millisecond = void 0;
var _interval = require("./interval.js");
var millisecond = exports.millisecond = (0, _interval.timeInterval)(function () {
  // noop
}, function (date, step) {
  date.setTime(+date + step);
}, function (start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function (k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return (0, _interval.timeInterval)(function (date) {
    date.setTime(Math.floor(date / k) * k);
  }, function (date, step) {
    date.setTime(+date + step * k);
  }, function (start, end) {
    return (end - start) / k;
  });
};
var milliseconds = exports.milliseconds = millisecond.range;
},{"./interval.js":"../node_modules/d3-time/src/interval.js"}],"../node_modules/d3-time/src/duration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.durationYear = exports.durationWeek = exports.durationSecond = exports.durationMonth = exports.durationMinute = exports.durationHour = exports.durationDay = void 0;
var durationSecond = exports.durationSecond = 1000;
var durationMinute = exports.durationMinute = durationSecond * 60;
var durationHour = exports.durationHour = durationMinute * 60;
var durationDay = exports.durationDay = durationHour * 24;
var durationWeek = exports.durationWeek = durationDay * 7;
var durationMonth = exports.durationMonth = durationDay * 30;
var durationYear = exports.durationYear = durationDay * 365;
},{}],"../node_modules/d3-time/src/second.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.seconds = exports.second = void 0;
var _interval = require("./interval.js");
var _duration = require("./duration.js");
var second = exports.second = (0, _interval.timeInterval)(function (date) {
  date.setTime(date - date.getMilliseconds());
}, function (date, step) {
  date.setTime(+date + step * _duration.durationSecond);
}, function (start, end) {
  return (end - start) / _duration.durationSecond;
}, function (date) {
  return date.getUTCSeconds();
});
var seconds = exports.seconds = second.range;
},{"./interval.js":"../node_modules/d3-time/src/interval.js","./duration.js":"../node_modules/d3-time/src/duration.js"}],"../node_modules/d3-time/src/minute.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcMinutes = exports.utcMinute = exports.timeMinutes = exports.timeMinute = void 0;
var _interval = require("./interval.js");
var _duration = require("./duration.js");
var timeMinute = exports.timeMinute = (0, _interval.timeInterval)(function (date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration.durationSecond);
}, function (date, step) {
  date.setTime(+date + step * _duration.durationMinute);
}, function (start, end) {
  return (end - start) / _duration.durationMinute;
}, function (date) {
  return date.getMinutes();
});
var timeMinutes = exports.timeMinutes = timeMinute.range;
var utcMinute = exports.utcMinute = (0, _interval.timeInterval)(function (date) {
  date.setUTCSeconds(0, 0);
}, function (date, step) {
  date.setTime(+date + step * _duration.durationMinute);
}, function (start, end) {
  return (end - start) / _duration.durationMinute;
}, function (date) {
  return date.getUTCMinutes();
});
var utcMinutes = exports.utcMinutes = utcMinute.range;
},{"./interval.js":"../node_modules/d3-time/src/interval.js","./duration.js":"../node_modules/d3-time/src/duration.js"}],"../node_modules/d3-time/src/hour.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcHours = exports.utcHour = exports.timeHours = exports.timeHour = void 0;
var _interval = require("./interval.js");
var _duration = require("./duration.js");
var timeHour = exports.timeHour = (0, _interval.timeInterval)(function (date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration.durationSecond - date.getMinutes() * _duration.durationMinute);
}, function (date, step) {
  date.setTime(+date + step * _duration.durationHour);
}, function (start, end) {
  return (end - start) / _duration.durationHour;
}, function (date) {
  return date.getHours();
});
var timeHours = exports.timeHours = timeHour.range;
var utcHour = exports.utcHour = (0, _interval.timeInterval)(function (date) {
  date.setUTCMinutes(0, 0, 0);
}, function (date, step) {
  date.setTime(+date + step * _duration.durationHour);
}, function (start, end) {
  return (end - start) / _duration.durationHour;
}, function (date) {
  return date.getUTCHours();
});
var utcHours = exports.utcHours = utcHour.range;
},{"./interval.js":"../node_modules/d3-time/src/interval.js","./duration.js":"../node_modules/d3-time/src/duration.js"}],"../node_modules/d3-time/src/day.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcDays = exports.utcDay = exports.unixDays = exports.unixDay = exports.timeDays = exports.timeDay = void 0;
var _interval = require("./interval.js");
var _duration = require("./duration.js");
var timeDay = exports.timeDay = (0, _interval.timeInterval)(function (date) {
  return date.setHours(0, 0, 0, 0);
}, function (date, step) {
  return date.setDate(date.getDate() + step);
}, function (start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration.durationMinute) / _duration.durationDay;
}, function (date) {
  return date.getDate() - 1;
});
var timeDays = exports.timeDays = timeDay.range;
var utcDay = exports.utcDay = (0, _interval.timeInterval)(function (date) {
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function (start, end) {
  return (end - start) / _duration.durationDay;
}, function (date) {
  return date.getUTCDate() - 1;
});
var utcDays = exports.utcDays = utcDay.range;
var unixDay = exports.unixDay = (0, _interval.timeInterval)(function (date) {
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function (start, end) {
  return (end - start) / _duration.durationDay;
}, function (date) {
  return Math.floor(date / _duration.durationDay);
});
var unixDays = exports.unixDays = unixDay.range;
},{"./interval.js":"../node_modules/d3-time/src/interval.js","./duration.js":"../node_modules/d3-time/src/duration.js"}],"../node_modules/d3-time/src/week.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcWednesdays = exports.utcWednesday = exports.utcTuesdays = exports.utcTuesday = exports.utcThursdays = exports.utcThursday = exports.utcSundays = exports.utcSunday = exports.utcSaturdays = exports.utcSaturday = exports.utcMondays = exports.utcMonday = exports.utcFridays = exports.utcFriday = exports.timeWednesdays = exports.timeWednesday = exports.timeTuesdays = exports.timeTuesday = exports.timeThursdays = exports.timeThursday = exports.timeSundays = exports.timeSunday = exports.timeSaturdays = exports.timeSaturday = exports.timeMondays = exports.timeMonday = exports.timeFridays = exports.timeFriday = void 0;
var _interval = require("./interval.js");
var _duration = require("./duration.js");
function timeWeekday(i) {
  return (0, _interval.timeInterval)(function (date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function (start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration.durationMinute) / _duration.durationWeek;
  });
}
var timeSunday = exports.timeSunday = timeWeekday(0);
var timeMonday = exports.timeMonday = timeWeekday(1);
var timeTuesday = exports.timeTuesday = timeWeekday(2);
var timeWednesday = exports.timeWednesday = timeWeekday(3);
var timeThursday = exports.timeThursday = timeWeekday(4);
var timeFriday = exports.timeFriday = timeWeekday(5);
var timeSaturday = exports.timeSaturday = timeWeekday(6);
var timeSundays = exports.timeSundays = timeSunday.range;
var timeMondays = exports.timeMondays = timeMonday.range;
var timeTuesdays = exports.timeTuesdays = timeTuesday.range;
var timeWednesdays = exports.timeWednesdays = timeWednesday.range;
var timeThursdays = exports.timeThursdays = timeThursday.range;
var timeFridays = exports.timeFridays = timeFriday.range;
var timeSaturdays = exports.timeSaturdays = timeSaturday.range;
function utcWeekday(i) {
  return (0, _interval.timeInterval)(function (date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function (start, end) {
    return (end - start) / _duration.durationWeek;
  });
}
var utcSunday = exports.utcSunday = utcWeekday(0);
var utcMonday = exports.utcMonday = utcWeekday(1);
var utcTuesday = exports.utcTuesday = utcWeekday(2);
var utcWednesday = exports.utcWednesday = utcWeekday(3);
var utcThursday = exports.utcThursday = utcWeekday(4);
var utcFriday = exports.utcFriday = utcWeekday(5);
var utcSaturday = exports.utcSaturday = utcWeekday(6);
var utcSundays = exports.utcSundays = utcSunday.range;
var utcMondays = exports.utcMondays = utcMonday.range;
var utcTuesdays = exports.utcTuesdays = utcTuesday.range;
var utcWednesdays = exports.utcWednesdays = utcWednesday.range;
var utcThursdays = exports.utcThursdays = utcThursday.range;
var utcFridays = exports.utcFridays = utcFriday.range;
var utcSaturdays = exports.utcSaturdays = utcSaturday.range;
},{"./interval.js":"../node_modules/d3-time/src/interval.js","./duration.js":"../node_modules/d3-time/src/duration.js"}],"../node_modules/d3-time/src/month.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcMonths = exports.utcMonth = exports.timeMonths = exports.timeMonth = void 0;
var _interval = require("./interval.js");
var timeMonth = exports.timeMonth = (0, _interval.timeInterval)(function (date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setMonth(date.getMonth() + step);
}, function (start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function (date) {
  return date.getMonth();
});
var timeMonths = exports.timeMonths = timeMonth.range;
var utcMonth = exports.utcMonth = (0, _interval.timeInterval)(function (date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function (start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function (date) {
  return date.getUTCMonth();
});
var utcMonths = exports.utcMonths = utcMonth.range;
},{"./interval.js":"../node_modules/d3-time/src/interval.js"}],"../node_modules/d3-time/src/year.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcYears = exports.utcYear = exports.timeYears = exports.timeYear = void 0;
var _interval = require("./interval.js");
var timeYear = exports.timeYear = (0, _interval.timeInterval)(function (date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function (start, end) {
  return end.getFullYear() - start.getFullYear();
}, function (date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
timeYear.every = function (k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0, _interval.timeInterval)(function (date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};
var timeYears = exports.timeYears = timeYear.range;
var utcYear = exports.utcYear = (0, _interval.timeInterval)(function (date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function (start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function (date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function (k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0, _interval.timeInterval)(function (date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};
var utcYears = exports.utcYears = utcYear.range;
},{"./interval.js":"../node_modules/d3-time/src/interval.js"}],"../node_modules/d3-time/src/ticks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcTicks = exports.utcTickInterval = exports.timeTicks = exports.timeTickInterval = void 0;
var _d3Array = require("d3-array");
var _duration = require("./duration.js");
var _millisecond = require("./millisecond.js");
var _second = require("./second.js");
var _minute = require("./minute.js");
var _hour = require("./hour.js");
var _day = require("./day.js");
var _week = require("./week.js");
var _month = require("./month.js");
var _year = require("./year.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function ticker(year, month, week, day, hour, minute) {
  var tickIntervals = [[_second.second, 1, _duration.durationSecond], [_second.second, 5, 5 * _duration.durationSecond], [_second.second, 15, 15 * _duration.durationSecond], [_second.second, 30, 30 * _duration.durationSecond], [minute, 1, _duration.durationMinute], [minute, 5, 5 * _duration.durationMinute], [minute, 15, 15 * _duration.durationMinute], [minute, 30, 30 * _duration.durationMinute], [hour, 1, _duration.durationHour], [hour, 3, 3 * _duration.durationHour], [hour, 6, 6 * _duration.durationHour], [hour, 12, 12 * _duration.durationHour], [day, 1, _duration.durationDay], [day, 2, 2 * _duration.durationDay], [week, 1, _duration.durationWeek], [month, 1, _duration.durationMonth], [month, 3, 3 * _duration.durationMonth], [year, 1, _duration.durationYear]];
  function ticks(start, stop, count) {
    var reverse = stop < start;
    if (reverse) {
      var _ref = [stop, start];
      start = _ref[0];
      stop = _ref[1];
    }
    var interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
    var ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
    return reverse ? ticks.reverse() : ticks;
  }
  function tickInterval(start, stop, count) {
    var target = Math.abs(stop - start) / count;
    var i = (0, _d3Array.bisector)(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 3),
        step = _ref3[2];
      return step;
    }).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every((0, _d3Array.tickStep)(start / _duration.durationYear, stop / _duration.durationYear, count));
    if (i === 0) return _millisecond.millisecond.every(Math.max((0, _d3Array.tickStep)(start, stop, count), 1));
    var _tickIntervals = _slicedToArray(tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i], 2),
      t = _tickIntervals[0],
      step = _tickIntervals[1];
    return t.every(step);
  }
  return [ticks, tickInterval];
}
var _ticker = ticker(_year.utcYear, _month.utcMonth, _week.utcSunday, _day.unixDay, _hour.utcHour, _minute.utcMinute),
  _ticker2 = _slicedToArray(_ticker, 2),
  utcTicks = exports.utcTicks = _ticker2[0],
  utcTickInterval = exports.utcTickInterval = _ticker2[1];
var _ticker3 = ticker(_year.timeYear, _month.timeMonth, _week.timeSunday, _day.timeDay, _hour.timeHour, _minute.timeMinute),
  _ticker4 = _slicedToArray(_ticker3, 2),
  timeTicks = exports.timeTicks = _ticker4[0],
  timeTickInterval = exports.timeTickInterval = _ticker4[1];
},{"d3-array":"../node_modules/d3-array/src/index.js","./duration.js":"../node_modules/d3-time/src/duration.js","./millisecond.js":"../node_modules/d3-time/src/millisecond.js","./second.js":"../node_modules/d3-time/src/second.js","./minute.js":"../node_modules/d3-time/src/minute.js","./hour.js":"../node_modules/d3-time/src/hour.js","./day.js":"../node_modules/d3-time/src/day.js","./week.js":"../node_modules/d3-time/src/week.js","./month.js":"../node_modules/d3-time/src/month.js","./year.js":"../node_modules/d3-time/src/year.js"}],"../node_modules/d3-time/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "timeDay", {
  enumerable: true,
  get: function () {
    return _day.timeDay;
  }
});
Object.defineProperty(exports, "timeDays", {
  enumerable: true,
  get: function () {
    return _day.timeDays;
  }
});
Object.defineProperty(exports, "timeFriday", {
  enumerable: true,
  get: function () {
    return _week.timeFriday;
  }
});
Object.defineProperty(exports, "timeFridays", {
  enumerable: true,
  get: function () {
    return _week.timeFridays;
  }
});
Object.defineProperty(exports, "timeHour", {
  enumerable: true,
  get: function () {
    return _hour.timeHour;
  }
});
Object.defineProperty(exports, "timeHours", {
  enumerable: true,
  get: function () {
    return _hour.timeHours;
  }
});
Object.defineProperty(exports, "timeInterval", {
  enumerable: true,
  get: function () {
    return _interval.timeInterval;
  }
});
Object.defineProperty(exports, "timeMillisecond", {
  enumerable: true,
  get: function () {
    return _millisecond.millisecond;
  }
});
Object.defineProperty(exports, "timeMilliseconds", {
  enumerable: true,
  get: function () {
    return _millisecond.milliseconds;
  }
});
Object.defineProperty(exports, "timeMinute", {
  enumerable: true,
  get: function () {
    return _minute.timeMinute;
  }
});
Object.defineProperty(exports, "timeMinutes", {
  enumerable: true,
  get: function () {
    return _minute.timeMinutes;
  }
});
Object.defineProperty(exports, "timeMonday", {
  enumerable: true,
  get: function () {
    return _week.timeMonday;
  }
});
Object.defineProperty(exports, "timeMondays", {
  enumerable: true,
  get: function () {
    return _week.timeMondays;
  }
});
Object.defineProperty(exports, "timeMonth", {
  enumerable: true,
  get: function () {
    return _month.timeMonth;
  }
});
Object.defineProperty(exports, "timeMonths", {
  enumerable: true,
  get: function () {
    return _month.timeMonths;
  }
});
Object.defineProperty(exports, "timeSaturday", {
  enumerable: true,
  get: function () {
    return _week.timeSaturday;
  }
});
Object.defineProperty(exports, "timeSaturdays", {
  enumerable: true,
  get: function () {
    return _week.timeSaturdays;
  }
});
Object.defineProperty(exports, "timeSecond", {
  enumerable: true,
  get: function () {
    return _second.second;
  }
});
Object.defineProperty(exports, "timeSeconds", {
  enumerable: true,
  get: function () {
    return _second.seconds;
  }
});
Object.defineProperty(exports, "timeSunday", {
  enumerable: true,
  get: function () {
    return _week.timeSunday;
  }
});
Object.defineProperty(exports, "timeSundays", {
  enumerable: true,
  get: function () {
    return _week.timeSundays;
  }
});
Object.defineProperty(exports, "timeThursday", {
  enumerable: true,
  get: function () {
    return _week.timeThursday;
  }
});
Object.defineProperty(exports, "timeThursdays", {
  enumerable: true,
  get: function () {
    return _week.timeThursdays;
  }
});
Object.defineProperty(exports, "timeTickInterval", {
  enumerable: true,
  get: function () {
    return _ticks.timeTickInterval;
  }
});
Object.defineProperty(exports, "timeTicks", {
  enumerable: true,
  get: function () {
    return _ticks.timeTicks;
  }
});
Object.defineProperty(exports, "timeTuesday", {
  enumerable: true,
  get: function () {
    return _week.timeTuesday;
  }
});
Object.defineProperty(exports, "timeTuesdays", {
  enumerable: true,
  get: function () {
    return _week.timeTuesdays;
  }
});
Object.defineProperty(exports, "timeWednesday", {
  enumerable: true,
  get: function () {
    return _week.timeWednesday;
  }
});
Object.defineProperty(exports, "timeWednesdays", {
  enumerable: true,
  get: function () {
    return _week.timeWednesdays;
  }
});
Object.defineProperty(exports, "timeWeek", {
  enumerable: true,
  get: function () {
    return _week.timeSunday;
  }
});
Object.defineProperty(exports, "timeWeeks", {
  enumerable: true,
  get: function () {
    return _week.timeSundays;
  }
});
Object.defineProperty(exports, "timeYear", {
  enumerable: true,
  get: function () {
    return _year.timeYear;
  }
});
Object.defineProperty(exports, "timeYears", {
  enumerable: true,
  get: function () {
    return _year.timeYears;
  }
});
Object.defineProperty(exports, "unixDay", {
  enumerable: true,
  get: function () {
    return _day.unixDay;
  }
});
Object.defineProperty(exports, "unixDays", {
  enumerable: true,
  get: function () {
    return _day.unixDays;
  }
});
Object.defineProperty(exports, "utcDay", {
  enumerable: true,
  get: function () {
    return _day.utcDay;
  }
});
Object.defineProperty(exports, "utcDays", {
  enumerable: true,
  get: function () {
    return _day.utcDays;
  }
});
Object.defineProperty(exports, "utcFriday", {
  enumerable: true,
  get: function () {
    return _week.utcFriday;
  }
});
Object.defineProperty(exports, "utcFridays", {
  enumerable: true,
  get: function () {
    return _week.utcFridays;
  }
});
Object.defineProperty(exports, "utcHour", {
  enumerable: true,
  get: function () {
    return _hour.utcHour;
  }
});
Object.defineProperty(exports, "utcHours", {
  enumerable: true,
  get: function () {
    return _hour.utcHours;
  }
});
Object.defineProperty(exports, "utcMillisecond", {
  enumerable: true,
  get: function () {
    return _millisecond.millisecond;
  }
});
Object.defineProperty(exports, "utcMilliseconds", {
  enumerable: true,
  get: function () {
    return _millisecond.milliseconds;
  }
});
Object.defineProperty(exports, "utcMinute", {
  enumerable: true,
  get: function () {
    return _minute.utcMinute;
  }
});
Object.defineProperty(exports, "utcMinutes", {
  enumerable: true,
  get: function () {
    return _minute.utcMinutes;
  }
});
Object.defineProperty(exports, "utcMonday", {
  enumerable: true,
  get: function () {
    return _week.utcMonday;
  }
});
Object.defineProperty(exports, "utcMondays", {
  enumerable: true,
  get: function () {
    return _week.utcMondays;
  }
});
Object.defineProperty(exports, "utcMonth", {
  enumerable: true,
  get: function () {
    return _month.utcMonth;
  }
});
Object.defineProperty(exports, "utcMonths", {
  enumerable: true,
  get: function () {
    return _month.utcMonths;
  }
});
Object.defineProperty(exports, "utcSaturday", {
  enumerable: true,
  get: function () {
    return _week.utcSaturday;
  }
});
Object.defineProperty(exports, "utcSaturdays", {
  enumerable: true,
  get: function () {
    return _week.utcSaturdays;
  }
});
Object.defineProperty(exports, "utcSecond", {
  enumerable: true,
  get: function () {
    return _second.second;
  }
});
Object.defineProperty(exports, "utcSeconds", {
  enumerable: true,
  get: function () {
    return _second.seconds;
  }
});
Object.defineProperty(exports, "utcSunday", {
  enumerable: true,
  get: function () {
    return _week.utcSunday;
  }
});
Object.defineProperty(exports, "utcSundays", {
  enumerable: true,
  get: function () {
    return _week.utcSundays;
  }
});
Object.defineProperty(exports, "utcThursday", {
  enumerable: true,
  get: function () {
    return _week.utcThursday;
  }
});
Object.defineProperty(exports, "utcThursdays", {
  enumerable: true,
  get: function () {
    return _week.utcThursdays;
  }
});
Object.defineProperty(exports, "utcTickInterval", {
  enumerable: true,
  get: function () {
    return _ticks.utcTickInterval;
  }
});
Object.defineProperty(exports, "utcTicks", {
  enumerable: true,
  get: function () {
    return _ticks.utcTicks;
  }
});
Object.defineProperty(exports, "utcTuesday", {
  enumerable: true,
  get: function () {
    return _week.utcTuesday;
  }
});
Object.defineProperty(exports, "utcTuesdays", {
  enumerable: true,
  get: function () {
    return _week.utcTuesdays;
  }
});
Object.defineProperty(exports, "utcWednesday", {
  enumerable: true,
  get: function () {
    return _week.utcWednesday;
  }
});
Object.defineProperty(exports, "utcWednesdays", {
  enumerable: true,
  get: function () {
    return _week.utcWednesdays;
  }
});
Object.defineProperty(exports, "utcWeek", {
  enumerable: true,
  get: function () {
    return _week.utcSunday;
  }
});
Object.defineProperty(exports, "utcWeeks", {
  enumerable: true,
  get: function () {
    return _week.utcSundays;
  }
});
Object.defineProperty(exports, "utcYear", {
  enumerable: true,
  get: function () {
    return _year.utcYear;
  }
});
Object.defineProperty(exports, "utcYears", {
  enumerable: true,
  get: function () {
    return _year.utcYears;
  }
});
var _interval = require("./interval.js");
var _millisecond = require("./millisecond.js");
var _second = require("./second.js");
var _minute = require("./minute.js");
var _hour = require("./hour.js");
var _day = require("./day.js");
var _week = require("./week.js");
var _month = require("./month.js");
var _year = require("./year.js");
var _ticks = require("./ticks.js");
},{"./interval.js":"../node_modules/d3-time/src/interval.js","./millisecond.js":"../node_modules/d3-time/src/millisecond.js","./second.js":"../node_modules/d3-time/src/second.js","./minute.js":"../node_modules/d3-time/src/minute.js","./hour.js":"../node_modules/d3-time/src/hour.js","./day.js":"../node_modules/d3-time/src/day.js","./week.js":"../node_modules/d3-time/src/week.js","./month.js":"../node_modules/d3-time/src/month.js","./year.js":"../node_modules/d3-time/src/year.js","./ticks.js":"../node_modules/d3-time/src/ticks.js"}],"../node_modules/d3-time-format/src/locale.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = formatLocale;
var _d3Time = require("d3-time");
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y, m, d) {
  return {
    y: y,
    m: m,
    d: d,
    H: 0,
    M: 0,
    S: 0,
    L: 0
  };
}
function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
    locale_date = locale.date,
    locale_time = locale.time,
    locale_periods = locale.periods,
    locale_weekdays = locale.days,
    locale_shortWeekdays = locale.shortDays,
    locale_months = locale.months,
    locale_shortMonths = locale.shortMonths;
  var periodRe = formatRe(locale_periods),
    periodLookup = formatLookup(locale_periods),
    weekdayRe = formatRe(locale_weekdays),
    weekdayLookup = formatLookup(locale_weekdays),
    shortWeekdayRe = formatRe(locale_shortWeekdays),
    shortWeekdayLookup = formatLookup(locale_shortWeekdays),
    monthRe = formatRe(locale_months),
    monthLookup = formatLookup(locale_months),
    shortMonthRe = formatRe(locale_shortMonths),
    shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats) {
    return function (date) {
      var string = [],
        i = -1,
        j = 0,
        n = specifier.length,
        c,
        pad,
        format;
      if (!(date instanceof Date)) date = new Date(+date);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function (string) {
      var d = newDate(1900, undefined, 1),
        i = parseSpecifier(d, specifier, string += "", 0),
        week,
        day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? _d3Time.utcMonday.ceil(week) : (0, _d3Time.utcMonday)(week);
          week = _d3Time.utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? _d3Time.timeMonday.ceil(week) : (0, _d3Time.timeMonday)(week);
          week = _d3Time.timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
      n = specifier.length,
      m = string.length,
      c,
      parse;
    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function format(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function () {
        return specifier;
      };
      return f;
    },
    parse: function parse(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function () {
        return specifier;
      };
      return p;
    },
    utcFormat: function utcFormat(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function () {
        return specifier;
      };
      return f;
    },
    utcParse: function utcParse(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function () {
        return specifier;
      };
      return p;
    }
  };
}
var pads = {
    "-": "",
    "_": " ",
    "0": "0"
  },
  numberRe = /^\s*\d+/,
  // note: ignores next directive
  percentRe = /^%/,
  requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
    string = (sign ? -value : value) + "",
    length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s) {
  return s.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map(function (name, i) {
    return [name.toLowerCase(), i];
  }));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad(1 + _d3Time.timeDay.count((0, _d3Time.timeYear)(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
  return pad(_d3Time.timeSunday.count((0, _d3Time.timeYear)(d) - 1, d), p, 2);
}
function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? (0, _d3Time.timeThursday)(d) : _d3Time.timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(_d3Time.timeThursday.count((0, _d3Time.timeYear)(d), d) + ((0, _d3Time.timeYear)(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad(_d3Time.timeMonday.count((0, _d3Time.timeYear)(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}
function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? (0, _d3Time.timeThursday)(d) : _d3Time.timeThursday.ceil(d);
  return pad(d.getFullYear() % 10000, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad(1 + _d3Time.utcDay.count((0, _d3Time.utcYear)(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad(_d3Time.utcSunday.count((0, _d3Time.utcYear)(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? (0, _d3Time.utcThursday)(d) : _d3Time.utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(_d3Time.utcThursday.count((0, _d3Time.utcYear)(d), d) + ((0, _d3Time.utcYear)(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad(_d3Time.utcMonday.count((0, _d3Time.utcYear)(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? (0, _d3Time.utcThursday)(d) : _d3Time.utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 10000, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}
},{"d3-time":"../node_modules/d3-time/src/index.js"}],"../node_modules/d3-time-format/src/defaultLocale.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defaultLocale;
exports.utcParse = exports.utcFormat = exports.timeParse = exports.timeFormat = void 0;
var _locale = _interopRequireDefault(require("./locale.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale(definition) {
  locale = (0, _locale.default)(definition);
  exports.timeFormat = timeFormat = locale.format;
  exports.timeParse = timeParse = locale.parse;
  exports.utcFormat = utcFormat = locale.utcFormat;
  exports.utcParse = utcParse = locale.utcParse;
  return locale;
}
},{"./locale.js":"../node_modules/d3-time-format/src/locale.js"}],"../node_modules/d3-time-format/src/isoFormat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isoSpecifier = exports.default = void 0;
var _defaultLocale = require("./defaultLocale.js");
var isoSpecifier = exports.isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date) {
  return date.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : (0, _defaultLocale.utcFormat)(isoSpecifier);
var _default = exports.default = formatIso;
},{"./defaultLocale.js":"../node_modules/d3-time-format/src/defaultLocale.js"}],"../node_modules/d3-time-format/src/isoParse.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _isoFormat = require("./isoFormat.js");
var _defaultLocale = require("./defaultLocale.js");
function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}
var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : (0, _defaultLocale.utcParse)(_isoFormat.isoSpecifier);
var _default = exports.default = parseIso;
},{"./isoFormat.js":"../node_modules/d3-time-format/src/isoFormat.js","./defaultLocale.js":"../node_modules/d3-time-format/src/defaultLocale.js"}],"../node_modules/d3-time-format/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "isoFormat", {
  enumerable: true,
  get: function () {
    return _isoFormat.default;
  }
});
Object.defineProperty(exports, "isoParse", {
  enumerable: true,
  get: function () {
    return _isoParse.default;
  }
});
Object.defineProperty(exports, "timeFormat", {
  enumerable: true,
  get: function () {
    return _defaultLocale.timeFormat;
  }
});
Object.defineProperty(exports, "timeFormatDefaultLocale", {
  enumerable: true,
  get: function () {
    return _defaultLocale.default;
  }
});
Object.defineProperty(exports, "timeFormatLocale", {
  enumerable: true,
  get: function () {
    return _locale.default;
  }
});
Object.defineProperty(exports, "timeParse", {
  enumerable: true,
  get: function () {
    return _defaultLocale.timeParse;
  }
});
Object.defineProperty(exports, "utcFormat", {
  enumerable: true,
  get: function () {
    return _defaultLocale.utcFormat;
  }
});
Object.defineProperty(exports, "utcParse", {
  enumerable: true,
  get: function () {
    return _defaultLocale.utcParse;
  }
});
var _defaultLocale = _interopRequireWildcard(require("./defaultLocale.js"));
var _locale = _interopRequireDefault(require("./locale.js"));
var _isoFormat = _interopRequireDefault(require("./isoFormat.js"));
var _isoParse = _interopRequireDefault(require("./isoParse.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
},{"./defaultLocale.js":"../node_modules/d3-time-format/src/defaultLocale.js","./locale.js":"../node_modules/d3-time-format/src/locale.js","./isoFormat.js":"../node_modules/d3-time-format/src/isoFormat.js","./isoParse.js":"../node_modules/d3-time-format/src/isoParse.js"}],"../node_modules/d3-scale/src/time.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calendar = calendar;
exports.default = time;
var _d3Time = require("d3-time");
var _d3TimeFormat = require("d3-time-format");
var _continuous = _interopRequireWildcard(require("./continuous.js"));
var _init = require("./init.js");
var _nice = _interopRequireDefault(require("./nice.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function date(t) {
  return new Date(t);
}
function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}
function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
  var scale = (0, _continuous.default)(),
    invert = scale.invert,
    domain = scale.domain;
  var formatMillisecond = format(".%L"),
    formatSecond = format(":%S"),
    formatMinute = format("%I:%M"),
    formatHour = format("%I %p"),
    formatDay = format("%a %d"),
    formatWeek = format("%b %d"),
    formatMonth = format("%B"),
    formatYear = format("%Y");
  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond : minute(date) < date ? formatSecond : hour(date) < date ? formatMinute : day(date) < date ? formatHour : month(date) < date ? week(date) < date ? formatDay : formatWeek : year(date) < date ? formatMonth : formatYear)(date);
  }
  scale.invert = function (y) {
    return new Date(invert(y));
  };
  scale.domain = function (_) {
    return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
  };
  scale.ticks = function (interval) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
  };
  scale.tickFormat = function (count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };
  scale.nice = function (interval) {
    var d = domain();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
    return interval ? domain((0, _nice.default)(d, interval)) : scale;
  };
  scale.copy = function () {
    return (0, _continuous.copy)(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
  };
  return scale;
}
function time() {
  return _init.initRange.apply(calendar(_d3Time.timeTicks, _d3Time.timeTickInterval, _d3Time.timeYear, _d3Time.timeMonth, _d3Time.timeWeek, _d3Time.timeDay, _d3Time.timeHour, _d3Time.timeMinute, _d3Time.timeSecond, _d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}
},{"d3-time":"../node_modules/d3-time/src/index.js","d3-time-format":"../node_modules/d3-time-format/src/index.js","./continuous.js":"../node_modules/d3-scale/src/continuous.js","./init.js":"../node_modules/d3-scale/src/init.js","./nice.js":"../node_modules/d3-scale/src/nice.js"}],"../node_modules/d3-scale/src/utcTime.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = utcTime;
var _d3Time = require("d3-time");
var _d3TimeFormat = require("d3-time-format");
var _time = require("./time.js");
var _init = require("./init.js");
function utcTime() {
  return _init.initRange.apply((0, _time.calendar)(_d3Time.utcTicks, _d3Time.utcTickInterval, _d3Time.utcYear, _d3Time.utcMonth, _d3Time.utcWeek, _d3Time.utcDay, _d3Time.utcHour, _d3Time.utcMinute, _d3Time.utcSecond, _d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
}
},{"d3-time":"../node_modules/d3-time/src/index.js","d3-time-format":"../node_modules/d3-time-format/src/index.js","./time.js":"../node_modules/d3-scale/src/time.js","./init.js":"../node_modules/d3-scale/src/init.js"}],"../node_modules/d3-scale/src/sequential.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copy = copy;
exports.default = sequential;
exports.sequentialLog = sequentialLog;
exports.sequentialPow = sequentialPow;
exports.sequentialSqrt = sequentialSqrt;
exports.sequentialSymlog = sequentialSymlog;
var _d3Interpolate = require("d3-interpolate");
var _continuous = require("./continuous.js");
var _init = require("./init.js");
var _linear = require("./linear.js");
var _log = require("./log.js");
var _symlog = require("./symlog.js");
var _pow = require("./pow.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function transformer() {
  var x0 = 0,
    x1 = 1,
    t0,
    t1,
    k10,
    transform,
    interpolator = _continuous.identity,
    clamp = false,
    unknown;
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }
  scale.domain = function (_) {
    var _ref;
    return arguments.length ? ((_ref = _slicedToArray(_, 2), x0 = _ref[0], x1 = _ref[1]), t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };
  scale.clamp = function (_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };
  scale.interpolator = function (_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  function range(interpolate) {
    return function (_) {
      var _ref2;
      var r0, r1;
      return arguments.length ? ((_ref2 = _slicedToArray(_, 2), r0 = _ref2[0], r1 = _ref2[1]), interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }
  scale.range = range(_d3Interpolate.interpolate);
  scale.rangeRound = range(_d3Interpolate.interpolateRound);
  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function (t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}
function copy(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale = (0, _linear.linearish)(transformer()(_continuous.identity));
  scale.copy = function () {
    return copy(scale, sequential());
  };
  return _init.initInterpolator.apply(scale, arguments);
}
function sequentialLog() {
  var scale = (0, _log.loggish)(transformer()).domain([1, 10]);
  scale.copy = function () {
    return copy(scale, sequentialLog()).base(scale.base());
  };
  return _init.initInterpolator.apply(scale, arguments);
}
function sequentialSymlog() {
  var scale = (0, _symlog.symlogish)(transformer());
  scale.copy = function () {
    return copy(scale, sequentialSymlog()).constant(scale.constant());
  };
  return _init.initInterpolator.apply(scale, arguments);
}
function sequentialPow() {
  var scale = (0, _pow.powish)(transformer());
  scale.copy = function () {
    return copy(scale, sequentialPow()).exponent(scale.exponent());
  };
  return _init.initInterpolator.apply(scale, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}
},{"d3-interpolate":"../node_modules/d3-interpolate/src/index.js","./continuous.js":"../node_modules/d3-scale/src/continuous.js","./init.js":"../node_modules/d3-scale/src/init.js","./linear.js":"../node_modules/d3-scale/src/linear.js","./log.js":"../node_modules/d3-scale/src/log.js","./symlog.js":"../node_modules/d3-scale/src/symlog.js","./pow.js":"../node_modules/d3-scale/src/pow.js"}],"../node_modules/d3-scale/src/sequentialQuantile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sequentialQuantile;
var _d3Array = require("d3-array");
var _continuous = require("./continuous.js");
var _init = require("./init.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function sequentialQuantile() {
  var domain = [],
    interpolator = _continuous.identity;
  function scale(x) {
    if (x != null && !isNaN(x = +x)) return interpolator(((0, _d3Array.bisect)(domain, x, 1) - 1) / (domain.length - 1));
  }
  scale.domain = function (_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    var _iterator = _createForOfIteratorHelper(_),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var d = _step.value;
        if (d != null && !isNaN(d = +d)) domain.push(d);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    domain.sort(_d3Array.ascending);
    return scale;
  };
  scale.interpolator = function (_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  scale.range = function () {
    return domain.map(function (d, i) {
      return interpolator(i / (domain.length - 1));
    });
  };
  scale.quantiles = function (n) {
    return Array.from({
      length: n + 1
    }, function (_, i) {
      return (0, _d3Array.quantile)(domain, i / n);
    });
  };
  scale.copy = function () {
    return sequentialQuantile(interpolator).domain(domain);
  };
  return _init.initInterpolator.apply(scale, arguments);
}
},{"d3-array":"../node_modules/d3-array/src/index.js","./continuous.js":"../node_modules/d3-scale/src/continuous.js","./init.js":"../node_modules/d3-scale/src/init.js"}],"../node_modules/d3-scale/src/diverging.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = diverging;
exports.divergingLog = divergingLog;
exports.divergingPow = divergingPow;
exports.divergingSqrt = divergingSqrt;
exports.divergingSymlog = divergingSymlog;
var _d3Interpolate = require("d3-interpolate");
var _continuous = require("./continuous.js");
var _init = require("./init.js");
var _linear = require("./linear.js");
var _log = require("./log.js");
var _sequential = require("./sequential.js");
var _symlog = require("./symlog.js");
var _pow = require("./pow.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function transformer() {
  var x0 = 0,
    x1 = 0.5,
    x2 = 1,
    s = 1,
    t0,
    t1,
    t2,
    k10,
    k21,
    interpolator = _continuous.identity,
    transform,
    clamp = false,
    unknown;
  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }
  scale.domain = function (_) {
    var _ref;
    return arguments.length ? ((_ref = _slicedToArray(_, 3), x0 = _ref[0], x1 = _ref[1], x2 = _ref[2]), t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
  };
  scale.clamp = function (_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };
  scale.interpolator = function (_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  function range(interpolate) {
    return function (_) {
      var _ref2;
      var r0, r1, r2;
      return arguments.length ? ((_ref2 = _slicedToArray(_, 3), r0 = _ref2[0], r1 = _ref2[1], r2 = _ref2[2]), interpolator = (0, _d3Interpolate.piecewise)(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale.range = range(_d3Interpolate.interpolate);
  scale.rangeRound = range(_d3Interpolate.interpolateRound);
  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function (t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
    return scale;
  };
}
function diverging() {
  var scale = (0, _linear.linearish)(transformer()(_continuous.identity));
  scale.copy = function () {
    return (0, _sequential.copy)(scale, diverging());
  };
  return _init.initInterpolator.apply(scale, arguments);
}
function divergingLog() {
  var scale = (0, _log.loggish)(transformer()).domain([0.1, 1, 10]);
  scale.copy = function () {
    return (0, _sequential.copy)(scale, divergingLog()).base(scale.base());
  };
  return _init.initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
  var scale = (0, _symlog.symlogish)(transformer());
  scale.copy = function () {
    return (0, _sequential.copy)(scale, divergingSymlog()).constant(scale.constant());
  };
  return _init.initInterpolator.apply(scale, arguments);
}
function divergingPow() {
  var scale = (0, _pow.powish)(transformer());
  scale.copy = function () {
    return (0, _sequential.copy)(scale, divergingPow()).exponent(scale.exponent());
  };
  return _init.initInterpolator.apply(scale, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}
},{"d3-interpolate":"../node_modules/d3-interpolate/src/index.js","./continuous.js":"../node_modules/d3-scale/src/continuous.js","./init.js":"../node_modules/d3-scale/src/init.js","./linear.js":"../node_modules/d3-scale/src/linear.js","./log.js":"../node_modules/d3-scale/src/log.js","./sequential.js":"../node_modules/d3-scale/src/sequential.js","./symlog.js":"../node_modules/d3-scale/src/symlog.js","./pow.js":"../node_modules/d3-scale/src/pow.js"}],"../node_modules/d3-scale/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "scaleBand", {
  enumerable: true,
  get: function () {
    return _band.default;
  }
});
Object.defineProperty(exports, "scaleDiverging", {
  enumerable: true,
  get: function () {
    return _diverging.default;
  }
});
Object.defineProperty(exports, "scaleDivergingLog", {
  enumerable: true,
  get: function () {
    return _diverging.divergingLog;
  }
});
Object.defineProperty(exports, "scaleDivergingPow", {
  enumerable: true,
  get: function () {
    return _diverging.divergingPow;
  }
});
Object.defineProperty(exports, "scaleDivergingSqrt", {
  enumerable: true,
  get: function () {
    return _diverging.divergingSqrt;
  }
});
Object.defineProperty(exports, "scaleDivergingSymlog", {
  enumerable: true,
  get: function () {
    return _diverging.divergingSymlog;
  }
});
Object.defineProperty(exports, "scaleIdentity", {
  enumerable: true,
  get: function () {
    return _identity.default;
  }
});
Object.defineProperty(exports, "scaleImplicit", {
  enumerable: true,
  get: function () {
    return _ordinal.implicit;
  }
});
Object.defineProperty(exports, "scaleLinear", {
  enumerable: true,
  get: function () {
    return _linear.default;
  }
});
Object.defineProperty(exports, "scaleLog", {
  enumerable: true,
  get: function () {
    return _log.default;
  }
});
Object.defineProperty(exports, "scaleOrdinal", {
  enumerable: true,
  get: function () {
    return _ordinal.default;
  }
});
Object.defineProperty(exports, "scalePoint", {
  enumerable: true,
  get: function () {
    return _band.point;
  }
});
Object.defineProperty(exports, "scalePow", {
  enumerable: true,
  get: function () {
    return _pow.default;
  }
});
Object.defineProperty(exports, "scaleQuantile", {
  enumerable: true,
  get: function () {
    return _quantile.default;
  }
});
Object.defineProperty(exports, "scaleQuantize", {
  enumerable: true,
  get: function () {
    return _quantize.default;
  }
});
Object.defineProperty(exports, "scaleRadial", {
  enumerable: true,
  get: function () {
    return _radial.default;
  }
});
Object.defineProperty(exports, "scaleSequential", {
  enumerable: true,
  get: function () {
    return _sequential.default;
  }
});
Object.defineProperty(exports, "scaleSequentialLog", {
  enumerable: true,
  get: function () {
    return _sequential.sequentialLog;
  }
});
Object.defineProperty(exports, "scaleSequentialPow", {
  enumerable: true,
  get: function () {
    return _sequential.sequentialPow;
  }
});
Object.defineProperty(exports, "scaleSequentialQuantile", {
  enumerable: true,
  get: function () {
    return _sequentialQuantile.default;
  }
});
Object.defineProperty(exports, "scaleSequentialSqrt", {
  enumerable: true,
  get: function () {
    return _sequential.sequentialSqrt;
  }
});
Object.defineProperty(exports, "scaleSequentialSymlog", {
  enumerable: true,
  get: function () {
    return _sequential.sequentialSymlog;
  }
});
Object.defineProperty(exports, "scaleSqrt", {
  enumerable: true,
  get: function () {
    return _pow.sqrt;
  }
});
Object.defineProperty(exports, "scaleSymlog", {
  enumerable: true,
  get: function () {
    return _symlog.default;
  }
});
Object.defineProperty(exports, "scaleThreshold", {
  enumerable: true,
  get: function () {
    return _threshold.default;
  }
});
Object.defineProperty(exports, "scaleTime", {
  enumerable: true,
  get: function () {
    return _time.default;
  }
});
Object.defineProperty(exports, "scaleUtc", {
  enumerable: true,
  get: function () {
    return _utcTime.default;
  }
});
Object.defineProperty(exports, "tickFormat", {
  enumerable: true,
  get: function () {
    return _tickFormat.default;
  }
});
var _band = _interopRequireWildcard(require("./band.js"));
var _identity = _interopRequireDefault(require("./identity.js"));
var _linear = _interopRequireDefault(require("./linear.js"));
var _log = _interopRequireDefault(require("./log.js"));
var _symlog = _interopRequireDefault(require("./symlog.js"));
var _ordinal = _interopRequireWildcard(require("./ordinal.js"));
var _pow = _interopRequireWildcard(require("./pow.js"));
var _radial = _interopRequireDefault(require("./radial.js"));
var _quantile = _interopRequireDefault(require("./quantile.js"));
var _quantize = _interopRequireDefault(require("./quantize.js"));
var _threshold = _interopRequireDefault(require("./threshold.js"));
var _time = _interopRequireDefault(require("./time.js"));
var _utcTime = _interopRequireDefault(require("./utcTime.js"));
var _sequential = _interopRequireWildcard(require("./sequential.js"));
var _sequentialQuantile = _interopRequireDefault(require("./sequentialQuantile.js"));
var _diverging = _interopRequireWildcard(require("./diverging.js"));
var _tickFormat = _interopRequireDefault(require("./tickFormat.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
},{"./band.js":"../node_modules/d3-scale/src/band.js","./identity.js":"../node_modules/d3-scale/src/identity.js","./linear.js":"../node_modules/d3-scale/src/linear.js","./log.js":"../node_modules/d3-scale/src/log.js","./symlog.js":"../node_modules/d3-scale/src/symlog.js","./ordinal.js":"../node_modules/d3-scale/src/ordinal.js","./pow.js":"../node_modules/d3-scale/src/pow.js","./radial.js":"../node_modules/d3-scale/src/radial.js","./quantile.js":"../node_modules/d3-scale/src/quantile.js","./quantize.js":"../node_modules/d3-scale/src/quantize.js","./threshold.js":"../node_modules/d3-scale/src/threshold.js","./time.js":"../node_modules/d3-scale/src/time.js","./utcTime.js":"../node_modules/d3-scale/src/utcTime.js","./sequential.js":"../node_modules/d3-scale/src/sequential.js","./sequentialQuantile.js":"../node_modules/d3-scale/src/sequentialQuantile.js","./diverging.js":"../node_modules/d3-scale/src/diverging.js","./tickFormat.js":"../node_modules/d3-scale/src/tickFormat.js"}],"../node_modules/gl-matrix/esm/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RANDOM = exports.EPSILON = exports.ARRAY_TYPE = void 0;
exports.equals = equals;
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = exports.EPSILON = 0.000001;
var ARRAY_TYPE = exports.ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = exports.RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
    i = arguments.length;
  while (i--) {
    y += arguments[i] * arguments[i];
  }
  return Math.sqrt(y);
};
},{}],"../node_modules/gl-matrix/esm/mat2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LDU = LDU;
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromValues = fromValues;
exports.identity = identity;
exports.invert = invert;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.rotate = rotate;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transpose = transpose;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */

function fromValues(m00, m01, m10, m11) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */

function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }
  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var v0 = v[0],
    v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */

var mul = exports.mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

var sub = exports.sub = subtract;
},{"./common.js":"../node_modules/gl-matrix/esm/common.js"}],"../node_modules/gl-matrix/esm/mat2d.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.identity = identity;
exports.invert = invert;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.rotate = rotate;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.translate = translate;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * 2x3 Matrix
 * @module mat2d
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(6);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */

function fromValues(a, b, c, d, tx, ty) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */

function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function invert(out, a) {
  var aa = a[0],
    ab = a[1],
    ac = a[2],
    ad = a[3];
  var atx = a[4],
    aty = a[5];
  var det = aa * ad - ab * ac;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5];
  var v0 = v[0],
    v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/

function translate(out, a, v) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5];
  var v0 = v[0],
    v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2d} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat2d} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {ReadonlyMat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */

var mul = exports.mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

var sub = exports.sub = subtract;
},{"./common.js":"../node_modules/gl-matrix/esm/common.js"}],"../node_modules/gl-matrix/esm/mat3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromMat2d = fromMat2d;
exports.fromMat4 = fromMat4;
exports.fromQuat = fromQuat;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.identity = identity;
exports.invert = invert;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.rotate = rotate;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.translate = translate;
exports.transpose = transpose;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(9);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
      a02 = a[2],
      a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  var b00 = b[0],
    b01 = b[1],
    b02 = b[2];
  var b10 = b[3],
    b11 = b[4],
    b12 = b[5];
  var b20 = b[6],
    b21 = b[7],
    b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a10 = a[3],
    a11 = a[4],
    a12 = a[5],
    a20 = a[6],
    a21 = a[7],
    a22 = a[8],
    x = v[0],
    y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a10 = a[3],
    a11 = a[4],
    a12 = a[5],
    a20 = a[6],
    a21 = a[7],
    a22 = a[8],
    s = Math.sin(rad),
    c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
    y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat(out, q) {
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5],
    a6 = a[6],
    a7 = a[7],
    a8 = a[8];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = exports.mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = exports.sub = subtract;
},{"./common.js":"../node_modules/gl-matrix/esm/common.js"}],"../node_modules/gl-matrix/esm/mat4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromQuat = fromQuat;
exports.fromQuat2 = fromQuat2;
exports.fromRotation = fromRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.frustum = frustum;
exports.getRotation = getRotation;
exports.getScaling = getScaling;
exports.getTranslation = getTranslation;
exports.identity = identity;
exports.invert = invert;
exports.lookAt = lookAt;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.ortho = void 0;
exports.orthoNO = orthoNO;
exports.orthoZO = orthoZO;
exports.perspective = void 0;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.perspectiveNO = perspectiveNO;
exports.perspectiveZO = perspectiveZO;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.targetTo = targetTo;
exports.translate = translate;
exports.transpose = transpose;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(16);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
      a02 = a[2],
      a03 = a[3];
    var a12 = a[6],
      a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
    y = v[1],
    z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
    y = v[1],
    z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
    y = axis[1],
    z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len < glMatrix.EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication

  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication

  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication

  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
    y = axis[1],
    z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  if (len < glMatrix.EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
    by = -a[1],
    bz = -a[2],
    bw = a[3],
    ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new glMatrix.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
    nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
/**
 * Alias for {@link mat4.perspectiveNO}
 * @function
 */

var perspective = exports.perspective = perspectiveNO;
/**
 * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
    nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Alias for {@link mat4.orthoNO}
 * @function
 */

var ortho = exports.ortho = orthoNO;
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
    eyey = eye[1],
    eyez = eye[2],
    upx = up[0],
    upy = up[1],
    upz = up[2];
  var z0 = eyex - target[0],
    z1 = eyey - target[1],
    z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }
  var x0 = upy * z2 - upz * z1,
    x1 = upz * z0 - upx * z2,
    x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var a4 = a[4],
    a5 = a[5],
    a6 = a[6],
    a7 = a[7];
  var a8 = a[8],
    a9 = a[9],
    a10 = a[10],
    a11 = a[11];
  var a12 = a[12],
    a13 = a[13],
    a14 = a[14],
    a15 = a[15];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  var b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7];
  var b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11];
  var b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = exports.mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = exports.sub = subtract;
},{"./common.js":"../node_modules/gl-matrix/esm/common.js"}],"../node_modules/gl-matrix/esm/vec3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.bezier = bezier;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.hermite = hermite;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(3);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2];
  var bx = b[0],
    by = b[1],
    bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3];
  var x = a[0],
    y = a[1],
    z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
    uvy = qz * x - qx * z,
    uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
    uuvy = qz * uvx - qx * uvz,
    uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
    r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
    r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
    r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    bx = b[0],
    by = b[1],
    bz = b[2],
    mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
    mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
    mag = mag1 * mag2,
    cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = exports.sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = exports.mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = exports.div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = exports.dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = exports.sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = exports.len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = exports.sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = exports.forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();
},{"./common.js":"../node_modules/gl-matrix/esm/common.js"}],"../node_modules/gl-matrix/esm/vec4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }
  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
    B = v[0] * w[2] - v[2] * w[0],
    C = v[0] * w[3] - v[3] * w[0],
    D = v[1] * w[2] - v[2] * w[1],
    E = v[1] * w[3] - v[3] * w[1],
    F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = glMatrix.RANDOM() * 2 - 1;
    v2 = glMatrix.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = glMatrix.RANDOM() * 2 - 1;
    v4 = glMatrix.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
    y = a[1],
    z = a[2];
  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = exports.sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = exports.mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = exports.div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = exports.dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = exports.sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = exports.len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = exports.sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = exports.forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();
},{"./common.js":"../node_modules/gl-matrix/esm/common.js"}],"../node_modules/gl-matrix/esm/quat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = void 0;
exports.calculateW = calculateW;
exports.clone = void 0;
exports.conjugate = conjugate;
exports.copy = void 0;
exports.create = create;
exports.exactEquals = exports.equals = exports.dot = void 0;
exports.exp = exp;
exports.fromEuler = fromEuler;
exports.fromMat3 = fromMat3;
exports.fromValues = void 0;
exports.getAngle = getAngle;
exports.getAxisAngle = getAxisAngle;
exports.identity = identity;
exports.invert = invert;
exports.lerp = exports.length = exports.len = void 0;
exports.ln = ln;
exports.mul = void 0;
exports.multiply = multiply;
exports.normalize = void 0;
exports.pow = pow;
exports.random = random;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.setAxes = exports.set = exports.scale = exports.rotationTo = void 0;
exports.setAxisAngle = setAxisAngle;
exports.slerp = slerp;
exports.squaredLength = exports.sqrLen = exports.sqlerp = void 0;
exports.str = str;
var glMatrix = _interopRequireWildcard(require("./common.js"));
var mat3 = _interopRequireWildcard(require("./mat3.js"));
var vec3 = _interopRequireWildcard(require("./vec3.js"));
var vec4 = _interopRequireWildcard(require("./vec4.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);
  if (s > glMatrix.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = b[0],
    by = b[1],
    bz = b[2],
    bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var by = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bz = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = b[0],
    by = b[1],
    bz = b[2],
    bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients

  if (1.0 - cosom > glMatrix.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values

  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = glMatrix.RANDOM();
  var u2 = glMatrix.RANDOM();
  var u3 = glMatrix.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = exports.clone = vec4.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = exports.fromValues = vec4.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = exports.copy = vec4.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = exports.set = vec4.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = exports.add = vec4.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = exports.mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = exports.scale = vec4.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = exports.dot = vec4.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = exports.lerp = vec4.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = exports.length = vec4.length;
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = exports.len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = exports.squaredLength = vec4.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = exports.sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = exports.normalize = vec4.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = exports.exactEquals = vec4.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = exports.equals = vec4.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = exports.rotationTo = function () {
  var tmpvec3 = vec3.create();
  var xUnitVec3 = vec3.fromValues(1, 0, 0);
  var yUnitVec3 = vec3.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = vec3.dot(a, b);
    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = exports.sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = exports.setAxes = function () {
  var matr = mat3.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();
},{"./common.js":"../node_modules/gl-matrix/esm/common.js","./mat3.js":"../node_modules/gl-matrix/esm/mat3.js","./vec3.js":"../node_modules/gl-matrix/esm/vec3.js","./vec4.js":"../node_modules/gl-matrix/esm/vec4.js"}],"../node_modules/gl-matrix/esm/quat2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.clone = clone;
exports.conjugate = conjugate;
exports.copy = copy;
exports.create = create;
exports.dot = void 0;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.fromMat4 = fromMat4;
exports.fromRotation = fromRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromRotationTranslationValues = fromRotationTranslationValues;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.getDual = getDual;
exports.getReal = void 0;
exports.getTranslation = getTranslation;
exports.identity = identity;
exports.invert = invert;
exports.length = exports.len = void 0;
exports.lerp = lerp;
exports.mul = void 0;
exports.multiply = multiply;
exports.normalize = normalize;
exports.rotateAroundAxis = rotateAroundAxis;
exports.rotateByQuatAppend = rotateByQuatAppend;
exports.rotateByQuatPrepend = rotateByQuatPrepend;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.scale = scale;
exports.set = set;
exports.setDual = setDual;
exports.squaredLength = exports.sqrLen = exports.setReal = void 0;
exports.str = str;
exports.translate = translate;
var glMatrix = _interopRequireWildcard(require("./common.js"));
var quat = _interopRequireWildcard(require("./quat.js"));
var mat4 = _interopRequireWildcard(require("./mat4.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */

function create() {
  var dq = new glMatrix.ARRAY_TYPE(8);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }
  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */

function clone(a) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
    ay = y2 * 0.5,
    az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q a normalized quaternion
 * @param {ReadonlyVec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
    ay = t[1] * 0.5,
    az = t[2] * 0.5,
    bx = q[0],
    by = q[1],
    bz = q[2],
    bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {ReadonlyMat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */

function fromMat4(out, a) {
  //TODO Optimize this
  var outer = quat.create();
  mat4.getRotation(outer, a);
  var t = new glMatrix.ARRAY_TYPE(3);
  mat4.getTranslation(t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */

function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} real part
 */

var getReal = exports.getReal = quat.copy;
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} dual part
 */

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */

var setReal = exports.setReal = quat.copy;
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */

function getTranslation(out, a) {
  var ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7],
    bx = -a[0],
    by = -a[1],
    bz = -a[2],
    bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {quat2} out
 */

function translate(out, a, v) {
  var ax1 = a[0],
    ay1 = a[1],
    az1 = a[2],
    aw1 = a[3],
    bx1 = v[0] * 0.5,
    by1 = v[1] * 0.5,
    bz1 = v[2] * 0.5,
    ax2 = a[4],
    ay2 = a[5],
    az2 = a[6],
    aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateX(out, a, rad) {
  var bx = -a[0],
    by = -a[1],
    bz = -a[2],
    bw = a[3],
    ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7],
    ax1 = ax * bw + aw * bx + ay * bz - az * by,
    ay1 = ay * bw + aw * by + az * bx - ax * bz,
    az1 = az * bw + aw * bz + ax * by - ay * bx,
    aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateX(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateY(out, a, rad) {
  var bx = -a[0],
    by = -a[1],
    bz = -a[2],
    bw = a[3],
    ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7],
    ax1 = ax * bw + aw * bx + ay * bz - az * by,
    ay1 = ay * bw + aw * by + az * bx - ax * bz,
    az1 = az * bw + aw * bz + ax * by - ay * bx,
    aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateY(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateZ(out, a, rad) {
  var bx = -a[0],
    by = -a[1],
    bz = -a[2],
    bw = a[3],
    ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7],
    ax1 = ax * bw + aw * bx + ay * bz - az * by,
    ay1 = ay * bw + aw * by + az * bx - ax * bz,
    az1 = az * bw + aw * bz + ax * by - ay * bx,
    aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateZ(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @returns {quat2} out
 */

function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3],
    ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */

function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3],
    bx = a[0],
    by = a[1],
    bz = a[2],
    bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */

function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < glMatrix.EPSILON) {
    return copy(out, a);
  }
  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
    ay1 = a[1],
    az1 = a[2],
    aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 * @function
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 */

function multiply(out, a, b) {
  var ax0 = a[0],
    ay0 = a[1],
    az0 = a[2],
    aw0 = a[3],
    bx1 = b[4],
    by1 = b[5],
    bz1 = b[6],
    bw1 = b[7],
    ax1 = a[4],
    ay1 = a[5],
    az1 = a[6],
    aw1 = a[7],
    bx0 = b[0],
    by0 = b[1],
    bz0 = b[2],
    bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */

var mul = exports.mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = exports.dot = quat.dot;
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */

function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */

var length = exports.length = quat.length;
/**
 * Alias for {@link quat2.length}
 * @function
 */

var len = exports.len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = exports.squaredLength = quat.squaredLength;
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

var sqrLen = exports.sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

function normalize(out, a) {
  var magnitude = squaredLength(a);
  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }
  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {ReadonlyQuat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */

function str(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat2} a the first dual quaternion.
 * @param {ReadonlyQuat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat2} a the first dual quat.
 * @param {ReadonlyQuat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5],
    a6 = a[6],
    a7 = a[7];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}
},{"./common.js":"../node_modules/gl-matrix/esm/common.js","./quat.js":"../node_modules/gl-matrix/esm/quat.js","./mat4.js":"../node_modules/gl-matrix/esm/mat4.js"}],"../node_modules/gl-matrix/esm/vec2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotate = rotate;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(2);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
    y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
    y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
    p1 = a[1] - b[1],
    sinC = Math.sin(rad),
    cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
    y1 = a[1],
    x2 = b[0],
    y2 = b[1],
    // mag is the product of the magnitudes of a and b
    mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
    // mag &&.. short circuits if mag == 0
    cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1];
  var b0 = b[0],
    b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = exports.len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = exports.sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = exports.mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = exports.div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = exports.dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = exports.sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = exports.sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = exports.forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();
},{"./common.js":"../node_modules/gl-matrix/esm/common.js"}],"../node_modules/gl-matrix/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec4 = exports.vec3 = exports.vec2 = exports.quat2 = exports.quat = exports.mat4 = exports.mat3 = exports.mat2d = exports.mat2 = exports.glMatrix = void 0;
var glMatrix = _interopRequireWildcard(require("./common.js"));
exports.glMatrix = glMatrix;
var mat2 = _interopRequireWildcard(require("./mat2.js"));
exports.mat2 = mat2;
var mat2d = _interopRequireWildcard(require("./mat2d.js"));
exports.mat2d = mat2d;
var mat3 = _interopRequireWildcard(require("./mat3.js"));
exports.mat3 = mat3;
var mat4 = _interopRequireWildcard(require("./mat4.js"));
exports.mat4 = mat4;
var quat = _interopRequireWildcard(require("./quat.js"));
exports.quat = quat;
var quat2 = _interopRequireWildcard(require("./quat2.js"));
exports.quat2 = quat2;
var vec2 = _interopRequireWildcard(require("./vec2.js"));
exports.vec2 = vec2;
var vec3 = _interopRequireWildcard(require("./vec3.js"));
exports.vec3 = vec3;
var vec4 = _interopRequireWildcard(require("./vec4.js"));
exports.vec4 = vec4;
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
},{"./common.js":"../node_modules/gl-matrix/esm/common.js","./mat2.js":"../node_modules/gl-matrix/esm/mat2.js","./mat2d.js":"../node_modules/gl-matrix/esm/mat2d.js","./mat3.js":"../node_modules/gl-matrix/esm/mat3.js","./mat4.js":"../node_modules/gl-matrix/esm/mat4.js","./quat.js":"../node_modules/gl-matrix/esm/quat.js","./quat2.js":"../node_modules/gl-matrix/esm/quat2.js","./vec2.js":"../node_modules/gl-matrix/esm/vec2.js","./vec3.js":"../node_modules/gl-matrix/esm/vec3.js","./vec4.js":"../node_modules/gl-matrix/esm/vec4.js"}],"../node_modules/seedrandom/lib/alea.js":[function(require,module,exports) {
var define;
// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = String(data);
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],"../node_modules/seedrandom/lib/xor128.js":[function(require,module,exports) {
var define;
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],"../node_modules/seedrandom/lib/xorwow.js":[function(require,module,exports) {
var define;
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],"../node_modules/seedrandom/lib/xorshift7.js":[function(require,module,exports) {
var define;
// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],"../node_modules/seedrandom/lib/xor4096.js":[function(require,module,exports) {
var define;
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],"../node_modules/seedrandom/lib/tychei.js":[function(require,module,exports) {
var define;
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],"../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"../node_modules/seedrandom/seedrandom.js":[function(require,module,exports) {
var global = arguments[3];
var define;
/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
} else {
  // When included as a plain script, set up Math.seedrandom global.
  math['seed' + rngname] = seedrandom;
}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":"../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/_empty.js"}],"../node_modules/seedrandom/index.js":[function(require,module,exports) {
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":"../node_modules/seedrandom/lib/alea.js","./lib/xor128":"../node_modules/seedrandom/lib/xor128.js","./lib/xorwow":"../node_modules/seedrandom/lib/xorwow.js","./lib/xorshift7":"../node_modules/seedrandom/lib/xorshift7.js","./lib/xor4096":"../node_modules/seedrandom/lib/xor4096.js","./lib/tychei":"../node_modules/seedrandom/lib/tychei.js","./seedrandom":"../node_modules/seedrandom/seedrandom.js"}],"../node_modules/random/dist/random.module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Random = exports.RNGFactory = exports.RNG = void 0;
var _seedrandom = _interopRequireDefault(require("seedrandom"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
var RNG = exports.RNG = /*#__PURE__*/function () {
  function RNG() {}
  var _proto = RNG.prototype;
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _proto._seed = function _seed(seed, _opts) {
    // TODO: add entropy and stuff
    if (seed === (seed || 0)) {
      return seed;
    } else {
      var strSeed = '' + seed;
      var s = 0;
      for (var k = 0; k < strSeed.length; ++k) {
        s ^= strSeed.charCodeAt(k) | 0;
      }
      return s;
    }
  };
  return RNG;
}();
var RNGFunction = /*#__PURE__*/function (_RNG) {
  _inheritsLoose(RNGFunction, _RNG);
  function RNGFunction(thunk, opts) {
    var _this;
    _this = _RNG.call(this) || this;
    _this._rng = void 0;
    _this.seed(thunk, opts);
    return _this;
  }
  var _proto = RNGFunction.prototype;
  _proto.next = function next() {
    return this._rng();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ;
  _proto.seed = function seed(thunk, _opts) {
    this._rng = thunk;
  };
  _proto.clone = function clone(_, opts) {
    return new RNGFunction(this._rng, opts);
  };
  _createClass(RNGFunction, [{
    key: "name",
    get: function get() {
      return 'function';
    }
  }]);
  return RNGFunction;
}(RNG);

/**
 * Construct an RNG with variable inputs. Used in calls to Random constructor
 * @param {...*} args - Distribution-specific arguments
 * @return RNG
 *
 * @example
 * new Random(RNGFactory(...args))
 */
var RNGFactory = exports.RNGFactory = function RNGFactory() {
  var args = [].slice.call(arguments);
  var _args = args,
    _args$ = _args[0],
    arg0 = _args$ === void 0 ? 'default' : _args$;
  switch (_typeof(arg0)) {
    case 'object':
      if (arg0 instanceof RNG) {
        return arg0;
      }
      break;
    case 'function':
      return new RNGFunction(arg0);
    case 'number':
    case 'string':
    default:
      return new RNGFunction(_seedrandom.default.apply(void 0, args));
  }
  throw new Error("invalid RNG \"" + arg0 + "\"");
};
var uniform = function uniform(random, min, max) {
  if (min === void 0) {
    min = 0;
  }
  if (max === void 0) {
    max = 1;
  }
  return function () {
    return random.next() * (max - min) + min;
  };
};
function numberValidator(num) {
  return new NumberValidator(num);
}
var NumberValidator = function NumberValidator(num) {
  var _this = this;
  this.n = void 0;
  this.isInt = function () {
    if (Number.isInteger(_this.n)) {
      return _this;
    }
    throw new Error("Expected number to be an integer, got " + _this.n);
  };
  this.isPositive = function () {
    if (_this.n > 0) {
      return _this;
    }
    throw new Error("Expected number to be positive, got " + _this.n);
  };
  this.lessThan = function (v) {
    if (_this.n < v) {
      return _this;
    }
    throw new Error("Expected number to be less than " + v + ", got " + _this.n);
  };
  this.greaterThanOrEqual = function (v) {
    if (_this.n >= v) {
      return _this;
    }
    throw new Error("Expected number to be greater than or equal to " + v + ", got " + _this.n);
  };
  this.greaterThan = function (v) {
    if (_this.n > v) {
      return _this;
    }
    throw new Error("Expected number to be greater than " + v + ", got " + _this.n);
  };
  this.n = num;
};
var uniformInt = function uniformInt(random, min, max) {
  if (min === void 0) {
    min = 0;
  }
  if (max === void 0) {
    max = 1;
  }
  if (max === undefined) {
    max = min === undefined ? 1 : min;
    min = 0;
  }
  numberValidator(min).isInt();
  numberValidator(max).isInt();
  return function () {
    return Math.floor(random.next() * (max - min + 1) + min);
  };
};
var uniformBoolean = function uniformBoolean(random) {
  return function () {
    return random.next() >= 0.5;
  };
};
var normal = function normal(random, mu, sigma) {
  if (mu === void 0) {
    mu = 0;
  }
  if (sigma === void 0) {
    sigma = 1;
  }
  return function () {
    var x, y, r;
    do {
      x = random.next() * 2 - 1;
      y = random.next() * 2 - 1;
      r = x * x + y * y;
    } while (!r || r > 1);
    return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
  };
};
var logNormal = function logNormal(random, mu, sigma) {
  if (mu === void 0) {
    mu = 0;
  }
  if (sigma === void 0) {
    sigma = 1;
  }
  var normal = random.normal(mu, sigma);
  return function () {
    return Math.exp(normal());
  };
};
var bernoulli = function bernoulli(random, p) {
  if (p === void 0) {
    p = 0.5;
  }
  numberValidator(p).greaterThanOrEqual(0).lessThan(1);
  return function () {
    return Math.floor(random.next() + p);
  };
};
var binomial = function binomial(random, n, p) {
  if (n === void 0) {
    n = 1;
  }
  if (p === void 0) {
    p = 0.5;
  }
  numberValidator(n).isInt().isPositive();
  numberValidator(p).greaterThanOrEqual(0).lessThan(1);
  return function () {
    var i = 0;
    var x = 0;
    while (i++ < n) {
      if (random.next() < p) {
        x++;
      }
    }
    return x;
  };
};
var geometric = function geometric(random, p) {
  if (p === void 0) {
    p = 0.5;
  }
  numberValidator(p).greaterThan(0).lessThan(1);
  var invLogP = 1.0 / Math.log(1.0 - p);
  return function () {
    return Math.floor(1 + Math.log(random.next()) * invLogP);
  };
};
var logFactorialTable = [0.0, 0.0, 0.69314718055994529, 1.791759469228055, 3.1780538303479458, 4.7874917427820458, 6.5792512120101012, 8.5251613610654147, 10.604602902745251, 12.801827480081469];
var logFactorial = function logFactorial(k) {
  return logFactorialTable[k];
};
var logSqrt2PI = 0.91893853320467267;
var poisson = function poisson(random, lambda) {
  if (lambda === void 0) {
    lambda = 1;
  }
  numberValidator(lambda).isPositive();
  if (lambda < 10) {
    // inversion method
    var expMean = Math.exp(-lambda);
    return function () {
      var p = expMean;
      var x = 0;
      var u = random.next();
      while (u > p) {
        u = u - p;
        p = lambda * p / ++x;
      }
      return x;
    };
  } else {
    // generative method
    var smu = Math.sqrt(lambda);
    var b = 0.931 + 2.53 * smu;
    var a = -0.059 + 0.02483 * b;
    var invAlpha = 1.1239 + 1.1328 / (b - 3.4);
    var vR = 0.9277 - 3.6224 / (b - 2);
    return function () {
      while (true) {
        var u = void 0;
        var v = random.next();
        if (v <= 0.86 * vR) {
          u = v / vR - 0.43;
          return Math.floor((2 * a / (0.5 - Math.abs(u)) + b) * u + lambda + 0.445);
        }
        if (v >= vR) {
          u = random.next() - 0.5;
        } else {
          u = v / vR - 0.93;
          u = (u < 0 ? -0.5 : 0.5) - u;
          v = random.next() * vR;
        }
        var us = 0.5 - Math.abs(u);
        if (us < 0.013 && v > us) {
          continue;
        }
        var k = Math.floor((2 * a / us + b) * u + lambda + 0.445);
        v = v * invAlpha / (a / (us * us) + b);
        if (k >= 10) {
          var t = (k + 0.5) * Math.log(lambda / k) - lambda - logSqrt2PI + k - (1 / 12.0 - (1 / 360.0 - 1 / (1260.0 * k * k)) / (k * k)) / k;
          if (Math.log(v * smu) <= t) {
            return k;
          }
        } else if (k >= 0) {
          var _logFactorial;
          var f = (_logFactorial = logFactorial(k)) != null ? _logFactorial : 0;
          if (Math.log(v) <= k * Math.log(lambda) - lambda - f) {
            return k;
          }
        }
      }
    };
  }
};
var exponential = function exponential(random, lambda) {
  if (lambda === void 0) {
    lambda = 1;
  }
  numberValidator(lambda).isPositive();
  return function () {
    return -Math.log(1 - random.next()) / lambda;
  };
};
var irwinHall = function irwinHall(random, n) {
  if (n === void 0) {
    n = 1;
  }
  numberValidator(n).isInt().greaterThanOrEqual(0);
  return function () {
    var sum = 0;
    for (var i = 0; i < n; ++i) {
      sum += random.next();
    }
    return sum;
  };
};
var bates = function bates(random, n) {
  if (n === void 0) {
    n = 1;
  }
  numberValidator(n).isInt().isPositive();
  var irwinHall = random.irwinHall(n);
  return function () {
    return irwinHall() / n;
  };
};
var pareto = function pareto(random, alpha) {
  if (alpha === void 0) {
    alpha = 1;
  }
  numberValidator(alpha).greaterThanOrEqual(0);
  var invAlpha = 1.0 / alpha;
  return function () {
    return 1.0 / Math.pow(1.0 - random.next(), invAlpha);
  };
};
var RNGMathRandom = /*#__PURE__*/function (_RNG) {
  _inheritsLoose(RNGMathRandom, _RNG);
  function RNGMathRandom() {
    return _RNG.apply(this, arguments) || this;
  }
  var _proto = RNGMathRandom.prototype;
  _proto.next = function next() {
    return Math.random();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ;
  _proto.seed = function seed(_seed, _opts) {
    // intentionally empty
  };
  _proto.clone = function clone() {
    return new RNGMathRandom();
  };
  _createClass(RNGMathRandom, [{
    key: "name",
    get: function get() {
      return 'default';
    }
  }]);
  return RNGMathRandom;
}(RNG);

/**
 * Seedable random number generator supporting many common distributions.
 *
 * Defaults to Math.random as its underlying pseudorandom number generator.
 *
 * @name Random
 * @class
 *
 * @param {RNG|function} [rng=Math.random] - Underlying pseudorandom number generator.
 */
var Random = exports.Random = /*#__PURE__*/function () {
  function Random(rng) {
    var _this = this;
    this._rng = void 0;
    this._patch = void 0;
    this._cache = {};
    this.next = function () {
      return _this._rng.next();
    };
    this["float"] = function (min, max) {
      return _this.uniform(min, max)();
    };
    this["int"] = function (min, max) {
      return _this.uniformInt(min, max)();
    };
    this.integer = function (min, max) {
      return _this.uniformInt(min, max)();
    };
    this.bool = function () {
      return _this.uniformBoolean()();
    };
    this["boolean"] = function () {
      return _this.uniformBoolean()();
    };
    this.uniform = function (min, max) {
      return _this._memoize('uniform', uniform, min, max);
    };
    this.uniformInt = function (min, max) {
      return _this._memoize('uniformInt', uniformInt, min, max);
    };
    this.uniformBoolean = function () {
      return _this._memoize('uniformBoolean', uniformBoolean);
    };
    this.normal = function (mu, sigma) {
      return normal(_this, mu, sigma);
    };
    this.logNormal = function (mu, sigma) {
      return logNormal(_this, mu, sigma);
    };
    this.bernoulli = function (p) {
      return bernoulli(_this, p);
    };
    this.binomial = function (n, p) {
      return binomial(_this, n, p);
    };
    this.geometric = function (p) {
      return geometric(_this, p);
    };
    this.poisson = function (lambda) {
      return poisson(_this, lambda);
    };
    this.exponential = function (lambda) {
      return exponential(_this, lambda);
    };
    this.irwinHall = function (n) {
      return irwinHall(_this, n);
    };
    this.bates = function (n) {
      return bates(_this, n);
    };
    this.pareto = function (alpha) {
      return pareto(_this, alpha);
    };
    if (rng && rng instanceof RNG) {
      this.use(rng);
    } else {
      this.use(new RNGMathRandom());
    }
    this._cache = {};
  }
  /**
   * @member {RNG} Underlying pseudo-random number generator
   */
  var _proto = Random.prototype;
  /**
   * Creates a new `Random` instance, optionally specifying parameters to
   * set a new seed.
   *
   * @see RNG.clone
   *
   * @param {string} [seed] - Optional seed for new RNG.
   * @param {object} [opts] - Optional config for new RNG options.
   * @return {Random}
   */
  _proto.clone = function clone() {
    var args = [].slice.call(arguments);
    if (args.length) {
      return new Random(RNGFactory.apply(void 0, args));
    } else {
      return new Random(this.rng.clone());
    }
  }
  /**
   * Sets the underlying pseudorandom number generator used via
   * either an instance of `seedrandom`, a custom instance of RNG
   * (for PRNG plugins), or a string specifying the PRNG to use
   * along with an optional `seed` and `opts` to initialize the
   * RNG.
   *
   * @example
   * import random from 'random'
   *
   * random.use('example_seedrandom_string')
   * // or
   * random.use(seedrandom('kittens'))
   * // or
   * random.use(Math.random)
   *
   * @param {...*} args
   */;
  _proto.use = function use() {
    this._rng = RNGFactory.apply(void 0, [].slice.call(arguments));
  }
  /**
   * Patches `Math.random` with this Random instance's PRNG.
   */;
  _proto.patch = function patch() {
    if (this._patch) {
      throw new Error('Math.random already patched');
    }
    this._patch = Math.random;
    Math.random = this.uniform();
  }
  /**
   * Restores a previously patched `Math.random` to its original value.
   */;
  _proto.unpatch = function unpatch() {
    if (this._patch) {
      Math.random = this._patch;
      delete this._patch;
    }
  }
  // --------------------------------------------------------------------------
  // Uniform utility functions
  // --------------------------------------------------------------------------
  /**
   * Convenience wrapper around `this.rng.next()`
   *
   * Returns a floating point number in [0, 1).
   *
   * @return {number}
   */;
  /**
   * Returns an item chosen uniformly at trandom from the given array.
   *
   * Convence wrapper around `random.uniformInt()`
   *
   * @param {Array<T>} [array] - Lower bound (integer, inclusive)
   * @return {T | undefined}
   */
  _proto.choice = function choice(array) {
    if (!Array.isArray(array)) {
      throw new Error("Random.choice expected input to be an array, got " + _typeof(array));
    }
    var length = array == null ? void 0 : array.length;
    if (length > 0) {
      var index = this.uniformInt(0, length - 1)();
      return array[index];
    } else {
      return undefined;
    }
  }
  // --------------------------------------------------------------------------
  // Uniform distributions
  // --------------------------------------------------------------------------
  /**
   * Generates a [Continuous uniform distribution](https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)).
   *
   * @param {number} [min=0] - Lower bound (float, inclusive)
   * @param {number} [max=1] - Upper bound (float, exclusive)
   * @return {function}
   */;
  // --------------------------------------------------------------------------
  // Internal
  // --------------------------------------------------------------------------
  /**
   * Memoizes distributions to ensure they're only created when necessary.
   *
   * Returns a thunk which that returns independent, identically distributed
   * samples from the specified distribution.
   *
   * @private
   *
   * @param {string} label - Name of distribution
   * @param {function} getter - Function which generates a new distribution
   * @param {...*} args - Distribution-specific arguments
   *
   * @return {function}
   */
  _proto._memoize = function _memoize(label, getter) {
    var args = [].slice.call(arguments, 2);
    var key = "" + args.join(';');
    var value = this._cache[label];
    if (value === undefined || value.key !== key) {
      value = {
        key: key,
        distribution: getter.apply(void 0, [this].concat(args))
      };
      this._cache[label] = value;
    }
    return value.distribution;
  };
  _createClass(Random, [{
    key: "rng",
    get: function get() {
      return this._rng;
    }
  }]);
  return Random;
}();
// defaults to Math.random as its RNG
var random = exports.default = new Random();
},{"seedrandom":"../node_modules/seedrandom/index.js"}],"../node_modules/d3-drag/src/noevent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.nonpassivecapture = exports.nonpassive = void 0;
exports.nopropagation = nopropagation;
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
var nonpassive = exports.nonpassive = {
  passive: false
};
var nonpassivecapture = exports.nonpassivecapture = {
  capture: true,
  passive: false
};
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function _default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
},{}],"../node_modules/d3-drag/src/nodrag.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.yesdrag = yesdrag;
var _d3Selection = require("d3-selection");
var _noevent = _interopRequireWildcard(require("./noevent.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _default(view) {
  var root = view.document.documentElement,
    selection = (0, _d3Selection.select)(view).on("dragstart.drag", _noevent.default, _noevent.nonpassivecapture);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent.default, _noevent.nonpassivecapture);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root = view.document.documentElement,
    selection = (0, _d3Selection.select)(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent.default, _noevent.nonpassivecapture);
    setTimeout(function () {
      selection.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}
},{"d3-selection":"../node_modules/d3-selection/src/index.js","./noevent.js":"../node_modules/d3-drag/src/noevent.js"}],"../node_modules/d3-drag/src/constant.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = exports.default = function _default(x) {
  return function () {
    return x;
  };
};
},{}],"../node_modules/d3-drag/src/event.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = DragEvent;
function DragEvent(type, _ref) {
  var sourceEvent = _ref.sourceEvent,
    subject = _ref.subject,
    target = _ref.target,
    identifier = _ref.identifier,
    active = _ref.active,
    x = _ref.x,
    y = _ref.y,
    dx = _ref.dx,
    dy = _ref.dy,
    dispatch = _ref.dispatch;
  Object.defineProperties(this, {
    type: {
      value: type,
      enumerable: true,
      configurable: true
    },
    sourceEvent: {
      value: sourceEvent,
      enumerable: true,
      configurable: true
    },
    subject: {
      value: subject,
      enumerable: true,
      configurable: true
    },
    target: {
      value: target,
      enumerable: true,
      configurable: true
    },
    identifier: {
      value: identifier,
      enumerable: true,
      configurable: true
    },
    active: {
      value: active,
      enumerable: true,
      configurable: true
    },
    x: {
      value: x,
      enumerable: true,
      configurable: true
    },
    y: {
      value: y,
      enumerable: true,
      configurable: true
    },
    dx: {
      value: dx,
      enumerable: true,
      configurable: true
    },
    dy: {
      value: dy,
      enumerable: true,
      configurable: true
    },
    _: {
      value: dispatch
    }
  });
}
DragEvent.prototype.on = function () {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};
},{}],"../node_modules/d3-drag/src/drag.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _d3Dispatch = require("d3-dispatch");
var _d3Selection = require("d3-selection");
var _nodrag = _interopRequireWildcard(require("./nodrag.js"));
var _noevent = _interopRequireWildcard(require("./noevent.js"));
var _constant = _interopRequireDefault(require("./constant.js"));
var _event = _interopRequireDefault(require("./event.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
// Ignore right-click, since that should open the context menu.
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d) {
  return d == null ? {
    x: event.x,
    y: event.y
  } : d;
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function _default() {
  var filter = defaultFilter,
    container = defaultContainer,
    subject = defaultSubject,
    touchable = defaultTouchable,
    gestures = {},
    listeners = (0, _d3Dispatch.dispatch)("start", "drag", "end"),
    active = 0,
    mousedownx,
    mousedowny,
    mousemoving,
    touchending,
    clickDistance2 = 0;
  function drag(selection) {
    selection.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, _noevent.nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d) {
    if (touchending || !filter.call(this, event, d)) return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture) return;
    (0, _d3Selection.select)(event.view).on("mousemove.drag", mousemoved, _noevent.nonpassivecapture).on("mouseup.drag", mouseupped, _noevent.nonpassivecapture);
    (0, _nodrag.default)(event.view);
    (0, _noevent.nopropagation)(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }
  function mousemoved(event) {
    (0, _noevent.default)(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx,
        dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    (0, _d3Selection.select)(event.view).on("mousemove.drag mouseup.drag", null);
    (0, _nodrag.yesdrag)(event.view, mousemoving);
    (0, _noevent.default)(event);
    gestures.mouse("end", event);
  }
  function touchstarted(event, d) {
    if (!filter.call(this, event, d)) return;
    var touches = event.changedTouches,
      c = container.call(this, event, d),
      n = touches.length,
      i,
      gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        (0, _noevent.nopropagation)(event);
        gesture("start", event, touches[i]);
      }
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches,
      n = touches.length,
      i,
      gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0, _noevent.default)(event);
        gesture("drag", event, touches[i]);
      }
    }
  }
  function touchended(event) {
    var touches = event.changedTouches,
      n = touches.length,
      i,
      gesture;
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function () {
      touchending = null;
    }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0, _noevent.nopropagation)(event);
        gesture("end", event, touches[i]);
      }
    }
  }
  function beforestart(that, container, event, d, identifier, touch) {
    var dispatch = listeners.copy(),
      p = (0, _d3Selection.pointer)(touch || event, container),
      dx,
      dy,
      s;
    if ((s = subject.call(that, new _event.default("beforestart", {
      sourceEvent: event,
      target: drag,
      identifier: identifier,
      active: active,
      x: p[0],
      y: p[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch
    }), d)) == null) return;
    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;
    return function gesture(type, event, touch) {
      var p0 = p,
        n;
      switch (type) {
        case "start":
          gestures[identifier] = gesture, n = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        // falls through
        case "drag":
          p = (0, _d3Selection.pointer)(touch || event, container), n = active;
          break;
      }
      dispatch.call(type, that, new _event.default(type, {
        sourceEvent: event,
        subject: s,
        target: drag,
        identifier: identifier,
        active: n,
        x: p[0] + dx,
        y: p[1] + dy,
        dx: p[0] - p0[0],
        dy: p[1] - p0[1],
        dispatch: dispatch
      }), d);
    };
  }
  drag.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0, _constant.default)(!!_), drag) : filter;
  };
  drag.container = function (_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : (0, _constant.default)(_), drag) : container;
  };
  drag.subject = function (_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : (0, _constant.default)(_), drag) : subject;
  };
  drag.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0, _constant.default)(!!_), drag) : touchable;
  };
  drag.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };
  drag.clickDistance = function (_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };
  return drag;
}
},{"d3-dispatch":"../node_modules/d3-dispatch/src/index.js","d3-selection":"../node_modules/d3-selection/src/index.js","./nodrag.js":"../node_modules/d3-drag/src/nodrag.js","./noevent.js":"../node_modules/d3-drag/src/noevent.js","./constant.js":"../node_modules/d3-drag/src/constant.js","./event.js":"../node_modules/d3-drag/src/event.js"}],"../node_modules/d3-drag/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "drag", {
  enumerable: true,
  get: function () {
    return _drag.default;
  }
});
Object.defineProperty(exports, "dragDisable", {
  enumerable: true,
  get: function () {
    return _nodrag.default;
  }
});
Object.defineProperty(exports, "dragEnable", {
  enumerable: true,
  get: function () {
    return _nodrag.yesdrag;
  }
});
var _drag = _interopRequireDefault(require("./drag.js"));
var _nodrag = _interopRequireWildcard(require("./nodrag.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./drag.js":"../node_modules/d3-drag/src/drag.js","./nodrag.js":"../node_modules/d3-drag/src/nodrag.js"}],"../node_modules/d3-zoom/src/constant.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = exports.default = function _default(x) {
  return function () {
    return x;
  };
};
},{}],"../node_modules/d3-zoom/src/event.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ZoomEvent;
function ZoomEvent(type, _ref) {
  var sourceEvent = _ref.sourceEvent,
    target = _ref.target,
    transform = _ref.transform,
    dispatch = _ref.dispatch;
  Object.defineProperties(this, {
    type: {
      value: type,
      enumerable: true,
      configurable: true
    },
    sourceEvent: {
      value: sourceEvent,
      enumerable: true,
      configurable: true
    },
    target: {
      value: target,
      enumerable: true,
      configurable: true
    },
    transform: {
      value: transform,
      enumerable: true,
      configurable: true
    },
    _: {
      value: dispatch
    }
  });
}
},{}],"../node_modules/d3-zoom/src/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transform = Transform;
exports.default = transform;
exports.identity = void 0;
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function scale(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function translate(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function apply(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function applyX(x) {
    return x * this.k + this.x;
  },
  applyY: function applyY(y) {
    return y * this.k + this.y;
  },
  invert: function invert(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function invertX(x) {
    return (x - this.x) / this.k;
  },
  invertY: function invertY(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function rescaleX(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function rescaleY(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function toString() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity = exports.identity = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}
},{}],"../node_modules/d3-zoom/src/noevent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.nopropagation = nopropagation;
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function _default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
},{}],"../node_modules/d3-zoom/src/zoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _d3Dispatch = require("d3-dispatch");
var _d3Drag = require("d3-drag");
var _d3Interpolate = require("d3-interpolate");
var _d3Selection = require("d3-selection");
var _d3Transition = require("d3-transition");
var _constant = _interopRequireDefault(require("./constant.js"));
var _event2 = _interopRequireDefault(require("./event.js"));
var _transform = require("./transform.js");
var _noevent = _interopRequireWildcard(require("./noevent.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}
function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || _transform.identity;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
    dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
    dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
    dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
}
function _default() {
  var filter = defaultFilter,
    extent = defaultExtent,
    constrain = defaultConstrain,
    wheelDelta = defaultWheelDelta,
    touchable = defaultTouchable,
    scaleExtent = [0, Infinity],
    translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
    duration = 250,
    interpolate = _d3Interpolate.interpolateZoom,
    listeners = (0, _d3Dispatch.dispatch)("start", "zoom", "end"),
    touchstarting,
    touchfirst,
    touchending,
    touchDelay = 500,
    wheelDelay = 150,
    clickDistance2 = 0,
    tapDistance = 10;
  function zoom(selection) {
    selection.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, {
      passive: false
    }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom.transform = function (collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function () {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
      });
    }
  };
  zoom.scaleBy = function (selection, k, p, event) {
    zoom.scaleTo(selection, function () {
      var k0 = this.__zoom.k,
        k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };
  zoom.scaleTo = function (selection, k, p, event) {
    zoom.transform(selection, function () {
      var e = extent.apply(this, arguments),
        t0 = this.__zoom,
        p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
        p1 = t0.invert(p0),
        k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };
  zoom.translateBy = function (selection, x, y, event) {
    zoom.transform(selection, function () {
      return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom.translateTo = function (selection, x, y, p, event) {
    zoom.transform(selection, function () {
      var e = extent.apply(this, arguments),
        t = this.__zoom,
        p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform.identity.translate(p0[0], p0[1]).scale(t.k).translate(typeof x === "function" ? -x.apply(this, arguments) : -x, typeof y === "function" ? -y.apply(this, arguments) : -y), e, translateExtent);
    }, p, event);
  };
  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform.Transform(k, transform.x, transform.y);
  }
  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k,
      y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform.Transform(transform.k, x, y);
  }
  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }
  function schedule(transition, transform, point, event) {
    transition.on("start.zoom", function () {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function () {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function () {
      var that = this,
        args = arguments,
        g = gesture(that, args).event(event),
        e = extent.apply(that, args),
        p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
        w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
        a = that.__zoom,
        b = typeof transform === "function" ? transform.apply(that, args) : transform,
        i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function (t) {
        if (t === 1) t = b; // Avoid rounding error on end.
        else {
          var l = i(t),
            k = w / l[2];
          t = new _transform.Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function event(_event) {
      if (_event) this.sourceEvent = _event;
      return this;
    },
    start: function start() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function zoom(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function end() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function emit(type) {
      var d = (0, _d3Selection.select)(this.that).datum();
      listeners.call(type, this.that, new _event2.default(type, {
        sourceEvent: this.sourceEvent,
        target: zoom,
        type: type,
        transform: this.that.__zoom,
        dispatch: listeners
      }), d);
    }
  };
  function wheeled(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
      t = this.__zoom,
      k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
      p = (0, _d3Selection.pointer)(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      (0, _d3Transition.interrupt)(this);
      g.start();
    }
    (0, _noevent.default)(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
      g = gesture(this, args, true).event(event),
      v = (0, _d3Selection.select)(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
      p = (0, _d3Selection.pointer)(event, currentTarget),
      x0 = event.clientX,
      y0 = event.clientY;
    (0, _d3Drag.dragDisable)(event.view);
    (0, _noevent.nopropagation)(event);
    g.mouse = [p, this.__zoom.invert(p)];
    (0, _d3Transition.interrupt)(this);
    g.start();
    function mousemoved(event) {
      (0, _noevent.default)(event);
      if (!g.moved) {
        var dx = event.clientX - x0,
          dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = (0, _d3Selection.pointer)(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      (0, _d3Drag.dragEnable)(event.view, g.moved);
      (0, _noevent.default)(event);
      g.event(event).end();
    }
  }
  function dblclicked(event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
      p0 = (0, _d3Selection.pointer)(event.changedTouches ? event.changedTouches[0] : event, this),
      p1 = t0.invert(p0),
      k1 = t0.k * (event.shiftKey ? 0.5 : 2),
      t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
    (0, _noevent.default)(event);
    if (duration > 0) (0, _d3Selection.select)(this).transition().duration(duration).call(schedule, t1, p0, event);else (0, _d3Selection.select)(this).call(zoom.transform, t1, p0, event);
  }
  function touchstarted(event) {
    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
      n = touches.length,
      g = gesture(this, args, event.changedTouches.length === n).event(event),
      started,
      i,
      t,
      p;
    (0, _noevent.nopropagation)(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0, _d3Selection.pointer)(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function () {
        touchstarting = null;
      }, touchDelay);
      (0, _d3Transition.interrupt)(this);
      g.start();
    }
  }
  function touchmoved(event) {
    if (!this.__zooming) return;
    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
      args[_key5 - 1] = arguments[_key5];
    }
    var g = gesture(this, args).event(event),
      touches = event.changedTouches,
      n = touches.length,
      i,
      t,
      p,
      l;
    (0, _noevent.default)(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0, _d3Selection.pointer)(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0],
        l0 = g.touch0[1],
        p1 = g.touch1[0],
        l1 = g.touch1[1],
        dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
        dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended(event) {
    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
      args[_key6 - 1] = arguments[_key6];
    }
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
      touches = event.changedTouches,
      n = touches.length,
      i,
      t;
    (0, _noevent.nopropagation)(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function () {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = (0, _d3Selection.pointer)(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = (0, _d3Selection.select)(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }
  zoom.wheelDelta = function (_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : (0, _constant.default)(+_), zoom) : wheelDelta;
  };
  zoom.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0, _constant.default)(!!_), zoom) : filter;
  };
  zoom.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0, _constant.default)(!!_), zoom) : touchable;
  };
  zoom.extent = function (_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0, _constant.default)([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };
  zoom.scaleExtent = function (_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom.translateExtent = function (_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom.constrain = function (_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };
  zoom.duration = function (_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };
  zoom.interpolate = function (_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };
  zoom.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };
  zoom.clickDistance = function (_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };
  zoom.tapDistance = function (_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };
  return zoom;
}
},{"d3-dispatch":"../node_modules/d3-dispatch/src/index.js","d3-drag":"../node_modules/d3-drag/src/index.js","d3-interpolate":"../node_modules/d3-interpolate/src/index.js","d3-selection":"../node_modules/d3-selection/src/index.js","d3-transition":"../node_modules/d3-transition/src/index.js","./constant.js":"../node_modules/d3-zoom/src/constant.js","./event.js":"../node_modules/d3-zoom/src/event.js","./transform.js":"../node_modules/d3-zoom/src/transform.js","./noevent.js":"../node_modules/d3-zoom/src/noevent.js"}],"../node_modules/d3-zoom/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ZoomTransform", {
  enumerable: true,
  get: function () {
    return _transform.Transform;
  }
});
Object.defineProperty(exports, "zoom", {
  enumerable: true,
  get: function () {
    return _zoom.default;
  }
});
Object.defineProperty(exports, "zoomIdentity", {
  enumerable: true,
  get: function () {
    return _transform.identity;
  }
});
Object.defineProperty(exports, "zoomTransform", {
  enumerable: true,
  get: function () {
    return _transform.default;
  }
});
var _zoom = _interopRequireDefault(require("./zoom.js"));
var _transform = _interopRequireWildcard(require("./transform.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./zoom.js":"../node_modules/d3-zoom/src/zoom.js","./transform.js":"../node_modules/d3-zoom/src/transform.js"}],"../node_modules/@cosmograph/cosmos/dist/index.js":[function(require,module,exports) {
var define;
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Graph = void 0;
var _d3Selection = require("d3-selection");
require("d3-transition");
var _d3Ease = require("d3-ease");
var _regl = _interopRequireDefault(require("regl"));
var _d3Color = require("d3-color");
var _d3Scale = require("d3-scale");
var _d3Array = require("d3-array");
var _glMatrix = require("gl-matrix");
var _random = require("random");
var _d3Zoom = require("d3-zoom");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var defaultNodeColor = '#b3b3b3';
var defaultGreyoutNodeOpacity = 0.1;
var defaultNodeSize = 4;
var defaultLinkColor = '#666666';
var defaultGreyoutLinkOpacity = 0.1;
var defaultLinkWidth = 1;
var defaultBackgroundColor = '#222222';
var defaultConfigValues = {
  disableSimulation: false,
  spaceSize: 4096,
  nodeSizeScale: 1,
  linkWidthScale: 1,
  arrowSizeScale: 1,
  renderLinks: true,
  curvedLinks: false,
  curvedLinkSegments: 19,
  curvedLinkWeight: 0.8,
  curvedLinkControlPointDistance: 0.5,
  arrowLinks: true,
  linkVisibilityDistanceRange: [50, 150],
  linkVisibilityMinTransparency: 0.25,
  hoveredNodeRingColor: 'white',
  focusedNodeRingColor: 'white',
  useQuadtree: false,
  simulation: {
    decay: 1000,
    gravity: 0,
    center: 0,
    repulsion: 0.1,
    repulsionTheta: 1.7,
    repulsionQuadtreeLevels: 12,
    linkSpring: 1,
    linkDistance: 2,
    linkDistRandomVariationRange: [1, 1.2],
    repulsionFromMouse: 2,
    friction: 0.85
  },
  showFPSMonitor: false,
  pixelRatio: 2,
  scaleNodesOnZoom: true,
  initialZoomLevel: 1,
  disableZoom: false,
  fitViewOnInit: true,
  fitViewDelay: 250,
  nodeSamplingDistance: 150
};
var hoveredNodeRingOpacity = 0.7;
var focusedNodeRingOpacity = 0.95;
var defaultScaleToZoom = 3;
var isFunction = function isFunction(a) {
  return typeof a === 'function';
};
var isArray = function isArray(a) {
  return Array.isArray(a);
};
var isObject = function isObject(a) {
  return a instanceof Object;
};
var isAClassInstance = function isAClassInstance(a) {
  if (a instanceof Object) {
    // eslint-disable-next-line @typescript-eslint/ban-types
    return a.constructor.name !== 'Function' && a.constructor.name !== 'Object';
  } else return false;
};
var isPlainObject = function isPlainObject(a) {
  return isObject(a) && !isArray(a) && !isFunction(a) && !isAClassInstance(a);
};
function getValue(d, accessor, index) {
  // eslint-disable-next-line @typescript-eslint/ban-types
  if (isFunction(accessor)) return accessor(d, index);else return accessor;
}
function getRgbaColor(value) {
  var _a;
  var rgba;
  if (isArray(value)) {
    rgba = value;
  } else {
    var color$1 = (0, _d3Color.color)(value);
    var rgb = color$1 === null || color$1 === void 0 ? void 0 : color$1.rgb();
    rgba = [(rgb === null || rgb === void 0 ? void 0 : rgb.r) || 0, (rgb === null || rgb === void 0 ? void 0 : rgb.g) || 0, (rgb === null || rgb === void 0 ? void 0 : rgb.b) || 0, (_a = color$1 === null || color$1 === void 0 ? void 0 : color$1.opacity) !== null && _a !== void 0 ? _a : 1];
  }
  return [rgba[0] / 255, rgba[1] / 255, rgba[2] / 255, rgba[3]];
}
function readPixels(reglInstance, fbo) {
  var resultPixels = new Float32Array();
  reglInstance({
    framebuffer: fbo
  })(function () {
    resultPixels = reglInstance.read();
  });
  return resultPixels;
}
function clamp(num, min, max) {
  return Math.min(Math.max(num, min), max);
}
var GraphConfig = /*#__PURE__*/function () {
  function GraphConfig() {
    _classCallCheck(this, GraphConfig);
    this.disableSimulation = defaultConfigValues.disableSimulation;
    this.backgroundColor = defaultBackgroundColor;
    this.spaceSize = defaultConfigValues.spaceSize;
    this.nodeColor = defaultNodeColor;
    this.nodeGreyoutOpacity = defaultGreyoutNodeOpacity;
    this.nodeSize = defaultNodeSize;
    this.nodeSizeScale = defaultConfigValues.nodeSizeScale;
    this.renderHighlightedNodeRing = true;
    this.highlightedNodeRingColor = undefined;
    this.renderHoveredNodeRing = true;
    this.hoveredNodeRingColor = defaultConfigValues.hoveredNodeRingColor;
    this.focusedNodeRingColor = defaultConfigValues.focusedNodeRingColor;
    this.linkColor = defaultLinkColor;
    this.linkGreyoutOpacity = defaultGreyoutLinkOpacity;
    this.linkWidth = defaultLinkWidth;
    this.linkWidthScale = defaultConfigValues.linkWidthScale;
    this.renderLinks = defaultConfigValues.renderLinks;
    this.curvedLinks = defaultConfigValues.curvedLinks;
    this.curvedLinkSegments = defaultConfigValues.curvedLinkSegments;
    this.curvedLinkWeight = defaultConfigValues.curvedLinkWeight;
    this.curvedLinkControlPointDistance = defaultConfigValues.curvedLinkControlPointDistance;
    this.linkArrows = defaultConfigValues.arrowLinks;
    this.linkArrowsSizeScale = defaultConfigValues.arrowSizeScale;
    this.linkVisibilityDistanceRange = defaultConfigValues.linkVisibilityDistanceRange;
    this.linkVisibilityMinTransparency = defaultConfigValues.linkVisibilityMinTransparency;
    this.useQuadtree = defaultConfigValues.useQuadtree;
    this.simulation = {
      decay: defaultConfigValues.simulation.decay,
      gravity: defaultConfigValues.simulation.gravity,
      center: defaultConfigValues.simulation.center,
      repulsion: defaultConfigValues.simulation.repulsion,
      repulsionTheta: defaultConfigValues.simulation.repulsionTheta,
      repulsionQuadtreeLevels: defaultConfigValues.simulation.repulsionQuadtreeLevels,
      linkSpring: defaultConfigValues.simulation.linkSpring,
      linkDistance: defaultConfigValues.simulation.linkDistance,
      linkDistRandomVariationRange: defaultConfigValues.simulation.linkDistRandomVariationRange,
      repulsionFromMouse: defaultConfigValues.simulation.repulsionFromMouse,
      friction: defaultConfigValues.simulation.friction,
      onStart: undefined,
      onTick: undefined,
      onEnd: undefined,
      onPause: undefined,
      onRestart: undefined
    };
    this.events = {
      onClick: undefined,
      onMouseMove: undefined,
      onNodeMouseOver: undefined,
      onNodeMouseOut: undefined,
      onZoomStart: undefined,
      onZoom: undefined,
      onZoomEnd: undefined
    };
    this.showFPSMonitor = defaultConfigValues.showFPSMonitor;
    this.pixelRatio = defaultConfigValues.pixelRatio;
    this.scaleNodesOnZoom = defaultConfigValues.scaleNodesOnZoom;
    this.initialZoomLevel = defaultConfigValues.initialZoomLevel;
    this.disableZoom = defaultConfigValues.disableZoom;
    this.fitViewOnInit = defaultConfigValues.fitViewOnInit;
    this.fitViewDelay = defaultConfigValues.fitViewDelay;
    this.fitViewByNodesInRect = undefined;
    this.randomSeed = undefined;
    this.nodeSamplingDistance = defaultConfigValues.nodeSamplingDistance;
  }
  _createClass(GraphConfig, [{
    key: "init",
    value: function init(config) {
      var _this = this;
      Object.keys(config).forEach(function (configParameter) {
        _this.deepMergeConfig(_this.getConfig(), config, configParameter);
      });
    }
  }, {
    key: "deepMergeConfig",
    value: function deepMergeConfig(current, next, key) {
      var _this2 = this;
      if (isPlainObject(current[key]) && isPlainObject(next[key])) {
        // eslint-disable-next-line @typescript-eslint/ban-types
        Object.keys(next[key]).forEach(function (configParameter) {
          _this2.deepMergeConfig(current[key], next[key], configParameter);
        });
      } else current[key] = next[key];
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return this;
    }
  }]);
  return GraphConfig;
}();
var CoreModule = /*#__PURE__*/_createClass(function CoreModule(reglInstance, config, store, data, points) {
  _classCallCheck(this, CoreModule);
  this.reglInstance = reglInstance;
  this.config = config;
  this.store = store;
  this.data = data;
  if (points) this.points = points;
});
var calculateCentermassFrag = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nvarying vec4 rgba;void main(){gl_FragColor=rgba;}"; // eslint-disable-line

var calculateCentermassVert = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nuniform sampler2D position;uniform float pointsTextureSize;attribute vec2 indexes;varying vec4 rgba;void main(){vec4 pointPosition=texture2D(position,indexes/pointsTextureSize);rgba=vec4(pointPosition.xy,1.0,0.0);gl_Position=vec4(0.0,0.0,0.0,1.0);gl_PointSize=1.0;}"; // eslint-disable-line

var forceFrag$5 = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nuniform sampler2D position;uniform sampler2D centermass;uniform float center;uniform float alpha;varying vec2 index;void main(){vec4 pointPosition=texture2D(position,index);vec4 velocity=vec4(0.0);vec4 centermassValues=texture2D(centermass,vec2(0.0));vec2 centermassPosition=centermassValues.xy/centermassValues.b;vec2 distVector=centermassPosition-pointPosition.xy;float dist=sqrt(dot(distVector,distVector));if(dist>0.0){float angle=atan(distVector.y,distVector.x);float addV=alpha*center*dist*0.01;velocity.rg+=addV*vec2(cos(angle),sin(angle));}gl_FragColor=velocity;}"; // eslint-disable-line

function createQuadBuffer(reglInstance) {
  var quadBuffer = reglInstance.buffer(new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]));
  return {
    buffer: quadBuffer,
    size: 2
  };
}
function createIndexesBuffer(reglInstance, textureSize) {
  var indexes = new Float32Array(textureSize * textureSize * 2);
  for (var y = 0; y < textureSize; y++) {
    for (var x = 0; x < textureSize; x++) {
      var i = y * textureSize * 2 + x * 2;
      indexes[i + 0] = x;
      indexes[i + 1] = y;
    }
  }
  var indexBuffer = reglInstance.buffer(indexes);
  return {
    buffer: indexBuffer,
    size: 2
  };
}
function destroyFramebuffer(fbo) {
  var _a;
  if (!fbo) return;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  if ((_a = fbo === null || fbo === void 0 ? void 0 : fbo._framebuffer) === null || _a === void 0 ? void 0 : _a.framebuffer) {
    fbo.destroy();
  }
}
function destroyBuffer(fbo) {
  var _a;
  if (!fbo) return;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  if ((_a = fbo === null || fbo === void 0 ? void 0 : fbo._buffer) === null || _a === void 0 ? void 0 : _a.buffer) {
    fbo.destroy();
  }
}
var clearFrag = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nvarying vec2 index;void main(){gl_FragColor=vec4(0.0);}"; // eslint-disable-line

var updateVert = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nattribute vec2 quad;varying vec2 index;void main(){index=(quad+1.0)/2.0;gl_Position=vec4(quad,0,1);}"; // eslint-disable-line
var ForceCenter = /*#__PURE__*/function (_CoreModule) {
  _inherits(ForceCenter, _CoreModule);
  function ForceCenter() {
    _classCallCheck(this, ForceCenter);
    return _callSuper(this, ForceCenter, arguments);
  }
  _createClass(ForceCenter, [{
    key: "create",
    value: function create() {
      var reglInstance = this.reglInstance;
      this.centermassFbo = reglInstance.framebuffer({
        color: reglInstance.texture({
          data: new Float32Array(4).fill(0),
          shape: [1, 1, 4],
          type: 'float'
        }),
        depth: false,
        stencil: false
      });
    }
  }, {
    key: "initPrograms",
    value: function initPrograms() {
      var _this3 = this;
      var reglInstance = this.reglInstance,
        config = this.config,
        store = this.store,
        data = this.data,
        points = this.points;
      this.clearCentermassCommand = reglInstance({
        frag: clearFrag,
        vert: updateVert,
        framebuffer: this.centermassFbo,
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        }
      });
      this.calculateCentermassCommand = reglInstance({
        frag: calculateCentermassFrag,
        vert: calculateCentermassVert,
        framebuffer: function framebuffer() {
          return _this3.centermassFbo;
        },
        primitive: 'points',
        count: function count() {
          return data.nodes.length;
        },
        attributes: {
          indexes: createIndexesBuffer(reglInstance, store.pointsTextureSize)
        },
        uniforms: {
          position: function position() {
            return points === null || points === void 0 ? void 0 : points.previousPositionFbo;
          },
          pointsTextureSize: function pointsTextureSize() {
            return store.pointsTextureSize;
          }
        },
        blend: {
          enable: true,
          func: {
            src: 'one',
            dst: 'one'
          },
          equation: {
            rgb: 'add',
            alpha: 'add'
          }
        },
        depth: {
          enable: false,
          mask: false
        },
        stencil: {
          enable: false
        }
      });
      this.runCommand = reglInstance({
        frag: forceFrag$5,
        vert: updateVert,
        framebuffer: function framebuffer() {
          return points === null || points === void 0 ? void 0 : points.velocityFbo;
        },
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        },
        uniforms: {
          position: function position() {
            return points === null || points === void 0 ? void 0 : points.previousPositionFbo;
          },
          centermass: function centermass() {
            return _this3.centermassFbo;
          },
          center: function center() {
            var _a;
            return (_a = config.simulation) === null || _a === void 0 ? void 0 : _a.center;
          },
          alpha: function alpha() {
            return store.alpha;
          }
        }
      });
    }
  }, {
    key: "run",
    value: function run() {
      var _a, _b, _c;
      (_a = this.clearCentermassCommand) === null || _a === void 0 ? void 0 : _a.call(this);
      (_b = this.calculateCentermassCommand) === null || _b === void 0 ? void 0 : _b.call(this);
      (_c = this.runCommand) === null || _c === void 0 ? void 0 : _c.call(this);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      destroyFramebuffer(this.centermassFbo);
    }
  }]);
  return ForceCenter;
}(CoreModule);
var forceFrag$4 = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nuniform sampler2D position;uniform float gravity;uniform float spaceSize;uniform float alpha;varying vec2 index;void main(){vec4 pointPosition=texture2D(position,index);vec4 velocity=vec4(0.0);vec2 centerPosition=vec2(spaceSize/2.0);vec2 distVector=centerPosition-pointPosition.rg;float dist=sqrt(dot(distVector,distVector));if(dist>0.0){float angle=atan(distVector.y,distVector.x);float addV=alpha*gravity*dist*0.1;velocity.rg+=addV*vec2(cos(angle),sin(angle));}gl_FragColor=velocity;}"; // eslint-disable-line
var ForceGravity = /*#__PURE__*/function (_CoreModule2) {
  _inherits(ForceGravity, _CoreModule2);
  function ForceGravity() {
    _classCallCheck(this, ForceGravity);
    return _callSuper(this, ForceGravity, arguments);
  }
  _createClass(ForceGravity, [{
    key: "initPrograms",
    value: function initPrograms() {
      var reglInstance = this.reglInstance,
        config = this.config,
        store = this.store,
        points = this.points;
      this.runCommand = reglInstance({
        frag: forceFrag$4,
        vert: updateVert,
        framebuffer: function framebuffer() {
          return points === null || points === void 0 ? void 0 : points.velocityFbo;
        },
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        },
        uniforms: {
          position: function position() {
            return points === null || points === void 0 ? void 0 : points.previousPositionFbo;
          },
          gravity: function gravity() {
            var _a;
            return (_a = config.simulation) === null || _a === void 0 ? void 0 : _a.gravity;
          },
          spaceSize: function spaceSize() {
            return store.adjustedSpaceSize;
          },
          alpha: function alpha() {
            return store.alpha;
          }
        }
      });
    }
  }, {
    key: "run",
    value: function run() {
      var _a;
      (_a = this.runCommand) === null || _a === void 0 ? void 0 : _a.call(this);
    }
  }]);
  return ForceGravity;
}(CoreModule);
function forceFrag$3(maxLinks) {
  return "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D position;\nuniform float linkSpring;\nuniform float linkDistance;\nuniform vec2 linkDistRandomVariationRange;\n\nuniform sampler2D linkFirstIndicesAndAmount;\nuniform sampler2D linkIndices;\nuniform sampler2D linkBiasAndStrength;\nuniform sampler2D linkRandomDistanceFbo;\n\nuniform float pointsTextureSize;\nuniform float linksTextureSize;\nuniform float alpha;\n\nvarying vec2 index;\n\nconst float MAX_LINKS = ".concat(maxLinks, ".0;\n\nvoid main() {\n  vec4 pointPosition = texture2D(position, index);\n  vec4 velocity = vec4(0.0);\n\n  vec4 linkFirstIJAndAmount = texture2D(linkFirstIndicesAndAmount, index);\n  float iCount = linkFirstIJAndAmount.r;\n  float jCount = linkFirstIJAndAmount.g;\n  float linkAmount = linkFirstIJAndAmount.b;\n  if (linkAmount > 0.0) {\n    for (float i = 0.0; i < MAX_LINKS; i += 1.0) {\n      if (i < linkAmount) {\n        if (iCount >= linksTextureSize) {\n          iCount = 0.0;\n          jCount += 1.0;\n        }\n        vec2 linkTextureIndex = (vec2(iCount, jCount) + 0.5) / linksTextureSize;\n        vec4 connectedPointIndex = texture2D(linkIndices, linkTextureIndex);\n        vec4 biasAndStrength = texture2D(linkBiasAndStrength, linkTextureIndex);\n        vec4 randomMinDistance = texture2D(linkRandomDistanceFbo, linkTextureIndex);\n        float bias = biasAndStrength.r;\n        float strength = biasAndStrength.g;\n        float randomMinLinkDist = randomMinDistance.r * (linkDistRandomVariationRange.g - linkDistRandomVariationRange.r) + linkDistRandomVariationRange.r;\n        randomMinLinkDist *= linkDistance;\n\n        iCount += 1.0;\n\n        vec4 connectedPointPosition = texture2D(position, (connectedPointIndex.rg + 0.5) / pointsTextureSize);\n        float x = connectedPointPosition.x - (pointPosition.x + velocity.x);\n        float y = connectedPointPosition.y - (pointPosition.y + velocity.y);\n        float l = sqrt(x * x + y * y);\n        l = max(l, randomMinLinkDist * 0.99);\n        l = (l - randomMinLinkDist) / l;\n        l *= linkSpring * alpha;\n        l *= strength;\n        l *= bias;\n        x *= l;\n        y *= l;\n        velocity.x += x;\n        velocity.y += y;\n      }\n    }\n  }\n\n  gl_FragColor = vec4(velocity.rg, 0.0, 0.0);\n}\n  ");
}
var LinkDirection;
(function (LinkDirection) {
  LinkDirection["OUTGOING"] = "outgoing";
  LinkDirection["INCOMING"] = "incoming";
})(LinkDirection || (LinkDirection = {}));
var ForceLink = /*#__PURE__*/function (_CoreModule3) {
  _inherits(ForceLink, _CoreModule3);
  function ForceLink() {
    var _this4;
    _classCallCheck(this, ForceLink);
    _this4 = _callSuper(this, ForceLink, arguments);
    _this4.linkFirstIndicesAndAmount = new Float32Array();
    _this4.indices = new Float32Array();
    _this4.maxPointDegree = 0;
    return _this4;
  }
  _createClass(ForceLink, [{
    key: "create",
    value: function create(direction) {
      var _this5 = this;
      var reglInstance = this.reglInstance,
        _this$store = this.store,
        pointsTextureSize = _this$store.pointsTextureSize,
        linksTextureSize = _this$store.linksTextureSize,
        data = this.data;
      if (!pointsTextureSize || !linksTextureSize) return;
      this.linkFirstIndicesAndAmount = new Float32Array(pointsTextureSize * pointsTextureSize * 4);
      this.indices = new Float32Array(linksTextureSize * linksTextureSize * 4);
      var linkBiasAndStrengthState = new Float32Array(linksTextureSize * linksTextureSize * 4);
      var linkDistanceState = new Float32Array(linksTextureSize * linksTextureSize * 4);
      var grouped = direction === LinkDirection.INCOMING ? data.groupedSourceToTargetLinks : data.groupedTargetToSourceLinks;
      this.maxPointDegree = 0;
      var linkIndex = 0;
      grouped.forEach(function (connectedNodeIndices, nodeIndex) {
        _this5.linkFirstIndicesAndAmount[nodeIndex * 4 + 0] = linkIndex % linksTextureSize;
        _this5.linkFirstIndicesAndAmount[nodeIndex * 4 + 1] = Math.floor(linkIndex / linksTextureSize);
        _this5.linkFirstIndicesAndAmount[nodeIndex * 4 + 2] = connectedNodeIndices.size;
        connectedNodeIndices.forEach(function (connectedNodeIndex) {
          var _a, _b;
          _this5.indices[linkIndex * 4 + 0] = connectedNodeIndex % pointsTextureSize;
          _this5.indices[linkIndex * 4 + 1] = Math.floor(connectedNodeIndex / pointsTextureSize);
          var degree = (_a = data.degree[data.getInputIndexBySortedIndex(connectedNodeIndex)]) !== null && _a !== void 0 ? _a : 0;
          var connectedDegree = (_b = data.degree[data.getInputIndexBySortedIndex(nodeIndex)]) !== null && _b !== void 0 ? _b : 0;
          var bias = degree / (degree + connectedDegree);
          var strength = 1 / Math.min(degree, connectedDegree);
          strength = Math.sqrt(strength);
          linkBiasAndStrengthState[linkIndex * 4 + 0] = bias;
          linkBiasAndStrengthState[linkIndex * 4 + 1] = strength;
          linkDistanceState[linkIndex * 4] = _this5.store.getRandomFloat(0, 1);
          linkIndex += 1;
        });
        _this5.maxPointDegree = Math.max(_this5.maxPointDegree, connectedNodeIndices.size);
      });
      this.linkFirstIndicesAndAmountFbo = reglInstance.framebuffer({
        color: reglInstance.texture({
          data: this.linkFirstIndicesAndAmount,
          shape: [pointsTextureSize, pointsTextureSize, 4],
          type: 'float'
        }),
        depth: false,
        stencil: false
      });
      this.indicesFbo = reglInstance.framebuffer({
        color: reglInstance.texture({
          data: this.indices,
          shape: [linksTextureSize, linksTextureSize, 4],
          type: 'float'
        }),
        depth: false,
        stencil: false
      });
      this.biasAndStrengthFbo = reglInstance.framebuffer({
        color: reglInstance.texture({
          data: linkBiasAndStrengthState,
          shape: [linksTextureSize, linksTextureSize, 4],
          type: 'float'
        }),
        depth: false,
        stencil: false
      });
      this.randomDistanceFbo = reglInstance.framebuffer({
        color: reglInstance.texture({
          data: linkDistanceState,
          shape: [linksTextureSize, linksTextureSize, 4],
          type: 'float'
        }),
        depth: false,
        stencil: false
      });
    }
  }, {
    key: "initPrograms",
    value: function initPrograms() {
      var _this6 = this;
      var reglInstance = this.reglInstance,
        config = this.config,
        store = this.store,
        points = this.points;
      this.runCommand = reglInstance({
        frag: function frag() {
          return forceFrag$3(_this6.maxPointDegree);
        },
        vert: updateVert,
        framebuffer: function framebuffer() {
          return points === null || points === void 0 ? void 0 : points.velocityFbo;
        },
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        },
        uniforms: {
          position: function position() {
            return points === null || points === void 0 ? void 0 : points.previousPositionFbo;
          },
          linkSpring: function linkSpring() {
            var _a;
            return (_a = config.simulation) === null || _a === void 0 ? void 0 : _a.linkSpring;
          },
          linkDistance: function linkDistance() {
            var _a;
            return (_a = config.simulation) === null || _a === void 0 ? void 0 : _a.linkDistance;
          },
          linkDistRandomVariationRange: function linkDistRandomVariationRange() {
            var _a;
            return (_a = config.simulation) === null || _a === void 0 ? void 0 : _a.linkDistRandomVariationRange;
          },
          linkFirstIndicesAndAmount: function linkFirstIndicesAndAmount() {
            return _this6.linkFirstIndicesAndAmountFbo;
          },
          linkIndices: function linkIndices() {
            return _this6.indicesFbo;
          },
          linkBiasAndStrength: function linkBiasAndStrength() {
            return _this6.biasAndStrengthFbo;
          },
          linkRandomDistanceFbo: function linkRandomDistanceFbo() {
            return _this6.randomDistanceFbo;
          },
          pointsTextureSize: function pointsTextureSize() {
            return store.pointsTextureSize;
          },
          linksTextureSize: function linksTextureSize() {
            return store.linksTextureSize;
          },
          alpha: function alpha() {
            return store.alpha;
          }
        }
      });
    }
  }, {
    key: "run",
    value: function run() {
      var _a;
      (_a = this.runCommand) === null || _a === void 0 ? void 0 : _a.call(this);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      destroyFramebuffer(this.linkFirstIndicesAndAmountFbo);
      destroyFramebuffer(this.indicesFbo);
      destroyFramebuffer(this.biasAndStrengthFbo);
      destroyFramebuffer(this.randomDistanceFbo);
    }
  }]);
  return ForceLink;
}(CoreModule);
var calculateLevelFrag = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nvarying vec4 rgba;void main(){gl_FragColor=rgba;}"; // eslint-disable-line

var calculateLevelVert = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nuniform sampler2D position;uniform float pointsTextureSize;uniform float levelTextureSize;uniform float cellSize;attribute vec2 indexes;varying vec4 rgba;void main(){vec4 pointPosition=texture2D(position,indexes/pointsTextureSize);rgba=vec4(pointPosition.rg,1.0,0.0);float n=floor(pointPosition.x/cellSize);float m=floor(pointPosition.y/cellSize);vec2 levelPosition=2.0*(vec2(n,m)+0.5)/levelTextureSize-1.0;gl_Position=vec4(levelPosition,0.0,1.0);gl_PointSize=1.0;}"; // eslint-disable-line

var forceFrag$2 = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nuniform sampler2D position;uniform sampler2D levelFbo;uniform float level;uniform float levels;uniform float levelTextureSize;uniform float repulsion;uniform float alpha;uniform float spaceSize;uniform float theta;varying vec2 index;const float MAX_LEVELS_NUM=14.0;vec2 calcAdd(vec2 ij,vec2 pp){vec2 add=vec2(0.0);vec4 centermass=texture2D(levelFbo,ij);if(centermass.r>0.0&&centermass.g>0.0&&centermass.b>0.0){vec2 centermassPosition=vec2(centermass.rg/centermass.b);vec2 distVector=pp-centermassPosition;float l=dot(distVector,distVector);float dist=sqrt(l);if(l>0.0){float angle=atan(distVector.y,distVector.x);float c=alpha*repulsion*centermass.b;float distanceMin2=1.0;if(l<distanceMin2)l=sqrt(distanceMin2*l);float addV=c/sqrt(l);add=addV*vec2(cos(angle),sin(angle));}}return add;}void main(){vec4 pointPosition=texture2D(position,index);float x=pointPosition.x;float y=pointPosition.y;float left=0.0;float top=0.0;float right=spaceSize;float bottom=spaceSize;float n_left=0.0;float n_top=0.0;float n_right=0.0;float n_bottom=0.0;float cellSize=0.0;for(float i=0.0;i<MAX_LEVELS_NUM;i+=1.0){if(i<=level){left+=cellSize*n_left;top+=cellSize*n_top;right-=cellSize*n_right;bottom-=cellSize*n_bottom;cellSize=pow(2.0,levels-i-1.0);float dist_left=x-left;n_left=max(0.0,floor(dist_left/cellSize-theta));float dist_top=y-top;n_top=max(0.0,floor(dist_top/cellSize-theta));float dist_right=right-x;n_right=max(0.0,floor(dist_right/cellSize-theta));float dist_bottom=bottom-y;n_bottom=max(0.0,floor(dist_bottom/cellSize-theta));}}vec4 velocity=vec4(vec2(0.0),1.0,0.0);for(float i=0.0;i<12.0;i+=1.0){for(float j=0.0;j<4.0;j+=1.0){float n=left+cellSize*j;float m=top+cellSize*n_top+cellSize*i;if(n<(left+n_left*cellSize)&&m<bottom){velocity.xy+=calcAdd(vec2(n/cellSize,m/cellSize)/levelTextureSize,pointPosition.xy);}n=left+cellSize*i;m=top+cellSize*j;if(n<(right-n_right*cellSize)&&m<(top+n_top*cellSize)){velocity.xy+=calcAdd(vec2(n/cellSize,m/cellSize)/levelTextureSize,pointPosition.xy);}n=right-n_right*cellSize+cellSize*j;m=top+cellSize*i;if(n<right&&m<(bottom-n_bottom*cellSize)){velocity.xy+=calcAdd(vec2(n/cellSize,m/cellSize)/levelTextureSize,pointPosition.xy);}n=left+n_left*cellSize+cellSize*i;m=bottom-n_bottom*cellSize+cellSize*j;if(n<right&&m<bottom){velocity.xy+=calcAdd(vec2(n/cellSize,m/cellSize)/levelTextureSize,pointPosition.xy);}}}gl_FragColor=velocity;}"; // eslint-disable-line

var forceCenterFrag = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nuniform sampler2D position;uniform sampler2D levelFbo;uniform sampler2D randomValues;uniform float levelTextureSize;uniform float repulsion;uniform float alpha;varying vec2 index;vec2 calcAdd(vec2 ij,vec2 pp){vec2 add=vec2(0.0);vec4 centermass=texture2D(levelFbo,ij);if(centermass.r>0.0&&centermass.g>0.0&&centermass.b>0.0){vec2 centermassPosition=vec2(centermass.rg/centermass.b);vec2 distVector=pp-centermassPosition;float l=dot(distVector,distVector);float dist=sqrt(l);if(l>0.0){float angle=atan(distVector.y,distVector.x);float c=alpha*repulsion*centermass.b;float distanceMin2=1.0;if(l<distanceMin2)l=sqrt(distanceMin2*l);float addV=c/sqrt(l);add=addV*vec2(cos(angle),sin(angle));}}return add;}void main(){vec4 pointPosition=texture2D(position,index);vec4 random=texture2D(randomValues,index);vec4 velocity=vec4(0.0);velocity.xy+=calcAdd(pointPosition.xy/levelTextureSize,pointPosition.xy);velocity.xy+=velocity.xy*random.rg;gl_FragColor=velocity;}"; // eslint-disable-line
var ForceManyBody = /*#__PURE__*/function (_CoreModule4) {
  _inherits(ForceManyBody, _CoreModule4);
  function ForceManyBody() {
    var _this7;
    _classCallCheck(this, ForceManyBody);
    _this7 = _callSuper(this, ForceManyBody, arguments);
    _this7.levelsFbos = new Map();
    _this7.quadtreeLevels = 0;
    return _this7;
  }
  _createClass(ForceManyBody, [{
    key: "create",
    value: function create() {
      var reglInstance = this.reglInstance,
        store = this.store;
      if (!store.pointsTextureSize) return;
      this.quadtreeLevels = Math.log2(store.adjustedSpaceSize);
      for (var i = 0; i < this.quadtreeLevels; i += 1) {
        var levelTextureSize = Math.pow(2, i + 1);
        this.levelsFbos.set("level[".concat(i, "]"), reglInstance.framebuffer({
          shape: [levelTextureSize, levelTextureSize],
          colorType: 'float',
          depth: false,
          stencil: false
        }));
      }
      // Create random number to prevent point to stick together in one coordinate
      var randomValuesState = new Float32Array(store.pointsTextureSize * store.pointsTextureSize * 4);
      for (var _i = 0; _i < store.pointsTextureSize * store.pointsTextureSize; ++_i) {
        randomValuesState[_i * 4] = store.getRandomFloat(-1, 1) * 0.00001;
        randomValuesState[_i * 4 + 1] = store.getRandomFloat(-1, 1) * 0.00001;
      }
      this.randomValuesFbo = reglInstance.framebuffer({
        color: reglInstance.texture({
          data: randomValuesState,
          shape: [store.pointsTextureSize, store.pointsTextureSize, 4],
          type: 'float'
        }),
        depth: false,
        stencil: false
      });
    }
  }, {
    key: "initPrograms",
    value: function initPrograms() {
      var _this8 = this;
      var reglInstance = this.reglInstance,
        config = this.config,
        store = this.store,
        data = this.data,
        points = this.points;
      this.clearLevelsCommand = reglInstance({
        frag: clearFrag,
        vert: updateVert,
        framebuffer: function framebuffer(_, props) {
          return props.levelFbo;
        },
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        }
      });
      this.calculateLevelsCommand = reglInstance({
        frag: calculateLevelFrag,
        vert: calculateLevelVert,
        framebuffer: function framebuffer(_, props) {
          return props.levelFbo;
        },
        primitive: 'points',
        count: function count() {
          return data.nodes.length;
        },
        attributes: {
          indexes: createIndexesBuffer(reglInstance, store.pointsTextureSize)
        },
        uniforms: {
          position: function position() {
            return points === null || points === void 0 ? void 0 : points.previousPositionFbo;
          },
          pointsTextureSize: function pointsTextureSize() {
            return store.pointsTextureSize;
          },
          levelTextureSize: function levelTextureSize(_, props) {
            return props.levelTextureSize;
          },
          cellSize: function cellSize(_, props) {
            return props.cellSize;
          }
        },
        blend: {
          enable: true,
          func: {
            src: 'one',
            dst: 'one'
          },
          equation: {
            rgb: 'add',
            alpha: 'add'
          }
        },
        depth: {
          enable: false,
          mask: false
        },
        stencil: {
          enable: false
        }
      });
      this.forceCommand = reglInstance({
        frag: forceFrag$2,
        vert: updateVert,
        framebuffer: function framebuffer() {
          return points === null || points === void 0 ? void 0 : points.velocityFbo;
        },
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        },
        uniforms: {
          position: function position() {
            return points === null || points === void 0 ? void 0 : points.previousPositionFbo;
          },
          level: function level(_, props) {
            return props.level;
          },
          levels: this.quadtreeLevels,
          levelFbo: function levelFbo(_, props) {
            return props.levelFbo;
          },
          levelTextureSize: function levelTextureSize(_, props) {
            return props.levelTextureSize;
          },
          alpha: function alpha() {
            return store.alpha;
          },
          repulsion: function repulsion() {
            var _a;
            return (_a = config.simulation) === null || _a === void 0 ? void 0 : _a.repulsion;
          },
          spaceSize: function spaceSize() {
            return store.adjustedSpaceSize;
          },
          theta: function theta() {
            var _a;
            return (_a = config.simulation) === null || _a === void 0 ? void 0 : _a.repulsionTheta;
          }
        },
        blend: {
          enable: true,
          func: {
            src: 'one',
            dst: 'one'
          },
          equation: {
            rgb: 'add',
            alpha: 'add'
          }
        },
        depth: {
          enable: false,
          mask: false
        },
        stencil: {
          enable: false
        }
      });
      this.forceFromItsOwnCentermassCommand = reglInstance({
        frag: forceCenterFrag,
        vert: updateVert,
        framebuffer: function framebuffer() {
          return points === null || points === void 0 ? void 0 : points.velocityFbo;
        },
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        },
        uniforms: {
          position: function position() {
            return points === null || points === void 0 ? void 0 : points.previousPositionFbo;
          },
          randomValues: function randomValues() {
            return _this8.randomValuesFbo;
          },
          levelFbo: function levelFbo(_, props) {
            return props.levelFbo;
          },
          levelTextureSize: function levelTextureSize(_, props) {
            return props.levelTextureSize;
          },
          alpha: function alpha() {
            return store.alpha;
          },
          repulsion: function repulsion() {
            var _a;
            return (_a = config.simulation) === null || _a === void 0 ? void 0 : _a.repulsion;
          },
          spaceSize: function spaceSize() {
            return store.adjustedSpaceSize;
          }
        },
        blend: {
          enable: true,
          func: {
            src: 'one',
            dst: 'one'
          },
          equation: {
            rgb: 'add',
            alpha: 'add'
          }
        },
        depth: {
          enable: false,
          mask: false
        },
        stencil: {
          enable: false
        }
      });
      this.clearVelocityCommand = reglInstance({
        frag: clearFrag,
        vert: updateVert,
        framebuffer: function framebuffer() {
          return points === null || points === void 0 ? void 0 : points.velocityFbo;
        },
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        }
      });
    }
  }, {
    key: "run",
    value: function run() {
      var _a, _b, _c, _d, _e;
      var store = this.store;
      for (var i = 0; i < this.quadtreeLevels; i += 1) {
        (_a = this.clearLevelsCommand) === null || _a === void 0 ? void 0 : _a.call(this, {
          levelFbo: this.levelsFbos.get("level[".concat(i, "]"))
        });
        var levelTextureSize = Math.pow(2, i + 1);
        var cellSize = store.adjustedSpaceSize / levelTextureSize;
        (_b = this.calculateLevelsCommand) === null || _b === void 0 ? void 0 : _b.call(this, {
          levelFbo: this.levelsFbos.get("level[".concat(i, "]")),
          levelTextureSize: levelTextureSize,
          cellSize: cellSize
        });
      }
      (_c = this.clearVelocityCommand) === null || _c === void 0 ? void 0 : _c.call(this);
      for (var _i2 = 0; _i2 < this.quadtreeLevels; _i2 += 1) {
        var _levelTextureSize = Math.pow(2, _i2 + 1);
        (_d = this.forceCommand) === null || _d === void 0 ? void 0 : _d.call(this, {
          levelFbo: this.levelsFbos.get("level[".concat(_i2, "]")),
          levelTextureSize: _levelTextureSize,
          level: _i2
        });
        if (_i2 === this.quadtreeLevels - 1) {
          (_e = this.forceFromItsOwnCentermassCommand) === null || _e === void 0 ? void 0 : _e.call(this, {
            levelFbo: this.levelsFbos.get("level[".concat(_i2, "]")),
            levelTextureSize: _levelTextureSize,
            level: _i2
          });
        }
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      destroyFramebuffer(this.randomValuesFbo);
      this.levelsFbos.forEach(function (fbo) {
        destroyFramebuffer(fbo);
      });
      this.levelsFbos.clear();
    }
  }]);
  return ForceManyBody;
}(CoreModule);
function forceFrag$1(startLevel, maxLevels) {
  startLevel = Math.min(startLevel, maxLevels);
  var delta = maxLevels - startLevel;
  var calcAdd = "\n    float dist = sqrt(l);\n    if (dist > 0.0) {\n      float c = alpha * repulsion * centermass.b;\n      addVelocity += calcAdd(vec2(x, y), l, c);\n      addVelocity += addVelocity * random.rg;\n    }\n  ";
  function quad(level) {
    if (level >= maxLevels) {
      return calcAdd;
    } else {
      var groupSize = Math.pow(2, level + 1);
      var iEnding = new Array(level + 1 - delta).fill(0).map(function (_, l) {
        return "pow(2.0, ".concat(level - (l + delta), ".0) * i").concat(l + delta);
      }).join('+');
      var jEnding = new Array(level + 1 - delta).fill(0).map(function (_, l) {
        return "pow(2.0, ".concat(level - (l + delta), ".0) * j").concat(l + delta);
      }).join('+');
      return "\n      for (float ij".concat(level, " = 0.0; ij").concat(level, " < 4.0; ij").concat(level, " += 1.0) {\n        float i").concat(level, " = 0.0;\n        float j").concat(level, " = 0.0;\n        if (ij").concat(level, " == 1.0 || ij").concat(level, " == 3.0) i").concat(level, " = 1.0;\n        if (ij").concat(level, " == 2.0 || ij").concat(level, " == 3.0) j").concat(level, " = 1.0;\n        float i = pow(2.0, ").concat(startLevel, ".0) * n / width").concat(level + 1, " + ").concat(iEnding, ";\n        float j = pow(2.0, ").concat(startLevel, ".0) * m / width").concat(level + 1, " + ").concat(jEnding, ";\n        float groupPosX = (i + 0.5) / ").concat(groupSize, ".0;\n        float groupPosY = (j + 0.5) / ").concat(groupSize, ".0;\n        \n        vec4 centermass = texture2D(level[").concat(level, "], vec2(groupPosX, groupPosY));\n        if (centermass.r > 0.0 && centermass.g > 0.0 && centermass.b > 0.0) {\n          float x = centermass.r / centermass.b - pointPosition.r;\n          float y = centermass.g / centermass.b - pointPosition.g;\n          float l = x * x + y * y;\n          if ((width").concat(level + 1, " * width").concat(level + 1, ") / theta < l) {\n            ").concat(calcAdd, "\n          } else {\n            ").concat(quad(level + 1), "\n          }\n        }\n      }\n      ");
    }
  }
  return "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D position;\nuniform sampler2D randomValues;\nuniform float spaceSize;\nuniform float repulsion;\nuniform float theta;\nuniform float alpha;\nuniform sampler2D level[".concat(maxLevels, "];\nvarying vec2 index;\n\nvec2 calcAdd(vec2 xy, float l, float c) {\n  float distanceMin2 = 1.0;\n  if (l < distanceMin2) l = sqrt(distanceMin2 * l);\n  float add = c / l;\n  return add * xy;\n}\n\nvoid main() {\n  vec4 pointPosition = texture2D(position, index);\n  vec4 random = texture2D(randomValues, index);\n\n  float width0 = spaceSize;\n\n  vec2 velocity = vec2(0.0);\n  vec2 addVelocity = vec2(0.0);\n\n  ").concat(new Array(maxLevels).fill(0).map(function (_, i) {
    return "float width".concat(i + 1, " = width").concat(i, " / 2.0;");
  }).join('\n'), "\n\n  for (float n = 0.0; n < pow(2.0, ").concat(delta, ".0); n += 1.0) {\n    for (float m = 0.0; m < pow(2.0, ").concat(delta, ".0); m += 1.0) {\n      ").concat(quad(delta), "\n    }\n  }\n\n  velocity -= addVelocity;\n\n  gl_FragColor = vec4(velocity, 0.0, 0.0);\n}\n");
}
var ForceManyBodyQuadtree = /*#__PURE__*/function (_CoreModule5) {
  _inherits(ForceManyBodyQuadtree, _CoreModule5);
  function ForceManyBodyQuadtree() {
    var _this9;
    _classCallCheck(this, ForceManyBodyQuadtree);
    _this9 = _callSuper(this, ForceManyBodyQuadtree, arguments);
    _this9.levelsFbos = new Map();
    _this9.quadtreeLevels = 0;
    return _this9;
  }
  _createClass(ForceManyBodyQuadtree, [{
    key: "create",
    value: function create() {
      var reglInstance = this.reglInstance,
        store = this.store;
      if (!store.pointsTextureSize) return;
      this.quadtreeLevels = Math.log2(store.adjustedSpaceSize);
      for (var i = 0; i < this.quadtreeLevels; i += 1) {
        var levelTextureSize = Math.pow(2, i + 1);
        this.levelsFbos.set("level[".concat(i, "]"), reglInstance.framebuffer({
          color: reglInstance.texture({
            data: new Float32Array(levelTextureSize * levelTextureSize * 4),
            shape: [levelTextureSize, levelTextureSize, 4],
            type: 'float'
          }),
          depth: false,
          stencil: false
        }));
      }
      // Create random number to prevent point to stick together in one coordinate
      var randomValuesState = new Float32Array(store.pointsTextureSize * store.pointsTextureSize * 4);
      for (var _i3 = 0; _i3 < store.pointsTextureSize * store.pointsTextureSize; ++_i3) {
        randomValuesState[_i3 * 4] = store.getRandomFloat(-1, 1) * 0.00001;
        randomValuesState[_i3 * 4 + 1] = store.getRandomFloat(-1, 1) * 0.00001;
      }
      this.randomValuesFbo = reglInstance.framebuffer({
        color: reglInstance.texture({
          data: randomValuesState,
          shape: [store.pointsTextureSize, store.pointsTextureSize, 4],
          type: 'float'
        }),
        depth: false,
        stencil: false
      });
    }
  }, {
    key: "initPrograms",
    value: function initPrograms() {
      var _this10 = this;
      var _a, _b;
      var reglInstance = this.reglInstance,
        config = this.config,
        store = this.store,
        data = this.data,
        points = this.points;
      this.clearLevelsCommand = reglInstance({
        frag: clearFrag,
        vert: updateVert,
        framebuffer: function framebuffer(_, props) {
          return props.levelFbo;
        },
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        }
      });
      this.calculateLevelsCommand = reglInstance({
        frag: calculateLevelFrag,
        vert: calculateLevelVert,
        framebuffer: function framebuffer(_, props) {
          return props.levelFbo;
        },
        primitive: 'points',
        count: function count() {
          return data.nodes.length;
        },
        attributes: {
          indexes: createIndexesBuffer(reglInstance, store.pointsTextureSize)
        },
        uniforms: {
          position: function position() {
            return points === null || points === void 0 ? void 0 : points.previousPositionFbo;
          },
          pointsTextureSize: function pointsTextureSize() {
            return store.pointsTextureSize;
          },
          levelTextureSize: function levelTextureSize(_, props) {
            return props.levelTextureSize;
          },
          cellSize: function cellSize(_, props) {
            return props.cellSize;
          }
        },
        blend: {
          enable: true,
          func: {
            src: 'one',
            dst: 'one'
          },
          equation: {
            rgb: 'add',
            alpha: 'add'
          }
        },
        depth: {
          enable: false,
          mask: false
        },
        stencil: {
          enable: false
        }
      });
      this.quadtreeCommand = reglInstance({
        frag: forceFrag$1((_b = (_a = config.simulation) === null || _a === void 0 ? void 0 : _a.repulsionQuadtreeLevels) !== null && _b !== void 0 ? _b : this.quadtreeLevels, this.quadtreeLevels),
        vert: updateVert,
        framebuffer: function framebuffer() {
          return points === null || points === void 0 ? void 0 : points.velocityFbo;
        },
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        },
        uniforms: _objectSpread({
          position: function position() {
            return points === null || points === void 0 ? void 0 : points.previousPositionFbo;
          },
          randomValues: function randomValues() {
            return _this10.randomValuesFbo;
          },
          spaceSize: function spaceSize() {
            return store.adjustedSpaceSize;
          },
          repulsion: function repulsion() {
            var _a;
            return (_a = config.simulation) === null || _a === void 0 ? void 0 : _a.repulsion;
          },
          theta: function theta() {
            var _a;
            return (_a = config.simulation) === null || _a === void 0 ? void 0 : _a.repulsionTheta;
          },
          alpha: function alpha() {
            return store.alpha;
          }
        }, Object.fromEntries(this.levelsFbos))
      });
    }
  }, {
    key: "run",
    value: function run() {
      var _a, _b, _c;
      var store = this.store;
      for (var i = 0; i < this.quadtreeLevels; i += 1) {
        (_a = this.clearLevelsCommand) === null || _a === void 0 ? void 0 : _a.call(this, {
          levelFbo: this.levelsFbos.get("level[".concat(i, "]"))
        });
        var levelTextureSize = Math.pow(2, i + 1);
        var cellSize = store.adjustedSpaceSize / levelTextureSize;
        (_b = this.calculateLevelsCommand) === null || _b === void 0 ? void 0 : _b.call(this, {
          levelFbo: this.levelsFbos.get("level[".concat(i, "]")),
          levelTextureSize: levelTextureSize,
          cellSize: cellSize
        });
      }
      (_c = this.quadtreeCommand) === null || _c === void 0 ? void 0 : _c.call(this);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      destroyFramebuffer(this.randomValuesFbo);
      this.levelsFbos.forEach(function (fbo) {
        destroyFramebuffer(fbo);
      });
      this.levelsFbos.clear();
    }
  }]);
  return ForceManyBodyQuadtree;
}(CoreModule);
var forceFrag = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nuniform sampler2D position;uniform float repulsion;uniform vec2 mousePos;varying vec2 index;void main(){vec4 pointPosition=texture2D(position,index);vec4 velocity=vec4(0.0);vec2 mouse=mousePos;vec2 distVector=mouse-pointPosition.rg;float dist=sqrt(dot(distVector,distVector));dist=max(dist,10.0);float angle=atan(distVector.y,distVector.x);float addV=100.0*repulsion/(dist*dist);velocity.rg-=addV*vec2(cos(angle),sin(angle));gl_FragColor=velocity;}"; // eslint-disable-line
var ForceMouse = /*#__PURE__*/function (_CoreModule6) {
  _inherits(ForceMouse, _CoreModule6);
  function ForceMouse() {
    _classCallCheck(this, ForceMouse);
    return _callSuper(this, ForceMouse, arguments);
  }
  _createClass(ForceMouse, [{
    key: "initPrograms",
    value: function initPrograms() {
      var reglInstance = this.reglInstance,
        config = this.config,
        store = this.store,
        points = this.points;
      this.runCommand = reglInstance({
        frag: forceFrag,
        vert: updateVert,
        framebuffer: function framebuffer() {
          return points === null || points === void 0 ? void 0 : points.velocityFbo;
        },
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        },
        uniforms: {
          position: function position() {
            return points === null || points === void 0 ? void 0 : points.previousPositionFbo;
          },
          mousePos: function mousePos() {
            return store.mousePosition;
          },
          repulsion: function repulsion() {
            var _a;
            return (_a = config.simulation) === null || _a === void 0 ? void 0 : _a.repulsionFromMouse;
          }
        }
      });
    }
  }, {
    key: "run",
    value: function run() {
      var _a;
      (_a = this.runCommand) === null || _a === void 0 ? void 0 : _a.call(this);
    }
  }]);
  return ForceMouse;
}(CoreModule);
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
var glBench = {
  exports: {}
};
(function (module, exports) {
  (function (global, factory) {
    module.exports = factory();
  })(commonjsGlobal, function () {
    var UISVG = "<div class=\"gl-box\">\n  <svg viewBox=\"0 0 55 60\">\n    <text x=\"27\" y=\"56\" class=\"gl-fps\">00 FPS</text>\n    <text x=\"28\" y=\"8\" class=\"gl-mem\"></text>\n    <rect x=\"0\" y=\"14\" rx=\"4\" ry=\"4\" width=\"55\" height=\"32\"></rect>\n    <polyline class=\"gl-chart\"></polyline>\n  </svg>\n  <svg viewBox=\"0 0 14 60\" class=\"gl-cpu-svg\">\n    <line x1=\"7\" y1=\"38\" x2=\"7\" y2=\"11\" class=\"opacity\"/>\n    <line x1=\"7\" y1=\"38\" x2=\"7\" y2=\"11\" class=\"gl-cpu\" stroke-dasharray=\"0 27\"/>\n    <path d=\"M5.35 43c-.464 0-.812.377-.812.812v1.16c-.783.1972-1.421.812-1.595 1.624h-1.16c-.435 0-.812.348-.812.812s.348.812.812.812h1.102v1.653H1.812c-.464 0-.812.377-.812.812 0 .464.377.812.812.812h1.131c.1943.783.812 1.392 1.595 1.595v1.131c0 .464.377.812.812.812.464 0 .812-.377.812-.812V53.15h1.653v1.073c0 .464.377.812.812.812.464 0 .812-.377.812-.812v-1.131c.783-.1943 1.392-.812 1.595-1.595h1.131c.464 0 .812-.377.812-.812 0-.464-.377-.812-.812-.812h-1.073V48.22h1.102c.435 0 .812-.348.812-.812s-.348-.812-.812-.812h-1.16c-.1885-.783-.812-1.421-1.595-1.624v-1.131c0-.464-.377-.812-.812-.812-.464 0-.812.377-.812.812v1.073H6.162v-1.073c0-.464-.377-.812-.812-.812zm.58 3.48h2.088c.754 0 1.363.609 1.363 1.363v2.088c0 .754-.609 1.363-1.363 1.363H5.93c-.754 0-1.363-.609-1.363-1.363v-2.088c0-.754.609-1.363 1.363-1.363z\"/>\n  </svg>\n  <svg viewBox=\"0 0 14 60\" class=\"gl-gpu-svg\">\n    <line x1=\"7\" y1=\"38\" x2=\"7\" y2=\"11\" class=\"opacity\"/>\n    <line x1=\"7\" y1=\"38\" x2=\"7\" y2=\"11\" class=\"gl-gpu\" stroke-dasharray=\"0 27\"/>\n    <path d=\"M1.94775 43.3772a.736.736 0 10-.00416 1.472c.58535.00231.56465.1288.6348.3197.07015.18975.04933.43585.04933.43585l-.00653.05405v8.671a.736.736 0 101.472 0v-1.4145c.253.09522.52785.1495.81765.1495h5.267c1.2535 0 2.254-.9752 2.254-2.185v-3.105c0-1.2075-1.00625-2.185-2.254-2.185h-5.267c-.28865 0-.5635.05405-.8165.1495.01806-.16445.04209-.598-.1357-1.0787-.22425-.6072-.9499-1.2765-2.0125-1.2765zm2.9095 3.6455c.42435 0 .7659.36225.7659.8119v2.9785c0 .44965-.34155.8119-.7659.8119s-.7659-.36225-.7659-.8119v-2.9785c0-.44965.34155-.8119.7659-.8119zm4.117 0a2.3 2.3 0 012.3 2.3 2.3 2.3 0 01-2.3 2.3 2.3 2.3 0 01-2.3-2.3 2.3 2.3 0 012.3-2.3z\"/>\n  </svg>\n</div>";
    var UICSS = "#gl-bench {\n  position:absolute;\n  left:0;\n  top:0;\n  z-index:1000;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n}\n\n#gl-bench div {\n  position: relative;\n  display: block;\n  margin: 4px;\n  padding: 0 7px 0 10px;\n  background: #6c6;\n  border-radius: 15px;\n  cursor: pointer;\n  opacity: 0.9;\n}\n\n#gl-bench svg {\n  height: 60px;\n  margin: 0 -1px;\n}\n\n#gl-bench text {\n  font-size: 12px;\n  font-family: Helvetica,Arial,sans-serif;\n  font-weight: 700;\n  dominant-baseline: middle;\n  text-anchor: middle;\n}\n\n#gl-bench .gl-mem {\n  font-size: 9px;\n}\n\n#gl-bench line {\n  stroke-width: 5;\n  stroke: #112211;\n  stroke-linecap: round;\n}\n\n#gl-bench polyline {\n  fill: none;\n  stroke: #112211;\n  stroke-linecap: round;\n  stroke-linejoin: round;\n  stroke-width: 3.5;\n}\n\n#gl-bench rect {\n  fill: #448844;\n}\n\n#gl-bench .opacity {\n  stroke: #448844;\n}\n";
    var GLBench = /*#__PURE__*/function () {
      /** GLBench constructor
       * @param { WebGLRenderingContext | WebGL2RenderingContext } gl context
       * @param { Object | undefined } settings additional settings
       */
      function GLBench(gl) {
        var _this11 = this;
        var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        _classCallCheck(this, GLBench);
        this.css = UICSS;
        this.svg = UISVG;
        this.paramLogger = function () {};
        this.chartLogger = function () {};
        this.chartLen = 20;
        this.chartHz = 20;
        this.names = [];
        this.cpuAccums = [];
        this.gpuAccums = [];
        this.activeAccums = [];
        this.chart = new Array(this.chartLen);
        this.now = function () {
          return performance && performance.now ? performance.now() : Date.now();
        };
        this.updateUI = function () {
          [].forEach.call(_this11.nodes['gl-gpu-svg'], function (node) {
            node.style.display = _this11.trackGPU ? 'inline' : 'none';
          });
        };
        Object.assign(this, settings);
        this.detected = 0;
        this.finished = [];
        this.isFramebuffer = 0;
        this.frameId = 0;

        // 120hz device detection
        var rafId,
          n = 0,
          t0;
        var loop = function loop(t) {
          if (++n < 20) {
            rafId = requestAnimationFrame(loop);
          } else {
            _this11.detected = Math.ceil(1e3 * n / (t - t0) / 70);
            cancelAnimationFrame(rafId);
          }
          if (!t0) t0 = t;
        };
        requestAnimationFrame(loop);

        // attach gpu profilers
        if (gl) {
          var glFinish = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(t, activeAccums) {
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    return _context.abrupt("return", Promise.resolve(setTimeout(function () {
                      gl.getError();
                      var dt = _this11.now() - t;
                      activeAccums.forEach(function (active, i) {
                        if (active) _this11.gpuAccums[i] += dt;
                      });
                    }, 0)));
                  case 1:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function glFinish(_x, _x2) {
              return _ref.apply(this, arguments);
            };
          }();
          var addProfiler = function addProfiler(fn, self, target) {
            return function () {
              var t = self.now();
              fn.apply(target, arguments);
              if (self.trackGPU) self.finished.push(glFinish(t, self.activeAccums.slice(0)));
            };
          };
          ['drawArrays', 'drawElements', 'drawArraysInstanced', 'drawBuffers', 'drawElementsInstanced', 'drawRangeElements'].forEach(function (fn) {
            if (gl[fn]) gl[fn] = addProfiler(gl[fn], _this11, gl);
          });
          gl.getExtension = function (fn, self) {
            return function () {
              var ext = fn.apply(gl, arguments);
              if (ext) {
                ['drawElementsInstancedANGLE', 'drawBuffersWEBGL'].forEach(function (fn) {
                  if (ext[fn]) ext[fn] = addProfiler(ext[fn], self, ext);
                });
              }
              return ext;
            };
          }(gl.getExtension, this);
        }

        // init ui and ui loggers
        if (!this.withoutUI) {
          if (!this.dom) this.dom = document.body;
          var elm = document.createElement('div');
          elm.id = 'gl-bench';
          this.dom.appendChild(elm);
          this.dom.insertAdjacentHTML('afterbegin', '<style id="gl-bench-style">' + this.css + '</style>');
          this.dom = elm;
          this.dom.addEventListener('click', function () {
            _this11.trackGPU = !_this11.trackGPU;
            _this11.updateUI();
          });
          this.paramLogger = function (logger, dom, names) {
            var classes = ['gl-cpu', 'gl-gpu', 'gl-mem', 'gl-fps', 'gl-gpu-svg', 'gl-chart'];
            var nodes = Object.assign({}, classes);
            classes.forEach(function (c) {
              return nodes[c] = dom.getElementsByClassName(c);
            });
            _this11.nodes = nodes;
            return function (i, cpu, gpu, mem, fps, totalTime, frameId) {
              nodes['gl-cpu'][i].style.strokeDasharray = (cpu * 0.27).toFixed(0) + ' 100';
              nodes['gl-gpu'][i].style.strokeDasharray = (gpu * 0.27).toFixed(0) + ' 100';
              nodes['gl-mem'][i].innerHTML = names[i] ? names[i] : mem ? 'mem: ' + mem.toFixed(0) + 'mb' : '';
              nodes['gl-fps'][i].innerHTML = fps.toFixed(0) + ' FPS';
              logger(names[i], cpu, gpu, mem, fps, totalTime, frameId);
            };
          }(this.paramLogger, this.dom, this.names);
          this.chartLogger = function (logger, dom) {
            var nodes = {
              'gl-chart': dom.getElementsByClassName('gl-chart')
            };
            return function (i, chart, circularId) {
              var points = '';
              var len = chart.length;
              for (var _i4 = 0; _i4 < len; _i4++) {
                var id = (circularId + _i4 + 1) % len;
                if (chart[id] != undefined) {
                  points = points + ' ' + (55 * _i4 / (len - 1)).toFixed(1) + ',' + (45 - chart[id] * 22 / 60 / _this11.detected).toFixed(1);
                }
              }
              nodes['gl-chart'][i].setAttribute('points', points);
              logger(_this11.names[i], chart, circularId);
            };
          }(this.chartLogger, this.dom);
        }
      }

      /**
       * Explicit UI add
       * @param { string | undefined } name 
       */
      _createClass(GLBench, [{
        key: "addUI",
        value: function addUI(name) {
          if (this.names.indexOf(name) == -1) {
            this.names.push(name);
            if (this.dom) {
              this.dom.insertAdjacentHTML('beforeend', this.svg);
              this.updateUI();
            }
            this.cpuAccums.push(0);
            this.gpuAccums.push(0);
            this.activeAccums.push(false);
          }
        }

        /**
         * Increase frameID
         * @param { number | undefined } now
         */
      }, {
        key: "nextFrame",
        value: function nextFrame(now) {
          var _this12 = this;
          this.frameId++;
          var t = now ? now : this.now();

          // params
          if (this.frameId <= 1) {
            this.paramFrame = this.frameId;
            this.paramTime = t;
          } else {
            var duration = t - this.paramTime;
            if (duration >= 1e3) {
              var frameCount = this.frameId - this.paramFrame;
              var fps = frameCount / duration * 1e3;
              var _loop = function _loop(i) {
                var cpu = _this12.cpuAccums[i] / duration * 100,
                  gpu = _this12.gpuAccums[i] / duration * 100,
                  mem = performance && performance.memory ? performance.memory.usedJSHeapSize / (1 << 20) : 0;
                _this12.paramLogger(i, cpu, gpu, mem, fps, duration, frameCount);
                _this12.cpuAccums[i] = 0;
                Promise.all(_this12.finished).then(function () {
                  _this12.gpuAccums[i] = 0;
                  _this12.finished = [];
                });
              };
              for (var i = 0; i < this.names.length; i++) {
                _loop(i);
              }
              this.paramFrame = this.frameId;
              this.paramTime = t;
            }
          }

          // chart
          if (!this.detected || !this.chartFrame) {
            this.chartFrame = this.frameId;
            this.chartTime = t;
            this.circularId = 0;
          } else {
            var timespan = t - this.chartTime;
            var hz = this.chartHz * timespan / 1e3;
            while (--hz > 0 && this.detected) {
              var _frameCount = this.frameId - this.chartFrame;
              var _fps = _frameCount / timespan * 1e3;
              this.chart[this.circularId % this.chartLen] = _fps;
              for (var _i5 = 0; _i5 < this.names.length; _i5++) {
                this.chartLogger(_i5, this.chart, this.circularId);
              }
              this.circularId++;
              this.chartFrame = this.frameId;
              this.chartTime = t;
            }
          }
        }

        /**
         * Begin named measurement
         * @param { string | undefined } name
         */
      }, {
        key: "begin",
        value: function begin(name) {
          this.updateAccums(name);
        }

        /**
         * End named measure
         * @param { string | undefined } name
         */
      }, {
        key: "end",
        value: function end(name) {
          this.updateAccums(name);
        }
      }, {
        key: "updateAccums",
        value: function updateAccums(name) {
          var nameId = this.names.indexOf(name);
          if (nameId == -1) {
            nameId = this.names.length;
            this.addUI(name);
          }
          var t = this.now();
          var dt = t - this.t0;
          for (var i = 0; i < nameId + 1; i++) {
            if (this.activeAccums[i]) {
              this.cpuAccums[i] += dt;
            }
          }
          this.activeAccums[nameId] = !this.activeAccums[nameId];
          this.t0 = t;
        }
      }]);
      return GLBench;
    }();
    return GLBench;
  });
})(glBench);
var GLBench = glBench.exports;
var benchCSS = "\n  #gl-bench {\n    position:absolute;\n    right:0;\n    top:0;\n    z-index:1000;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  #gl-bench div {\n    position: relative;\n    display: block;\n    margin: 4px;\n    padding: 0 7px 0 10px;\n    background: #5f69de;\n    border-radius: 15px;\n    cursor: pointer;\n    opacity: 0.9;\n  }\n  #gl-bench svg {\n    height: 60px;\n    margin: 0 -1px;\n  }\n  #gl-bench text {\n    font-size: 12px;\n    font-family: Helvetica,Arial,sans-serif;\n    font-weight: 700;\n    dominant-baseline: middle;\n    text-anchor: middle;\n  }\n  #gl-bench .gl-mem {\n    font-size: 9px;\n  }\n  #gl-bench line {\n    stroke-width: 5;\n    stroke: #112211;\n    stroke-linecap: round;\n  }\n  #gl-bench polyline {\n    fill: none;\n    stroke: #112211;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n    stroke-width: 3.5;\n  }\n  #gl-bench rect {\n    fill: #8288e4;\n  }\n  #gl-bench .opacity {\n    stroke: #8288e4;\n  }\n";
var FPSMonitor = /*#__PURE__*/function () {
  function FPSMonitor(canvas) {
    _classCallCheck(this, FPSMonitor);
    this.destroy();
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    this.bench = new GLBench(gl, {
      css: benchCSS
    });
  }
  _createClass(FPSMonitor, [{
    key: "begin",
    value: function begin() {
      var _a;
      (_a = this.bench) === null || _a === void 0 ? void 0 : _a.begin('frame');
    }
  }, {
    key: "end",
    value: function end(now) {
      var _a, _b;
      (_a = this.bench) === null || _a === void 0 ? void 0 : _a.end('frame');
      (_b = this.bench) === null || _b === void 0 ? void 0 : _b.nextFrame(now);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.bench = undefined;
      (0, _d3Selection.select)('#gl-bench').remove();
    }
  }]);
  return FPSMonitor;
}();
var GraphData = /*#__PURE__*/function () {
  function GraphData() {
    _classCallCheck(this, GraphData);
    /** Links that have existing source and target nodes  */
    this.completeLinks = new Set();
    this.degree = [];
    /** Mapping the source node index to a `Set` of target node indices connected to that node */
    this.groupedSourceToTargetLinks = new Map();
    /** Mapping the target node index to a `Set` of source node indices connected to that node */
    this.groupedTargetToSourceLinks = new Map();
    this._nodes = [];
    this._links = [];
    /** Mapping the original id to the original node */
    this.idToNodeMap = new Map();
    /** We want to display more important nodes (i.e. with the biggest number of connections)
     * on top of the other. To render them in the right order,
     * we create an array of node indices sorted by degree (number of connections)
     * and and we store multiple maps that help us referencing the right data objects
     * and other properties by original node index, sorted index, and id 👇. */
    /** Mapping the sorted index to the original index */
    this.sortedIndexToInputIndexMap = new Map();
    /** Mapping the original index to the sorted index of the node */
    this.inputIndexToSortedIndexMap = new Map();
    /** Mapping the original id to the sorted index of the node */
    this.idToSortedIndexMap = new Map();
    /** Mapping the original index to the original id of the node */
    this.inputIndexToIdMap = new Map();
    /** Mapping the original id to the indegree value of the node */
    this.idToIndegreeMap = new Map();
    /** Mapping the original id to the outdegree value of the node */
    this.idToOutdegreeMap = new Map();
  }
  _createClass(GraphData, [{
    key: "nodes",
    get: function get() {
      return this._nodes;
    }
  }, {
    key: "links",
    get: function get() {
      return this._links;
    }
  }, {
    key: "linksNumber",
    get: function get() {
      return this.completeLinks.size;
    }
  }, {
    key: "setData",
    value: function setData(inputNodes, inputLinks) {
      var _this13 = this;
      this.idToNodeMap.clear();
      this.idToSortedIndexMap.clear();
      this.inputIndexToIdMap.clear();
      this.idToIndegreeMap.clear();
      this.idToOutdegreeMap.clear();
      inputNodes.forEach(function (n, i) {
        _this13.idToNodeMap.set(n.id, n);
        _this13.inputIndexToIdMap.set(i, n.id);
        _this13.idToIndegreeMap.set(n.id, 0);
        _this13.idToOutdegreeMap.set(n.id, 0);
      });
      // Calculate node outdegree/indegree values
      // And filter links if source/target node does not exist
      this.completeLinks.clear();
      inputLinks.forEach(function (l) {
        var sourceNode = _this13.idToNodeMap.get(l.source);
        var targetNode = _this13.idToNodeMap.get(l.target);
        if (sourceNode !== undefined && targetNode !== undefined) {
          _this13.completeLinks.add(l);
          var outdegree = _this13.idToOutdegreeMap.get(sourceNode.id);
          if (outdegree !== undefined) _this13.idToOutdegreeMap.set(sourceNode.id, outdegree + 1);
          var indegree = _this13.idToIndegreeMap.get(targetNode.id);
          if (indegree !== undefined) _this13.idToIndegreeMap.set(targetNode.id, indegree + 1);
        }
      });
      // Calculate node degree value
      this.degree = new Array(inputNodes.length);
      inputNodes.forEach(function (n, i) {
        var outdegree = _this13.idToOutdegreeMap.get(n.id);
        var indegree = _this13.idToIndegreeMap.get(n.id);
        _this13.degree[i] = (outdegree !== null && outdegree !== void 0 ? outdegree : 0) + (indegree !== null && indegree !== void 0 ? indegree : 0);
      });
      // Sort nodes by degree value
      this.sortedIndexToInputIndexMap.clear();
      this.inputIndexToSortedIndexMap.clear();
      var sortedDegrees = Object.entries(this.degree).sort(function (a, b) {
        return a[1] - b[1];
      });
      sortedDegrees.forEach(function (_ref2, sortedIndex) {
        var _ref3 = _slicedToArray(_ref2, 1),
          inputStringedIndex = _ref3[0];
        var inputIndex = +inputStringedIndex;
        _this13.sortedIndexToInputIndexMap.set(sortedIndex, inputIndex);
        _this13.inputIndexToSortedIndexMap.set(inputIndex, sortedIndex);
        _this13.idToSortedIndexMap.set(_this13.inputIndexToIdMap.get(inputIndex), sortedIndex);
      });
      this.groupedSourceToTargetLinks.clear();
      this.groupedTargetToSourceLinks.clear();
      inputLinks.forEach(function (l) {
        var sourceIndex = _this13.idToSortedIndexMap.get(l.source);
        var targetIndex = _this13.idToSortedIndexMap.get(l.target);
        if (sourceIndex !== undefined && targetIndex !== undefined) {
          if (_this13.groupedSourceToTargetLinks.get(sourceIndex) === undefined) _this13.groupedSourceToTargetLinks.set(sourceIndex, new Set());
          var targets = _this13.groupedSourceToTargetLinks.get(sourceIndex);
          targets === null || targets === void 0 ? void 0 : targets.add(targetIndex);
          if (_this13.groupedTargetToSourceLinks.get(targetIndex) === undefined) _this13.groupedTargetToSourceLinks.set(targetIndex, new Set());
          var sources = _this13.groupedTargetToSourceLinks.get(targetIndex);
          sources === null || sources === void 0 ? void 0 : sources.add(sourceIndex);
        }
      });
      this._nodes = inputNodes;
      this._links = inputLinks;
    }
  }, {
    key: "getNodeById",
    value: function getNodeById(id) {
      return this.idToNodeMap.get(id);
    }
  }, {
    key: "getNodeByIndex",
    value: function getNodeByIndex(index) {
      return this._nodes[index];
    }
  }, {
    key: "getSortedIndexByInputIndex",
    value: function getSortedIndexByInputIndex(index) {
      return this.inputIndexToSortedIndexMap.get(index);
    }
  }, {
    key: "getInputIndexBySortedIndex",
    value: function getInputIndexBySortedIndex(index) {
      return this.sortedIndexToInputIndexMap.get(index);
    }
  }, {
    key: "getSortedIndexById",
    value: function getSortedIndexById(id) {
      return id !== undefined ? this.idToSortedIndexMap.get(id) : undefined;
    }
  }, {
    key: "getInputIndexById",
    value: function getInputIndexById(id) {
      if (id === undefined) return undefined;
      var sortedIndex = this.getSortedIndexById(id);
      if (sortedIndex === undefined) return undefined;
      return this.getInputIndexBySortedIndex(sortedIndex);
    }
  }, {
    key: "getAdjacentNodes",
    value: function getAdjacentNodes(id) {
      var _this14 = this;
      var _a, _b;
      var index = this.getSortedIndexById(id);
      if (index === undefined) return undefined;
      var outgoingSet = (_a = this.groupedSourceToTargetLinks.get(index)) !== null && _a !== void 0 ? _a : [];
      var incomingSet = (_b = this.groupedTargetToSourceLinks.get(index)) !== null && _b !== void 0 ? _b : [];
      return _toConsumableArray(new Set([].concat(_toConsumableArray(outgoingSet), _toConsumableArray(incomingSet)))).map(function (index) {
        return _this14.getNodeByIndex(_this14.getInputIndexBySortedIndex(index));
      });
    }
  }]);
  return GraphData;
}();
var drawLineFrag = "precision highp float;\n#define GLSLIFY 1\nuniform bool useArrow;varying vec4 rgbaColor;varying vec2 pos;varying float arrowLength;varying float linkWidthArrowWidthRatio;varying float smoothWidthRatio;float map(float value,float min1,float max1,float min2,float max2){return min2+(value-min1)*(max2-min2)/(max1-min1);}void main(){float opacity=1.0;vec3 color=rgbaColor.rgb;float smoothDelta=smoothWidthRatio/2.0;if(useArrow){float end_arrow=0.5+arrowLength/2.0;float start_arrow=end_arrow-arrowLength;float arrowWidthDelta=linkWidthArrowWidthRatio/2.0;float linkOpacity=rgbaColor.a*smoothstep(0.5-arrowWidthDelta,0.5-arrowWidthDelta-smoothDelta,abs(pos.y));float arrowOpacity=1.0;if(pos.x>start_arrow&&pos.x<start_arrow+arrowLength){float xmapped=map(pos.x,start_arrow,end_arrow,0.0,1.0);arrowOpacity=rgbaColor.a*smoothstep(xmapped-smoothDelta,xmapped,map(abs(pos.y),0.5,0.0,0.0,1.0));if(linkOpacity!=arrowOpacity){linkOpacity+=arrowOpacity;}}opacity=linkOpacity;}else opacity=rgbaColor.a*smoothstep(0.5,0.5-smoothDelta,abs(pos.y));gl_FragColor=vec4(color,opacity);}"; // eslint-disable-line

var drawLineVert = "precision highp float;\n#define GLSLIFY 1\nattribute vec2 position,pointA,pointB;attribute vec4 color;attribute float width;uniform sampler2D positions;uniform sampler2D particleGreyoutStatus;uniform mat3 transform;uniform float pointsTextureSize;uniform float widthScale;uniform float nodeSizeScale;uniform bool useArrow;uniform float arrowSizeScale;uniform float spaceSize;uniform vec2 screenSize;uniform float ratio;uniform vec2 linkVisibilityDistanceRange;uniform float linkVisibilityMinTransparency;uniform float greyoutOpacity;uniform bool scaleNodesOnZoom;uniform float curvedWeight;uniform float curvedLinkControlPointDistance;uniform float curvedLinkSegments;varying vec4 rgbaColor;varying vec2 pos;varying float arrowLength;varying float linkWidthArrowWidthRatio;varying float smoothWidthRatio;float map(float value,float min1,float max1,float min2,float max2){return min2+(value-min1)*(max2-min2)/(max1-min1);}vec2 conicParametricCurve(vec2 A,vec2 B,vec2 ControlPoint,float t,float w){vec2 divident=(1.0-t)*(1.0-t)*A+2.0*(1.0-t)*t*w*ControlPoint+t*t*B;float divisor=(1.0-t)*(1.0-t)+2.0*(1.0-t)*t*w+t*t;return divident/divisor;}void main(){pos=position;vec2 pointTexturePosA=(pointA+0.5)/pointsTextureSize;vec2 pointTexturePosB=(pointB+0.5)/pointsTextureSize;vec4 greyoutStatusA=texture2D(particleGreyoutStatus,pointTexturePosA);vec4 greyoutStatusB=texture2D(particleGreyoutStatus,pointTexturePosB);vec4 pointPositionA=texture2D(positions,pointTexturePosA);vec4 pointPositionB=texture2D(positions,pointTexturePosB);vec2 a=pointPositionA.xy;vec2 b=pointPositionB.xy;vec2 xBasis=b-a;vec2 yBasis=normalize(vec2(-xBasis.y,xBasis.x));float linkDist=length(xBasis);float h=curvedLinkControlPointDistance;vec2 controlPoint=(a+b)/2.0+yBasis*linkDist*h;float linkDistPx=linkDist*transform[0][0];float linkWidth=width*widthScale;float k=2.0;float arrowWidth=max(5.0,linkWidth*k);arrowWidth*=arrowSizeScale;float arrowWidthPx=arrowWidth/transform[0][0];arrowLength=min(0.3,(0.866*arrowWidthPx*2.0)/linkDist);float smoothWidth=2.0;float arrowExtraWidth=arrowWidth-linkWidth;linkWidth+=smoothWidth/2.0;if(useArrow){linkWidth+=arrowExtraWidth;}smoothWidthRatio=smoothWidth/linkWidth;linkWidthArrowWidthRatio=arrowExtraWidth/linkWidth;float linkWidthPx=linkWidth/transform[0][0];vec3 rgbColor=color.rgb;float opacity=color.a*max(linkVisibilityMinTransparency,map(linkDistPx,linkVisibilityDistanceRange.g,linkVisibilityDistanceRange.r,0.0,1.0));if(greyoutStatusA.r>0.0||greyoutStatusB.r>0.0){opacity*=greyoutOpacity;}rgbaColor=vec4(rgbColor,opacity);float t=position.x;float w=curvedWeight;float tPrev=t-1.0/curvedLinkSegments;float tNext=t+1.0/curvedLinkSegments;vec2 pointCurr=conicParametricCurve(a,b,controlPoint,t,w);vec2 pointPrev=conicParametricCurve(a,b,controlPoint,max(0.0,tPrev),w);vec2 pointNext=conicParametricCurve(a,b,controlPoint,min(tNext,1.0),w);vec2 xBasisCurved=pointNext-pointPrev;vec2 yBasisCurved=normalize(vec2(-xBasisCurved.y,xBasisCurved.x));pointCurr+=yBasisCurved*linkWidthPx*position.y;vec2 p=2.0*pointCurr/spaceSize-1.0;p*=spaceSize/screenSize;vec3 final=transform*vec3(p,1);gl_Position=vec4(final.rg,0,1);}"; // eslint-disable-line

var getCurveLineGeometry = function getCurveLineGeometry(segments) {
  var scale = (0, _d3Scale.scalePow)().exponent(2).range([0, 1]).domain([-1, 1]);
  var hodographValues = (0, _d3Array.range)(0, segments).map(function (d) {
    return -0.5 + d / segments;
  });
  hodographValues.push(0.5);
  var result = new Array(hodographValues.length * 2);
  hodographValues.forEach(function (d, i) {
    result[i * 2] = [scale(d * 2), 0.5];
    result[i * 2 + 1] = [scale(d * 2), -0.5];
  });
  return result;
};
var Lines = /*#__PURE__*/function (_CoreModule7) {
  _inherits(Lines, _CoreModule7);
  function Lines() {
    _classCallCheck(this, Lines);
    return _callSuper(this, Lines, arguments);
  }
  _createClass(Lines, [{
    key: "create",
    value: function create() {
      this.updateColor();
      this.updateWidth();
      this.updateCurveLineGeometry();
    }
  }, {
    key: "initPrograms",
    value: function initPrograms() {
      var _this15 = this;
      var reglInstance = this.reglInstance,
        config = this.config,
        store = this.store,
        data = this.data,
        points = this.points;
      var pointsTextureSize = store.pointsTextureSize;
      var instancePoints = [];
      data.completeLinks.forEach(function (l) {
        var toIndex = data.getSortedIndexById(l.target);
        var fromIndex = data.getSortedIndexById(l.source);
        var fromX = fromIndex % pointsTextureSize;
        var fromY = Math.floor(fromIndex / pointsTextureSize);
        var toX = toIndex % pointsTextureSize;
        var toY = Math.floor(toIndex / pointsTextureSize);
        instancePoints.push([fromX, fromY]);
        instancePoints.push([toX, toY]);
      });
      var pointsBuffer = reglInstance.buffer(instancePoints);
      this.drawCurveCommand = reglInstance({
        vert: drawLineVert,
        frag: drawLineFrag,
        attributes: {
          position: {
            buffer: function buffer() {
              return _this15.curveLineBuffer;
            },
            divisor: 0
          },
          pointA: {
            buffer: function buffer() {
              return pointsBuffer;
            },
            divisor: 1,
            offset: Float32Array.BYTES_PER_ELEMENT * 0,
            stride: Float32Array.BYTES_PER_ELEMENT * 4
          },
          pointB: {
            buffer: function buffer() {
              return pointsBuffer;
            },
            divisor: 1,
            offset: Float32Array.BYTES_PER_ELEMENT * 2,
            stride: Float32Array.BYTES_PER_ELEMENT * 4
          },
          color: {
            buffer: function buffer() {
              return _this15.colorBuffer;
            },
            divisor: 1,
            offset: Float32Array.BYTES_PER_ELEMENT * 0,
            stride: Float32Array.BYTES_PER_ELEMENT * 4
          },
          width: {
            buffer: function buffer() {
              return _this15.widthBuffer;
            },
            divisor: 1,
            offset: Float32Array.BYTES_PER_ELEMENT * 0,
            stride: Float32Array.BYTES_PER_ELEMENT * 1
          }
        },
        uniforms: {
          positions: function positions() {
            return points === null || points === void 0 ? void 0 : points.currentPositionFbo;
          },
          particleGreyoutStatus: function particleGreyoutStatus() {
            return points === null || points === void 0 ? void 0 : points.greyoutStatusFbo;
          },
          transform: function transform() {
            return store.transform;
          },
          pointsTextureSize: function pointsTextureSize() {
            return store.pointsTextureSize;
          },
          nodeSizeScale: function nodeSizeScale() {
            return config.nodeSizeScale;
          },
          widthScale: function widthScale() {
            return config.linkWidthScale;
          },
          useArrow: function useArrow() {
            return config.linkArrows;
          },
          arrowSizeScale: function arrowSizeScale() {
            return config.linkArrowsSizeScale;
          },
          spaceSize: function spaceSize() {
            return store.adjustedSpaceSize;
          },
          screenSize: function screenSize() {
            return store.screenSize;
          },
          ratio: function ratio() {
            return config.pixelRatio;
          },
          linkVisibilityDistanceRange: function linkVisibilityDistanceRange() {
            return config.linkVisibilityDistanceRange;
          },
          linkVisibilityMinTransparency: function linkVisibilityMinTransparency() {
            return config.linkVisibilityMinTransparency;
          },
          greyoutOpacity: function greyoutOpacity() {
            return config.linkGreyoutOpacity;
          },
          scaleNodesOnZoom: function scaleNodesOnZoom() {
            return config.scaleNodesOnZoom;
          },
          curvedWeight: function curvedWeight() {
            return config.curvedLinkWeight;
          },
          curvedLinkControlPointDistance: function curvedLinkControlPointDistance() {
            return config.curvedLinkControlPointDistance;
          },
          curvedLinkSegments: function curvedLinkSegments() {
            var _a;
            return config.curvedLinks ? (_a = config.curvedLinkSegments) !== null && _a !== void 0 ? _a : defaultConfigValues.curvedLinkSegments : 1;
          }
        },
        cull: {
          enable: true,
          face: 'back'
        },
        blend: {
          enable: true,
          func: {
            dstRGB: 'one minus src alpha',
            srcRGB: 'src alpha',
            dstAlpha: 'one minus src alpha',
            srcAlpha: 'one'
          },
          equation: {
            rgb: 'add',
            alpha: 'add'
          }
        },
        depth: {
          enable: false,
          mask: false
        },
        count: function count() {
          var _a, _b;
          return (_b = (_a = _this15.curveLineGeometry) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        },
        instances: function instances() {
          return data.linksNumber;
        },
        primitive: 'triangle strip'
      });
    }
  }, {
    key: "draw",
    value: function draw() {
      var _a;
      if (!this.colorBuffer || !this.widthBuffer || !this.curveLineBuffer) return;
      (_a = this.drawCurveCommand) === null || _a === void 0 ? void 0 : _a.call(this);
    }
  }, {
    key: "updateColor",
    value: function updateColor() {
      var reglInstance = this.reglInstance,
        config = this.config,
        data = this.data;
      var instancePoints = [];
      data.completeLinks.forEach(function (l) {
        var _a;
        var c = (_a = getValue(l, config.linkColor)) !== null && _a !== void 0 ? _a : defaultLinkColor;
        var rgba = getRgbaColor(c);
        instancePoints.push(rgba);
      });
      this.colorBuffer = reglInstance.buffer(instancePoints);
    }
  }, {
    key: "updateWidth",
    value: function updateWidth() {
      var reglInstance = this.reglInstance,
        config = this.config,
        data = this.data;
      var instancePoints = [];
      data.completeLinks.forEach(function (l) {
        var linkWidth = getValue(l, config.linkWidth);
        instancePoints.push([linkWidth !== null && linkWidth !== void 0 ? linkWidth : defaultLinkWidth]);
      });
      this.widthBuffer = reglInstance.buffer(instancePoints);
    }
  }, {
    key: "updateCurveLineGeometry",
    value: function updateCurveLineGeometry() {
      var reglInstance = this.reglInstance,
        _this$config = this.config,
        curvedLinks = _this$config.curvedLinks,
        curvedLinkSegments = _this$config.curvedLinkSegments;
      this.curveLineGeometry = getCurveLineGeometry(curvedLinks ? curvedLinkSegments !== null && curvedLinkSegments !== void 0 ? curvedLinkSegments : defaultConfigValues.curvedLinkSegments : 1);
      this.curveLineBuffer = reglInstance.buffer(this.curveLineGeometry);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      destroyBuffer(this.colorBuffer);
      destroyBuffer(this.widthBuffer);
      destroyBuffer(this.curveLineBuffer);
    }
  }]);
  return Lines;
}(CoreModule);
function createColorBuffer(data, reglInstance, textureSize, colorAccessor) {
  var _a;
  if (textureSize === 0) return undefined;
  var initialState = new Float32Array(textureSize * textureSize * 4);
  for (var i = 0; i < data.nodes.length; ++i) {
    var sortedIndex = data.getSortedIndexByInputIndex(i);
    var node = data.nodes[i];
    if (node && sortedIndex !== undefined) {
      var c = (_a = getValue(node, colorAccessor, i)) !== null && _a !== void 0 ? _a : defaultNodeColor;
      var rgba = getRgbaColor(c);
      initialState[sortedIndex * 4 + 0] = rgba[0];
      initialState[sortedIndex * 4 + 1] = rgba[1];
      initialState[sortedIndex * 4 + 2] = rgba[2];
      initialState[sortedIndex * 4 + 3] = rgba[3];
    }
  }
  var initialTexture = reglInstance.texture({
    data: initialState,
    width: textureSize,
    height: textureSize,
    type: 'float'
  });
  return reglInstance.framebuffer({
    color: initialTexture,
    depth: false,
    stencil: false
  });
}
function createGreyoutStatusBuffer(selectedIndices, reglInstance, textureSize) {
  if (textureSize === 0) return undefined;
  // Greyout status: 0 - false, highlighted or normal point; 1 - true, greyout point
  var initialState = new Float32Array(textureSize * textureSize * 4).fill(selectedIndices ? 1 : 0);
  if (selectedIndices) {
    var _iterator = _createForOfIteratorHelper(selectedIndices),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var selectedIndex = _step.value;
        initialState[selectedIndex * 4] = 0;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  var initialTexture = reglInstance.texture({
    data: initialState,
    width: textureSize,
    height: textureSize,
    type: 'float'
  });
  return reglInstance.framebuffer({
    color: initialTexture,
    depth: false,
    stencil: false
  });
}
var drawPointsFrag = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nvarying vec2 index;varying vec3 rgbColor;varying float alpha;const float smoothing=0.9;void main(){if(alpha==0.0){discard;}float r=0.0;float delta=0.0;vec2 cxy=2.0*gl_PointCoord-1.0;r=dot(cxy,cxy);float opacity=alpha*(1.0-smoothstep(smoothing,1.0,r));gl_FragColor=vec4(rgbColor,opacity);}"; // eslint-disable-line

var drawPointsVert = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nattribute vec2 indexes;uniform sampler2D positions;uniform sampler2D particleColor;uniform sampler2D particleGreyoutStatus;uniform sampler2D particleSize;uniform float ratio;uniform mat3 transform;uniform float pointsTextureSize;uniform float sizeScale;uniform float spaceSize;uniform vec2 screenSize;uniform float greyoutOpacity;uniform bool scaleNodesOnZoom;varying vec2 index;varying vec3 rgbColor;varying float alpha;float pointSize(float size){float pSize;if(scaleNodesOnZoom){pSize=size*ratio*transform[0][0];}else{pSize=size*ratio*min(5.0,max(1.0,transform[0][0]*0.01));}return pSize;}void main(){index=indexes;vec4 pointPosition=texture2D(positions,(index+0.5)/pointsTextureSize);vec2 point=pointPosition.rg;vec2 p=2.0*point/spaceSize-1.0;p*=spaceSize/screenSize;vec3 final=transform*vec3(p,1);gl_Position=vec4(final.rg,0,1);vec4 pSize=texture2D(particleSize,(index+0.5)/pointsTextureSize);float size=pSize.r*sizeScale;vec4 pColor=texture2D(particleColor,(index+0.5)/pointsTextureSize);rgbColor=pColor.rgb;gl_PointSize=pointSize(size);alpha=pColor.a;vec4 greyoutStatus=texture2D(particleGreyoutStatus,(index+0.5)/pointsTextureSize);if(greyoutStatus.r>0.0){alpha*=greyoutOpacity;}}"; // eslint-disable-line

var findPointsOnAreaSelectionFrag = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nuniform sampler2D position;uniform sampler2D particleSize;uniform float sizeScale;uniform float spaceSize;uniform vec2 screenSize;uniform float ratio;uniform mat3 transform;uniform vec2 selection[2];uniform bool scaleNodesOnZoom;uniform float maxPointSize;varying vec2 index;float pointSize(float size){float pSize;if(scaleNodesOnZoom){pSize=size*ratio*transform[0][0];}else{pSize=size*ratio*min(5.0,max(1.0,transform[0][0]*0.01));}return min(pSize,maxPointSize);}void main(){vec4 pointPosition=texture2D(position,index);vec2 p=2.0*pointPosition.rg/spaceSize-1.0;p*=spaceSize/screenSize;vec3 final=transform*vec3(p,1);vec4 pSize=texture2D(particleSize,index);float size=pSize.r*sizeScale;float left=2.0*(selection[0].x-0.5*pointSize(size))/screenSize.x-1.0;float right=2.0*(selection[1].x+0.5*pointSize(size))/screenSize.x-1.0;float top=2.0*(selection[0].y-0.5*pointSize(size))/screenSize.y-1.0;float bottom=2.0*(selection[1].y+0.5*pointSize(size))/screenSize.y-1.0;gl_FragColor=vec4(0.0,0.0,pointPosition.rg);if(final.x>=left&&final.x<=right&&final.y>=top&&final.y<=bottom){gl_FragColor.r=1.0;}}"; // eslint-disable-line

var drawHighlightedFrag = "precision mediump float;\n#define GLSLIFY 1\nuniform vec4 color;uniform float width;varying vec2 pos;varying float particleOpacity;const float smoothing=1.05;void main(){vec2 cxy=pos;float r=dot(cxy,cxy);float opacity=smoothstep(r,r*smoothing,1.0);float stroke=smoothstep(width,width*smoothing,r);gl_FragColor=vec4(color.rgb,opacity*stroke*color.a*particleOpacity);}"; // eslint-disable-line

var drawHighlightedVert = "precision mediump float;\n#define GLSLIFY 1\nattribute vec2 quad;uniform sampler2D positions;uniform sampler2D particleColor;uniform sampler2D particleGreyoutStatus;uniform sampler2D particleSize;uniform mat3 transform;uniform float pointsTextureSize;uniform float sizeScale;uniform float spaceSize;uniform vec2 screenSize;uniform bool scaleNodesOnZoom;uniform float pointIndex;uniform float maxPointSize;uniform vec4 color;uniform float greyoutOpacity;varying vec2 pos;varying float particleOpacity;float pointSize(float size){float pSize;if(scaleNodesOnZoom){pSize=size*transform[0][0];}else{pSize=size*min(5.0,max(1.0,transform[0][0]*0.01));}return min(pSize,maxPointSize);}const float relativeRingRadius=1.3;void main(){pos=quad;vec2 ij=vec2(mod(pointIndex,pointsTextureSize),floor(pointIndex/pointsTextureSize))+0.5;vec4 pointPosition=texture2D(positions,ij/pointsTextureSize);vec4 pSize=texture2D(particleSize,ij/pointsTextureSize);vec4 pColor=texture2D(particleColor,ij/pointsTextureSize);particleOpacity=pColor.a;vec4 greyoutStatus=texture2D(particleGreyoutStatus,ij/pointsTextureSize);if(greyoutStatus.r>0.0){particleOpacity*=greyoutOpacity;}float size=(pointSize(pSize.r*sizeScale)*relativeRingRadius)/transform[0][0];float radius=size*0.5;vec2 a=pointPosition.xy;vec2 b=pointPosition.xy+vec2(0.0,radius);vec2 xBasis=b-a;vec2 yBasis=normalize(vec2(-xBasis.y,xBasis.x));vec2 point=a+xBasis*quad.x+yBasis*radius*quad.y;vec2 p=2.0*point/spaceSize-1.0;p*=spaceSize/screenSize;vec3 final=transform*vec3(p,1);gl_Position=vec4(final.rg,0,1);}"; // eslint-disable-line

var findHoveredPointFrag = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nvarying vec4 rgba;void main(){gl_FragColor=rgba;}"; // eslint-disable-line

var findHoveredPointVert = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nuniform sampler2D position;uniform float pointsTextureSize;uniform sampler2D particleSize;uniform float sizeScale;uniform float spaceSize;uniform vec2 screenSize;uniform float ratio;uniform mat3 transform;uniform vec2 mousePosition;uniform bool scaleNodesOnZoom;uniform float maxPointSize;attribute vec2 indexes;varying vec4 rgba;float pointSize(float size){float pSize;if(scaleNodesOnZoom){pSize=size*ratio*transform[0][0];}else{pSize=size*ratio*min(5.0,max(1.0,transform[0][0]*0.01));}return min(pSize,maxPointSize);}float euclideanDistance(float x1,float x2,float y1,float y2){return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));}void main(){vec4 pointPosition=texture2D(position,(indexes+0.5)/pointsTextureSize);vec2 p=2.0*pointPosition.rg/spaceSize-1.0;p*=spaceSize/screenSize;vec3 final=transform*vec3(p,1);vec4 pSize=texture2D(particleSize,indexes/pointsTextureSize);float size=pSize.r*sizeScale;float pointRadius=0.5*pointSize(size);vec2 pointScreenPosition=(final.xy+1.0)*screenSize/2.0;rgba=vec4(0.0);gl_Position=vec4(0.5,0.5,0.0,1.0);if(euclideanDistance(pointScreenPosition.x,mousePosition.x,pointScreenPosition.y,mousePosition.y)<pointRadius){float index=indexes.g*pointsTextureSize+indexes.r;rgba=vec4(index,pSize.r,pointPosition.xy);gl_Position=vec4(-0.5,-0.5,0.0,1.0);}gl_PointSize=1.0;}"; // eslint-disable-line

var fillGridWithSampledNodesFrag = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nvarying vec4 rgba;void main(){gl_FragColor=rgba;}"; // eslint-disable-line

var fillGridWithSampledNodesVert = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nuniform sampler2D position;uniform float pointsTextureSize;uniform float spaceSize;uniform vec2 screenSize;uniform mat3 transform;attribute vec2 indexes;varying vec4 rgba;void main(){vec4 pointPosition=texture2D(position,(indexes+0.5)/pointsTextureSize);vec2 p=2.0*pointPosition.rg/spaceSize-1.0;p*=spaceSize/screenSize;vec3 final=transform*vec3(p,1);vec2 pointScreenPosition=(final.xy+1.0)*screenSize/2.0;float index=indexes.g*pointsTextureSize+indexes.r;rgba=vec4(index,1.0,pointPosition.xy);float i=(pointScreenPosition.x+0.5)/screenSize.x;float j=(pointScreenPosition.y+0.5)/screenSize.y;gl_Position=vec4(2.0*vec2(i,j)-1.0,0.0,1.0);gl_PointSize=1.0;}"; // eslint-disable-line

function getNodeSize(node, sizeAccessor, index) {
  var size = getValue(node, sizeAccessor, index);
  return size !== null && size !== void 0 ? size : defaultNodeSize;
}
function createSizeBufferAndFillSizeStore(data, reglInstance, pointTextureSize, sizeAccessor, sizeStore) {
  if (pointTextureSize === 0) return undefined;
  var numParticles = data.nodes.length;
  var initialState = new Float32Array(pointTextureSize * pointTextureSize * 4);
  for (var i = 0; i < numParticles; ++i) {
    var sortedIndex = data.getSortedIndexByInputIndex(i);
    var node = data.nodes[i];
    if (node && sortedIndex !== undefined) {
      var nodeSize = getNodeSize(node, sizeAccessor, i);
      initialState[sortedIndex * 4] = nodeSize;
      sizeStore[i] = nodeSize;
    }
  }
  var initialTexture = reglInstance.texture({
    data: initialState,
    width: pointTextureSize,
    height: pointTextureSize,
    type: 'float'
  });
  return reglInstance.framebuffer({
    color: initialTexture,
    depth: false,
    stencil: false
  });
}
var updatePositionFrag = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nuniform sampler2D position;uniform sampler2D velocity;uniform float friction;uniform float spaceSize;varying vec2 index;void main(){vec4 pointPosition=texture2D(position,index);vec4 pointVelocity=texture2D(velocity,index);pointVelocity.rg*=friction;pointPosition.rg+=pointVelocity.rg;pointPosition.r=clamp(pointPosition.r,0.0,spaceSize);pointPosition.g=clamp(pointPosition.g,0.0,spaceSize);gl_FragColor=pointPosition;}"; // eslint-disable-line

function createTrackedPositionsBuffer(indices, reglInstance) {
  var size = Math.ceil(Math.sqrt(indices.length));
  return reglInstance.framebuffer({
    shape: [size, size],
    depth: false,
    stencil: false,
    colorType: 'float'
  });
}
function createTrackedIndicesBuffer(indices, pointsTextureSize, reglInstance) {
  var size = Math.ceil(Math.sqrt(indices.length));
  if (size === 0) return undefined;
  var initialState = new Float32Array(size * size * 4).fill(-1);
  var _iterator2 = _createForOfIteratorHelper(indices.entries()),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
        i = _step2$value[0],
        sortedIndex = _step2$value[1];
      if (sortedIndex !== undefined) {
        initialState[i * 4] = sortedIndex % pointsTextureSize;
        initialState[i * 4 + 1] = Math.floor(sortedIndex / pointsTextureSize);
        initialState[i * 4 + 2] = 0;
        initialState[i * 4 + 3] = 0;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  var initialTexture = reglInstance.texture({
    data: initialState,
    width: size,
    height: size,
    type: 'float'
  });
  return reglInstance.framebuffer({
    color: initialTexture,
    depth: false,
    stencil: false
  });
}
var trackPositionsFrag = "#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\nuniform sampler2D position;uniform sampler2D trackedIndices;uniform float pointsTextureSize;varying vec2 index;void main(){vec4 trackedPointIndicies=texture2D(trackedIndices,index);if(trackedPointIndicies.r<0.0)discard;vec4 pointPosition=texture2D(position,(trackedPointIndicies.rg+0.5)/pointsTextureSize);gl_FragColor=vec4(pointPosition.rg,1.0,1.0);}"; // eslint-disable-line
var Points = /*#__PURE__*/function (_CoreModule8) {
  _inherits(Points, _CoreModule8);
  function Points() {
    var _this16;
    _classCallCheck(this, Points);
    _this16 = _callSuper(this, Points, arguments);
    _this16.trackedPositionsById = new Map();
    return _this16;
  }
  _createClass(Points, [{
    key: "create",
    value: function create() {
      var _a, _b;
      var reglInstance = this.reglInstance,
        store = this.store,
        data = this.data,
        config = this.config;
      var pointsTextureSize = store.pointsTextureSize,
        adjustedSpaceSize = store.adjustedSpaceSize;
      if (!pointsTextureSize) return;
      var numParticles = data.nodes.length;
      var initialState = new Float32Array(pointsTextureSize * pointsTextureSize * 4);
      if (!config.disableSimulation) this.rescaleInitialNodePositions();
      for (var i = 0; i < numParticles; ++i) {
        var sortedIndex = this.data.getSortedIndexByInputIndex(i);
        var node = data.nodes[i];
        if (node && sortedIndex !== undefined) {
          initialState[sortedIndex * 4 + 0] = (_a = node.x) !== null && _a !== void 0 ? _a : adjustedSpaceSize * store.getRandomFloat(0.495, 0.505);
          initialState[sortedIndex * 4 + 1] = (_b = node.y) !== null && _b !== void 0 ? _b : adjustedSpaceSize * store.getRandomFloat(0.495, 0.505);
        }
      }
      // Create position buffer
      this.currentPositionFbo = reglInstance.framebuffer({
        color: reglInstance.texture({
          data: initialState,
          shape: [pointsTextureSize, pointsTextureSize, 4],
          type: 'float'
        }),
        depth: false,
        stencil: false
      });
      if (!this.config.disableSimulation) {
        this.previousPositionFbo = reglInstance.framebuffer({
          color: reglInstance.texture({
            data: initialState,
            shape: [pointsTextureSize, pointsTextureSize, 4],
            type: 'float'
          }),
          depth: false,
          stencil: false
        });
        // Create velocity buffer
        this.velocityFbo = reglInstance.framebuffer({
          color: reglInstance.texture({
            data: new Float32Array(pointsTextureSize * pointsTextureSize * 4).fill(0),
            shape: [pointsTextureSize, pointsTextureSize, 4],
            type: 'float'
          }),
          depth: false,
          stencil: false
        });
      }
      // Create selected points buffer
      this.selectedFbo = reglInstance.framebuffer({
        color: reglInstance.texture({
          data: initialState,
          shape: [pointsTextureSize, pointsTextureSize, 4],
          type: 'float'
        }),
        depth: false,
        stencil: false
      });
      this.hoveredFbo = reglInstance.framebuffer({
        shape: [2, 2],
        colorType: 'float',
        depth: false,
        stencil: false
      });
      this.updateSize();
      this.updateColor();
      this.updateGreyoutStatus();
      this.updateSampledNodesGrid();
    }
  }, {
    key: "initPrograms",
    value: function initPrograms() {
      var _this17 = this;
      var reglInstance = this.reglInstance,
        config = this.config,
        store = this.store,
        data = this.data;
      if (!config.disableSimulation) {
        this.updatePositionCommand = reglInstance({
          frag: updatePositionFrag,
          vert: updateVert,
          framebuffer: function framebuffer() {
            return _this17.currentPositionFbo;
          },
          primitive: 'triangle strip',
          count: 4,
          attributes: {
            quad: createQuadBuffer(reglInstance)
          },
          uniforms: {
            position: function position() {
              return _this17.previousPositionFbo;
            },
            velocity: function velocity() {
              return _this17.velocityFbo;
            },
            friction: function friction() {
              var _a;
              return (_a = config.simulation) === null || _a === void 0 ? void 0 : _a.friction;
            },
            spaceSize: function spaceSize() {
              return store.adjustedSpaceSize;
            }
          }
        });
      }
      this.drawCommand = reglInstance({
        frag: drawPointsFrag,
        vert: drawPointsVert,
        primitive: 'points',
        count: function count() {
          return data.nodes.length;
        },
        attributes: {
          indexes: createIndexesBuffer(reglInstance, store.pointsTextureSize)
        },
        uniforms: {
          positions: function positions() {
            return _this17.currentPositionFbo;
          },
          particleColor: function particleColor() {
            return _this17.colorFbo;
          },
          particleGreyoutStatus: function particleGreyoutStatus() {
            return _this17.greyoutStatusFbo;
          },
          particleSize: function particleSize() {
            return _this17.sizeFbo;
          },
          ratio: function ratio() {
            return config.pixelRatio;
          },
          sizeScale: function sizeScale() {
            return config.nodeSizeScale;
          },
          pointsTextureSize: function pointsTextureSize() {
            return store.pointsTextureSize;
          },
          transform: function transform() {
            return store.transform;
          },
          spaceSize: function spaceSize() {
            return store.adjustedSpaceSize;
          },
          screenSize: function screenSize() {
            return store.screenSize;
          },
          greyoutOpacity: function greyoutOpacity() {
            return config.nodeGreyoutOpacity;
          },
          scaleNodesOnZoom: function scaleNodesOnZoom() {
            return config.scaleNodesOnZoom;
          }
        },
        blend: {
          enable: true,
          func: {
            dstRGB: 'one minus src alpha',
            srcRGB: 'src alpha',
            dstAlpha: 'one minus src alpha',
            srcAlpha: 'one'
          },
          equation: {
            rgb: 'add',
            alpha: 'add'
          }
        },
        depth: {
          enable: false,
          mask: false
        }
      });
      this.findPointsOnAreaSelectionCommand = reglInstance({
        frag: findPointsOnAreaSelectionFrag,
        vert: updateVert,
        framebuffer: function framebuffer() {
          return _this17.selectedFbo;
        },
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        },
        uniforms: {
          position: function position() {
            return _this17.currentPositionFbo;
          },
          particleSize: function particleSize() {
            return _this17.sizeFbo;
          },
          spaceSize: function spaceSize() {
            return store.adjustedSpaceSize;
          },
          screenSize: function screenSize() {
            return store.screenSize;
          },
          sizeScale: function sizeScale() {
            return config.nodeSizeScale;
          },
          transform: function transform() {
            return store.transform;
          },
          ratio: function ratio() {
            return config.pixelRatio;
          },
          'selection[0]': function selection0() {
            return store.selectedArea[0];
          },
          'selection[1]': function selection1() {
            return store.selectedArea[1];
          },
          scaleNodesOnZoom: function scaleNodesOnZoom() {
            return config.scaleNodesOnZoom;
          },
          maxPointSize: function maxPointSize() {
            return store.maxPointSize;
          }
        }
      });
      this.clearHoveredFboCommand = reglInstance({
        frag: clearFrag,
        vert: updateVert,
        framebuffer: this.hoveredFbo,
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        }
      });
      this.findHoveredPointCommand = reglInstance({
        frag: findHoveredPointFrag,
        vert: findHoveredPointVert,
        primitive: 'points',
        count: function count() {
          return data.nodes.length;
        },
        framebuffer: function framebuffer() {
          return _this17.hoveredFbo;
        },
        attributes: {
          indexes: createIndexesBuffer(reglInstance, store.pointsTextureSize)
        },
        uniforms: {
          position: function position() {
            return _this17.currentPositionFbo;
          },
          particleSize: function particleSize() {
            return _this17.sizeFbo;
          },
          ratio: function ratio() {
            return config.pixelRatio;
          },
          sizeScale: function sizeScale() {
            return config.nodeSizeScale;
          },
          pointsTextureSize: function pointsTextureSize() {
            return store.pointsTextureSize;
          },
          transform: function transform() {
            return store.transform;
          },
          spaceSize: function spaceSize() {
            return store.adjustedSpaceSize;
          },
          screenSize: function screenSize() {
            return store.screenSize;
          },
          scaleNodesOnZoom: function scaleNodesOnZoom() {
            return config.scaleNodesOnZoom;
          },
          mousePosition: function mousePosition() {
            return store.screenMousePosition;
          },
          maxPointSize: function maxPointSize() {
            return store.maxPointSize;
          }
        },
        depth: {
          enable: false,
          mask: false
        }
      });
      this.clearSampledNodesFboCommand = reglInstance({
        frag: clearFrag,
        vert: updateVert,
        framebuffer: function framebuffer() {
          return _this17.sampledNodesFbo;
        },
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        }
      });
      this.fillSampledNodesFboCommand = reglInstance({
        frag: fillGridWithSampledNodesFrag,
        vert: fillGridWithSampledNodesVert,
        primitive: 'points',
        count: function count() {
          return data.nodes.length;
        },
        framebuffer: function framebuffer() {
          return _this17.sampledNodesFbo;
        },
        attributes: {
          indexes: createIndexesBuffer(reglInstance, store.pointsTextureSize)
        },
        uniforms: {
          position: function position() {
            return _this17.currentPositionFbo;
          },
          pointsTextureSize: function pointsTextureSize() {
            return store.pointsTextureSize;
          },
          transform: function transform() {
            return store.transform;
          },
          spaceSize: function spaceSize() {
            return store.adjustedSpaceSize;
          },
          screenSize: function screenSize() {
            return store.screenSize;
          }
        },
        depth: {
          enable: false,
          mask: false
        }
      });
      this.drawHighlightedCommand = reglInstance({
        frag: drawHighlightedFrag,
        vert: drawHighlightedVert,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        },
        primitive: 'triangle strip',
        count: 4,
        uniforms: {
          color: reglInstance.prop('color'),
          width: reglInstance.prop('width'),
          pointIndex: reglInstance.prop('pointIndex'),
          positions: function positions() {
            return _this17.currentPositionFbo;
          },
          particleColor: function particleColor() {
            return _this17.colorFbo;
          },
          particleSize: function particleSize() {
            return _this17.sizeFbo;
          },
          sizeScale: function sizeScale() {
            return config.nodeSizeScale;
          },
          pointsTextureSize: function pointsTextureSize() {
            return store.pointsTextureSize;
          },
          transform: function transform() {
            return store.transform;
          },
          spaceSize: function spaceSize() {
            return store.adjustedSpaceSize;
          },
          screenSize: function screenSize() {
            return store.screenSize;
          },
          scaleNodesOnZoom: function scaleNodesOnZoom() {
            return config.scaleNodesOnZoom;
          },
          maxPointSize: function maxPointSize() {
            return store.maxPointSize;
          },
          particleGreyoutStatus: function particleGreyoutStatus() {
            return _this17.greyoutStatusFbo;
          },
          greyoutOpacity: function greyoutOpacity() {
            return config.nodeGreyoutOpacity;
          }
        },
        blend: {
          enable: true,
          func: {
            dstRGB: 'one minus src alpha',
            srcRGB: 'src alpha',
            dstAlpha: 'one minus src alpha',
            srcAlpha: 'one'
          },
          equation: {
            rgb: 'add',
            alpha: 'add'
          }
        },
        depth: {
          enable: false,
          mask: false
        }
      });
      this.trackPointsCommand = reglInstance({
        frag: trackPositionsFrag,
        vert: updateVert,
        framebuffer: function framebuffer() {
          return _this17.trackedPositionsFbo;
        },
        primitive: 'triangle strip',
        count: 4,
        attributes: {
          quad: createQuadBuffer(reglInstance)
        },
        uniforms: {
          position: function position() {
            return _this17.currentPositionFbo;
          },
          trackedIndices: function trackedIndices() {
            return _this17.trackedIndicesFbo;
          },
          pointsTextureSize: function pointsTextureSize() {
            return store.pointsTextureSize;
          }
        }
      });
    }
  }, {
    key: "updateColor",
    value: function updateColor() {
      var reglInstance = this.reglInstance,
        config = this.config,
        pointsTextureSize = this.store.pointsTextureSize,
        data = this.data;
      if (!pointsTextureSize) return;
      this.colorFbo = createColorBuffer(data, reglInstance, pointsTextureSize, config.nodeColor);
    }
  }, {
    key: "updateGreyoutStatus",
    value: function updateGreyoutStatus() {
      var reglInstance = this.reglInstance,
        store = this.store;
      this.greyoutStatusFbo = createGreyoutStatusBuffer(store.selectedIndices, reglInstance, store.pointsTextureSize);
    }
  }, {
    key: "updateSize",
    value: function updateSize() {
      var reglInstance = this.reglInstance,
        config = this.config,
        pointsTextureSize = this.store.pointsTextureSize,
        data = this.data;
      if (!pointsTextureSize) return;
      this.sizeByIndex = new Float32Array(data.nodes.length);
      this.sizeFbo = createSizeBufferAndFillSizeStore(data, reglInstance, pointsTextureSize, config.nodeSize, this.sizeByIndex);
    }
  }, {
    key: "updateSampledNodesGrid",
    value: function updateSampledNodesGrid() {
      var screenSize = this.store.screenSize,
        nodeSamplingDistance = this.config.nodeSamplingDistance,
        reglInstance = this.reglInstance;
      var dist = nodeSamplingDistance !== null && nodeSamplingDistance !== void 0 ? nodeSamplingDistance : Math.min.apply(Math, _toConsumableArray(screenSize)) / 2;
      var w = Math.ceil(screenSize[0] / dist);
      var h = Math.ceil(screenSize[1] / dist);
      destroyFramebuffer(this.sampledNodesFbo);
      this.sampledNodesFbo = reglInstance.framebuffer({
        shape: [w, h],
        depth: false,
        stencil: false,
        colorType: 'float'
      });
    }
  }, {
    key: "trackPoints",
    value: function trackPoints() {
      var _a;
      if (!this.trackedIndicesFbo || !this.trackedPositionsFbo) return;
      (_a = this.trackPointsCommand) === null || _a === void 0 ? void 0 : _a.call(this);
    }
  }, {
    key: "draw",
    value: function draw() {
      var _a, _b, _c;
      var _this$config2 = this.config,
        renderHoveredNodeRing = _this$config2.renderHoveredNodeRing,
        renderHighlightedNodeRing = _this$config2.renderHighlightedNodeRing,
        store = this.store;
      (_a = this.drawCommand) === null || _a === void 0 ? void 0 : _a.call(this);
      if ((renderHoveredNodeRing !== null && renderHoveredNodeRing !== void 0 ? renderHoveredNodeRing : renderHighlightedNodeRing) && store.hoveredNode) {
        (_b = this.drawHighlightedCommand) === null || _b === void 0 ? void 0 : _b.call(this, {
          width: 0.85,
          color: store.hoveredNodeRingColor,
          pointIndex: store.hoveredNode.index
        });
      }
      if (store.focusedNode) {
        (_c = this.drawHighlightedCommand) === null || _c === void 0 ? void 0 : _c.call(this, {
          width: 0.75,
          color: store.focusedNodeRingColor,
          pointIndex: store.focusedNode.index
        });
      }
    }
  }, {
    key: "updatePosition",
    value: function updatePosition() {
      var _a;
      (_a = this.updatePositionCommand) === null || _a === void 0 ? void 0 : _a.call(this);
      this.swapFbo();
    }
  }, {
    key: "findPointsOnAreaSelection",
    value: function findPointsOnAreaSelection() {
      var _a;
      (_a = this.findPointsOnAreaSelectionCommand) === null || _a === void 0 ? void 0 : _a.call(this);
    }
  }, {
    key: "findHoveredPoint",
    value: function findHoveredPoint() {
      var _a, _b;
      (_a = this.clearHoveredFboCommand) === null || _a === void 0 ? void 0 : _a.call(this);
      (_b = this.findHoveredPointCommand) === null || _b === void 0 ? void 0 : _b.call(this);
    }
  }, {
    key: "getNodeRadiusByIndex",
    value: function getNodeRadiusByIndex(index) {
      var _a;
      return (_a = this.sizeByIndex) === null || _a === void 0 ? void 0 : _a[index];
    }
  }, {
    key: "trackNodesByIds",
    value: function trackNodesByIds(ids) {
      var _this18 = this;
      this.trackedIds = ids.length ? ids : undefined;
      this.trackedPositionsById.clear();
      var indices = ids.map(function (id) {
        return _this18.data.getSortedIndexById(id);
      }).filter(function (d) {
        return d !== undefined;
      });
      destroyFramebuffer(this.trackedIndicesFbo);
      this.trackedIndicesFbo = undefined;
      destroyFramebuffer(this.trackedPositionsFbo);
      this.trackedPositionsFbo = undefined;
      if (indices.length) {
        this.trackedIndicesFbo = createTrackedIndicesBuffer(indices, this.store.pointsTextureSize, this.reglInstance);
        this.trackedPositionsFbo = createTrackedPositionsBuffer(indices, this.reglInstance);
      }
      this.trackPoints();
    }
  }, {
    key: "getTrackedPositions",
    value: function getTrackedPositions() {
      var _this19 = this;
      if (!this.trackedIds) return this.trackedPositionsById;
      var pixels = readPixels(this.reglInstance, this.trackedPositionsFbo);
      this.trackedIds.forEach(function (id, i) {
        var x = pixels[i * 4];
        var y = pixels[i * 4 + 1];
        if (x !== undefined && y !== undefined) _this19.trackedPositionsById.set(id, [x, y]);
      });
      return this.trackedPositionsById;
    }
  }, {
    key: "getSampledNodePositionsMap",
    value: function getSampledNodePositionsMap() {
      var _a, _b, _c;
      var positions = new Map();
      if (!this.sampledNodesFbo) return positions;
      (_a = this.clearSampledNodesFboCommand) === null || _a === void 0 ? void 0 : _a.call(this);
      (_b = this.fillSampledNodesFboCommand) === null || _b === void 0 ? void 0 : _b.call(this);
      var pixels = readPixels(this.reglInstance, this.sampledNodesFbo);
      for (var i = 0; i < pixels.length / 4; i++) {
        var index = pixels[i * 4];
        var isNotEmpty = !!pixels[i * 4 + 1];
        var x = pixels[i * 4 + 2];
        var y = pixels[i * 4 + 3];
        if (isNotEmpty && index !== undefined && x !== undefined && y !== undefined) {
          var inputIndex = this.data.getInputIndexBySortedIndex(index);
          if (inputIndex !== undefined) {
            var id = (_c = this.data.getNodeByIndex(inputIndex)) === null || _c === void 0 ? void 0 : _c.id;
            if (id !== undefined) positions.set(id, [x, y]);
          }
        }
      }
      return positions;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      destroyFramebuffer(this.currentPositionFbo);
      destroyFramebuffer(this.previousPositionFbo);
      destroyFramebuffer(this.velocityFbo);
      destroyFramebuffer(this.selectedFbo);
      destroyFramebuffer(this.colorFbo);
      destroyFramebuffer(this.sizeFbo);
      destroyFramebuffer(this.greyoutStatusFbo);
      destroyFramebuffer(this.hoveredFbo);
      destroyFramebuffer(this.trackedIndicesFbo);
      destroyFramebuffer(this.trackedPositionsFbo);
    }
  }, {
    key: "swapFbo",
    value: function swapFbo() {
      var temp = this.previousPositionFbo;
      this.previousPositionFbo = this.currentPositionFbo;
      this.currentPositionFbo = temp;
    }
  }, {
    key: "rescaleInitialNodePositions",
    value: function rescaleInitialNodePositions() {
      var nodes = this.data.nodes;
      var spaceSize = this.config.spaceSize;
      if (nodes.length === 0) return;
      var xs = nodes.map(function (n) {
        return n.x;
      }).filter(function (n) {
        return n !== undefined;
      });
      if (xs.length === 0) return;
      var ys = nodes.map(function (n) {
        return n.y;
      }).filter(function (n) {
        return n !== undefined;
      });
      if (ys.length === 0) return;
      var minX = Math.min.apply(Math, _toConsumableArray(xs));
      var maxX = Math.max.apply(Math, _toConsumableArray(xs));
      var minY = Math.min.apply(Math, _toConsumableArray(ys));
      var maxY = Math.max.apply(Math, _toConsumableArray(ys));
      var w = maxX - minX;
      var h = maxY - minY;
      var size = Math.max(w, h);
      var dw = (size - w) / 2;
      var dh = (size - h) / 2;
      var scaleX = (0, _d3Scale.scaleLinear)().range([0, spaceSize !== null && spaceSize !== void 0 ? spaceSize : defaultConfigValues.spaceSize]).domain([minX - dw, maxX + dw]);
      var scaleY = (0, _d3Scale.scaleLinear)().range([0, spaceSize !== null && spaceSize !== void 0 ? spaceSize : defaultConfigValues.spaceSize]).domain([minY - dh, maxY + dh]);
      nodes.forEach(function (n) {
        n.x = scaleX(n.x);
        n.y = scaleY(n.y);
      });
    }
  }]);
  return Points;
}(CoreModule);
var ALPHA_MIN = 0.001;
var MAX_POINT_SIZE = 64;
var Store = /*#__PURE__*/function () {
  function Store() {
    _classCallCheck(this, Store);
    this.pointsTextureSize = 0;
    this.linksTextureSize = 0;
    this.alpha = 1;
    this.transform = _glMatrix.mat3.create();
    this.backgroundColor = [0, 0, 0, 0];
    this.screenSize = [0, 0];
    this.mousePosition = [0, 0];
    this.screenMousePosition = [0, 0];
    this.selectedArea = [[0, 0], [0, 0]];
    this.isSimulationRunning = false;
    this.simulationProgress = 0;
    this.selectedIndices = null;
    this.maxPointSize = MAX_POINT_SIZE;
    this.hoveredNode = undefined;
    this.focusedNode = undefined;
    this.adjustedSpaceSize = defaultConfigValues.spaceSize;
    this.hoveredNodeRingColor = [1, 1, 1, hoveredNodeRingOpacity];
    this.focusedNodeRingColor = [1, 1, 1, focusedNodeRingOpacity];
    this.alphaTarget = 0;
    this.scaleNodeX = (0, _d3Scale.scaleLinear)();
    this.scaleNodeY = (0, _d3Scale.scaleLinear)();
    this.random = new _random.Random();
    this.alphaDecay = function (decay) {
      return 1 - Math.pow(ALPHA_MIN, 1 / decay);
    };
  }
  _createClass(Store, [{
    key: "addRandomSeed",
    value: function addRandomSeed(seed) {
      this.random = this.random.clone(seed);
    }
  }, {
    key: "getRandomFloat",
    value: function getRandomFloat(min, max) {
      return this.random.float(min, max);
    }
    /**
     * If the config parameter `spaceSize` exceeds the limits of WebGL,
     * it reduces the space size without changing the config parameter.
     */
  }, {
    key: "adjustSpaceSize",
    value: function adjustSpaceSize(configSpaceSize, webglMaxTextureSize) {
      if (configSpaceSize >= webglMaxTextureSize) {
        this.adjustedSpaceSize = webglMaxTextureSize / 2;
        console.warn("The `spaceSize` has been reduced to ".concat(this.adjustedSpaceSize, " due to WebGL limits"));
      } else this.adjustedSpaceSize = configSpaceSize;
    }
  }, {
    key: "updateScreenSize",
    value: function updateScreenSize(width, height) {
      var adjustedSpaceSize = this.adjustedSpaceSize;
      this.screenSize = [width, height];
      this.scaleNodeX.domain([0, adjustedSpaceSize]).range([(width - adjustedSpaceSize) / 2, (width + adjustedSpaceSize) / 2]);
      this.scaleNodeY.domain([adjustedSpaceSize, 0]).range([(height - adjustedSpaceSize) / 2, (height + adjustedSpaceSize) / 2]);
    }
  }, {
    key: "scaleX",
    value: function scaleX(x) {
      return this.scaleNodeX(x);
    }
  }, {
    key: "scaleY",
    value: function scaleY(y) {
      return this.scaleNodeY(y);
    }
  }, {
    key: "setHoveredNodeRingColor",
    value: function setHoveredNodeRingColor(color) {
      var convertedRgba = getRgbaColor(color);
      this.hoveredNodeRingColor[0] = convertedRgba[0];
      this.hoveredNodeRingColor[1] = convertedRgba[1];
      this.hoveredNodeRingColor[2] = convertedRgba[2];
    }
  }, {
    key: "setFocusedNodeRingColor",
    value: function setFocusedNodeRingColor(color) {
      var convertedRgba = getRgbaColor(color);
      this.focusedNodeRingColor[0] = convertedRgba[0];
      this.focusedNodeRingColor[1] = convertedRgba[1];
      this.focusedNodeRingColor[2] = convertedRgba[2];
    }
  }, {
    key: "setFocusedNode",
    value: function setFocusedNode(node, index) {
      if (node && index !== undefined) {
        this.focusedNode = {
          node: node,
          index: index
        };
      } else this.focusedNode = undefined;
    }
  }, {
    key: "addAlpha",
    value: function addAlpha(decay) {
      return (this.alphaTarget - this.alpha) * this.alphaDecay(decay);
    }
  }]);
  return Store;
}();
var Zoom = /*#__PURE__*/function () {
  function Zoom(store, config) {
    var _this20 = this;
    _classCallCheck(this, Zoom);
    this.eventTransform = _d3Zoom.zoomIdentity;
    this.behavior = (0, _d3Zoom.zoom)().scaleExtent([0.001, Infinity]).on('start', function (e) {
      var _a, _b, _c;
      _this20.isRunning = true;
      var userDriven = !!e.sourceEvent;
      (_c = (_b = (_a = _this20.config) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.onZoomStart) === null || _c === void 0 ? void 0 : _c.call(_b, e, userDriven);
    }).on('zoom', function (e) {
      var _a, _b, _c;
      _this20.eventTransform = e.transform;
      var _this20$eventTransfor = _this20.eventTransform,
        x = _this20$eventTransfor.x,
        y = _this20$eventTransfor.y,
        k = _this20$eventTransfor.k,
        _this20$store = _this20.store,
        transform = _this20$store.transform,
        screenSize = _this20$store.screenSize;
      var w = screenSize[0];
      var h = screenSize[1];
      _glMatrix.mat3.projection(transform, w, h);
      _glMatrix.mat3.translate(transform, transform, [x, y]);
      _glMatrix.mat3.scale(transform, transform, [k, k]);
      _glMatrix.mat3.translate(transform, transform, [w / 2, h / 2]);
      _glMatrix.mat3.scale(transform, transform, [w / 2, h / 2]);
      _glMatrix.mat3.scale(transform, transform, [1, -1]);
      var userDriven = !!e.sourceEvent;
      (_c = (_b = (_a = _this20.config) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.onZoom) === null || _c === void 0 ? void 0 : _c.call(_b, e, userDriven);
    }).on('end', function (e) {
      var _a, _b, _c;
      _this20.isRunning = false;
      var userDriven = !!e.sourceEvent;
      (_c = (_b = (_a = _this20.config) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.onZoomEnd) === null || _c === void 0 ? void 0 : _c.call(_b, e, userDriven);
    });
    this.isRunning = false;
    this.store = store;
    this.config = config;
  }
  _createClass(Zoom, [{
    key: "getTransform",
    value: function getTransform(positions, scale) {
      var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.store.maxPointSize / 2;
      if (positions.length === 0) return this.eventTransform;
      var screenSize = this.store.screenSize;
      var width = screenSize[0];
      var height = screenSize[1];
      var xExtent = (0, _d3Array.extent)(positions.map(function (d) {
        return d[0];
      }));
      var yExtent = (0, _d3Array.extent)(positions.map(function (d) {
        return d[1];
      }));
      xExtent[0] = this.store.scaleX(xExtent[0] - padding);
      xExtent[1] = this.store.scaleX(xExtent[1] + padding);
      yExtent[0] = this.store.scaleY(yExtent[0] - padding);
      yExtent[1] = this.store.scaleY(yExtent[1] + padding);
      var xScale = width / (xExtent[1] - xExtent[0]);
      var yScale = height / (yExtent[0] - yExtent[1]);
      var clampedScale = clamp.apply(void 0, [scale !== null && scale !== void 0 ? scale : Math.min(xScale, yScale)].concat(_toConsumableArray(this.behavior.scaleExtent())));
      var xCenter = (xExtent[1] + xExtent[0]) / 2;
      var yCenter = (yExtent[1] + yExtent[0]) / 2;
      var translateX = width / 2 - xCenter * clampedScale;
      var translateY = height / 2 - yCenter * clampedScale;
      var transform = _d3Zoom.zoomIdentity.translate(translateX, translateY).scale(clampedScale);
      return transform;
    }
  }, {
    key: "getDistanceToPoint",
    value: function getDistanceToPoint(position) {
      var _this$eventTransform = this.eventTransform,
        x = _this$eventTransform.x,
        y = _this$eventTransform.y,
        k = _this$eventTransform.k;
      var point = this.getTransform([position], k);
      var dx = x - point.x;
      var dy = y - point.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
  }, {
    key: "getMiddlePointTransform",
    value: function getMiddlePointTransform(position) {
      var screenSize = this.store.screenSize,
        _this$eventTransform2 = this.eventTransform,
        x = _this$eventTransform2.x,
        y = _this$eventTransform2.y,
        k = _this$eventTransform2.k;
      var width = screenSize[0];
      var height = screenSize[1];
      var currX = (width / 2 - x) / k;
      var currY = (height / 2 - y) / k;
      var pointX = this.store.scaleX(position[0]);
      var pointY = this.store.scaleY(position[1]);
      var centerX = (currX + pointX) / 2;
      var centerY = (currY + pointY) / 2;
      var scale = 1;
      var translateX = width / 2 - centerX * scale;
      var translateY = height / 2 - centerY * scale;
      return _d3Zoom.zoomIdentity.translate(translateX, translateY).scale(scale);
    }
  }, {
    key: "convertSpaceToScreenPosition",
    value: function convertSpaceToScreenPosition(spacePosition) {
      var screenPointX = this.eventTransform.applyX(this.store.scaleX(spacePosition[0]));
      var screenPointY = this.eventTransform.applyY(this.store.scaleY(spacePosition[1]));
      return [screenPointX, screenPointY];
    }
  }, {
    key: "convertSpaceToScreenRadius",
    value: function convertSpaceToScreenRadius(spaceRadius) {
      var scaleNodesOnZoom = this.config.scaleNodesOnZoom,
        maxPointSize = this.store.maxPointSize,
        k = this.eventTransform.k;
      var size = spaceRadius * 2;
      if (scaleNodesOnZoom) {
        size *= k;
      } else {
        size *= Math.min(5.0, Math.max(1.0, k * 0.01));
      }
      return Math.min(size, maxPointSize) / 2;
    }
  }]);
  return Zoom;
}();
var Graph = exports.Graph = /*#__PURE__*/function () {
  function Graph(canvas, config) {
    var _this21 = this;
    _classCallCheck(this, Graph);
    var _a;
    this.config = new GraphConfig();
    this.graph = new GraphData();
    this.requestAnimationFrameId = 0;
    this.isRightClickMouse = false;
    this.store = new Store();
    this.zoomInstance = new Zoom(this.store, this.config);
    this.hasParticleSystemDestroyed = false;
    /**
     * The value of `_findHoveredPointExecutionCount` is incremented by 1 on each animation frame.
     * When the counter reaches 2 (or more), it is reset to 0 and the `findHoveredPoint` method is executed.
     */
    this._findHoveredPointExecutionCount = 0;
    /**
     * If the mouse is not on the Canvas, the `findHoveredPoint` method will not be executed.
     */
    this._isMouseOnCanvas = false;
    /**
     * After setting data at a first time, the fit logic will run
     * */
    this._isFirstDataAfterInit = true;
    if (config) this.config.init(config);
    var w = canvas.clientWidth;
    var h = canvas.clientHeight;
    canvas.width = w * this.config.pixelRatio;
    canvas.height = h * this.config.pixelRatio;
    // If the canvas element has no CSS width and height style, the clientWidth and the clientHeight will always
    // be equal to the width and height canvas attribute.
    // In order to prevent resize problem assume that canvas CSS style width and height has a value of 100%.
    if (canvas.style.width === '' && canvas.style.height === '') {
      (0, _d3Selection.select)(canvas).style('width', '100%').style('height', '100%');
    }
    this.canvas = canvas;
    this.canvasD3Selection = (0, _d3Selection.select)(canvas);
    this.canvasD3Selection.on('mouseenter.cosmos', function () {
      _this21._isMouseOnCanvas = true;
    }).on('mouseleave.cosmos', function () {
      _this21._isMouseOnCanvas = false;
    });
    this.zoomInstance.behavior.on('start.detect', function (e) {
      _this21.currentEvent = e;
    }).on('zoom.detect', function (e) {
      var userDriven = !!e.sourceEvent;
      if (userDriven) _this21.updateMousePosition(e.sourceEvent);
      _this21.currentEvent = e;
    }).on('end.detect', function (e) {
      _this21.currentEvent = e;
    });
    this.canvasD3Selection.call(this.zoomInstance.behavior).on('click', this.onClick.bind(this)).on('mousemove', this.onMouseMove.bind(this)).on('contextmenu', this.onRightClickMouse.bind(this));
    if (this.config.disableZoom) this.disableZoom();
    this.setZoomLevel(this.config.initialZoomLevel);
    this.reglInstance = (0, _regl.default)({
      canvas: this.canvas,
      attributes: {
        antialias: false,
        preserveDrawingBuffer: true,
        premultipliedAlpha: false,
        alpha: false
      },
      extensions: ['OES_texture_float', 'ANGLE_instanced_arrays']
    });
    this.store.maxPointSize = ((_a = this.reglInstance.limits.pointSizeDims[1]) !== null && _a !== void 0 ? _a : MAX_POINT_SIZE) / this.config.pixelRatio;
    this.store.adjustSpaceSize(this.config.spaceSize, this.reglInstance.limits.maxTextureSize);
    this.store.updateScreenSize(w, h);
    this.points = new Points(this.reglInstance, this.config, this.store, this.graph);
    this.lines = new Lines(this.reglInstance, this.config, this.store, this.graph, this.points);
    if (!this.config.disableSimulation) {
      this.forceGravity = new ForceGravity(this.reglInstance, this.config, this.store, this.graph, this.points);
      this.forceCenter = new ForceCenter(this.reglInstance, this.config, this.store, this.graph, this.points);
      this.forceManyBody = this.config.useQuadtree ? new ForceManyBodyQuadtree(this.reglInstance, this.config, this.store, this.graph, this.points) : new ForceManyBody(this.reglInstance, this.config, this.store, this.graph, this.points);
      this.forceLinkIncoming = new ForceLink(this.reglInstance, this.config, this.store, this.graph, this.points);
      this.forceLinkOutgoing = new ForceLink(this.reglInstance, this.config, this.store, this.graph, this.points);
      this.forceMouse = new ForceMouse(this.reglInstance, this.config, this.store, this.graph, this.points);
    }
    this.store.backgroundColor = getRgbaColor(this.config.backgroundColor);
    if (this.config.highlightedNodeRingColor) {
      this.store.setHoveredNodeRingColor(this.config.highlightedNodeRingColor);
      this.store.setFocusedNodeRingColor(this.config.highlightedNodeRingColor);
    } else {
      if (this.config.hoveredNodeRingColor) {
        this.store.setHoveredNodeRingColor(this.config.hoveredNodeRingColor);
      }
      if (this.config.focusedNodeRingColor) {
        this.store.setFocusedNodeRingColor(this.config.focusedNodeRingColor);
      }
    }
    if (this.config.showFPSMonitor) this.fpsMonitor = new FPSMonitor(this.canvas);
    if (this.config.randomSeed !== undefined) this.store.addRandomSeed(this.config.randomSeed);
  }
  _createClass(Graph, [{
    key: "progress",
    get: function get() {
      return this.store.simulationProgress;
    }
    /**
     * A value that gives information about the running simulation status.
     */
  }, {
    key: "isSimulationRunning",
    get: function get() {
      return this.store.isSimulationRunning;
    }
    /**
     * The maximum point size.
     * This value is the maximum size of the `gl.POINTS` primitive that WebGL can render on the user's hardware.
     */
  }, {
    key: "maxPointSize",
    get: function get() {
      return this.store.maxPointSize;
    }
    /**
     * Set or update Cosmos configuration. The changes will be applied in real time.
     * @param config Cosmos configuration object.
     */
  }, {
    key: "setConfig",
    value: function setConfig(config) {
      var _a, _b;
      var prevConfig = _objectSpread({}, this.config);
      this.config.init(config);
      if (prevConfig.linkColor !== this.config.linkColor) this.lines.updateColor();
      if (prevConfig.nodeColor !== this.config.nodeColor) this.points.updateColor();
      if (prevConfig.nodeSize !== this.config.nodeSize) this.points.updateSize();
      if (prevConfig.linkWidth !== this.config.linkWidth) this.lines.updateWidth();
      if (prevConfig.curvedLinkSegments !== this.config.curvedLinkSegments || prevConfig.curvedLinks !== this.config.curvedLinks) {
        this.lines.updateCurveLineGeometry();
      }
      if (prevConfig.backgroundColor !== this.config.backgroundColor) this.store.backgroundColor = getRgbaColor(this.config.backgroundColor);
      if (prevConfig.highlightedNodeRingColor !== this.config.highlightedNodeRingColor) {
        this.store.setHoveredNodeRingColor(this.config.highlightedNodeRingColor);
        this.store.setFocusedNodeRingColor(this.config.highlightedNodeRingColor);
      }
      if (prevConfig.hoveredNodeRingColor !== this.config.hoveredNodeRingColor) {
        this.store.setHoveredNodeRingColor(this.config.hoveredNodeRingColor);
      }
      if (prevConfig.focusedNodeRingColor !== this.config.focusedNodeRingColor) {
        this.store.setFocusedNodeRingColor(this.config.focusedNodeRingColor);
      }
      if (prevConfig.spaceSize !== this.config.spaceSize || prevConfig.simulation.repulsionQuadtreeLevels !== this.config.simulation.repulsionQuadtreeLevels) {
        this.store.adjustSpaceSize(this.config.spaceSize, this.reglInstance.limits.maxTextureSize);
        this.resizeCanvas(true);
        this.update(this.store.isSimulationRunning);
      }
      if (prevConfig.showFPSMonitor !== this.config.showFPSMonitor) {
        if (this.config.showFPSMonitor) {
          this.fpsMonitor = new FPSMonitor(this.canvas);
        } else {
          (_a = this.fpsMonitor) === null || _a === void 0 ? void 0 : _a.destroy();
          this.fpsMonitor = undefined;
        }
      }
      if (prevConfig.pixelRatio !== this.config.pixelRatio) {
        this.store.maxPointSize = ((_b = this.reglInstance.limits.pointSizeDims[1]) !== null && _b !== void 0 ? _b : MAX_POINT_SIZE) / this.config.pixelRatio;
      }
      if (prevConfig.disableZoom !== this.config.disableZoom) {
        if (this.config.disableZoom) this.disableZoom();else this.enableZoom();
      }
    }
    /**
     * Pass data to Cosmos.
     * @param nodes Array of nodes.
     * @param links Array of links.
     * @param runSimulation When set to `false`, the simulation won't be started automatically (`true` by default).
     */
  }, {
    key: "setData",
    value: function setData(nodes, links) {
      var _this22 = this;
      var runSimulation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var _this$config3 = this.config,
        fitViewOnInit = _this$config3.fitViewOnInit,
        fitViewDelay = _this$config3.fitViewDelay,
        fitViewByNodesInRect = _this$config3.fitViewByNodesInRect;
      if (!nodes.length && !links.length) {
        this.destroyParticleSystem();
        this.reglInstance.clear({
          color: this.store.backgroundColor,
          depth: 1,
          stencil: 0
        });
        return;
      }
      this.graph.setData(nodes, links);
      if (this._isFirstDataAfterInit && fitViewOnInit) {
        this._fitViewOnInitTimeoutID = window.setTimeout(function () {
          if (fitViewByNodesInRect) _this22.setZoomTransformByNodePositions(fitViewByNodesInRect, undefined, undefined, 0);else _this22.fitView();
        }, fitViewDelay);
      }
      this._isFirstDataAfterInit = false;
      this.update(runSimulation);
    }
    /**
     * Center the view on a node and zoom in, by node id.
     * @param id Id of the node.
     * @param duration Duration of the animation transition in milliseconds (`700` by default).
     * @param scale Scale value to zoom in or out (`3` by default).
     * @param canZoomOut Set to `false` to prevent zooming out from the node (`true` by default).
     */
  }, {
    key: "zoomToNodeById",
    value: function zoomToNodeById(id) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 700;
      var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultScaleToZoom;
      var canZoomOut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var node = this.graph.getNodeById(id);
      if (!node) return;
      this.zoomToNode(node, duration, scale, canZoomOut);
    }
    /**
     * Center the view on a node and zoom in, by node index.
     * @param index The index of the node in the array of nodes.
     * @param duration Duration of the animation transition in milliseconds (`700` by default).
     * @param scale Scale value to zoom in or out (`3` by default).
     * @param canZoomOut Set to `false` to prevent zooming out from the node (`true` by default).
     */
  }, {
    key: "zoomToNodeByIndex",
    value: function zoomToNodeByIndex(index) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 700;
      var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultScaleToZoom;
      var canZoomOut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var node = this.graph.getNodeByIndex(index);
      if (!node) return;
      this.zoomToNode(node, duration, scale, canZoomOut);
    }
    /**
     * Zoom the view in or out to the specified zoom level.
     * @param value Zoom level
     * @param duration Duration of the zoom in/out transition.
     */
  }, {
    key: "zoom",
    value: function zoom(value) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.setZoomLevel(value, duration);
    }
    /**
     * Zoom the view in or out to the specified zoom level.
     * @param value Zoom level
     * @param duration Duration of the zoom in/out transition.
     */
  }, {
    key: "setZoomLevel",
    value: function setZoomLevel(value) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.canvasD3Selection.transition().duration(duration).call(this.zoomInstance.behavior.scaleTo, value);
    }
    /**
     * Get zoom level.
     * @returns Zoom level value of the view.
     */
  }, {
    key: "getZoomLevel",
    value: function getZoomLevel() {
      return this.zoomInstance.eventTransform.k;
    }
    /**
     * Get current X and Y coordinates of the nodes.
     * @returns Object where keys are the ids of the nodes and values are corresponding `{ x: number; y: number }` objects.
     */
  }, {
    key: "getNodePositions",
    value: function getNodePositions() {
      var _this23 = this;
      if (this.hasParticleSystemDestroyed) return {};
      var particlePositionPixels = readPixels(this.reglInstance, this.points.currentPositionFbo);
      return this.graph.nodes.reduce(function (acc, curr) {
        var index = _this23.graph.getSortedIndexById(curr.id);
        var posX = particlePositionPixels[index * 4 + 0];
        var posY = particlePositionPixels[index * 4 + 1];
        if (posX !== undefined && posY !== undefined) {
          acc[curr.id] = {
            x: posX,
            y: posY
          };
        }
        return acc;
      }, {});
    }
    /**
     * Get current X and Y coordinates of the nodes.
     * @returns A Map object where keys are the ids of the nodes and values are their corresponding X and Y coordinates in the [number, number] format.
     */
  }, {
    key: "getNodePositionsMap",
    value: function getNodePositionsMap() {
      var _this24 = this;
      var positionMap = new Map();
      if (this.hasParticleSystemDestroyed) return positionMap;
      var particlePositionPixels = readPixels(this.reglInstance, this.points.currentPositionFbo);
      return this.graph.nodes.reduce(function (acc, curr) {
        var index = _this24.graph.getSortedIndexById(curr.id);
        var posX = particlePositionPixels[index * 4 + 0];
        var posY = particlePositionPixels[index * 4 + 1];
        if (posX !== undefined && posY !== undefined) {
          acc.set(curr.id, [posX, posY]);
        }
        return acc;
      }, positionMap);
    }
    /**
     * Get current X and Y coordinates of the nodes.
     * @returns Array of `[x: number, y: number]` arrays.
     */
  }, {
    key: "getNodePositionsArray",
    value: function getNodePositionsArray() {
      var positions = [];
      if (this.hasParticleSystemDestroyed) return [];
      var particlePositionPixels = readPixels(this.reglInstance, this.points.currentPositionFbo);
      positions.length = this.graph.nodes.length;
      for (var i = 0; i < this.graph.nodes.length; i += 1) {
        var index = this.graph.getSortedIndexByInputIndex(i);
        var posX = particlePositionPixels[index * 4 + 0];
        var posY = particlePositionPixels[index * 4 + 1];
        if (posX !== undefined && posY !== undefined) {
          positions[i] = [posX, posY];
        }
      }
      return positions;
    }
    /**
     * Center and zoom in/out the view to fit all nodes in the scene.
     * @param duration Duration of the center and zoom in/out animation in milliseconds (`250` by default).
     */
  }, {
    key: "fitView",
    value: function fitView() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 250;
      this.setZoomTransformByNodePositions(this.getNodePositionsArray(), duration);
    }
    /**
     * Center and zoom in/out the view to fit nodes by their ids in the scene.
     * @param duration Duration of the center and zoom in/out animation in milliseconds (`250` by default).
     */
  }, {
    key: "fitViewByNodeIds",
    value: function fitViewByNodeIds(ids) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
      var positionsMap = this.getNodePositionsMap();
      var positions = ids.map(function (id) {
        return positionsMap.get(id);
      }).filter(function (d) {
        return d !== undefined;
      });
      this.setZoomTransformByNodePositions(positions, duration);
    }
    /** Select nodes inside a rectangular area.
     * @param selection - Array of two corner points `[[left, top], [right, bottom]]`.
     * The `left` and `right` coordinates should be from 0 to the width of the canvas.
     * The `top` and `bottom` coordinates should be from 0 to the height of the canvas. */
  }, {
    key: "selectNodesInRange",
    value: function selectNodesInRange(selection) {
      if (selection) {
        var h = this.store.screenSize[1];
        this.store.selectedArea = [[selection[0][0], h - selection[1][1]], [selection[1][0], h - selection[0][1]]];
        this.points.findPointsOnAreaSelection();
        var pixels = readPixels(this.reglInstance, this.points.selectedFbo);
        this.store.selectedIndices = pixels.map(function (pixel, i) {
          if (i % 4 === 0 && pixel !== 0) return i / 4;else return -1;
        }).filter(function (d) {
          return d !== -1;
        });
      } else {
        this.store.selectedIndices = null;
      }
      this.points.updateGreyoutStatus();
    }
    /**
     * Select a node by id. If you want the adjacent nodes to get selected too, provide `true` as the second argument.
     * @param id Id of the node.
     * @param selectAdjacentNodes When set to `true`, selects adjacent nodes (`false` by default).
     */
  }, {
    key: "selectNodeById",
    value: function selectNodeById(id) {
      var selectAdjacentNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var _a;
      if (selectAdjacentNodes) {
        var adjacentNodes = (_a = this.graph.getAdjacentNodes(id)) !== null && _a !== void 0 ? _a : [];
        this.selectNodesByIds([id].concat(_toConsumableArray(adjacentNodes.map(function (d) {
          return d.id;
        }))));
      } else this.selectNodesByIds([id]);
    }
    /**
     * Select a node by index. If you want the adjacent nodes to get selected too, provide `true` as the second argument.
     * @param index The index of the node in the array of nodes.
     * @param selectAdjacentNodes When set to `true`, selects adjacent nodes (`false` by default).
     */
  }, {
    key: "selectNodeByIndex",
    value: function selectNodeByIndex(index) {
      var selectAdjacentNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var node = this.graph.getNodeByIndex(index);
      if (node) this.selectNodeById(node.id, selectAdjacentNodes);
    }
    /**
     * Select multiples nodes by their ids.
     * @param ids Array of nodes ids.
     */
  }, {
    key: "selectNodesByIds",
    value: function selectNodesByIds(ids) {
      var _this25 = this;
      this.selectNodesByIndices(ids === null || ids === void 0 ? void 0 : ids.map(function (d) {
        return _this25.graph.getSortedIndexById(d);
      }));
    }
    /**
     * Select multiples nodes by their indices.
     * @param indices Array of nodes indices.
     */
  }, {
    key: "selectNodesByIndices",
    value: function selectNodesByIndices(indices) {
      if (!indices) {
        this.store.selectedIndices = null;
      } else if (indices.length === 0) {
        this.store.selectedIndices = new Float32Array();
      } else {
        this.store.selectedIndices = new Float32Array(indices.filter(function (d) {
          return d !== undefined;
        }));
      }
      this.points.updateGreyoutStatus();
    }
    /**
     * Unselect all nodes.
     */
  }, {
    key: "unselectNodes",
    value: function unselectNodes() {
      this.store.selectedIndices = null;
      this.points.updateGreyoutStatus();
    }
    /**
     * Get nodes that are currently selected.
     * @returns Array of selected nodes.
     */
  }, {
    key: "getSelectedNodes",
    value: function getSelectedNodes() {
      var selectedIndices = this.store.selectedIndices;
      if (!selectedIndices) return null;
      var points = new Array(selectedIndices.length);
      var _iterator3 = _createForOfIteratorHelper(selectedIndices.entries()),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = _slicedToArray(_step3.value, 2),
            i = _step3$value[0],
            selectedIndex = _step3$value[1];
          if (selectedIndex !== undefined) {
            var index = this.graph.getInputIndexBySortedIndex(selectedIndex);
            if (index !== undefined) points[i] = this.graph.nodes[index];
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return points;
    }
    /**
     * Get nodes that are adjacent to a specific node by its id.
     * @param id Id of the node.
     * @returns Array of adjacent nodes.
     */
  }, {
    key: "getAdjacentNodes",
    value: function getAdjacentNodes(id) {
      return this.graph.getAdjacentNodes(id);
    }
    /**
     * Set focus on a node by id. A ring will be highlighted around the focused node.
     * If no id is specified, the focus will be reset.
     * @param id Id of the node.
     */
  }, {
    key: "setFocusedNodeById",
    value: function setFocusedNodeById(id) {
      if (id === undefined) {
        this.store.setFocusedNode();
      } else {
        this.store.setFocusedNode(this.graph.getNodeById(id), this.graph.getSortedIndexById(id));
      }
    }
    /**
     * Set focus on a node by index. A ring will be highlighted around the focused node.
     * If no index is specified, the focus will be reset.
     * @param index The index of the node in the array of nodes.
     */
  }, {
    key: "setFocusedNodeByIndex",
    value: function setFocusedNodeByIndex(index) {
      if (index === undefined) {
        this.store.setFocusedNode();
      } else {
        this.store.setFocusedNode(this.graph.getNodeByIndex(index), index);
      }
    }
    /**
     * Converts the X and Y node coordinates from the space coordinate system to the screen coordinate system.
     * @param spacePosition Array of x and y coordinates in the space coordinate system.
     * @returns Array of x and y coordinates in the screen coordinate system.
     */
  }, {
    key: "spaceToScreenPosition",
    value: function spaceToScreenPosition(spacePosition) {
      return this.zoomInstance.convertSpaceToScreenPosition(spacePosition);
    }
    /**
     * Converts the node radius value from the space coordinate system to the screen coordinate system.
     * @param spaceRadius Radius of Node in the space coordinate system.
     * @returns Radius of Node in the screen coordinate system.
     */
  }, {
    key: "spaceToScreenRadius",
    value: function spaceToScreenRadius(spaceRadius) {
      return this.zoomInstance.convertSpaceToScreenRadius(spaceRadius);
    }
    /**
     * Get node radius by its index.
     * @param index Index of the node.
     * @returns Radius of the node.
     */
  }, {
    key: "getNodeRadiusByIndex",
    value: function getNodeRadiusByIndex(index) {
      return this.points.getNodeRadiusByIndex(index);
    }
    /**
     * Get node radius by its id.
     * @param id Id of the node.
     * @returns Radius of the node.
     */
  }, {
    key: "getNodeRadiusById",
    value: function getNodeRadiusById(id) {
      var index = this.graph.getInputIndexById(id);
      if (index === undefined) return undefined;
      return this.points.getNodeRadiusByIndex(index);
    }
    /**
     * Track multiple node positions by their ids on each Cosmos tick.
     * @param ids Array of nodes ids.
     */
  }, {
    key: "trackNodePositionsByIds",
    value: function trackNodePositionsByIds(ids) {
      this.points.trackNodesByIds(ids);
    }
    /**
     * Track multiple node positions by their indices on each Cosmos tick.
     * @param ids Array of nodes indices.
     */
  }, {
    key: "trackNodePositionsByIndices",
    value: function trackNodePositionsByIndices(indices) {
      var _this26 = this;
      this.points.trackNodesByIds(indices.map(function (index) {
        return _this26.graph.getNodeByIndex(index);
      }).filter(function (d) {
        return d !== undefined;
      }).map(function (d) {
        return d.id;
      }));
    }
    /**
     * Get current X and Y coordinates of the tracked nodes.
     * @returns A Map object where keys are the ids of the nodes and values are their corresponding X and Y coordinates in the [number, number] format.
     */
  }, {
    key: "getTrackedNodePositionsMap",
    value: function getTrackedNodePositionsMap() {
      return this.points.getTrackedPositions();
    }
    /**
     * For the nodes that are currently visible on the screen, get a sample of node ids with their coordinates.
     * The resulting number of nodes will depend on the `nodeSamplingDistance` configuration property,
     * and the sampled nodes will be evenly distributed.
     * @returns A Map object where keys are the ids of the nodes and values are their corresponding X and Y coordinates in the [number, number] format.
     */
  }, {
    key: "getSampledNodePositionsMap",
    value: function getSampledNodePositionsMap() {
      return this.points.getSampledNodePositionsMap();
    }
    /**
     * Start the simulation.
     * @param alpha Value from 0 to 1. The higher the value, the more initial energy the simulation will get.
     */
  }, {
    key: "start",
    value: function start() {
      var alpha = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var _a, _b;
      if (!this.graph.nodes.length) return;
      this.store.isSimulationRunning = true;
      this.store.alpha = alpha;
      this.store.simulationProgress = 0;
      (_b = (_a = this.config.simulation).onStart) === null || _b === void 0 ? void 0 : _b.call(_a);
      this.stopFrames();
      this.frame();
    }
    /**
     * Pause the simulation.
     */
  }, {
    key: "pause",
    value: function pause() {
      var _a, _b;
      this.store.isSimulationRunning = false;
      (_b = (_a = this.config.simulation).onPause) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    /**
     * Restart the simulation.
     */
  }, {
    key: "restart",
    value: function restart() {
      var _a, _b;
      this.store.isSimulationRunning = true;
      (_b = (_a = this.config.simulation).onRestart) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    /**
     * Render only one frame of the simulation (stops the simulation if it was running).
     */
  }, {
    key: "step",
    value: function step() {
      this.store.isSimulationRunning = false;
      this.stopFrames();
      this.frame();
    }
    /**
     * Destroy this Cosmos instance.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _a, _b;
      window.clearTimeout(this._fitViewOnInitTimeoutID);
      this.stopFrames();
      this.destroyParticleSystem();
      (_a = this.fpsMonitor) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = document.getElementById('gl-bench-style')) === null || _b === void 0 ? void 0 : _b.remove();
    }
    /**
     * Create new Cosmos instance.
     */
  }, {
    key: "create",
    value: function create() {
      var _a, _b, _c, _d;
      this.points.create();
      this.lines.create();
      (_a = this.forceManyBody) === null || _a === void 0 ? void 0 : _a.create();
      (_b = this.forceLinkIncoming) === null || _b === void 0 ? void 0 : _b.create(LinkDirection.INCOMING);
      (_c = this.forceLinkOutgoing) === null || _c === void 0 ? void 0 : _c.create(LinkDirection.OUTGOING);
      (_d = this.forceCenter) === null || _d === void 0 ? void 0 : _d.create();
      this.hasParticleSystemDestroyed = false;
    }
  }, {
    key: "destroyParticleSystem",
    value: function destroyParticleSystem() {
      var _a, _b, _c, _d;
      if (this.hasParticleSystemDestroyed) return;
      this.points.destroy();
      this.lines.destroy();
      (_a = this.forceCenter) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.forceLinkIncoming) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.forceLinkOutgoing) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.forceManyBody) === null || _d === void 0 ? void 0 : _d.destroy();
      this.reglInstance.destroy();
      this.hasParticleSystemDestroyed = true;
    }
  }, {
    key: "update",
    value: function update(runSimulation) {
      var graph = this.graph;
      this.store.pointsTextureSize = Math.ceil(Math.sqrt(graph.nodes.length));
      this.store.linksTextureSize = Math.ceil(Math.sqrt(graph.linksNumber * 2));
      this.destroyParticleSystem();
      this.create();
      this.initPrograms();
      this.setFocusedNodeById();
      this.store.hoveredNode = undefined;
      if (runSimulation) {
        this.start();
      } else {
        this.step();
      }
    }
  }, {
    key: "initPrograms",
    value: function initPrograms() {
      var _a, _b, _c, _d, _e, _f;
      this.points.initPrograms();
      this.lines.initPrograms();
      (_a = this.forceGravity) === null || _a === void 0 ? void 0 : _a.initPrograms();
      (_b = this.forceLinkIncoming) === null || _b === void 0 ? void 0 : _b.initPrograms();
      (_c = this.forceLinkOutgoing) === null || _c === void 0 ? void 0 : _c.initPrograms();
      (_d = this.forceMouse) === null || _d === void 0 ? void 0 : _d.initPrograms();
      (_e = this.forceManyBody) === null || _e === void 0 ? void 0 : _e.initPrograms();
      (_f = this.forceCenter) === null || _f === void 0 ? void 0 : _f.initPrograms();
    }
  }, {
    key: "frame",
    value: function frame() {
      var _this27 = this;
      var _this$config4 = this.config,
        simulation = _this$config4.simulation,
        renderLinks = _this$config4.renderLinks,
        disableSimulation = _this$config4.disableSimulation,
        _this$store2 = this.store,
        alpha = _this$store2.alpha,
        isSimulationRunning = _this$store2.isSimulationRunning;
      if (alpha < ALPHA_MIN && isSimulationRunning) this.end();
      if (!this.store.pointsTextureSize) return;
      this.requestAnimationFrameId = window.requestAnimationFrame(function (now) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        (_a = _this27.fpsMonitor) === null || _a === void 0 ? void 0 : _a.begin();
        _this27.resizeCanvas();
        _this27.findHoveredPoint();
        if (!disableSimulation) {
          if (_this27.isRightClickMouse) {
            if (!isSimulationRunning) _this27.start(0.1);
            (_b = _this27.forceMouse) === null || _b === void 0 ? void 0 : _b.run();
            _this27.points.updatePosition();
          }
          if (isSimulationRunning && !_this27.zoomInstance.isRunning) {
            if (simulation.gravity) {
              (_c = _this27.forceGravity) === null || _c === void 0 ? void 0 : _c.run();
              _this27.points.updatePosition();
            }
            if (simulation.center) {
              (_d = _this27.forceCenter) === null || _d === void 0 ? void 0 : _d.run();
              _this27.points.updatePosition();
            }
            (_e = _this27.forceManyBody) === null || _e === void 0 ? void 0 : _e.run();
            _this27.points.updatePosition();
            if (_this27.store.linksTextureSize) {
              (_f = _this27.forceLinkIncoming) === null || _f === void 0 ? void 0 : _f.run();
              _this27.points.updatePosition();
              (_g = _this27.forceLinkOutgoing) === null || _g === void 0 ? void 0 : _g.run();
              _this27.points.updatePosition();
            }
            _this27.store.alpha += _this27.store.addAlpha((_h = _this27.config.simulation.decay) !== null && _h !== void 0 ? _h : defaultConfigValues.simulation.decay);
            if (_this27.isRightClickMouse) _this27.store.alpha = Math.max(_this27.store.alpha, 0.1);
            _this27.store.simulationProgress = Math.sqrt(Math.min(1, ALPHA_MIN / _this27.store.alpha));
            (_k = (_j = _this27.config.simulation).onTick) === null || _k === void 0 ? void 0 : _k.call(_j, _this27.store.alpha, (_l = _this27.store.hoveredNode) === null || _l === void 0 ? void 0 : _l.node, _this27.store.hoveredNode ? _this27.graph.getInputIndexBySortedIndex(_this27.store.hoveredNode.index) : undefined, (_m = _this27.store.hoveredNode) === null || _m === void 0 ? void 0 : _m.position);
          }
          _this27.points.trackPoints();
        }
        // Clear canvas
        _this27.reglInstance.clear({
          color: _this27.store.backgroundColor,
          depth: 1,
          stencil: 0
        });
        if (renderLinks && _this27.store.linksTextureSize) {
          _this27.lines.draw();
        }
        _this27.points.draw();
        (_o = _this27.fpsMonitor) === null || _o === void 0 ? void 0 : _o.end(now);
        _this27.currentEvent = undefined;
        _this27.frame();
      });
    }
  }, {
    key: "stopFrames",
    value: function stopFrames() {
      if (this.requestAnimationFrameId) window.cancelAnimationFrame(this.requestAnimationFrameId);
    }
  }, {
    key: "end",
    value: function end() {
      var _a, _b;
      this.store.isSimulationRunning = false;
      this.store.simulationProgress = 1;
      (_b = (_a = this.config.simulation).onEnd) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
  }, {
    key: "onClick",
    value: function onClick(event) {
      var _a, _b, _c, _d;
      (_b = (_a = this.config.events).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, (_c = this.store.hoveredNode) === null || _c === void 0 ? void 0 : _c.node, this.store.hoveredNode ? this.graph.getInputIndexBySortedIndex(this.store.hoveredNode.index) : undefined, (_d = this.store.hoveredNode) === null || _d === void 0 ? void 0 : _d.position, event);
    }
  }, {
    key: "updateMousePosition",
    value: function updateMousePosition(event) {
      if (!event || event.offsetX === undefined || event.offsetY === undefined) return;
      var _this$zoomInstance$ev = this.zoomInstance.eventTransform,
        x = _this$zoomInstance$ev.x,
        y = _this$zoomInstance$ev.y,
        k = _this$zoomInstance$ev.k;
      var h = this.canvas.clientHeight;
      var mouseX = event.offsetX;
      var mouseY = event.offsetY;
      var invertedX = (mouseX - x) / k;
      var invertedY = (mouseY - y) / k;
      this.store.mousePosition = [invertedX, h - invertedY];
      this.store.mousePosition[0] -= (this.store.screenSize[0] - this.store.adjustedSpaceSize) / 2;
      this.store.mousePosition[1] -= (this.store.screenSize[1] - this.store.adjustedSpaceSize) / 2;
      this.store.screenMousePosition = [mouseX, this.store.screenSize[1] - mouseY];
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      var _a, _b, _c, _d;
      this.currentEvent = event;
      this.updateMousePosition(event);
      this.isRightClickMouse = event.which === 3;
      (_b = (_a = this.config.events).onMouseMove) === null || _b === void 0 ? void 0 : _b.call(_a, (_c = this.store.hoveredNode) === null || _c === void 0 ? void 0 : _c.node, this.store.hoveredNode ? this.graph.getInputIndexBySortedIndex(this.store.hoveredNode.index) : undefined, (_d = this.store.hoveredNode) === null || _d === void 0 ? void 0 : _d.position, this.currentEvent);
    }
  }, {
    key: "onRightClickMouse",
    value: function onRightClickMouse(event) {
      event.preventDefault();
    }
  }, {
    key: "resizeCanvas",
    value: function resizeCanvas() {
      var forceResize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var prevWidth = this.canvas.width;
      var prevHeight = this.canvas.height;
      var w = this.canvas.clientWidth;
      var h = this.canvas.clientHeight;
      if (forceResize || prevWidth !== w * this.config.pixelRatio || prevHeight !== h * this.config.pixelRatio) {
        this.store.updateScreenSize(w, h);
        this.canvas.width = w * this.config.pixelRatio;
        this.canvas.height = h * this.config.pixelRatio;
        this.reglInstance.poll();
        this.canvasD3Selection.call(this.zoomInstance.behavior.transform, this.zoomInstance.eventTransform);
        this.points.updateSampledNodesGrid();
      }
    }
  }, {
    key: "setZoomTransformByNodePositions",
    value: function setZoomTransformByNodePositions(positions) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
      var scale = arguments.length > 2 ? arguments[2] : undefined;
      var padding = arguments.length > 3 ? arguments[3] : undefined;
      this.resizeCanvas();
      var transform = this.zoomInstance.getTransform(positions, scale, padding);
      this.canvasD3Selection.transition().ease(_d3Ease.easeQuadInOut).duration(duration).call(this.zoomInstance.behavior.transform, transform);
    }
  }, {
    key: "zoomToNode",
    value: function zoomToNode(node, duration, scale, canZoomOut) {
      var graph = this.graph,
        screenSize = this.store.screenSize;
      var positionPixels = readPixels(this.reglInstance, this.points.currentPositionFbo);
      var nodeIndex = graph.getSortedIndexById(node.id);
      if (nodeIndex === undefined) return;
      var posX = positionPixels[nodeIndex * 4 + 0];
      var posY = positionPixels[nodeIndex * 4 + 1];
      if (posX === undefined || posY === undefined) return;
      var distance = this.zoomInstance.getDistanceToPoint([posX, posY]);
      var zoomLevel = canZoomOut ? scale : Math.max(this.getZoomLevel(), scale);
      if (distance < Math.min(screenSize[0], screenSize[1])) {
        this.setZoomTransformByNodePositions([[posX, posY]], duration, zoomLevel);
      } else {
        var transform = this.zoomInstance.getTransform([[posX, posY]], zoomLevel);
        var middle = this.zoomInstance.getMiddlePointTransform([posX, posY]);
        this.canvasD3Selection.transition().ease(_d3Ease.easeQuadIn).duration(duration / 2).call(this.zoomInstance.behavior.transform, middle).transition().ease(_d3Ease.easeQuadOut).duration(duration / 2).call(this.zoomInstance.behavior.transform, transform);
      }
    }
  }, {
    key: "disableZoom",
    value: function disableZoom() {
      this.canvasD3Selection.call(this.zoomInstance.behavior).on('wheel.zoom', null);
    }
  }, {
    key: "enableZoom",
    value: function enableZoom() {
      this.canvasD3Selection.call(this.zoomInstance.behavior);
    }
  }, {
    key: "findHoveredPoint",
    value: function findHoveredPoint() {
      var _a, _b, _c, _d, _e;
      if (!this._isMouseOnCanvas) return;
      if (this._findHoveredPointExecutionCount < 2) {
        this._findHoveredPointExecutionCount += 1;
        return;
      }
      this._findHoveredPointExecutionCount = 0;
      this.points.findHoveredPoint();
      var isMouseover = false;
      var isMouseout = false;
      var pixels = readPixels(this.reglInstance, this.points.hoveredFbo);
      var nodeSize = pixels[1];
      if (nodeSize) {
        var index = pixels[0];
        var inputIndex = this.graph.getInputIndexBySortedIndex(index);
        var hovered = inputIndex !== undefined ? this.graph.getNodeByIndex(inputIndex) : undefined;
        if (((_a = this.store.hoveredNode) === null || _a === void 0 ? void 0 : _a.node) !== hovered) isMouseover = true;
        var pointX = pixels[2];
        var pointY = pixels[3];
        this.store.hoveredNode = hovered && {
          node: hovered,
          index: index,
          position: [pointX, pointY]
        };
      } else {
        if (this.store.hoveredNode) isMouseout = true;
        this.store.hoveredNode = undefined;
      }
      if (isMouseover && this.store.hoveredNode) {
        (_c = (_b = this.config.events).onNodeMouseOver) === null || _c === void 0 ? void 0 : _c.call(_b, this.store.hoveredNode.node, this.graph.getInputIndexBySortedIndex(this.graph.getSortedIndexById(this.store.hoveredNode.node.id)), this.store.hoveredNode.position, this.currentEvent);
      }
      if (isMouseout) (_e = (_d = this.config.events).onNodeMouseOut) === null || _e === void 0 ? void 0 : _e.call(_d, this.currentEvent);
    }
  }]);
  return Graph;
}();
},{"d3-selection":"../node_modules/d3-selection/src/index.js","d3-transition":"../node_modules/d3-transition/src/index.js","d3-ease":"../node_modules/d3-ease/src/index.js","regl":"../node_modules/regl/dist/regl.js","d3-color":"../node_modules/d3-color/src/index.js","d3-scale":"../node_modules/d3-scale/src/index.js","d3-array":"../node_modules/d3-array/src/index.js","gl-matrix":"../node_modules/gl-matrix/esm/index.js","random":"../node_modules/random/dist/random.module.js","d3-zoom":"../node_modules/d3-zoom/src/index.js"}],"../node_modules/@interacta/css-labels/dist/helper.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rectIntersect = rectIntersect;
function rectIntersect(rect1, rect2) {
  const [left1, top1, right1, bottom1] = [rect1.x, rect1.y + rect1.height, rect1.x + rect1.width, rect1.y];
  const [left2, top2, right2, bottom2] = [rect2.x, rect2.y + rect2.height, rect2.x + rect2.width, rect2.y];
  return !(top1 < bottom2 || top2 < bottom1 || right1 < left2 || right2 < left1);
}
},{}],"../node_modules/@interacta/css-labels/dist/variables.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TOP_BOTTOM_PADDING = exports.LEFT_RIGHT_PADDING = exports.DEFAULT_FONT_SIZE = void 0;
const TOP_BOTTOM_PADDING = exports.TOP_BOTTOM_PADDING = 6;
const LEFT_RIGHT_PADDING = exports.LEFT_RIGHT_PADDING = 9;
const DEFAULT_FONT_SIZE = exports.DEFAULT_FONT_SIZE = 14;
},{}],"../node_modules/@interacta/css-labels/dist/css-label-styles.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.label = exports.hiddenLabel = exports.createCssStyles = void 0;
const label = exports.label = 'css-label--label';
const hiddenLabel = exports.hiddenLabel = 'css-label--hidden';
let globalCssLabelStyles;
const createCssStyles = () => {
  if (globalCssLabelStyles) return;
  globalCssLabelStyles = document.createElement('style');
  globalCssLabelStyles.innerHTML = `
  :root {
    --css-label-background-color: #1e2428;
    --css-label-brightness: brightness(150%);
  }

  .${label} {
    position: absolute;
    top: 0;
    left: 0;

    font-weight: 500;
    cursor: pointer;
    
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

    filter: var(--css-label-brightness);
    pointer-events: none;
    background-color: var(--css-label-background-color);
    font-weight: 700;
    border-radius: 6px;
    
    transition: opacity 600ms;
    opacity: 1;
  }

  .${hiddenLabel} {
    opacity: 0 !important;
  }
`;
  // Insert the global CSS style element into the head of the document if it doesn't already exist
  const firstStyleTagInHead = document.head.getElementsByTagName('style')[0];
  if (firstStyleTagInHead) document.head.insertBefore(globalCssLabelStyles, firstStyleTagInHead);else document.head.appendChild(globalCssLabelStyles);
};
exports.createCssStyles = createCssStyles;
},{}],"../node_modules/@interacta/css-labels/dist/css-label.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CssLabel = void 0;
var _helper = require("./helper.js");
var _variables = require("./variables.js");
var s = _interopRequireWildcard(require("./css-label-styles.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
class CssLabel {
  constructor(container, text) {
    this.element = document.createElement('div');
    this.fontWidthHeightRatio = 0.6;
    this._x = 0;
    this._y = 0;
    this._estimatedWidth = 0;
    this._estimatedHeight = 0;
    this._visible = false;
    this._prevVisible = false;
    this._weight = 0;
    this._customFontSize = _variables.DEFAULT_FONT_SIZE;
    this._customColor = undefined;
    this._customOpacity = undefined;
    this._shouldBeShown = false;
    this._text = '';
    this._customPadding = {
      left: _variables.LEFT_RIGHT_PADDING,
      top: _variables.TOP_BOTTOM_PADDING,
      right: _variables.LEFT_RIGHT_PADDING,
      bottom: _variables.TOP_BOTTOM_PADDING
    };
    s.createCssStyles();
    this._container = container;
    this._updateClasses();
    if (text) this.setText(text);
    this.resetFontSize();
    this.resetPadding();
  }
  /**
   * Sets the text of the element.
   * @param text - The text to set.
   */
  setText(text) {
    if (this._text !== text) {
      this._text = text;
      this.element.innerHTML = text;
      this._measureText();
    }
  }
  /**
   * Sets the position of the label
   * @param x - The x coordinate of the label
   * @param y - The y coordinate of the label
   */
  setPosition(x, y) {
    this._x = x;
    this._y = y;
  }
  /**
   * Sets the CSS style of the element.
   * If a color, opacity or pointer-events is specified using the `setColor`,
   * `setOpacity` or `setPointerEvents` method, it takes priority over all custom styles.
   * The `fontSize` style will not apply from `setStyle`, and the `transform` style
   * will not apply, as it is used in the draw method to update the label position.
   * @param style - The style to be set.
   */
  setStyle(style) {
    if (this._customStyle !== style) {
      this._customStyle = style;
      this.element.style.cssText = this._customStyle;
      if (this._customColor) this.element.style.color = this._customColor;
      if (this._customOpacity) this.element.style.opacity = String(this._customOpacity);
      if (this._customPointerEvents) this.element.style.pointerEvents = this._customPointerEvents;
      if (this._customFontSize) this.element.style.fontSize = `${this._customFontSize}px`;
      if (this._customPadding) {
        const {
          top,
          right,
          bottom,
          left
        } = this._customPadding;
        this.element.style.padding = `${top}px ${right}px ${bottom}px ${left}px`;
      }
    }
  }
  /**
   * Sets the class name of the component
   * @param className - The class name to be set
   */
  setClassName(className) {
    if (this._customClassName !== className) {
      this._customClassName = className;
      this._updateClasses();
    }
  }
  /**
   * Sets the font size of the text in pixels.
   * This value cannot be changed through `setStyle` or `setClassName`
   * methods because it is used to measure the width and height of the label.
   * @param fontSize - The font size to set. If not specified, it will use the default value of `14px`.
   */
  setFontSize(fontSize = _variables.DEFAULT_FONT_SIZE) {
    if (this._customFontSize !== fontSize) {
      this.element.style.fontSize = `${fontSize}px`;
      this._customFontSize = fontSize;
      this._measureText();
    }
  }
  /**
   * Resets the font size of the element to default value.
   */
  resetFontSize() {
    this.element.style.fontSize = `${_variables.DEFAULT_FONT_SIZE}px`;
    this._customFontSize = _variables.DEFAULT_FONT_SIZE;
    this._measureText();
  }
  /**
   * Sets the color of the element.
   * This color will rewrite the color from `setStyle` CSS style if specified.
   * @param color - The color to set
   */
  setColor(color) {
    if (this._customColor !== color) {
      this.element.style.color = color;
      this._customColor = color;
    }
  }
  /**
   * Resets the color of the element.
   */
  resetColor() {
    this.element.style.removeProperty('color');
    this._customColor = undefined;
  }
  /**
   * Sets the opacity of the element.
   * This opacity will rewrite the opacity from `setStyle` CSS style if specified.
   * @param opacity - The opacity to set.
   */
  setOpacity(opacity) {
    if (this._customOpacity !== opacity) {
      this.element.style.opacity = String(opacity);
      this._customOpacity = opacity;
    }
  }
  /**
   * Resets the opacity of the element.
   */
  resetOpacity() {
    this.element.style.removeProperty('opacity');
    this._customOpacity = undefined;
  }
  /**
   * Sets the `pointerEvents` property to 'none', 'auto', or 'all'.
   * This `pointerEvents` value will rewrite the opacity from `setStyle` CSS style if specified.
   * @param pointerEvents - The `pointerEvents` value to be set.
   */
  setPointerEvents(pointerEvents) {
    if (this._customPointerEvents !== pointerEvents) {
      this.element.style.pointerEvents = `${pointerEvents}`;
      this._customPointerEvents = pointerEvents;
    }
  }
  /**
   * Resets the pointer-events of the element.
   */
  resetPointerEvents() {
    this.element.style.removeProperty('pointer-events');
    this._customPointerEvents = undefined;
  }
  /**
   * Sets the padding of the element in pixels.
   * This value cannot be changed through `setStyle` or `setClassName`
   * methods because it is used to measure the width and height of the label.
   * @param padding - The padding object with left, top, right and bottom properties.
   * If not specified, it will use the default value of `{ left: 9px, top: 6px, right: 9px, bottom: 6px }`.
   */
  setPadding(padding = {
    left: _variables.LEFT_RIGHT_PADDING,
    top: _variables.TOP_BOTTOM_PADDING,
    right: _variables.LEFT_RIGHT_PADDING,
    bottom: _variables.TOP_BOTTOM_PADDING
  }) {
    if (this._customPadding.left !== padding.left || this._customPadding.top !== padding.top || this._customPadding.right !== padding.right || this._customPadding.bottom !== padding.bottom) {
      this._customPadding = padding;
      this.element.style.padding = `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px`;
      this._measureText();
    }
  }
  resetPadding() {
    const padding = {
      left: _variables.LEFT_RIGHT_PADDING,
      top: _variables.TOP_BOTTOM_PADDING,
      right: _variables.LEFT_RIGHT_PADDING,
      bottom: _variables.TOP_BOTTOM_PADDING
    };
    this.element.style.padding = `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px`;
    this._customPadding = padding;
    this._measureText();
  }
  /**
   * Sets the boolean value of whether the element should be forced to shown or not
   * @param shouldBeShown - The boolean value to set
   */
  setForceShow(shouldBeShown) {
    this._shouldBeShown = shouldBeShown;
  }
  /**
   * Gets the boolean value of whether the element should be shown or not.
   * @returns The boolean value of whether the element should be shown or not.
   */
  getForceShow() {
    return this._shouldBeShown;
  }
  /**
   * Draws the element to the container and updates the label's coordinate.
   * The label's coordinate updates using `transform` style. It rewrite
   * the `transform` from `setStyle` CSS style if specified.
   */
  draw() {
    const isVisible = this.getVisibility();
    if (isVisible !== this._prevVisible) {
      if (this._prevVisible === false) {
        this._container.appendChild(this.element);
      } else {
        this._container.removeChild(this.element);
      }
      this._updateClasses();
      this._prevVisible = isVisible;
    }
    if (isVisible) {
      this.element.style.transform = `
        translate(-50%, -100%)
        translate3d(${this._x}px, ${this._y}px, 0)
      `;
    }
  }
  overlaps(label) {
    return (0, _helper.rectIntersect)({
      height: this._estimatedHeight,
      width: this._estimatedWidth,
      x: this._x,
      y: this._y
    }, {
      height: label._estimatedHeight,
      width: label._estimatedWidth,
      x: label._x,
      y: label._y
    });
  }
  setVisibility(visible = true) {
    this._visible = visible;
  }
  getVisibility() {
    return this._visible;
  }
  isOnScreen() {
    return this._x > 0 && this._y > 0 && this._x < this._container.offsetWidth && this._y < this._container.offsetHeight;
  }
  setWeight(weight) {
    this._weight = weight;
  }
  getWeight() {
    return this._weight;
  }
  /**
   * Appends the element to the top of the container
   */
  raise() {
    this._container.appendChild(this.element);
  }
  /**
   * Removes the element from the DOM.
   */
  destroy() {
    this.element.remove();
  }
  _updateClasses() {
    const isVisible = this.getVisibility();
    if (isVisible) {
      window.requestAnimationFrame(() => {
        this.element.className = `${s.label} ${this._customClassName || ''}`;
      });
    } else {
      this.element.className = `${s.label} ${this._customClassName || ''} ${s.hiddenLabel}`;
    }
  }
  _measureText() {
    const {
      left,
      top,
      right,
      bottom
    } = this._customPadding;
    this._estimatedWidth = this._customFontSize * this.fontWidthHeightRatio * this.element.innerHTML.length + left + right;
    this._estimatedHeight = this._customFontSize + top + bottom;
  }
}
exports.CssLabel = CssLabel;
},{"./helper.js":"../node_modules/@interacta/css-labels/dist/helper.js","./variables.js":"../node_modules/@interacta/css-labels/dist/variables.js","./css-label-styles.js":"../node_modules/@interacta/css-labels/dist/css-label-styles.js"}],"../node_modules/@interacta/css-labels/dist/styles.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.labelsContainer = exports.hidden = exports.createCssStyles = void 0;
const labelsContainer = exports.labelsContainer = 'css-label--labels-container';
const hidden = exports.hidden = 'css-label--labels-container-hidden';
let globalContainerStyle;
const createCssStyles = () => {
  if (globalContainerStyle) return;
  globalContainerStyle = document.createElement('style');
  globalContainerStyle.innerHTML = `
  .${labelsContainer} {
    transition: opacity 100ms;
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: hidden;
    top: 0%;
    pointer-events: none;
    opacity: 1;
  }
  .${hidden} {
    opacity: 0;

    div {
      pointer-events: none;
    }
  }
`;
  // Insert the global CSS style element into the head of the document if it doesn't already exist
  const firstStyleTagInHead = document.head.getElementsByTagName('style')[0];
  if (firstStyleTagInHead) document.head.insertBefore(globalContainerStyle, firstStyleTagInHead);else document.head.appendChild(globalContainerStyle);
};
exports.createCssStyles = createCssStyles;
},{}],"../node_modules/@interacta/css-labels/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "CssLabel", {
  enumerable: true,
  get: function () {
    return _cssLabel.CssLabel;
  }
});
exports.LabelRenderer = void 0;
var _cssLabel = require("./css-label.js");
var s = _interopRequireWildcard(require("./styles.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
class LabelRenderer {
  constructor(container, options) {
    this._cssLabels = new Map();
    this._elementToData = new Map();
    s.createCssStyles();
    this._container = container;
    container.addEventListener('click', this._onClick.bind(this));
    this._container.className = s.labelsContainer;
    if (options === null || options === void 0 ? void 0 : options.onLabelClick) this._onClickCallback = options.onLabelClick;
    if (options === null || options === void 0 ? void 0 : options.padding) this._padding = options.padding;
    if (options === null || options === void 0 ? void 0 : options.pointerEvents) this._pointerEvents = options.pointerEvents;
    if (options === null || options === void 0 ? void 0 : options.dispatchWheelEventElement) {
      this._dispatchWheelEventElement = options.dispatchWheelEventElement;
      this._container.addEventListener('wheel', this._onWheel.bind(this));
    }
  }
  setLabels(labels) {
    // Add new labels and take into account existing labels
    const labelsToDelete = new Map(this._cssLabels);
    labels.forEach(label => {
      const {
        x,
        y,
        fontSize,
        color,
        text,
        weight,
        opacity,
        shouldBeShown,
        style,
        className
      } = label;
      const exists = labelsToDelete.get(label.id);
      if (exists) {
        labelsToDelete.delete(label.id);
      } else {
        const cssLabel = new _cssLabel.CssLabel(this._container, label.text);
        this._cssLabels.set(label.id, cssLabel);
        this._elementToData.set(cssLabel.element, label);
      }
      const labelToUpdate = this._cssLabels.get(label.id);
      if (labelToUpdate) {
        labelToUpdate.setText(text);
        labelToUpdate.setPosition(x, y);
        if (style !== undefined) labelToUpdate.setStyle(style);
        if (weight !== undefined) labelToUpdate.setWeight(weight);
        if (fontSize !== undefined) labelToUpdate.setFontSize(fontSize);
        if (color !== undefined) labelToUpdate.setColor(color);
        if (this._padding !== undefined) labelToUpdate.setPadding(this._padding);
        if (this._pointerEvents !== undefined) labelToUpdate.setPointerEvents(this._pointerEvents);
        if (opacity !== undefined) labelToUpdate.setOpacity(opacity);
        if (shouldBeShown !== undefined) labelToUpdate.setForceShow(shouldBeShown);
        if (className !== undefined) labelToUpdate.setClassName(className);
      }
    });
    // Remove labels from points that don't longer exist
    for (const [key] of labelsToDelete) {
      const cssLabel = this._cssLabels.get(key);
      if (cssLabel) {
        this._elementToData.delete(cssLabel.element);
        cssLabel.destroy();
      }
      this._cssLabels.delete(key);
    }
  }
  draw(withIntersection = true) {
    if (withIntersection) this._intersectLabels();
    this._cssLabels.forEach(cssLabel => cssLabel.draw());
  }
  show() {
    this._container.className = s.labelsContainer;
  }
  hide() {
    this._container.className = `${s.labelsContainer} ${s.hidden}`;
  }
  destroy() {
    this._container.removeEventListener('click', this._onClick.bind(this));
    this._container.removeEventListener('wheel', this._onWheel.bind(this));
    this._cssLabels.forEach(cssLabel => cssLabel.destroy());
  }
  _onClick(e) {
    var _a;
    const label = this._elementToData.get(e.target);
    if (label) {
      (_a = this._onClickCallback) === null || _a === void 0 ? void 0 : _a.call(this, e, label);
    }
  }
  _onWheel(e) {
    var _a;
    e.preventDefault();
    const newWheelEvent = new WheelEvent('wheel', e);
    (_a = this._dispatchWheelEventElement) === null || _a === void 0 ? void 0 : _a.dispatchEvent(newWheelEvent);
  }
  _intersectLabels() {
    const cssLabels = Array.from(this._cssLabels.values());
    cssLabels.forEach(l => l.setVisibility(l.isOnScreen()));
    for (let i = 0; i < cssLabels.length; i += 1) {
      const label1 = cssLabels[i];
      if (!label1.getVisibility()) continue;
      for (let j = i + 1; j < cssLabels.length; j += 1) {
        const label2 = cssLabels[j];
        if (!label2.getVisibility()) continue;
        const isOverlapping = label1.overlaps(label2);
        if (isOverlapping) {
          if (label2.getWeight() > label1.getWeight()) {
            label1.setVisibility(label2.getForceShow() ? false : label1.getForceShow());
          } else {
            label2.setVisibility(label1.getForceShow() ? false : label2.getForceShow());
          }
          continue;
        }
      }
    }
  }
}
exports.LabelRenderer = LabelRenderer;
},{"./css-label.js":"../node_modules/@interacta/css-labels/dist/css-label.js","./styles.js":"../node_modules/@interacta/css-labels/dist/styles.js"}],"../node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resizeObservers = void 0;
var resizeObservers = exports.resizeObservers = [];
},{}],"../node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasActiveObservations = void 0;
var _resizeObservers = require("../utils/resizeObservers");
var hasActiveObservations = function () {
  return _resizeObservers.resizeObservers.some(function (ro) {
    return ro.activeTargets.length > 0;
  });
};
exports.hasActiveObservations = hasActiveObservations;
},{"../utils/resizeObservers":"../node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js"}],"../node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasSkippedObservations = void 0;
var _resizeObservers = require("../utils/resizeObservers");
var hasSkippedObservations = function () {
  return _resizeObservers.resizeObservers.some(function (ro) {
    return ro.skippedTargets.length > 0;
  });
};
exports.hasSkippedObservations = hasSkippedObservations;
},{"../utils/resizeObservers":"../node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js"}],"../node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deliverResizeLoopError = void 0;
var msg = 'ResizeObserver loop completed with undelivered notifications.';
var deliverResizeLoopError = function () {
  var event;
  if (typeof ErrorEvent === 'function') {
    event = new ErrorEvent('error', {
      message: msg
    });
  } else {
    event = document.createEvent('Event');
    event.initEvent('error', false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};
exports.deliverResizeLoopError = deliverResizeLoopError;
},{}],"../node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResizeObserverBoxOptions = void 0;
var ResizeObserverBoxOptions;
(function (ResizeObserverBoxOptions) {
  ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (exports.ResizeObserverBoxOptions = ResizeObserverBoxOptions = {}));
},{}],"../node_modules/@juggle/resize-observer/lib/utils/freeze.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.freeze = void 0;
var freeze = function (obj) {
  return Object.freeze(obj);
};
exports.freeze = freeze;
},{}],"../node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResizeObserverSize = void 0;
var _freeze = require("./utils/freeze");
var ResizeObserverSize = exports.ResizeObserverSize = function () {
  function ResizeObserverSize(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    (0, _freeze.freeze)(this);
  }
  return ResizeObserverSize;
}();
},{"./utils/freeze":"../node_modules/@juggle/resize-observer/lib/utils/freeze.js"}],"../node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DOMRectReadOnly = void 0;
var _freeze = require("./utils/freeze");
var DOMRectReadOnly = exports.DOMRectReadOnly = function () {
  function DOMRectReadOnly(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return (0, _freeze.freeze)(this);
  }
  DOMRectReadOnly.prototype.toJSON = function () {
    var _a = this,
      x = _a.x,
      y = _a.y,
      top = _a.top,
      right = _a.right,
      bottom = _a.bottom,
      left = _a.left,
      width = _a.width,
      height = _a.height;
    return {
      x: x,
      y: y,
      top: top,
      right: right,
      bottom: bottom,
      left: left,
      width: width,
      height: height
    };
  };
  DOMRectReadOnly.fromRect = function (rectangle) {
    return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly;
}();
},{"./utils/freeze":"../node_modules/@juggle/resize-observer/lib/utils/freeze.js"}],"../node_modules/@juggle/resize-observer/lib/utils/element.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSVG = exports.isReplacedElement = exports.isHidden = exports.isElement = void 0;
var isSVG = function (target) {
  return target instanceof SVGElement && 'getBBox' in target;
};
exports.isSVG = isSVG;
var isHidden = function (target) {
  if (isSVG(target)) {
    var _a = target.getBBox(),
      width = _a.width,
      height = _a.height;
    return !width && !height;
  }
  var _b = target,
    offsetWidth = _b.offsetWidth,
    offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
exports.isHidden = isHidden;
var isElement = function (obj) {
  var _a;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
exports.isElement = isElement;
var isReplacedElement = function (target) {
  switch (target.tagName) {
    case 'INPUT':
      if (target.type !== 'image') {
        break;
      }
    case 'VIDEO':
    case 'AUDIO':
    case 'EMBED':
    case 'OBJECT':
    case 'CANVAS':
    case 'IFRAME':
    case 'IMG':
      return true;
  }
  return false;
};
exports.isReplacedElement = isReplacedElement;
},{}],"../node_modules/@juggle/resize-observer/lib/utils/global.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.global = void 0;
var global = exports.global = typeof window !== 'undefined' ? window : {};
},{}],"../node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateBoxSizes = exports.calculateBoxSize = void 0;
var _ResizeObserverBoxOptions = require("../ResizeObserverBoxOptions");
var _ResizeObserverSize = require("../ResizeObserverSize");
var _DOMRectReadOnly = require("../DOMRectReadOnly");
var _element = require("../utils/element");
var _freeze = require("../utils/freeze");
var _global = require("../utils/global");
var cache = new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(_global.global.navigator && _global.global.navigator.userAgent);
var parseDimension = function (pixel) {
  return parseFloat(pixel || '0');
};
var size = function (inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new _ResizeObserverSize.ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = (0, _freeze.freeze)({
  devicePixelContentBoxSize: size(),
  borderBoxSize: size(),
  contentBoxSize: size(),
  contentRect: new _DOMRectReadOnly.DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function (target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if ((0, _element.isHidden)(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = (0, _element.isSVG)(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === 'border-box';
  var switchSizes = verticalRegexp.test(cs.writingMode || '');
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = (0, _freeze.freeze)({
    devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size(contentWidth, contentHeight, switchSizes),
    contentRect: new _DOMRectReadOnly.DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
exports.calculateBoxSizes = calculateBoxSizes;
var calculateBoxSize = function (target, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target, forceRecalculation),
    borderBoxSize = _a.borderBoxSize,
    contentBoxSize = _a.contentBoxSize,
    devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case _ResizeObserverBoxOptions.ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case _ResizeObserverBoxOptions.ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};
exports.calculateBoxSize = calculateBoxSize;
},{"../ResizeObserverBoxOptions":"../node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js","../ResizeObserverSize":"../node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js","../DOMRectReadOnly":"../node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js","../utils/element":"../node_modules/@juggle/resize-observer/lib/utils/element.js","../utils/freeze":"../node_modules/@juggle/resize-observer/lib/utils/freeze.js","../utils/global":"../node_modules/@juggle/resize-observer/lib/utils/global.js"}],"../node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResizeObserverEntry = void 0;
var _calculateBoxSize = require("./algorithms/calculateBoxSize");
var _freeze = require("./utils/freeze");
var ResizeObserverEntry = exports.ResizeObserverEntry = function () {
  function ResizeObserverEntry(target) {
    var boxes = (0, _calculateBoxSize.calculateBoxSizes)(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = (0, _freeze.freeze)([boxes.borderBoxSize]);
    this.contentBoxSize = (0, _freeze.freeze)([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = (0, _freeze.freeze)([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry;
}();
},{"./algorithms/calculateBoxSize":"../node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js","./utils/freeze":"../node_modules/@juggle/resize-observer/lib/utils/freeze.js"}],"../node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateDepthForNode = void 0;
var _element = require("../utils/element");
var calculateDepthForNode = function (node) {
  if ((0, _element.isHidden)(node)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};
exports.calculateDepthForNode = calculateDepthForNode;
},{"../utils/element":"../node_modules/@juggle/resize-observer/lib/utils/element.js"}],"../node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.broadcastActiveObservations = void 0;
var _resizeObservers = require("../utils/resizeObservers");
var _ResizeObserverEntry = require("../ResizeObserverEntry");
var _calculateDepthForNode = require("./calculateDepthForNode");
var _calculateBoxSize = require("./calculateBoxSize");
var broadcastActiveObservations = function () {
  var shallowestDepth = Infinity;
  var callbacks = [];
  _resizeObservers.resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new _ResizeObserverEntry.ResizeObserverEntry(ot.target);
      var targetDepth = (0, _calculateDepthForNode.calculateDepthForNode)(ot.target);
      entries.push(entry);
      ot.lastReportedSize = (0, _calculateBoxSize.calculateBoxSize)(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};
exports.broadcastActiveObservations = broadcastActiveObservations;
},{"../utils/resizeObservers":"../node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js","../ResizeObserverEntry":"../node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js","./calculateDepthForNode":"../node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js","./calculateBoxSize":"../node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js"}],"../node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gatherActiveObservationsAtDepth = void 0;
var _resizeObservers = require("../utils/resizeObservers");
var _calculateDepthForNode = require("./calculateDepthForNode");
var gatherActiveObservationsAtDepth = function (depth) {
  _resizeObservers.resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if ((0, _calculateDepthForNode.calculateDepthForNode)(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};
exports.gatherActiveObservationsAtDepth = gatherActiveObservationsAtDepth;
},{"../utils/resizeObservers":"../node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js","./calculateDepthForNode":"../node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js"}],"../node_modules/@juggle/resize-observer/lib/utils/process.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.process = void 0;
var _hasActiveObservations = require("../algorithms/hasActiveObservations");
var _hasSkippedObservations = require("../algorithms/hasSkippedObservations");
var _deliverResizeLoopError = require("../algorithms/deliverResizeLoopError");
var _broadcastActiveObservations = require("../algorithms/broadcastActiveObservations");
var _gatherActiveObservationsAtDepth = require("../algorithms/gatherActiveObservationsAtDepth");
var process = function () {
  var depth = 0;
  (0, _gatherActiveObservationsAtDepth.gatherActiveObservationsAtDepth)(depth);
  while ((0, _hasActiveObservations.hasActiveObservations)()) {
    depth = (0, _broadcastActiveObservations.broadcastActiveObservations)();
    (0, _gatherActiveObservationsAtDepth.gatherActiveObservationsAtDepth)(depth);
  }
  if ((0, _hasSkippedObservations.hasSkippedObservations)()) {
    (0, _deliverResizeLoopError.deliverResizeLoopError)();
  }
  return depth > 0;
};
exports.process = process;
},{"../algorithms/hasActiveObservations":"../node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js","../algorithms/hasSkippedObservations":"../node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js","../algorithms/deliverResizeLoopError":"../node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js","../algorithms/broadcastActiveObservations":"../node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js","../algorithms/gatherActiveObservationsAtDepth":"../node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js"}],"../node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.queueMicroTask = void 0;
var trigger;
var callbacks = [];
var notify = function () {
  return callbacks.splice(0).forEach(function (cb) {
    return cb();
  });
};
var queueMicroTask = function (callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode('');
    var config = {
      characterData: true
    };
    new MutationObserver(function () {
      return notify();
    }).observe(el_1, config);
    trigger = function () {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};
exports.queueMicroTask = queueMicroTask;
},{}],"../node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.queueResizeObserver = void 0;
var _queueMicroTask = require("./queueMicroTask");
var queueResizeObserver = function (cb) {
  (0, _queueMicroTask.queueMicroTask)(function ResizeObserver() {
    requestAnimationFrame(cb);
  });
};
exports.queueResizeObserver = queueResizeObserver;
},{"./queueMicroTask":"../node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js"}],"../node_modules/@juggle/resize-observer/lib/utils/scheduler.js":[function(require,module,exports) {


"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateCount = exports.scheduler = void 0;
var _process = require("./process");
var _global = require("./global");
var _queueResizeObserver = require("./queueResizeObserver");
var watching = 0;
var isWatching = function () {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = {
  attributes: true,
  characterData: true,
  childList: true,
  subtree: true
};
var events = ['resize', 'load', 'transitionend', 'animationend', 'animationstart', 'animationiteration', 'keyup', 'keydown', 'mouseup', 'mousedown', 'mouseover', 'mouseout', 'blur', 'focus'];
var time = function (timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function () {
  function Scheduler() {
    var _this = this;
    this.stopped = true;
    this.listener = function () {
      return _this.schedule();
    };
  }
  Scheduler.prototype.run = function (timeout) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout);
    (0, _queueResizeObserver.queueResizeObserver)(function () {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = (0, _process.process)();
      } finally {
        scheduled = false;
        timeout = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1000);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler.prototype.schedule = function () {
    this.stop();
    this.run();
  };
  Scheduler.prototype.observe = function () {
    var _this = this;
    var cb = function () {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : _global.global.addEventListener('DOMContentLoaded', cb);
  };
  Scheduler.prototype.start = function () {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function (name) {
        return _global.global.addEventListener(name, _this.listener, true);
      });
    }
  };
  Scheduler.prototype.stop = function () {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function (name) {
        return _global.global.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler;
}();
var scheduler = exports.scheduler = new Scheduler();
var updateCount = function (n) {
  !watching && n > 0 && scheduler.start();
  watching += n;
  !watching && scheduler.stop();
};
exports.updateCount = updateCount;
},{"./process":"../node_modules/@juggle/resize-observer/lib/utils/process.js","./global":"../node_modules/@juggle/resize-observer/lib/utils/global.js","./queueResizeObserver":"../node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js"}],"../node_modules/@juggle/resize-observer/lib/ResizeObservation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResizeObservation = void 0;
var _ResizeObserverBoxOptions = require("./ResizeObserverBoxOptions");
var _calculateBoxSize = require("./algorithms/calculateBoxSize");
var _element = require("./utils/element");
var skipNotifyOnElement = function (target) {
  return !(0, _element.isSVG)(target) && !(0, _element.isReplacedElement)(target) && getComputedStyle(target).display === 'inline';
};
var ResizeObservation = exports.ResizeObservation = function () {
  function ResizeObservation(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || _ResizeObserverBoxOptions.ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation.prototype.isActive = function () {
    var size = (0, _calculateBoxSize.calculateBoxSize)(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size;
    }
    if (this.lastReportedSize.inlineSize !== size.inlineSize || this.lastReportedSize.blockSize !== size.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation;
}();
},{"./ResizeObserverBoxOptions":"../node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js","./algorithms/calculateBoxSize":"../node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js","./utils/element":"../node_modules/@juggle/resize-observer/lib/utils/element.js"}],"../node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResizeObserverDetail = void 0;
var ResizeObserverDetail = exports.ResizeObserverDetail = function () {
  function ResizeObserverDetail(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail;
}();
},{}],"../node_modules/@juggle/resize-observer/lib/ResizeObserverController.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResizeObserverController = void 0;
var _scheduler = require("./utils/scheduler");
var _ResizeObservation = require("./ResizeObservation");
var _ResizeObserverDetail = require("./ResizeObserverDetail");
var _resizeObservers = require("./utils/resizeObservers");
var observerMap = new WeakMap();
var getObservationIndex = function (observationTargets, target) {
  for (var i = 0; i < observationTargets.length; i += 1) {
    if (observationTargets[i].target === target) {
      return i;
    }
  }
  return -1;
};
var ResizeObserverController = exports.ResizeObserverController = function () {
  function ResizeObserverController() {}
  ResizeObserverController.connect = function (resizeObserver, callback) {
    var detail = new _ResizeObserverDetail.ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController.observe = function (resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && _resizeObservers.resizeObservers.push(detail);
      detail.observationTargets.push(new _ResizeObservation.ResizeObservation(target, options && options.box));
      (0, _scheduler.updateCount)(1);
      _scheduler.scheduler.schedule();
    }
  };
  ResizeObserverController.unobserve = function (resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index >= 0) {
      lastObservation && _resizeObservers.resizeObservers.splice(_resizeObservers.resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index, 1);
      (0, _scheduler.updateCount)(-1);
    }
  };
  ResizeObserverController.disconnect = function (resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function (ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController;
}();
},{"./utils/scheduler":"../node_modules/@juggle/resize-observer/lib/utils/scheduler.js","./ResizeObservation":"../node_modules/@juggle/resize-observer/lib/ResizeObservation.js","./ResizeObserverDetail":"../node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js","./utils/resizeObservers":"../node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js"}],"../node_modules/@juggle/resize-observer/lib/ResizeObserver.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResizeObserver = void 0;
var _ResizeObserverController = require("./ResizeObserverController");
var _element = require("./utils/element");
var ResizeObserver = exports.ResizeObserver = function () {
  function ResizeObserver(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== 'function') {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    _ResizeObserverController.ResizeObserverController.connect(this, callback);
  }
  ResizeObserver.prototype.observe = function (target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!(0, _element.isElement)(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    _ResizeObserverController.ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver.prototype.unobserve = function (target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!(0, _element.isElement)(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    _ResizeObserverController.ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver.prototype.disconnect = function () {
    _ResizeObserverController.ResizeObserverController.disconnect(this);
  };
  ResizeObserver.toString = function () {
    return 'function ResizeObserver () { [polyfill code] }';
  };
  return ResizeObserver;
}();
},{"./ResizeObserverController":"../node_modules/@juggle/resize-observer/lib/ResizeObserverController.js","./utils/element":"../node_modules/@juggle/resize-observer/lib/utils/element.js"}],"../node_modules/@juggle/resize-observer/lib/exports/resize-observer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ResizeObserver", {
  enumerable: true,
  get: function () {
    return _ResizeObserver.ResizeObserver;
  }
});
Object.defineProperty(exports, "ResizeObserverEntry", {
  enumerable: true,
  get: function () {
    return _ResizeObserverEntry.ResizeObserverEntry;
  }
});
Object.defineProperty(exports, "ResizeObserverSize", {
  enumerable: true,
  get: function () {
    return _ResizeObserverSize.ResizeObserverSize;
  }
});
var _ResizeObserver = require("../ResizeObserver");
var _ResizeObserverEntry = require("../ResizeObserverEntry");
var _ResizeObserverSize = require("../ResizeObserverSize");
},{"../ResizeObserver":"../node_modules/@juggle/resize-observer/lib/ResizeObserver.js","../ResizeObserverEntry":"../node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js","../ResizeObserverSize":"../node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js"}],"../node_modules/d3-axis/src/identity.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(x) {
  return x;
}
},{}],"../node_modules/d3-axis/src/axis.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.axisBottom = axisBottom;
exports.axisLeft = axisLeft;
exports.axisRight = axisRight;
exports.axisTop = axisTop;
var _identity = _interopRequireDefault(require("./identity.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var top = 1,
  right = 2,
  bottom = 3,
  left = 4,
  epsilon = 1e-6;
function translateX(x) {
  return "translate(" + x + ",0)";
}
function translateY(y) {
  return "translate(0," + y + ")";
}
function number(scale) {
  return function (d) {
    return +scale(d);
  };
}
function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round()) offset = Math.round(offset);
  return function (d) {
    return +scale(d) + offset;
  };
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [],
    tickValues = null,
    tickFormat = null,
    tickSizeInner = 6,
    tickSizeOuter = 6,
    tickPadding = 3,
    offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
    k = orient === top || orient === left ? -1 : 1,
    x = orient === left || orient === right ? "x" : "y",
    transform = orient === top || orient === bottom ? translateX : translateY;
  function axis(context) {
    var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues,
      format = tickFormat == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : _identity.default : tickFormat,
      spacing = Math.max(tickSizeInner, 0) + tickPadding,
      range = scale.range(),
      range0 = +range[0] + offset,
      range1 = +range[range.length - 1] + offset,
      position = (scale.bandwidth ? center : number)(scale.copy(), offset),
      selection = context.selection ? context.selection() : context,
      path = selection.selectAll(".domain").data([null]),
      tick = selection.selectAll(".tick").data(values, scale).order(),
      tickExit = tick.exit(),
      tickEnter = tick.enter().append("g").attr("class", "tick"),
      line = tick.select("line"),
      text = tick.select("text");
    path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x + "2", k * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function (d) {
        return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function (d) {
        var p = this.parentNode.__axis;
        return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset);
      });
    }
    tickExit.remove();
    path.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function (d) {
      return transform(position(d) + offset);
    });
    line.attr(x + "2", k * tickSizeInner);
    text.attr(x, k * spacing).text(format);
    selection.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection.each(function () {
      this.__axis = position;
    });
  }
  axis.scale = function (_) {
    return arguments.length ? (scale = _, axis) : scale;
  };
  axis.ticks = function () {
    return tickArguments = Array.from(arguments), axis;
  };
  axis.tickArguments = function (_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();
  };
  axis.tickValues = function (_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();
  };
  axis.tickFormat = function (_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };
  axis.tickSize = function (_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };
  axis.tickSizeInner = function (_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };
  axis.tickSizeOuter = function (_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };
  axis.tickPadding = function (_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };
  axis.offset = function (_) {
    return arguments.length ? (offset = +_, axis) : offset;
  };
  return axis;
}
function axisTop(scale) {
  return axis(top, scale);
}
function axisRight(scale) {
  return axis(right, scale);
}
function axisBottom(scale) {
  return axis(bottom, scale);
}
function axisLeft(scale) {
  return axis(left, scale);
}
},{"./identity.js":"../node_modules/d3-axis/src/identity.js"}],"../node_modules/d3-axis/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "axisBottom", {
  enumerable: true,
  get: function () {
    return _axis.axisBottom;
  }
});
Object.defineProperty(exports, "axisLeft", {
  enumerable: true,
  get: function () {
    return _axis.axisLeft;
  }
});
Object.defineProperty(exports, "axisRight", {
  enumerable: true,
  get: function () {
    return _axis.axisRight;
  }
});
Object.defineProperty(exports, "axisTop", {
  enumerable: true,
  get: function () {
    return _axis.axisTop;
  }
});
var _axis = require("./axis.js");
},{"./axis.js":"../node_modules/d3-axis/src/axis.js"}],"../node_modules/d3-brush/src/constant.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = exports.default = function _default(x) {
  return function () {
    return x;
  };
};
},{}],"../node_modules/d3-brush/src/event.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BrushEvent;
function BrushEvent(type, _ref) {
  var sourceEvent = _ref.sourceEvent,
    target = _ref.target,
    selection = _ref.selection,
    mode = _ref.mode,
    dispatch = _ref.dispatch;
  Object.defineProperties(this, {
    type: {
      value: type,
      enumerable: true,
      configurable: true
    },
    sourceEvent: {
      value: sourceEvent,
      enumerable: true,
      configurable: true
    },
    target: {
      value: target,
      enumerable: true,
      configurable: true
    },
    selection: {
      value: selection,
      enumerable: true,
      configurable: true
    },
    mode: {
      value: mode,
      enumerable: true,
      configurable: true
    },
    _: {
      value: dispatch
    }
  });
}
},{}],"../node_modules/d3-brush/src/noevent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.nopropagation = nopropagation;
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function _default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
},{}],"../node_modules/d3-brush/src/brush.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.brushSelection = brushSelection;
exports.brushX = brushX;
exports.brushY = brushY;
exports.default = _default;
var _d3Dispatch = require("d3-dispatch");
var _d3Drag = require("d3-drag");
var _d3Interpolate = require("d3-interpolate");
var _d3Selection = require("d3-selection");
var _d3Transition = require("d3-transition");
var _constant = _interopRequireDefault(require("./constant.js"));
var _event = _interopRequireDefault(require("./event.js"));
var _noevent = _interopRequireWildcard(require("./noevent.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var MODE_DRAG = {
    name: "drag"
  },
  MODE_SPACE = {
    name: "space"
  },
  MODE_HANDLE = {
    name: "handle"
  },
  MODE_CENTER = {
    name: "center"
  };
var abs = Math.abs,
  max = Math.max,
  min = Math.min;
function number1(e) {
  return [+e[0], +e[1]];
}
function number2(e) {
  return [number1(e[0]), number1(e[1])];
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function input(x, e) {
    return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]];
  },
  output: function output(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function input(y, e) {
    return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]];
  },
  output: function output(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function input(xy) {
    return xy == null ? null : number2(xy);
  },
  output: function output(xy) {
    return xy;
  }
};
var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};
var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};
var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};
var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};
var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};
function type(t) {
  return {
    type: t
  };
}

// Ignore right-click, since that should open the context menu.
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}

// Like d3.local, but with the name “__brush” rather than auto-generated.
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}
function empty(extent) {
  return extent[0][0] === extent[1][0] || extent[0][1] === extent[1][1];
}
function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}
function brushX() {
  return brush(X);
}
function brushY() {
  return brush(Y);
}
function _default() {
  return brush(XY);
}
function brush(dim) {
  var extent = defaultExtent,
    filter = defaultFilter,
    touchable = defaultTouchable,
    keys = true,
    listeners = (0, _d3Dispatch.dispatch)("start", "brush", "end"),
    handleSize = 6,
    touchending;
  function brush(group) {
    var overlay = group.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function () {
      var extent = local(this).extent;
      (0, _d3Selection.select)(this).attr("x", extent[0][0]).attr("y", extent[0][1]).attr("width", extent[1][0] - extent[0][0]).attr("height", extent[1][1] - extent[0][1]);
    });
    group.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var handle = group.selectAll(".handle").data(dim.handles, function (d) {
      return d.type;
    });
    handle.exit().remove();
    handle.enter().append("rect").attr("class", function (d) {
      return "handle handle--" + d.type;
    }).attr("cursor", function (d) {
      return cursors[d.type];
    });
    group.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  brush.move = function (group, selection, event) {
    if (group.tween) {
      group.on("start.brush", function (event) {
        emitter(this, arguments).beforestart().start(event);
      }).on("interrupt.brush end.brush", function (event) {
        emitter(this, arguments).end(event);
      }).tween("brush", function () {
        var that = this,
          state = that.__brush,
          emit = emitter(that, arguments),
          selection0 = state.selection,
          selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
          i = (0, _d3Interpolate.interpolate)(selection0, selection1);
        function tween(t) {
          state.selection = t === 1 && selection1 === null ? null : i(t);
          redraw.call(that);
          emit.brush();
        }
        return selection0 !== null && selection1 !== null ? tween : tween(1);
      });
    } else {
      group.each(function () {
        var that = this,
          args = arguments,
          state = that.__brush,
          selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
          emit = emitter(that, args).beforestart();
        (0, _d3Transition.interrupt)(that);
        state.selection = selection1 === null ? null : selection1;
        redraw.call(that);
        emit.start(event).brush(event).end(event);
      });
    }
  };
  brush.clear = function (group, event) {
    brush.move(group, null, event);
  };
  function redraw() {
    var group = (0, _d3Selection.select)(this),
      selection = local(this).selection;
    if (selection) {
      group.selectAll(".selection").style("display", null).attr("x", selection[0][0]).attr("y", selection[0][1]).attr("width", selection[1][0] - selection[0][0]).attr("height", selection[1][1] - selection[0][1]);
      group.selectAll(".handle").style("display", null).attr("x", function (d) {
        return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2;
      }).attr("y", function (d) {
        return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2;
      }).attr("width", function (d) {
        return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize;
      }).attr("height", function (d) {
        return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize;
      });
    } else {
      group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }
  function emitter(that, args, clean) {
    var emit = that.__brush.emitter;
    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
  }
  function Emitter(that, args, clean) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
    this.clean = clean;
  }
  Emitter.prototype = {
    beforestart: function beforestart() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function start(event, mode) {
      if (this.starting) this.starting = false, this.emit("start", event, mode);else this.emit("brush", event);
      return this;
    },
    brush: function brush(event, mode) {
      this.emit("brush", event, mode);
      return this;
    },
    end: function end(event, mode) {
      if (--this.active === 0) delete this.state.emitter, this.emit("end", event, mode);
      return this;
    },
    emit: function emit(type, event, mode) {
      var d = (0, _d3Selection.select)(this.that).datum();
      listeners.call(type, this.that, new _event.default(type, {
        sourceEvent: event,
        target: brush,
        selection: dim.output(this.state.selection),
        mode: mode,
        dispatch: listeners
      }), d);
    }
  };
  function started(event) {
    if (touchending && !event.touches) return;
    if (!filter.apply(this, arguments)) return;
    var that = this,
      type = event.target.__data__.type,
      mode = (keys && event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : keys && event.altKey ? MODE_CENTER : MODE_HANDLE,
      signX = dim === Y ? null : signsX[type],
      signY = dim === X ? null : signsY[type],
      state = local(that),
      extent = state.extent,
      selection = state.selection,
      W = extent[0][0],
      w0,
      w1,
      N = extent[0][1],
      n0,
      n1,
      E = extent[1][0],
      e0,
      e1,
      S = extent[1][1],
      s0,
      s1,
      dx = 0,
      dy = 0,
      moving,
      shifting = signX && signY && keys && event.shiftKey,
      lockX,
      lockY,
      points = Array.from(event.touches || [event], function (t) {
        var i = t.identifier;
        t = (0, _d3Selection.pointer)(t, that);
        t.point0 = t.slice();
        t.identifier = i;
        return t;
      });
    (0, _d3Transition.interrupt)(that);
    var emit = emitter(that, arguments, true).beforestart();
    if (type === "overlay") {
      if (selection) moving = true;
      var pts = [points[0], points[1] || points[0]];
      state.selection = selection = [[w0 = dim === Y ? W : min(pts[0][0], pts[1][0]), n0 = dim === X ? N : min(pts[0][1], pts[1][1])], [e0 = dim === Y ? E : max(pts[0][0], pts[1][0]), s0 = dim === X ? S : max(pts[0][1], pts[1][1])]];
      if (points.length > 1) move(event);
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }
    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;
    var group = (0, _d3Selection.select)(that).attr("pointer-events", "none");
    var overlay = group.selectAll(".overlay").attr("cursor", cursors[type]);
    if (event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = (0, _d3Selection.select)(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
      if (keys) view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
      (0, _d3Drag.dragDisable)(event.view);
    }
    redraw.call(that);
    emit.start(event, mode.name);
    function moved(event) {
      var _iterator = _createForOfIteratorHelper(event.changedTouches || [event]),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var _iterator3 = _createForOfIteratorHelper(points),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var d = _step3.value;
              if (d.identifier === p.identifier) d.cur = (0, _d3Selection.pointer)(p, that);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (shifting && !lockX && !lockY && points.length === 1) {
        var point = points[0];
        if (abs(point.cur[0] - point[0]) > abs(point.cur[1] - point[1])) lockY = true;else lockX = true;
      }
      var _iterator2 = _createForOfIteratorHelper(points),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _point = _step2.value;
          if (_point.cur) _point[0] = _point.cur[0], _point[1] = _point.cur[1];
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      moving = true;
      (0, _noevent.default)(event);
      move(event);
    }
    function move(event) {
      var point = points[0],
        point0 = point.point0;
      var t;
      dx = point[0] - point0[0];
      dy = point[1] - point0[1];
      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG:
          {
            if (signX) dx = max(W - w0, min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
            if (signY) dy = max(N - n0, min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
            break;
          }
        case MODE_HANDLE:
          {
            if (points[1]) {
              if (signX) w1 = max(W, min(E, points[0][0])), e1 = max(W, min(E, points[1][0])), signX = 1;
              if (signY) n1 = max(N, min(S, points[0][1])), s1 = max(N, min(S, points[1][1])), signY = 1;
            } else {
              if (signX < 0) dx = max(W - w0, min(E - w0, dx)), w1 = w0 + dx, e1 = e0;else if (signX > 0) dx = max(W - e0, min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
              if (signY < 0) dy = max(N - n0, min(S - n0, dy)), n1 = n0 + dy, s1 = s0;else if (signY > 0) dy = max(N - s0, min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
            }
            break;
          }
        case MODE_CENTER:
          {
            if (signX) w1 = max(W, min(E, w0 - dx * signX)), e1 = max(W, min(E, e0 + dx * signX));
            if (signY) n1 = max(N, min(S, n0 - dy * signY)), s1 = max(N, min(S, s0 + dy * signY));
            break;
          }
      }
      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }
      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }
      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];
      if (selection[0][0] !== w1 || selection[0][1] !== n1 || selection[1][0] !== e1 || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush(event, mode.name);
      }
    }
    function ended(event) {
      (0, _noevent.nopropagation)(event);
      if (event.touches) {
        if (event.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function () {
          touchending = null;
        }, 500); // Ghost clicks are delayed!
      } else {
        (0, _d3Drag.dragEnable)(event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end(event, mode.name);
    }
    function keydowned(event) {
      switch (event.keyCode) {
        case 16:
          {
            // SHIFT
            shifting = signX && signY;
            break;
          }
        case 18:
          {
            // ALT
            if (mode === MODE_HANDLE) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
              move(event);
            }
            break;
          }
        case 32:
          {
            // SPACE; takes priority over ALT
            if (mode === MODE_HANDLE || mode === MODE_CENTER) {
              if (signX < 0) e0 = e1 - dx;else if (signX > 0) w0 = w1 - dx;
              if (signY < 0) s0 = s1 - dy;else if (signY > 0) n0 = n1 - dy;
              mode = MODE_SPACE;
              overlay.attr("cursor", cursors.selection);
              move(event);
            }
            break;
          }
        default:
          return;
      }
      (0, _noevent.default)(event);
    }
    function keyupped(event) {
      switch (event.keyCode) {
        case 16:
          {
            // SHIFT
            if (shifting) {
              lockX = lockY = shifting = false;
              move(event);
            }
            break;
          }
        case 18:
          {
            // ALT
            if (mode === MODE_CENTER) {
              if (signX < 0) e0 = e1;else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1;else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
              move(event);
            }
            break;
          }
        case 32:
          {
            // SPACE
            if (mode === MODE_SPACE) {
              if (event.altKey) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
              } else {
                if (signX < 0) e0 = e1;else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1;else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
              }
              overlay.attr("cursor", cursors[type]);
              move(event);
            }
            break;
          }
        default:
          return;
      }
      (0, _noevent.default)(event);
    }
  }
  function touchmoved(event) {
    emitter(this, arguments).moved(event);
  }
  function touchended(event) {
    emitter(this, arguments).ended(event);
  }
  function initialize() {
    var state = this.__brush || {
      selection: null
    };
    state.extent = number2(extent.apply(this, arguments));
    state.dim = dim;
    return state;
  }
  brush.extent = function (_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0, _constant.default)(number2(_)), brush) : extent;
  };
  brush.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0, _constant.default)(!!_), brush) : filter;
  };
  brush.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0, _constant.default)(!!_), brush) : touchable;
  };
  brush.handleSize = function (_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };
  brush.keyModifiers = function (_) {
    return arguments.length ? (keys = !!_, brush) : keys;
  };
  brush.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };
  return brush;
}
},{"d3-dispatch":"../node_modules/d3-dispatch/src/index.js","d3-drag":"../node_modules/d3-drag/src/index.js","d3-interpolate":"../node_modules/d3-interpolate/src/index.js","d3-selection":"../node_modules/d3-selection/src/index.js","d3-transition":"../node_modules/d3-transition/src/index.js","./constant.js":"../node_modules/d3-brush/src/constant.js","./event.js":"../node_modules/d3-brush/src/event.js","./noevent.js":"../node_modules/d3-brush/src/noevent.js"}],"../node_modules/d3-brush/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "brush", {
  enumerable: true,
  get: function () {
    return _brush.default;
  }
});
Object.defineProperty(exports, "brushSelection", {
  enumerable: true,
  get: function () {
    return _brush.brushSelection;
  }
});
Object.defineProperty(exports, "brushX", {
  enumerable: true,
  get: function () {
    return _brush.brushX;
  }
});
Object.defineProperty(exports, "brushY", {
  enumerable: true,
  get: function () {
    return _brush.brushY;
  }
});
var _brush = _interopRequireWildcard(require("./brush.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
},{"./brush.js":"../node_modules/d3-brush/src/brush.js"}],"../node_modules/@cosmograph/ui/modules/timeline/assets.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.play = exports.pause = void 0;
const c = exports.pause = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M48 64C21.5 64 0 85.5 0 112V400c0 26.5 21.5 48 48 48H80c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H48zm192 0c-26.5 0-48 21.5-48 48V400c0 26.5 21.5 48 48 48h32c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H240z"/></svg>',
  s = exports.play = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentColor" d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg>';
},{}],"../node_modules/@cosmograph/ui/modules/timeline/format.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultDateFormat = void 0;
var _d3TimeFormat = require("d3-time-format");
require("d3-format");
var _d3Time = require("d3-time");
const a = (0, _d3TimeFormat.timeFormat)(".%L"),
  f = (0, _d3TimeFormat.timeFormat)(":%S"),
  n = (0, _d3TimeFormat.timeFormat)("%I:%M"),
  b = (0, _d3TimeFormat.timeFormat)("%I %p"),
  c = (0, _d3TimeFormat.timeFormat)("%a %d"),
  s = (0, _d3TimeFormat.timeFormat)("%b %d"),
  I = (0, _d3TimeFormat.timeFormat)("%b"),
  u = (0, _d3TimeFormat.timeFormat)("%Y"),
  w = t => {
    const w = new Date(t);
    return ((0, _d3Time.timeSecond)(w) < w ? a : (0, _d3Time.timeMinute)(w) < w ? f : (0, _d3Time.timeHour)(w) < w ? n : (0, _d3Time.timeDay)(w) < w ? b : (0, _d3Time.timeMonth)(w) < w ? (0, _d3Time.timeWeek)(w) < w ? c : s : (0, _d3Time.timeYear)(w) < w ? I : u)(w);
  };
exports.defaultDateFormat = w;
},{"d3-time-format":"../node_modules/d3-time-format/src/index.js","d3-format":"../node_modules/d3-format/src/index.js","d3-time":"../node_modules/d3-time/src/index.js"}],"../node_modules/@cosmograph/ui/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.merge = exports.isPlainObject = exports.isObject = exports.isFunction = exports.isBetween = exports.isArray = exports.isAClassInstance = exports.getInnerDimensions = exports.getCountsInRange = exports.cloneDeep = exports.Config = void 0;
const t = t => "function" == typeof t,
  e = t => Array.isArray(t),
  n = t => t instanceof Object,
  r = t => "Function" !== t.constructor.name && "Object" !== t.constructor.name,
  o = o => n(o) && !e(o) && !t(o) && !r(o),
  s = (t, e = new Map()) => {
    if ("object" != typeof t || null === t) return t;
    if (t instanceof Date) return new Date(t.getTime());
    if (t instanceof Array) {
      const n = [];
      e.set(t, n);
      for (const r of t) n.push(e.has(r) ? e.get(r) : s(r, e));
      return t;
    }
    if (r(t)) {
      return t;
    }
    if (t instanceof Object) {
      const n = {};
      e.set(t, n);
      const r = t;
      return Object.keys(t).reduce((t, n) => (t[n] = e.has(r[n]) ? e.get(r[n]) : s(r[n], e), t), n), n;
    }
    return t;
  },
  a = (t, e, n = new Map()) => {
    const c = r(t) ? t : s(t);
    return t === e ? t : n.has(e) ? n.get(e) : (n.set(e, c), Object.keys(e).forEach(i => {
      o(t[i]) && o(e[i]) ? c[i] = a(t[i], e[i], n) : r(e) ? c[i] = e : c[i] = s(e[i]);
    }), c);
  },
  c = (t, e, n) => t >= +e && +t <= +n,
  i = (t, e) => {
    const [n, r] = e,
      o = Array.from(t.keys());
    let s = 0;
    return o.forEach(e => {
      var o;
      c(+e, +n, +r) && (s += null !== (o = t.get(e)) && void 0 !== o ? o : 0);
    }), s;
  },
  f = t => {
    const e = getComputedStyle(t);
    let n = t.clientWidth,
      r = t.clientHeight;
    return r -= parseFloat(e.paddingTop) + parseFloat(e.paddingBottom), n -= parseFloat(e.paddingLeft) + parseFloat(e.paddingRight), {
      height: r,
      width: n
    };
  };
exports.getInnerDimensions = f;
exports.getCountsInRange = i;
exports.isBetween = c;
exports.merge = a;
exports.cloneDeep = s;
exports.isPlainObject = o;
exports.isAClassInstance = r;
exports.isObject = n;
exports.isArray = e;
exports.isFunction = t;
class u {
  init(t) {
    const e = this;
    return Object.keys(t).forEach(n => {
      o(e[n]) ? e[n] = a(e[n], t[n]) : e[n] = t[n];
    }), this;
  }
}
exports.Config = u;
},{}],"../node_modules/@cosmograph/ui/modules/timeline/config.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TimelineConfig = exports.DEFAULT_PADDING = void 0;
var _format = require("./format.js");
var _utils = require("../../utils.js");
const o = exports.DEFAULT_PADDING = {
  top: 1,
  left: 0,
  bottom: 1,
  right: 0
};
class s extends _utils.Config {
  constructor() {
    super(...arguments), this.allowSelection = !0, this.showAnimationControls = !1, this.animationSpeed = 50, this.padding = o, this.axisTickHeight = 25, this.selectionRadius = 3, this.selectionPadding = 8, this.barCount = 100, this.barRadius = 1, this.barPadding = .1, this.barTopMargin = 3, this.minBarHeight = 1, this.dataStep = void 0, this.tickStep = void 0, this.formatter = _format.defaultDateFormat, this.events = {
      onBrush: void 0,
      onBarHover: void 0,
      onAnimationPlay: void 0,
      onAnimationPause: void 0
    };
  }
}
exports.TimelineConfig = s;
},{"./format.js":"../node_modules/@cosmograph/ui/modules/timeline/format.js","../../utils.js":"../node_modules/@cosmograph/ui/utils.js"}],"../node_modules/@cosmograph/ui/ext/rollup-plugin-styles/dist/runtime/inject-css.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = n;
var e = [],
  t = [];
function n(n, r) {
  if (n && "undefined" != typeof document) {
    var a,
      s = !0 === r.prepend ? "prepend" : "append",
      d = !0 === r.singleTag,
      i = "string" == typeof r.container ? document.querySelector(r.container) : document.getElementsByTagName("head")[0];
    if (d) {
      var u = e.indexOf(i);
      -1 === u && (u = e.push(i) - 1, t[u] = {}), a = t[u] && t[u][s] ? t[u][s] : t[u][s] = c();
    } else a = c();
    65279 === n.charCodeAt(0) && (n = n.substring(1)), a.styleSheet ? a.styleSheet.cssText += n : a.appendChild(document.createTextNode(n));
  }
  function c() {
    var e = document.createElement("style");
    if (e.setAttribute("type", "text/css"), r.attributes) for (var t = Object.keys(r.attributes), n = 0; n < t.length; n++) e.setAttribute(t[n], r.attributes[t[n]]);
    var a = "prepend" === s ? "afterbegin" : "beforeend";
    return i.insertAdjacentElement(a, e), e;
  }
}
},{}],"../node_modules/@cosmograph/ui/modules/timeline/style.module.css.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.css = void 0;
var _injectCss = _interopRequireDefault(require("./../../ext/rollup-plugin-styles/dist/runtime/inject-css.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var o = exports.css = ":root{--cosmograph-timeline-text-color:#fff;--cosmograph-timeline-axis-color:#fff;--cosmograph-timeline-selection-color:#777;--cosmograph-timeline-selection-opacity:0.5;--cosmograph-timeline-bar-color:#7a7a7a;--cosmograph-timeline-font-family:inherit;--cosmograph-timeline-font-size:11px;--cosmograph-timeline-background:#222}.style_module_timeline__f90332e1{background:var(--cosmograph-timeline-background);display:flex;overflow:hidden;position:relative;width:100%}.style_module_timelineSvg__f90332e1{height:100%;position:relative;width:100%}.style_module_selection__f90332e1{fill:var(--cosmograph-timeline-selection-color);fill-opacity:var(--cosmograph-timeline-selection-opacity);stroke:none}.style_module_axisTick__f90332e1{text-anchor:initial;alignment-baseline:text-before-edge;color:var(--cosmograph-timeline-axis-color);font:var(--cosmograph-timeline-font-family);font-size:var(--cosmograph-timeline-font-size);font-weight:400;opacity:.7;user-select:none}.style_module_axisLine__f90332e1{color:var(--cosmograph-timeline-axis-color);opacity:.2}.style_module_bar__f90332e1{fill:var(--cosmograph-timeline-bar-color);opacity:0;transform:scaleY(-1)}.style_module_noData__f90332e1{height:100%;position:absolute;top:0;width:100%}.style_module_noData__f90332e1 div{align-items:center;display:flex;font-size:calc(var(--cosmograph-timeline-font-size) + 5px);font-weight:300;height:100%;justify-content:center;letter-spacing:1;opacity:.25;user-select:none}.style_module_animationControl__f90332e1{align-items:center;color:var(--cosmograph-timeline-axis-color);cursor:pointer;display:flex;height:100%;justify-content:center;max-width:30px;min-width:20px;opacity:.5;position:relative;user-select:none;width:6%}.style_module_animationControl__f90332e1>svg{max-height:20px;padding-right:2px;width:50%}.style_module_hidden__f90332e1{display:none}.style_module_disabled__f90332e1{opacity:.2;pointer-events:none}",
  i = exports.default = {
    timeline: "style_module_timeline__f90332e1",
    timelineSvg: "style_module_timelineSvg__f90332e1",
    selection: "style_module_selection__f90332e1",
    axisTick: "style_module_axisTick__f90332e1",
    axisLine: "style_module_axisLine__f90332e1",
    bar: "style_module_bar__f90332e1",
    noData: "style_module_noData__f90332e1",
    axis: "style_module_axis__f90332e1",
    bars: "style_module_bars__f90332e1",
    brush: "style_module_brush__f90332e1",
    animationControl: "style_module_animationControl__f90332e1",
    hidden: "style_module_hidden__f90332e1",
    disabled: "style_module_disabled__f90332e1",
    playAnimation: "style_module_playAnimation__f90332e1",
    pauseAnimation: "style_module_pauseAnimation__f90332e1"
  };
(0, _injectCss.default)(o, {});
},{"./../../ext/rollup-plugin-styles/dist/runtime/inject-css.js":"../node_modules/@cosmograph/ui/ext/rollup-plugin-styles/dist/runtime/inject-css.js"}],"../node_modules/@cosmograph/ui/modules/timeline/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Timeline = void 0;
Object.defineProperty(exports, "TimelineConfig", {
  enumerable: true,
  get: function () {
    return _config.TimelineConfig;
  }
});
require("d3-transition");
var _resizeObserver = require("@juggle/resize-observer");
var _d3Axis = require("d3-axis");
var _d3Brush = require("d3-brush");
var _d3Scale = require("d3-scale");
var _d3Selection = require("d3-selection");
var _d3Array = require("d3-array");
var _assets = require("./assets.js");
var _config = require("./config.js");
var _styleModuleCss = _interopRequireDefault(require("./style.module.css.js"));
var _utils = require("../../utils.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class p {
  constructor(s, r) {
    var h;
    if (this._isAnimationRunning = !1, this._svgParser = new DOMParser(), this._height = 0, this._width = 0, this._timelineWidth = 0, this._timelineHeight = 0, this._config = new _config.TimelineConfig(), this._barWidth = 0, this._maxCount = 0, this._barsData = [], this._timeData = void 0, this._bandIntervals = [], this._isNumericTimeline = !1, this._firstRender = !0, this._yScale = (0, _d3Scale.scaleSymlog)(), this._timeScale = (0, _d3Scale.scaleTime)(), this._numScale = (0, _d3Scale.scaleLinear)(), this._activeAxisScale = this._timeScale, this._timeAxis = (0, _d3Axis.axisBottom)(this._timeScale), this._numAxis = (0, _d3Axis.axisBottom)(this._numScale), this._toggleAnimation = i => {
      i.preventDefault(), this._isAnimationRunning ? this.pauseAnimation() : this.playAnimation();
    }, this._disableAnimation = () => {
      var i, t;
      this.pauseAnimation(), null === (i = this._animationControlDiv) || void 0 === i || i.removeEventListener("click", this._toggleAnimation), null === (t = this._animationControlDiv) || void 0 === t || t.remove();
    }, this.playAnimation = () => {
      var i, t, s, n;
      clearInterval(this._animationInterval), this._currentSelectionInPixels && (this._animationInterval = setInterval(this._animateSelection, this._config.animationSpeed), this._isAnimationRunning = !0, null === (t = (i = this._config.events).onAnimationPlay) || void 0 === t || t.call(i, this._isAnimationRunning, this._currentSelection)), null === (s = this._pauseButtonSvg) || void 0 === s || s.classList.remove(_styleModuleCss.default.hidden), null === (n = this._playButtonSvg) || void 0 === n || n.classList.add(_styleModuleCss.default.hidden);
    }, this.pauseAnimation = () => {
      var i, t, s, n;
      clearInterval(this._animationInterval), this._isAnimationRunning = !1, null === (t = (i = this._config.events).onAnimationPause) || void 0 === t || t.call(i, this._isAnimationRunning, this._currentSelection), null === (s = this._pauseButtonSvg) || void 0 === s || s.classList.add(_styleModuleCss.default.hidden), null === (n = this._playButtonSvg) || void 0 === n || n.classList.remove(_styleModuleCss.default.hidden);
    }, this.stopAnimation = () => {
      var i, t;
      this.pauseAnimation(), this.setSelection(void 0), null === (t = (i = this._config.events).onBrush) || void 0 === t || t.call(i, void 0);
    }, this._animateSelection = () => {
      var i, t;
      const s = this._currentSelectionInPixels;
      s && void 0 !== s[0] && void 0 !== s[1] && (this.setSelectionInPixels([s[0] + this._barWidth, s[1] + this._barWidth]), s[1] !== (null === (i = this._currentSelectionInPixels) || void 0 === i ? void 0 : i[1]) && void 0 !== (null === (t = this._currentSelectionInPixels) || void 0 === t ? void 0 : t[1]) || this.stopAnimation());
    }, this._checkLastTickPosition = () => {
      var i;
      const t = this._axisGroup.selectAll(".tick:last-of-type").nodes();
      if (null == t ? void 0 : t.length) {
        const s = t[0],
          n = null == s ? void 0 : s.getBoundingClientRect().right,
          e = null === (i = this._svg) || void 0 === i ? void 0 : i.getBoundingClientRect().right;
        s.style.display = n >= e ? "none" : "inherit";
      }
    }, this.destroy = () => {
      this._containerNode.innerHTML = "", clearInterval(this._animationInterval);
    }, r && this._config.init(r), this._containerNode = s, this._svg = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._svg.classList.add(_styleModuleCss.default.timelineSvg), this._animationControlDiv = document.createElement("div"), this._animationControlDiv.classList.add(_styleModuleCss.default.animationControl), this._containerNode.classList.add(_styleModuleCss.default.timeline), this._containerNode.appendChild(this._svg), this._noDataDiv = document.createElement("div"), (0, _d3Selection.select)(this._noDataDiv).style("display", "none").attr("class", _styleModuleCss.default.noData).append("div").text("No timeline data"), this._containerNode.appendChild(this._noDataDiv), null === (h = this._config) || void 0 === h ? void 0 : h.showAnimationControls) {
      const i = setInterval(() => {
        null !== this._containerNode && (this._initAnimationControls(), clearInterval(i));
      }, 100);
    }
    this._barsGroup = (0, _d3Selection.select)(this._svg).append("g").attr("class", _styleModuleCss.default.bars), this._axisGroup = (0, _d3Selection.select)(this._svg).append("g").attr("class", _styleModuleCss.default.axis), this._brushGroup = (0, _d3Selection.select)(this._svg).append("g").attr("class", _styleModuleCss.default.brush), this._timeAxis.tickFormat(this._config.formatter), this._numAxis.tickFormat(this._config.formatter), this._resizeObserver = new _resizeObserver.ResizeObserver(i => {
      window.requestAnimationFrame(() => {
        Array.isArray(i) && i.length && this.resize();
      });
    }), this._resizeObserver = new _resizeObserver.ResizeObserver(() => {
      this.resize();
    }), this._resizeObserver.observe(this._containerNode);
  }
  get _barPadding() {
    return this._barWidth * this._config.barPadding;
  }
  getCurrentSelection() {
    return this._currentSelection;
  }
  getCurrentSelectionInPixels() {
    return this._currentSelectionInPixels;
  }
  getBarWidth() {
    return this._barWidth - this._barPadding;
  }
  getConfig() {
    return this._config;
  }
  getIsAnimationRunning() {
    return this._isAnimationRunning;
  }
  setConfig(i) {
    var t, s, n, e, a, o;
    const r = JSON.parse(JSON.stringify(this._config));
    i ? this._config.init(i) : this._config = new _config.TimelineConfig(), (null === (t = this._config) || void 0 === t ? void 0 : t.showAnimationControls) ? (null === (s = this._animationControlDiv) || void 0 === s ? void 0 : s.isConnected) || this._initAnimationControls() : this._animationControlDiv && this._disableAnimation(), this._config.allowSelection || this._disableBrush(), this._config.formatter && (this._timeAxis.tickFormat(this._config.formatter), this._numAxis.tickFormat(this._config.formatter)), (null === (n = this._config) || void 0 === n ? void 0 : n.dataStep) === (null === (e = r.config) || void 0 === e ? void 0 : e.dataStep) && (null === (a = this._config) || void 0 === a ? void 0 : a.barCount) === (null === (o = r.config) || void 0 === o ? void 0 : o.barCount) || this._updateTimelineData(), this.resize();
  }
  setTimeData(i) {
    var t, s, n;
    this._timeData = null == i ? void 0 : i.filter(i => !isNaN(+i) && void 0 !== i), this._currentSelection = void 0, null === (s = (t = this._config.events).onBrush) || void 0 === s || s.call(t, this._currentSelection), this._updateScales(), (0, _d3Selection.select)(this._noDataDiv).style("display", "none"), (null === (n = this._timeData) || void 0 === n ? void 0 : n.length) ? (this._dateExtent = (0, _d3Array.extent)(this._timeData), this._updateTimelineData()) : (this._barsData = [], this._axisGroup.selectAll("*").remove(), this._barsGroup.selectAll("*").remove(), this._brushGroup.selectAll("*").remove(), (0, _d3Selection.select)(this._noDataDiv).style("display", "block"), this._firstRender = !0);
  }
  _getBarsData(i, t) {
    var s, n;
    if (!(i[1] <= i[0]) && (null === (s = this._timeData) || void 0 === s ? void 0 : s.length) && this._dateExtent) {
      const s = (0, _d3Array.rollup)(this._timeData, i => i.length, i => i),
        e = null !== (n = this._config.dataStep) && void 0 !== n ? n : (i[1] - i[0]) / (this._config.barCount - 1);
      if (0 === e) return;
      this._bandIntervals = (0, _d3Array.range)(+i[0], +i[1], e);
      const a = this._bandIntervals[this._bandIntervals.length - 1];
      let o = this._config.dataStep ? +a + e : i[1];
      t && (this._bandIntervals = this._bandIntervals.map(i => new Date(i)), o = new Date(o)), a < i[1] && this._bandIntervals.push(o);
      const r = (0, _d3Array.pairs)(this._bandIntervals);
      this._barsData = r.map(i => ({
        rangeStart: i[0],
        rangeEnd: i[1],
        count: (0, _utils.getCountsInRange)(s, i)
      }));
    }
  }
  _updateTimelineData() {
    var i;
    if ((null === (i = this._timeData) || void 0 === i ? void 0 : i.length) && this._dateExtent) {
      if (this._isNumericTimeline = !(this._timeData[0] instanceof Date), this._isNumericTimeline) this._getBarsData(this._dateExtent);else {
        this._timeData = this._timeData.map(i => new Date(i));
        const i = this._dateExtent.map(i => {
          var t;
          return null !== (t = i.getTime()) && void 0 !== t ? t : 0;
        });
        this._getBarsData(i);
      }
      this._maxCount = Math.max(...this._barsData.map(i => i.count));
    }
  }
  setSelection(i, t = !1) {
    var s, n, e, a;
    const o = this._currentSelection;
    i && this._dateExtent && i[0] >= this._dateExtent[0] && i[1] <= this._dateExtent[1] && i[0] < i[1] ? (this._currentSelection = i, this._currentSelectionInPixels = this._currentSelection.map(this._activeAxisScale), null === (s = this._animationControlDiv) || void 0 === s || s.classList.remove(_styleModuleCss.default.disabled)) : (this._currentSelection = void 0, this._currentSelectionInPixels = void 0, null === (n = this._animationControlDiv) || void 0 === n || n.classList.add(_styleModuleCss.default.disabled));
    const {
      _currentSelection: r
    } = this;
    t || (null == o ? void 0 : o[0]) === (null == r ? void 0 : r[0]) && (null == o ? void 0 : o[1]) === (null == r ? void 0 : r[1]) || null === (a = (e = this._config.events).onBrush) || void 0 === a || a.call(e, this._currentSelection, !0), this._brushInstance && !this._firstRender && this._brushGroup.call(this._brushInstance.move, this._currentSelectionInPixels);
  }
  setSelectionInPixels(i) {
    var t, s, n, e, a;
    i && i[0] > 0 && i[1] < this._timelineWidth && i[0] < i[1] ? (this._currentSelection = i.map(i => this._activeAxisScale.invert(i)), this._currentSelectionInPixels = null === (t = this._currentSelection) || void 0 === t ? void 0 : t.map(this._activeAxisScale), null === (s = this._animationControlDiv) || void 0 === s || s.classList.remove(_styleModuleCss.default.disabled)) : (this._currentSelection = void 0, this._currentSelectionInPixels = void 0, null === (n = this._animationControlDiv) || void 0 === n || n.classList.add(_styleModuleCss.default.disabled)), this._brushInstance && !this._firstRender && this._brushGroup.call(this._brushInstance.move, this._currentSelectionInPixels), null === (a = (e = this._config.events).onBrush) || void 0 === a || a.call(e, this._currentSelection);
  }
  resize() {
    const {
        height: i,
        width: t
      } = (0, _utils.getInnerDimensions)(this._containerNode),
      {
        offsetWidth: s
      } = this._animationControlDiv;
    this._width = t, this._height = i, this._timelineWidth = this._width - this._config.padding.left - this._config.padding.right - s, this._timelineHeight = this._height - this._config.padding.top - this._config.padding.bottom, this._timelineHeight > this._config.padding.top + this._config.padding.bottom && (this._updateScales(), this._checkLastTickPosition(), this._currentSelection && this.setSelection(this._currentSelection, !0), this.render());
  }
  render() {
    this._updateBrush(), this._updateBars(), this._updateAxis(), this._firstRender && (this._firstRender = !1);
  }
  _updateAxis() {
    this._timeData && (this._axisGroup.style("transform", `translate(${this._config.padding.left}px, ${this._config.padding.top + this._config.axisTickHeight + 1 + this._config.selectionPadding / 2}px)`).call(this._isNumericTimeline ? this._numAxis : this._timeAxis).call(i => i.select(".domain").remove()), this._axisGroup.selectAll(".tick").select("text").attr("class", _styleModuleCss.default.axisTick).attr("y", 0).attr("dy", -this._config.axisTickHeight).attr("dx", "5px"), this._axisGroup.selectAll("line").attr("class", _styleModuleCss.default.axisLine).attr("y2", -this._config.axisTickHeight));
  }
  _updateBrush() {
    var i;
    this._config.allowSelection && (this._brushGroup.style("transform", `translate(${this._config.padding.left}px, ${this._config.padding.top}px)`), this._brushInstance = (0, _d3Brush.brushX)().extent([[0, 0], [this._timelineWidth, this._timelineHeight]]), this._brushInstance.on("end", ({
      selection: i,
      sourceEvent: t
    }) => {
      var s, n, e, a, o, r, h;
      t && (i ? (this._currentSelection = i.map(i => this._activeAxisScale.invert(i)), this._currentSelectionInPixels = null === (s = this._currentSelection) || void 0 === s ? void 0 : s.map(this._activeAxisScale), null === (n = this._animationControlDiv) || void 0 === n || n.classList.remove(_styleModuleCss.default.disabled), null === (a = (e = this._config.events).onBrush) || void 0 === a || a.call(e, this._currentSelection)) : (this._currentSelection = void 0, this._currentSelectionInPixels = void 0, null === (r = (o = this._config.events).onBrush) || void 0 === r || r.call(o, void 0), null === (h = this._animationControlDiv) || void 0 === h || h.classList.add(_styleModuleCss.default.disabled)));
    }), this._brushGroup.call(this._brushInstance), this._currentSelection ? (this._currentSelectionInPixels = this._currentSelection.map(this._activeAxisScale), this._brushGroup.call(this._brushInstance.move, this._currentSelectionInPixels)) : null === (i = this._brushInstance) || void 0 === i || i.clear(this._brushGroup), this._brushGroup.select("rect.selection").classed(_styleModuleCss.default.selection, !0).attr("rx", this._config.selectionRadius).attr("ry", this._config.selectionRadius));
  }
  _updateBars() {
    this._barsGroup.style("transform", `translate(${this._config.padding.left}px, ${this._config.padding.top - this._config.selectionPadding / 2}px)`);
    const i = this._barsGroup.selectAll(`.${_styleModuleCss.default.bar}`).data(this._barsData).join("rect").attr("class", _styleModuleCss.default.bar).attr("x", i => this._activeAxisScale(+i.rangeStart) + this._barPadding / 2).attr("width", this.getBarWidth()).attr("rx", this._config.barRadius).attr("ry", this._config.barRadius).attr("y", -this._timelineHeight);
    this._config.events.onBarHover && i.on("mouseover", this._config.events.onBarHover), i.transition().duration(300).attr("height", i => this._yScale(i.count)).style("opacity", i => this._yScale(i.count) === this._config.minBarHeight ? .25 : 1);
  }
  _updateScales() {
    if (!this._dateExtent || !this._barsData.length) return;
    const i = this._barsData[this._barsData.length - 1];
    if (this._config.tickStep) {
      const i = (0, _d3Array.range)(+this._dateExtent[0], +this._dateExtent[1], this._config.tickStep);
      this._isNumericTimeline ? this._numAxis.tickValues(i) : this._timeAxis.tickValues(i.map(i => new Date(i)));
    }
    this._yScale.range([this._config.minBarHeight, this._timelineHeight - this._config.barTopMargin - this._config.selectionPadding]).domain([0, this._maxCount]).clamp(!0), this._isNumericTimeline ? (this._numScale.domain([this._dateExtent[0], i.rangeEnd]).range([0, this._timelineWidth]).clamp(!0), this._activeAxisScale = this._numScale) : (this._timeScale.domain([this._dateExtent[0], i.rangeEnd]).range([0, this._timelineWidth]).clamp(!0), this._activeAxisScale = this._timeScale);
    const t = this._barsData[0],
      s = this._activeAxisScale(t.rangeEnd) - this._activeAxisScale(t.rangeStart);
    this._barWidth = s;
  }
  _disableBrush() {
    var i, t;
    null === (i = this._brushInstance) || void 0 === i || i.clear(this._brushGroup), this._currentSelectionInPixels = void 0, this._currentSelection = void 0, this.pauseAnimation(), this._brushGroup.selectAll("*").remove(), this._config.showAnimationControls && (null === (t = this._animationControlDiv) || void 0 === t || t.classList.add(_styleModuleCss.default.disabled));
  }
  async _initAnimationControls() {
    this._containerNode.insertBefore(this._animationControlDiv, this._svg);
    await (async () => {
      var i, t;
      if (!this._animationControlDiv.firstChild) {
        const s = this._svgParser.parseFromString(_assets.play, "image/svg+xml").firstChild,
          n = this._svgParser.parseFromString(_assets.pause, "image/svg+xml").firstChild;
        this._pauseButtonSvg = null === (i = this._animationControlDiv) || void 0 === i ? void 0 : i.appendChild(n), this._playButtonSvg = null === (t = this._animationControlDiv) || void 0 === t ? void 0 : t.appendChild(s);
      }
    })().then(() => {
      var i, t, s, n, e;
      this._isAnimationRunning ? (null === (s = this._playButtonSvg) || void 0 === s || s.classList.add(_styleModuleCss.default.playAnimation, _styleModuleCss.default.hidden), null === (n = this._pauseButtonSvg) || void 0 === n || n.classList.add(_styleModuleCss.default.pauseAnimation)) : (null === (i = this._playButtonSvg) || void 0 === i || i.classList.add(_styleModuleCss.default.playAnimation), null === (t = this._pauseButtonSvg) || void 0 === t || t.classList.add(_styleModuleCss.default.pauseAnimation, _styleModuleCss.default.hidden)), this._currentSelection || null === (e = this._animationControlDiv) || void 0 === e || e.classList.add(_styleModuleCss.default.disabled), this._animationControlDiv.addEventListener("click", this._toggleAnimation);
    });
  }
}
exports.Timeline = p;
},{"d3-transition":"../node_modules/d3-transition/src/index.js","@juggle/resize-observer":"../node_modules/@juggle/resize-observer/lib/exports/resize-observer.js","d3-axis":"../node_modules/d3-axis/src/index.js","d3-brush":"../node_modules/d3-brush/src/index.js","d3-scale":"../node_modules/d3-scale/src/index.js","d3-selection":"../node_modules/d3-selection/src/index.js","d3-array":"../node_modules/d3-array/src/index.js","./assets.js":"../node_modules/@cosmograph/ui/modules/timeline/assets.js","./config.js":"../node_modules/@cosmograph/ui/modules/timeline/config.js","./style.module.css.js":"../node_modules/@cosmograph/ui/modules/timeline/style.module.css.js","../../utils.js":"../node_modules/@cosmograph/ui/utils.js"}],"../node_modules/@cosmograph/ui/modules/histogram/config.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HistogramConfig = exports.DEFAULT_PADDING = void 0;
var _utils = require("../../utils.js");
const i = exports.DEFAULT_PADDING = {
  top: 5,
  left: 5,
  bottom: 1,
  right: 5
};
class s extends _utils.Config {
  constructor() {
    super(...arguments), this.padding = i, this.barsCount = 50, this.barPadding = .1, this.minBarHeight = 2, this.selectionRadius = 3, this.selectionPadding = 8, this.barCount = 30, this.dataStep = void 0, this.barRadius = 1, this.barTopMargin = 7, this.labelSideMargin = 3, this.formatter = void 0, this.allowSelection = !0, this.stickySelection = !0, this.events = {
      onBrush: void 0,
      onBarHover: void 0
    };
  }
}
exports.HistogramConfig = s;
},{"../../utils.js":"../node_modules/@cosmograph/ui/utils.js"}],"../node_modules/@cosmograph/ui/modules/histogram/style.module.css.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.css = void 0;
var _injectCss = _interopRequireDefault(require("./../../ext/rollup-plugin-styles/dist/runtime/inject-css.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var o = exports.css = ":root{--cosmograph-histogram-text-color:#fff;--cosmograph-histogram-axis-color:#d7d7d7;--cosmograph-histogram-selection-color:#777;--cosmograph-histogram-selection-opacity:0.5;--cosmograph-histogram-bar-color:#7a7a7a;--cosmograph-histogram-highlighted-bar-color:#fff;--cosmograph-histogram-font-family:inherit;--cosmograph-histogram-font-size:11px;--cosmograph-histogram-background:#222}.style_module_histogram__ee5eb209{background:var(--cosmograph-histogram-background);display:flex;position:relative;width:100%}.style_module_histogramSvg__ee5eb209{height:100%;position:relative;width:100%}.style_module_selection__ee5eb209{fill:var(--cosmograph-histogram-selection-color);fill-opacity:var(--cosmograph-histogram-selection-opacity);stroke:none}.style_module_axisTick__ee5eb209{alignment-baseline:text-before-edge;text-anchor:initial;font-size:var(--cosmograph-histogram-font-size);font-weight:400;opacity:1;user-select:none}.style_module_bar__ee5eb209{fill:var(--cosmograph-histogram-bar-color);transform:scaleY(-1)}.style_module_highlightedBar__ee5eb209{fill:var(--cosmograph-histogram-highlighted-bar-color);pointer-events:none;transform:scaleY(-1)}.style_module_axis__ee5eb209{color:var(--cosmograph-histogram-axis-color)}.style_module_noData__ee5eb209{height:100%;position:absolute;top:0;width:100%}.style_module_noData__ee5eb209 div{align-items:center;display:flex;font-size:calc(var(--cosmograph-histogram-font-size));font-weight:300;height:100%;justify-content:center;letter-spacing:1;opacity:.25;user-select:none}",
  t = exports.default = {
    histogram: "style_module_histogram__ee5eb209",
    histogramSvg: "style_module_histogramSvg__ee5eb209",
    selection: "style_module_selection__ee5eb209",
    axisTick: "style_module_axisTick__ee5eb209",
    bar: "style_module_bar__ee5eb209",
    highlightedBar: "style_module_highlightedBar__ee5eb209",
    axis: "style_module_axis__ee5eb209",
    bars: "style_module_bars__ee5eb209",
    brush: "style_module_brush__ee5eb209",
    noData: "style_module_noData__ee5eb209"
  };
(0, _injectCss.default)(o, {});
},{"./../../ext/rollup-plugin-styles/dist/runtime/inject-css.js":"../node_modules/@cosmograph/ui/ext/rollup-plugin-styles/dist/runtime/inject-css.js"}],"../node_modules/@cosmograph/ui/modules/histogram/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Histogram = void 0;
Object.defineProperty(exports, "HistogramConfig", {
  enumerable: true,
  get: function () {
    return _config.HistogramConfig;
  }
});
var _d3Axis = require("d3-axis");
var _resizeObserver = require("@juggle/resize-observer");
var _d3Brush = require("d3-brush");
var _d3Scale = require("d3-scale");
var _d3Selection = require("d3-selection");
var _d3Array = require("d3-array");
var _config = require("./config.js");
var _utils = require("../../utils.js");
var _styleModuleCss = _interopRequireDefault(require("./style.module.css.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class d {
  constructor(s, n) {
    var r;
    this._config = new _config.HistogramConfig(), this._firstRender = !0, this._barWidth = 0, this._maxCount = 0, this._barsData = [], this._highlightedBarsData = [], this._histogramData = void 0, this._highlightedData = void 0, this._bandIntervals = [], this._calculatedStep = 0, this._yScale = (0, _d3Scale.scaleSymlog)(), this._xScale = (0, _d3Scale.scaleLinear)(), this._axis = (0, _d3Axis.axisBottom)(this._xScale), this._getClosestRange = (t, i) => {
      var s;
      return null === (s = this._barsData) || void 0 === s ? void 0 : s.reduce((s, e) => Math.abs(e[i ? "rangeEnd" : "rangeStart"] - t) < Math.abs(s[i ? "rangeEnd" : "rangeStart"] - t) ? e : s);
    };
    const {
      offsetWidth: o,
      offsetHeight: l
    } = s;
    n && this._config.init(n), this._containerNode = s, this._containerNode.classList.add(_styleModuleCss.default.histogram), this._width = o, this._height = l, this._formatter = null !== (r = null == n ? void 0 : n.formatter) && void 0 !== r ? r : void 0, this._histogramWidth = this._width - this._config.padding.left - this._config.padding.right, this._histogramHeight = this._height - this._config.padding.top - this._config.padding.bottom, this._svg = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._svg.classList.add(_styleModuleCss.default.histogramSvg), this._containerNode.appendChild(this._svg), this._noDataDiv = document.createElement("div"), (0, _d3Selection.select)(this._noDataDiv).style("display", "none").attr("class", _styleModuleCss.default.noData).append("div").text("No histogram data"), this._containerNode.appendChild(this._noDataDiv), this._axisGroup = (0, _d3Selection.select)(this._svg).append("g").attr("class", _styleModuleCss.default.axis), this._barsGroup = (0, _d3Selection.select)(this._svg).append("g").attr("class", _styleModuleCss.default.bars), this._highlightedBarsGroup = (0, _d3Selection.select)(this._svg).append("g").attr("class", _styleModuleCss.default.bars), this._brushGroup = (0, _d3Selection.select)(this._svg).append("g").attr("class", _styleModuleCss.default.brush), this._axis.tickFormat(t => this._formatter ? this._formatter(t) : t.toFixed(0)), this._resizeObserver = new _resizeObserver.ResizeObserver(() => {
      this.resize();
    }), this._resizeObserver.observe(this._containerNode);
  }
  get _barPadding() {
    return this._barWidth * this._config.barPadding;
  }
  get getCurrentSelection() {
    return this._currentSelection;
  }
  get getCurrentSelectionInPixels() {
    var t;
    return null !== (t = this._currentSelectionInPixels) && void 0 !== t ? t : [];
  }
  getBarWidth() {
    return this._barWidth - this._barPadding;
  }
  getConfig() {
    return this._config;
  }
  setConfig(t) {
    var i, s, e, a;
    const h = JSON.parse(JSON.stringify(this._config));
    t ? this._config.init(t) : this._config = new _config.HistogramConfig(), this._config.allowSelection || this._disableBrush(), (null === (i = this._config) || void 0 === i ? void 0 : i.dataStep) === (null === (s = h.config) || void 0 === s ? void 0 : s.dataStep) && (null === (e = this._config) || void 0 === e ? void 0 : e.barCount) === (null === (a = h.config) || void 0 === a ? void 0 : a.barCount) || (this._updateHistogramData(), this._updateHistogramHighlightedData()), this.resize();
  }
  setHistogramData(t, i) {
    var s, e, a;
    i && i[1] <= i[0] || (this._histogramData = null == t ? void 0 : t.filter(t => !isNaN(t) && void 0 !== t), this._highlightedBarsData = [], this._currentSelection = void 0, this._brushCurrentSelection(), null === (e = (s = this._config.events).onBrush) || void 0 === e || e.call(s, this._currentSelection), (0, _d3Selection.select)(this._noDataDiv).style("display", "none"), (null === (a = this._histogramData) || void 0 === a ? void 0 : a.length) ? (this._extent = i || (0, _d3Array.extent)(this._histogramData), this._firstRender = !0, this._updateHistogramData(), this._updateScales(), this.render()) : (0, _d3Selection.select)(this._noDataDiv).style("display", "block"));
  }
  setHighlightedData(t) {
    if (this._histogramData) if (t && 0 !== t.length) this._highlightedData = null == t ? void 0 : t.filter(t => !isNaN(t) && void 0 !== t), this._updateHistogramHighlightedData(), this._updateBars(!0);else {
      const t = JSON.stringify(this._highlightedBarsData);
      this._highlightedData = [], this._highlightedBarsData = [], t !== JSON.stringify(this._highlightedBarsData) && this._updateBars(!0);
    }
  }
  setSelection(t, i = !1) {
    var s, e;
    const a = this._currentSelection;
    if (t && this._extent && t[0] >= this._extent[0] && t[1] <= this._extent[1] && t[0] < t[1]) {
      const i = t.map(this._xScale);
      this._mapSelection(i);
    } else this._currentSelection = void 0;
    const {
      _currentSelection: h
    } = this;
    i || (null == a ? void 0 : a[0]) === (null == h ? void 0 : h[0]) && (null == a ? void 0 : a[1]) === (null == h ? void 0 : h[1]) || null === (e = (s = this._config.events).onBrush) || void 0 === e || e.call(s, this._currentSelection, !0), this._brushCurrentSelection();
  }
  resize() {
    const {
      offsetWidth: t,
      offsetHeight: i
    } = this._containerNode;
    this._width = t, this._height = i, this._histogramWidth = this._width - this._config.padding.left - this._config.padding.right, this._histogramHeight = this._height - this._config.padding.top - this._config.padding.bottom, this._histogramHeight > this._config.padding.top + this._config.padding.bottom && (this._updateScales(), this._currentSelection && this.setSelection(this._currentSelection, !0), this._firstRender || this.render());
  }
  render() {
    this._updateBrush(), this._updateBars(), this._updateBars(!0), this._updateAxis(), this._firstRender && (this._firstRender = !1);
  }
  destroy() {
    this._containerNode.innerHTML = "";
  }
  _updateAxis() {
    this._histogramData && (this._axisGroup.style("transform", `translate(${this._config.padding.left}px, ${this._config.padding.top - this._config.selectionPadding / 2 + 1}px)`).call(this._axis).call(t => t.select(".domain").remove()), this._axisGroup.selectAll(".tick").select("text").attr("class", _styleModuleCss.default.axisTick).attr("y", 0).attr("dy", 0).attr("dx", this._config.labelSideMargin), this._axisGroup.selectAll(".tick:last-of-type text").attr("dx", -this._config.labelSideMargin).style("text-anchor", "end"), this._axisGroup.selectAll("line").attr("y2", this._histogramHeight).attr("y1", 0).attr("opacity", .1));
  }
  _updateBrush() {
    this._config.allowSelection && (this._brushGroup.style("transform", `translate(${this._config.padding.left}px, ${this._config.padding.top}px)`), this._brushInstance = (0, _d3Brush.brushX)().extent([[0, 0], [this._histogramWidth, this._histogramHeight]]), this._brushInstance.on("end", ({
      selection: t,
      sourceEvent: i
    }) => {
      var s, e, a, h;
      i && (t ? (this._mapSelection(t), null === (e = (s = this._config.events).onBrush) || void 0 === e || e.call(s, this._currentSelection)) : (this._currentSelection = void 0, null === (h = (a = this._config.events).onBrush) || void 0 === h || h.call(a, void 0)), this._brushCurrentSelection());
    }), this._brushGroup.call(this._brushInstance), this._brushGroup.select("rect.selection").classed(_styleModuleCss.default.selection, !0).attr("rx", this._config.selectionRadius).attr("ry", this._config.selectionRadius));
  }
  _updateBars(t) {
    const i = t ? this._highlightedBarsGroup : this._barsGroup;
    i.style("transform", `translate(${this._config.padding.left}px, ${this._config.padding.top - this._config.selectionPadding / 2}px)`);
    const s = t ? .5 : 1,
      e = i.selectAll(`.${t ? _styleModuleCss.default.highlightedBar : _styleModuleCss.default.bar}`).data(t ? this._highlightedBarsData : this._barsData).join("rect").attr("class", t ? _styleModuleCss.default.highlightedBar : _styleModuleCss.default.bar).attr("x", t => this._xScale(t.rangeStart) + this._barPadding / 2).attr("width", this.getBarWidth()).attr("rx", this._config.barRadius).attr("ry", this._config.barRadius).attr("y", -this._histogramHeight);
    t || this._config.events.onBarHover && e.on("mouseover", this._config.events.onBarHover), e.transition().duration(300).attr("height", i => t && 0 === i.count ? 0 : this._yScale(i.count)).style("opacity", t => this._yScale(t.count) === this._config.minBarHeight ? .4 : s);
  }
  _updateScales() {
    if (!this._extent || !this._barsData.length) return;
    const t = this._barsData[this._barsData.length - 1],
      i = this._config.dataStep ? [this._extent[0], t.rangeEnd] : this._extent;
    this._xScale.domain(i).range([0, this._histogramWidth]).clamp(!0), this._yScale.range([this._config.minBarHeight, this._histogramHeight - this._config.barTopMargin - this._config.selectionPadding]).domain([0, this._maxCount]).clamp(!0), this._axis.tickValues(i), this._barWidth = this._xScale(t.rangeEnd) - this._xScale(t.rangeStart);
  }
  _disableBrush() {
    this._currentSelection = void 0, this._brushCurrentSelection(), this._brushGroup.selectAll("*").remove();
  }
  _updateHistogramData() {
    var t, i;
    if ((null === (t = this._histogramData) || void 0 === t ? void 0 : t.length) && this._extent) {
      const t = (0, _d3Array.rollup)(this._histogramData, t => t.length, t => t),
        s = null !== (i = this._config.dataStep) && void 0 !== i ? i : Math.abs(this._extent[1] - this._extent[0]) / (this._config.barCount - 1);
      if (0 === s) return;
      if (this._calculatedStep = s, this._bandIntervals = this._generateSequence(this._extent[0], this._extent[1], this._calculatedStep), this._config.dataStep) {
        const t = this._bandIntervals[this._bandIntervals.length - 1];
        t < this._extent[1] && this._bandIntervals.push(+t + this._calculatedStep);
      }
      const e = (0, _d3Array.pairs)(this._bandIntervals);
      this._barsData = e.map(i => ({
        rangeStart: i[0],
        rangeEnd: i[1],
        count: (0, _utils.getCountsInRange)(t, i)
      })), this._maxCount = Math.max(...this._barsData.map(t => t.count));
    }
  }
  _updateHistogramHighlightedData() {
    var t;
    if ((null === (t = this._highlightedData) || void 0 === t ? void 0 : t.length) && this._extent) {
      const t = (0, _d3Array.rollup)(this._highlightedData, t => t.length, t => t);
      this._bandIntervals = this._generateSequence(this._extent[0], this._extent[1], this._calculatedStep);
      const i = (0, _d3Array.pairs)(this._bandIntervals);
      this._highlightedBarsData = i.map((i, s) => {
        let e = (0, _utils.getCountsInRange)(t, i);
        const a = this._barsData[s];
        return a && e > this._barsData[s].count && (e = this._barsData[s].count), {
          rangeStart: a.rangeStart,
          rangeEnd: a.rangeEnd,
          count: e
        };
      });
    }
  }
  _mapSelection(t) {
    this._barsData.length && (this._config.stickySelection ? (this._currentSelection = [this._getClosestRange(this._xScale.invert(t[0])).rangeStart, this._getClosestRange(this._xScale.invert(t[1]), !0).rangeEnd], this._currentSelection[0] === this._currentSelection[1] && (this._currentSelection = void 0)) : this._currentSelection = t.map(this._xScale.invert));
  }
  _brushCurrentSelection() {
    var t;
    this._currentSelection ? (this._currentSelectionInPixels = this._currentSelection.map(this._xScale), this._brushInstance && !this._firstRender && this._brushGroup.call(this._brushInstance.move, this._currentSelectionInPixels)) : (this._currentSelectionInPixels = void 0, null === (t = this._brushInstance) || void 0 === t || t.clear(this._brushGroup));
  }
  _generateSequence(t, i, s) {
    const e = Math.round((i - t) / s) + 1,
      a = new Array(e);
    for (let i = 0; i < e; i++) a[i] = t + i * s;
    return a;
  }
}
exports.Histogram = d;
},{"d3-axis":"../node_modules/d3-axis/src/index.js","@juggle/resize-observer":"../node_modules/@juggle/resize-observer/lib/exports/resize-observer.js","d3-brush":"../node_modules/d3-brush/src/index.js","d3-scale":"../node_modules/d3-scale/src/index.js","d3-selection":"../node_modules/d3-selection/src/index.js","d3-array":"../node_modules/d3-array/src/index.js","./config.js":"../node_modules/@cosmograph/ui/modules/histogram/config.js","../../utils.js":"../node_modules/@cosmograph/ui/utils.js","./style.module.css.js":"../node_modules/@cosmograph/ui/modules/histogram/style.module.css.js"}],"../node_modules/@cosmograph/ui/modules/search/config.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultSearchConfig = void 0;
const e = exports.defaultSearchConfig = {
  isDisabled: !1,
  minMatch: 1,
  limitSuggestions: 50,
  truncateValues: 100,
  maxVisibleItems: 10,
  openListUpwards: !1,
  placeholder: "Search...",
  activeAccessorIndex: void 0,
  accessors: [{
    label: "id",
    accessor: e => e.id
  }],
  matchPalette: ["#fbb4ae80", "#b3cde380", "#ccebc580", "#decbe480", "#fed9a680", "#ffffcc80", "#e5d8bd80", "#fddaec80"],
  ordering: void 0,
  events: {
    onSelect: void 0,
    onSearch: void 0,
    onEnter: void 0,
    onAccessorSelect: void 0
  }
};
},{}],"../node_modules/@cosmograph/ui/modules/search/types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Events = void 0;
var e;
!function (e) {
  e.Input = "input", e.Select = "select", e.Enter = "enter", e.AccessorSelect = "accessorSelect";
}(e || (exports.Events = e = {}));
},{}],"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SvelteComponent = void 0;
exports.action_destroyer = m;
exports.add_flush_callback = ft;
exports.add_render_callback = it;
exports.append = x;
exports.assign = n;
exports.attr = M;
exports.bind = Et;
exports.binding_callbacks = void 0;
exports.blank_object = o;
exports.bubble = Y;
exports.check_outros = gt;
exports.children = z;
exports.component_subscribe = s;
exports.compute_rest_props = y;
exports.compute_slots = g;
exports.construct_svelte_component = I;
exports.createEventDispatcher = V;
exports.create_component = Ot;
exports.create_slot = l;
exports.current_component = void 0;
exports.custom_event = H;
exports.destroy_block = _t;
exports.destroy_component = St;
exports.detach = v;
exports.dirty_components = void 0;
exports.element = k;
exports.empty = S;
exports.exclude_internal_props = $;
exports.flush = at;
exports.flush_render_callbacks = ht;
exports.getContext = X;
exports.get_all_dirty_from_scope = p;
exports.get_current_component = Q;
exports.get_slot_changes = d;
exports.get_spread_object = kt;
exports.get_spread_update = vt;
exports.globals = void 0;
exports.group_outros = yt;
exports.init = At;
exports.insert = w;
exports.is_empty = i;
exports.is_function = c;
exports.listen = A;
exports.mount_component = jt;
exports.noop = t;
exports.onDestroy = U;
exports.onMount = R;
exports.outro_and_destroy_block = xt;
exports.run = e;
exports.run_all = r;
exports.safe_not_equal = u;
exports.schedule_update = ct;
exports.setContext = W;
exports.set_attributes = P;
exports.set_current_component = K;
exports.set_custom_element_data = L;
exports.set_custom_element_data_map = T;
exports.set_data = B;
exports.set_dynamic_element_data = q;
exports.set_input_value = D;
exports.set_store_value = b;
exports.set_style = F;
exports.set_svg_attributes = C;
exports.space = j;
exports.subscribe = f;
exports.svg_element = E;
exports.text = O;
exports.tick = ut;
exports.toggle_class = G;
exports.transition_in = bt;
exports.transition_out = mt;
exports.update_keyed_each = wt;
exports.update_slot_base = h;
function t() {}
function n(t, n) {
  for (const e in n) t[e] = n[e];
  return t;
}
function e(t) {
  return t();
}
function o() {
  return Object.create(null);
}
function r(t) {
  t.forEach(e);
}
function c(t) {
  return "function" == typeof t;
}
function u(t, n) {
  return t != t ? n == n : t !== n || t && "object" == typeof t || "function" == typeof t;
}
function i(t) {
  return 0 === Object.keys(t).length;
}
function f(n, ...e) {
  if (null == n) return t;
  const o = n.subscribe(...e);
  return o.unsubscribe ? () => o.unsubscribe() : o;
}
function s(t, n, e) {
  t.$$.on_destroy.push(f(n, e));
}
function l(t, n, e, o) {
  if (t) {
    const r = a(t, n, e, o);
    return t[0](r);
  }
}
function a(t, e, o, r) {
  return t[1] && r ? n(o.ctx.slice(), t[1](r(e))) : o.ctx;
}
function d(t, n, e, o) {
  if (t[2] && o) {
    const r = t[2](o(e));
    if (void 0 === n.dirty) return r;
    if ("object" == typeof r) {
      const t = [],
        e = Math.max(n.dirty.length, r.length);
      for (let o = 0; o < e; o += 1) t[o] = n.dirty[o] | r[o];
      return t;
    }
    return n.dirty | r;
  }
  return n.dirty;
}
function h(t, n, e, o, r, c) {
  if (r) {
    const u = a(n, e, o, c);
    t.p(u, r);
  }
}
function p(t) {
  if (t.ctx.length > 32) {
    const n = [],
      e = t.ctx.length / 32;
    for (let t = 0; t < e; t++) n[t] = -1;
    return n;
  }
  return -1;
}
function $(t) {
  const n = {};
  for (const e in t) "$" !== e[0] && (n[e] = t[e]);
  return n;
}
function y(t, n) {
  const e = {};
  n = new Set(n);
  for (const o in t) n.has(o) || "$" === o[0] || (e[o] = t[o]);
  return e;
}
function g(t) {
  const n = {};
  for (const e in t) n[e] = !0;
  return n;
}
function b(t, n, e) {
  return t.set(e), n;
}
function m(n) {
  return n && c(n.destroy) ? n.destroy : t;
}
const _ = exports.globals = "undefined" != typeof window ? window : "undefined" != typeof globalThis ? globalThis : global;
function x(t, n) {
  t.appendChild(n);
}
function w(t, n, e) {
  t.insertBefore(n, e || null);
}
function v(t) {
  t.parentNode && t.parentNode.removeChild(t);
}
function k(t) {
  return document.createElement(t);
}
function E(t) {
  return document.createElementNS("http://www.w3.org/2000/svg", t);
}
function O(t) {
  return document.createTextNode(t);
}
function j() {
  return O(" ");
}
function S() {
  return O("");
}
function A(t, n, e, o) {
  return t.addEventListener(n, e, o), () => t.removeEventListener(n, e, o);
}
function M(t, n, e) {
  null == e ? t.removeAttribute(n) : t.getAttribute(n) !== e && t.setAttribute(n, e);
}
const N = ["width", "height"];
function P(t, n) {
  const e = Object.getOwnPropertyDescriptors(t.__proto__);
  for (const o in n) null == n[o] ? t.removeAttribute(o) : "style" === o ? t.style.cssText = n[o] : "__value" === o ? t.value = t[o] = n[o] : e[o] && e[o].set && -1 === N.indexOf(o) ? t[o] = n[o] : M(t, o, n[o]);
}
function C(t, n) {
  for (const e in n) M(t, e, n[e]);
}
function T(t, n) {
  Object.keys(n).forEach(e => {
    L(t, e, n[e]);
  });
}
function L(t, n, e) {
  n in t ? t[n] = "boolean" == typeof t[n] && "" === e || e : M(t, n, e);
}
function q(t) {
  return /-/.test(t) ? T : P;
}
function z(t) {
  return Array.from(t.childNodes);
}
function B(t, n) {
  n = "" + n, t.data !== n && (t.data = n);
}
function D(t, n) {
  t.value = null == n ? "" : n;
}
function F(t, n, e, o) {
  null == e ? t.style.removeProperty(n) : t.style.setProperty(n, e, o ? "important" : "");
}
function G(t, n, e) {
  t.classList[e ? "add" : "remove"](n);
}
function H(t, n, {
  bubbles: e = !1,
  cancelable: o = !1
} = {}) {
  const r = document.createEvent("CustomEvent");
  return r.initCustomEvent(t, e, o, n), r;
}
function I(t, n) {
  return new t(n);
}
let J = exports.current_component = void 0;
function K(t) {
  exports.current_component = J = t;
}
function Q() {
  if (!J) throw new Error("Function called outside component initialization");
  return J;
}
function R(t) {
  Q().$$.on_mount.push(t);
}
function U(t) {
  Q().$$.on_destroy.push(t);
}
function V() {
  const t = Q();
  return (n, e, {
    cancelable: o = !1
  } = {}) => {
    const r = t.$$.callbacks[n];
    if (r) {
      const c = H(n, e, {
        cancelable: o
      });
      return r.slice().forEach(n => {
        n.call(t, c);
      }), !c.defaultPrevented;
    }
    return !0;
  };
}
function W(t, n) {
  return Q().$$.context.set(t, n), n;
}
function X(t) {
  return Q().$$.context.get(t);
}
function Y(t, n) {
  const e = t.$$.callbacks[n.type];
  e && e.slice().forEach(t => t.call(this, n));
}
const Z = exports.dirty_components = [],
  tt = exports.binding_callbacks = [];
let nt = [];
const et = [],
  ot = Promise.resolve();
let rt = !1;
function ct() {
  rt || (rt = !0, ot.then(at));
}
function ut() {
  return ct(), ot;
}
function it(t) {
  nt.push(t);
}
function ft(t) {
  et.push(t);
}
const st = new Set();
let lt = 0;
function at() {
  if (0 !== lt) return;
  const t = J;
  do {
    try {
      for (; lt < Z.length;) {
        const t = Z[lt];
        lt++, K(t), dt(t.$$);
      }
    } catch (t) {
      throw Z.length = 0, lt = 0, t;
    }
    for (K(null), Z.length = 0, lt = 0; tt.length;) tt.pop()();
    for (let t = 0; t < nt.length; t += 1) {
      const n = nt[t];
      st.has(n) || (st.add(n), n());
    }
    nt.length = 0;
  } while (Z.length);
  for (; et.length;) et.pop()();
  rt = !1, st.clear(), K(t);
}
function dt(t) {
  if (null !== t.fragment) {
    t.update(), r(t.before_update);
    const n = t.dirty;
    t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, n), t.after_update.forEach(it);
  }
}
function ht(t) {
  const n = [],
    e = [];
  nt.forEach(o => -1 === t.indexOf(o) ? n.push(o) : e.push(o)), e.forEach(t => t()), nt = n;
}
const pt = new Set();
let $t;
function yt() {
  $t = {
    r: 0,
    c: [],
    p: $t
  };
}
function gt() {
  $t.r || r($t.c), $t = $t.p;
}
function bt(t, n) {
  t && t.i && (pt.delete(t), t.i(n));
}
function mt(t, n, e, o) {
  if (t && t.o) {
    if (pt.has(t)) return;
    pt.add(t), $t.c.push(() => {
      pt.delete(t), o && (e && t.d(1), o());
    }), t.o(n);
  } else o && o();
}
function _t(t, n) {
  t.d(1), n.delete(t.key);
}
function xt(t, n) {
  mt(t, 1, 1, () => {
    n.delete(t.key);
  });
}
function wt(t, n, e, o, c, u, i, f, s, l, a, d) {
  let h = t.length,
    p = u.length,
    $ = h;
  const y = {};
  for (; $--;) y[t[$].key] = $;
  const g = [],
    b = new Map(),
    m = new Map(),
    _ = [];
  for ($ = p; $--;) {
    const t = d(c, u, $),
      r = e(t);
    let f = i.get(r);
    f ? o && _.push(() => f.p(t, n)) : (f = l(r, t), f.c()), b.set(r, g[$] = f), r in y && m.set(r, Math.abs($ - y[r]));
  }
  const x = new Set(),
    w = new Set();
  function v(t) {
    bt(t, 1), t.m(f, a), i.set(t.key, t), a = t.first, p--;
  }
  for (; h && p;) {
    const n = g[p - 1],
      e = t[h - 1],
      o = n.key,
      r = e.key;
    n === e ? (a = n.first, h--, p--) : b.has(r) ? !i.has(o) || x.has(o) ? v(n) : w.has(r) ? h-- : m.get(o) > m.get(r) ? (w.add(o), v(n)) : (x.add(r), h--) : (s(e, i), h--);
  }
  for (; h--;) {
    const n = t[h];
    b.has(n.key) || s(n, i);
  }
  for (; p;) v(g[p - 1]);
  return r(_), g;
}
function vt(t, n) {
  const e = {},
    o = {},
    r = {
      $$scope: 1
    };
  let c = t.length;
  for (; c--;) {
    const u = t[c],
      i = n[c];
    if (i) {
      for (const t in u) t in i || (o[t] = 1);
      for (const t in i) r[t] || (e[t] = i[t], r[t] = 1);
      t[c] = i;
    } else for (const t in u) r[t] = 1;
  }
  for (const t in o) t in e || (e[t] = void 0);
  return e;
}
function kt(t) {
  return "object" == typeof t && null !== t ? t : {};
}
function Et(t, n, e) {
  const o = t.$$.props[n];
  void 0 !== o && (t.$$.bound[o] = e, e(t.$$.ctx[o]));
}
function Ot(t) {
  t && t.c();
}
function jt(t, n, o, u) {
  const {
    fragment: i,
    after_update: f
  } = t.$$;
  i && i.m(n, o), u || it(() => {
    const n = t.$$.on_mount.map(e).filter(c);
    t.$$.on_destroy ? t.$$.on_destroy.push(...n) : r(n), t.$$.on_mount = [];
  }), f.forEach(it);
}
function St(t, n) {
  const e = t.$$;
  null !== e.fragment && (ht(e.after_update), r(e.on_destroy), e.fragment && e.fragment.d(n), e.on_destroy = e.fragment = null, e.ctx = []);
}
function At(n, e, c, u, i, f, s, l = [-1]) {
  const a = J;
  K(n);
  const d = n.$$ = {
    fragment: null,
    ctx: [],
    props: f,
    update: t,
    not_equal: i,
    bound: o(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(e.context || (a ? a.$$.context : [])),
    callbacks: o(),
    dirty: l,
    skip_bound: !1,
    root: e.target || a.$$.root
  };
  s && s(d.root);
  let h = !1;
  if (d.ctx = c ? c(n, e.props || {}, (t, e, ...o) => {
    const r = o.length ? o[0] : e;
    return d.ctx && i(d.ctx[t], d.ctx[t] = r) && (!d.skip_bound && d.bound[t] && d.bound[t](r), h && function (t, n) {
      -1 === t.$$.dirty[0] && (Z.push(t), ct(), t.$$.dirty.fill(0)), t.$$.dirty[n / 31 | 0] |= 1 << n % 31;
    }(n, t)), e;
  }) : [], d.update(), h = !0, r(d.before_update), d.fragment = !!u && u(d.ctx), e.target) {
    if (e.hydrate) {
      const t = z(e.target);
      d.fragment && d.fragment.l(t), t.forEach(v);
    } else d.fragment && d.fragment.c();
    e.intro && bt(n.$$.fragment), jt(n, e.target, e.anchor, e.customElement), at();
  }
  K(a);
}
class Mt {
  $destroy() {
    St(this, 1), this.$destroy = t;
  }
  $on(n, e) {
    if (!c(e)) return t;
    const o = this.$$.callbacks[n] || (this.$$.callbacks[n] = []);
    return o.push(e), () => {
      const t = o.indexOf(e);
      -1 !== t && o.splice(t, 1);
    };
  }
  $set(t) {
    this.$$set && !i(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);
  }
}
exports.SvelteComponent = Mt;
},{}],"../node_modules/escape-string-regexp/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = escapeStringRegexp;
function escapeStringRegexp(string) {
  if (typeof string !== 'string') {
    throw new TypeError('Expected a string');
  }

  // Escape characters with special meaning either inside or outside character sets.
  // Use a simple backslash escape when it’s always valid, and a `\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
  return string.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
}
},{}],"../node_modules/@cosmograph/ui/ext/@material/dom/ponyfill.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.closest = e;
exports.estimateScrollWidth = r;
exports.matches = t;
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function e(e, r) {
  if (e.closest) return e.closest(r);
  for (var n = e; n;) {
    if (t(n, r)) return n;
    n = n.parentElement;
  }
  return null;
}
function t(e, t) {
  return (e.matches || e.webkitMatchesSelector || e.msMatchesSelector).call(e, t);
}
function r(e) {
  var t = e;
  if (null !== t.offsetParent) return t.scrollWidth;
  var r = t.cloneNode(!0);
  r.style.setProperty("position", "absolute"), r.style.setProperty("transform", "translate(-9999px, -9999px)"), document.documentElement.appendChild(r);
  var n = r.scrollWidth;
  return document.documentElement.removeChild(r), n;
}
},{}],"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/classMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.classMap = e;
function e(e) {
  return Object.entries(e).filter(([e, t]) => "" !== e && t).map(([e]) => e).join(" ");
}
},{}],"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/dispatch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dispatch = e;
function e(e, t, n, i = {
  bubbles: !0
}, s = !1) {
  if ("undefined" == typeof Event) throw new Error("Event not defined.");
  if (!e) throw new Error("Tried to dipatch event without element.");
  const r = new CustomEvent(t, Object.assign(Object.assign({}, i), {
    detail: n
  }));
  if (null == e || e.dispatchEvent(r), s && t.startsWith("SMUI")) {
    const s = new CustomEvent(t.replace(/^SMUI/g, () => "MDC"), Object.assign(Object.assign({}, i), {
      detail: n
    }));
    null == e || e.dispatchEvent(s), s.defaultPrevented && r.preventDefault();
  }
  return r;
}
},{}],"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forwardEventsBuilder = n;
const t = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/,
  e = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
function n(n) {
  let s,
    r = [];
  function i(t) {
    const e = n.$$.callbacks[t.type];
    e && e.slice().forEach(e => e.call(this, t));
  }
  return n.$on = (e, n) => {
    let o = e,
      i = () => {};
    s ? i = s(o, n) : r.push([o, n]);
    return o.match(t) && console && console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', o), () => {
      i();
    };
  }, n => {
    const a = [],
      c = {};
    s = (s, r) => {
      let l = s,
        u = r,
        p = !1;
      const f = l.match(t),
        h = l.match(e),
        v = f || h;
      if (l.match(/^SMUI:\w+:/)) {
        const t = l.split(":");
        let e = "";
        for (let n = 0; n < t.length; n++) e += n === t.length - 1 ? ":" + t[n] : t[n].split("-").map(t => t.slice(0, 1).toUpperCase() + t.slice(1)).join("");
        console.warn(`The event ${l.split("$")[0]} has been renamed to ${e.split("$")[0]}.`), l = e;
      }
      if (v) {
        const t = l.split(f ? ":" : "$");
        l = t[0];
        const e = t.slice(1).reduce((t, e) => (t[e] = !0, t), {});
        e.passive && (p = p || {}, p.passive = !0), e.nonpassive && (p = p || {}, p.passive = !1), e.capture && (p = p || {}, p.capture = !0), e.once && (p = p || {}, p.once = !0), e.preventDefault && (d = u, u = function (t) {
          return t.preventDefault(), d.call(this, t);
        }), e.stopPropagation && (u = function (t) {
          return function (e) {
            return e.stopPropagation(), t.call(this, e);
          };
        }(u)), e.stopImmediatePropagation && (u = function (t) {
          return function (e) {
            return e.stopImmediatePropagation(), t.call(this, e);
          };
        }(u)), e.self && (u = function (t, e) {
          return function (n) {
            if (n.target === t) return e.call(this, n);
          };
        }(n, u)), e.trusted && (u = function (t) {
          return function (e) {
            if (e.isTrusted) return t.call(this, e);
          };
        }(u));
      }
      var d;
      const m = o(n, l, u, p),
        $ = () => {
          m();
          const t = a.indexOf($);
          t > -1 && a.splice(t, 1);
        };
      return a.push($), l in c || (c[l] = o(n, l, i)), $;
    };
    for (let t = 0; t < r.length; t++) s(r[t][0], r[t][1]);
    return {
      destroy: () => {
        for (let t = 0; t < a.length; t++) a[t]();
        for (let t of Object.entries(c)) t[1]();
      }
    };
  };
}
function o(t, e, n, o) {
  return t.addEventListener(e, n, o), () => t.removeEventListener(e, n, o);
}
},{}],"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/useActions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useActions = t;
function t(t, r) {
  let e = [];
  if (r) for (let n = 0; n < r.length; n++) {
    const o = r[n],
      a = Array.isArray(o) ? o[0] : o;
    Array.isArray(o) && o.length > 1 ? e.push(a(t, o[1])) : e.push(a(t));
  }
  return {
    update(t) {
      if ((t && t.length || 0) != e.length) throw new Error("You must not change the length of an actions array.");
      if (t) for (let r = 0; r < t.length; r++) {
        const n = e[r];
        if (n && n.update) {
          const e = t[r];
          Array.isArray(e) && e.length > 1 ? n.update(e[1]) : n.update();
        }
      }
    },
    destroy() {
      for (let t = 0; t < e.length; t++) {
        const r = e[t];
        r && r.destroy && r.destroy();
      }
    }
  };
}
},{}],"../node_modules/@cosmograph/ui/ext/@smui/common/dist/SmuiElement.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("../../../svelte/internal/index.mjs.js");
var _forwardEventsBuilder = require("./internal/forwardEventsBuilder.js");
var _useActions = require("./internal/useActions.js");
function q(l) {
  let t,
    r,
    s = l[1],
    i = l[1] && D(l);
  return {
    c() {
      i && i.c(), t = (0, _indexMjs.empty)();
    },
    m(l, n) {
      i && i.m(l, n), (0, _indexMjs.insert)(l, t, n), r = !0;
    },
    p(l, e) {
      l[1] ? s ? (0, _indexMjs.safe_not_equal)(s, l[1]) ? (i.d(1), i = D(l), s = l[1], i.c(), i.m(t.parentNode, t)) : i.p(l, e) : (i = D(l), s = l[1], i.c(), i.m(t.parentNode, t)) : s && (i.d(1), i = null, s = l[1]);
    },
    i(l) {
      r || ((0, _indexMjs.transition_in)(i), r = !0);
    },
    o(l) {
      (0, _indexMjs.transition_out)(i), r = !1;
    },
    d(l) {
      l && (0, _indexMjs.detach)(t), i && i.d(l);
    }
  };
}
function z(l) {
  let t,
    c = l[1],
    r = l[1] && F(l);
  return {
    c() {
      r && r.c(), t = (0, _indexMjs.empty)();
    },
    m(l, n) {
      r && r.m(l, n), (0, _indexMjs.insert)(l, t, n);
    },
    p(l, e) {
      l[1] ? c ? (0, _indexMjs.safe_not_equal)(c, l[1]) ? (r.d(1), r = F(l), c = l[1], r.c(), r.m(t.parentNode, t)) : r.p(l, e) : (r = F(l), c = l[1], r.c(), r.m(t.parentNode, t)) : c && (r.d(1), r = null, c = l[1]);
    },
    i: _indexMjs.noop,
    o: _indexMjs.noop,
    d(l) {
      l && (0, _indexMjs.detach)(t), r && r.d(l);
    }
  };
}
function C(l) {
  let t, n, e, r, s;
  const i = l[8].default,
    p = (0, _indexMjs.create_slot)(i, l, l[7], null);
  let m = [l[5]],
    f = {};
  for (let l = 0; l < m.length; l += 1) f = (0, _indexMjs.assign)(f, m[l]);
  return {
    c() {
      t = (0, _indexMjs.svg_element)("svg"), p && p.c(), (0, _indexMjs.set_svg_attributes)(t, f);
    },
    m(c, o) {
      (0, _indexMjs.insert)(c, t, o), p && p.m(t, null), l[9](t), e = !0, r || (s = [(0, _indexMjs.action_destroyer)(n = _useActions.useActions.call(null, t, l[0])), (0, _indexMjs.action_destroyer)(l[4].call(null, t))], r = !0);
    },
    p(l, u) {
      p && p.p && (!e || 128 & u) && (0, _indexMjs.update_slot_base)(p, i, l, l[7], e ? (0, _indexMjs.get_slot_changes)(i, l[7], u, null) : (0, _indexMjs.get_all_dirty_from_scope)(l[7]), null), (0, _indexMjs.set_svg_attributes)(t, f = (0, _indexMjs.get_spread_update)(m, [32 & u && l[5]])), n && (0, _indexMjs.is_function)(n.update) && 1 & u && n.update.call(null, l[0]);
    },
    i(l) {
      e || ((0, _indexMjs.transition_in)(p, l), e = !0);
    },
    o(l) {
      (0, _indexMjs.transition_out)(p, l), e = !1;
    },
    d(n) {
      n && (0, _indexMjs.detach)(t), p && p.d(n), l[9](null), r = !1, (0, _indexMjs.run_all)(s);
    }
  };
}
function D(l) {
  let t, n, e, r, s;
  const i = l[8].default,
    p = (0, _indexMjs.create_slot)(i, l, l[7], null);
  let m = [l[5]],
    f = {};
  for (let l = 0; l < m.length; l += 1) f = (0, _indexMjs.assign)(f, m[l]);
  return {
    c() {
      t = (0, _indexMjs.element)(l[1]), p && p.c(), (0, _indexMjs.set_dynamic_element_data)(l[1])(t, f);
    },
    m(c, o) {
      (0, _indexMjs.insert)(c, t, o), p && p.m(t, null), l[11](t), e = !0, r || (s = [(0, _indexMjs.action_destroyer)(n = _useActions.useActions.call(null, t, l[0])), (0, _indexMjs.action_destroyer)(l[4].call(null, t))], r = !0);
    },
    p(l, u) {
      p && p.p && (!e || 128 & u) && (0, _indexMjs.update_slot_base)(p, i, l, l[7], e ? (0, _indexMjs.get_slot_changes)(i, l[7], u, null) : (0, _indexMjs.get_all_dirty_from_scope)(l[7]), null), (0, _indexMjs.set_dynamic_element_data)(l[1])(t, f = (0, _indexMjs.get_spread_update)(m, [32 & u && l[5]])), n && (0, _indexMjs.is_function)(n.update) && 1 & u && n.update.call(null, l[0]);
    },
    i(l) {
      e || ((0, _indexMjs.transition_in)(p, l), e = !0);
    },
    o(l) {
      (0, _indexMjs.transition_out)(p, l), e = !1;
    },
    d(n) {
      n && (0, _indexMjs.detach)(t), p && p.d(n), l[11](null), r = !1, (0, _indexMjs.run_all)(s);
    }
  };
}
function F(l) {
  let t,
    n,
    e,
    c,
    r = [l[5]],
    o = {};
  for (let l = 0; l < r.length; l += 1) o = (0, _indexMjs.assign)(o, r[l]);
  return {
    c() {
      t = (0, _indexMjs.element)(l[1]), (0, _indexMjs.set_dynamic_element_data)(l[1])(t, o);
    },
    m(r, o) {
      (0, _indexMjs.insert)(r, t, o), l[10](t), e || (c = [(0, _indexMjs.action_destroyer)(n = _useActions.useActions.call(null, t, l[0])), (0, _indexMjs.action_destroyer)(l[4].call(null, t))], e = !0);
    },
    p(l, e) {
      (0, _indexMjs.set_dynamic_element_data)(l[1])(t, o = (0, _indexMjs.get_spread_update)(r, [32 & e && l[5]])), n && (0, _indexMjs.is_function)(n.update) && 1 & e && n.update.call(null, l[0]);
    },
    d(n) {
      n && (0, _indexMjs.detach)(t), l[10](null), e = !1, (0, _indexMjs.run_all)(c);
    }
  };
}
function G(l) {
  let t, n, s, i;
  const d = [C, z, q],
    p = [];
  function f(l, t) {
    return "svg" === l[1] ? 0 : l[3] ? 1 : 2;
  }
  return t = f(l), n = p[t] = d[t](l), {
    c() {
      n.c(), s = (0, _indexMjs.empty)();
    },
    m(l, n) {
      p[t].m(l, n), (0, _indexMjs.insert)(l, s, n), i = !0;
    },
    p(l, [e]) {
      let u = t;
      t = f(l), t === u ? p[t].p(l, e) : ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(p[u], 1, 1, () => {
        p[u] = null;
      }), (0, _indexMjs.check_outros)(), n = p[t], n ? n.p(l, e) : (n = p[t] = d[t](l), n.c()), (0, _indexMjs.transition_in)(n, 1), n.m(s.parentNode, s));
    },
    i(l) {
      i || ((0, _indexMjs.transition_in)(n), i = !0);
    },
    o(l) {
      (0, _indexMjs.transition_out)(n), i = !1;
    },
    d(l) {
      p[t].d(l), l && (0, _indexMjs.detach)(s);
    }
  };
}
function H(l, t, n) {
  let e;
  const u = ["use", "tag", "getElement"];
  let c = (0, _indexMjs.compute_rest_props)(t, u),
    {
      $$slots: r = {},
      $$scope: o
    } = t,
    {
      use: a = []
    } = t,
    {
      tag: m
    } = t;
  const $ = (0, _forwardEventsBuilder.forwardEventsBuilder)((0, _indexMjs.get_current_component)());
  let g;
  return l.$$set = l => {
    t = (0, _indexMjs.assign)((0, _indexMjs.assign)({}, t), (0, _indexMjs.exclude_internal_props)(l)), n(5, c = (0, _indexMjs.compute_rest_props)(t, u)), "use" in l && n(0, a = l.use), "tag" in l && n(1, m = l.tag), "$$scope" in l && n(7, o = l.$$scope);
  }, l.$$.update = () => {
    2 & l.$$.dirty && n(3, e = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"].indexOf(m) > -1);
  }, [a, m, g, e, $, c, function () {
    return g;
  }, o, r, function (l) {
    _indexMjs.binding_callbacks[l ? "unshift" : "push"](() => {
      g = l, n(2, g);
    });
  }, function (l) {
    _indexMjs.binding_callbacks[l ? "unshift" : "push"](() => {
      g = l, n(2, g);
    });
  }, function (l) {
    _indexMjs.binding_callbacks[l ? "unshift" : "push"](() => {
      g = l, n(2, g);
    });
  }];
}
class I extends _indexMjs.SvelteComponent {
  constructor(l) {
    super(), (0, _indexMjs.init)(this, l, H, G, _indexMjs.safe_not_equal, {
      use: 0,
      tag: 1,
      getElement: 6
    });
  }
  get getElement() {
    return this.$$.ctx[6];
  }
}
exports.default = I;
},{"../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","./internal/forwardEventsBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js","./internal/useActions.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/useActions.js"}],"../node_modules/@cosmograph/ui/_virtual/_tslib.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__assign = void 0;
exports.__extends = t;
exports.__read = e;
exports.__spreadArray = i;
exports.__values = n;
var r = function (t, o) {
  return r = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (r, t) {
    r.__proto__ = t;
  } || function (r, t) {
    for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (r[o] = t[o]);
  }, r(t, o);
};
function t(t, o) {
  if ("function" != typeof o && null !== o) throw new TypeError("Class extends value " + String(o) + " is not a constructor or null");
  function n() {
    this.constructor = t;
  }
  r(t, o), t.prototype = null === o ? Object.create(o) : (n.prototype = o.prototype, new n());
}
var o = function () {
  return exports.__assign = o = Object.assign || function (r) {
    for (var t, o = 1, n = arguments.length; o < n; o++) for (var e in t = arguments[o]) Object.prototype.hasOwnProperty.call(t, e) && (r[e] = t[e]);
    return r;
  }, o.apply(this, arguments);
};
exports.__assign = o;
function n(r) {
  var t = "function" == typeof Symbol && Symbol.iterator,
    o = t && r[t],
    n = 0;
  if (o) return o.call(r);
  if (r && "number" == typeof r.length) return {
    next: function () {
      return r && n >= r.length && (r = void 0), {
        value: r && r[n++],
        done: !r
      };
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function e(r, t) {
  var o = "function" == typeof Symbol && r[Symbol.iterator];
  if (!o) return r;
  var n,
    e,
    i = o.call(r),
    l = [];
  try {
    for (; (void 0 === t || t-- > 0) && !(n = i.next()).done;) l.push(n.value);
  } catch (r) {
    e = {
      error: r
    };
  } finally {
    try {
      n && !n.done && (o = i.return) && o.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return l;
}
function i(r, t, o) {
  if (o || 2 === arguments.length) for (var n, e = 0, i = t.length; e < i; e++) !n && e in t || (n || (n = Array.prototype.slice.call(t, 0, e)), n[e] = t[e]);
  return r.concat(n || Array.prototype.slice.call(t));
}
"function" == typeof SuppressedError && SuppressedError;
},{}],"../node_modules/@cosmograph/ui/ext/@material/base/foundation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MDCFoundation = void 0;
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var e = exports.default = exports.MDCFoundation = function () {
  function e(e) {
    void 0 === e && (e = {}), this.adapter = e;
  }
  return Object.defineProperty(e, "cssClasses", {
    get: function () {
      return {};
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "strings", {
    get: function () {
      return {};
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "numbers", {
    get: function () {
      return {};
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "defaultAdapter", {
    get: function () {
      return {};
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.init = function () {}, e.prototype.destroy = function () {}, e;
}();
},{}],"../node_modules/@cosmograph/ui/ext/@material/dom/keyboard.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KEY = void 0;
exports.normalizeKey = U;
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var E = exports.KEY = {
    UNKNOWN: "Unknown",
    BACKSPACE: "Backspace",
    ENTER: "Enter",
    SPACEBAR: "Spacebar",
    PAGE_UP: "PageUp",
    PAGE_DOWN: "PageDown",
    END: "End",
    HOME: "Home",
    ARROW_LEFT: "ArrowLeft",
    ARROW_UP: "ArrowUp",
    ARROW_RIGHT: "ArrowRight",
    ARROW_DOWN: "ArrowDown",
    DELETE: "Delete",
    ESCAPE: "Escape",
    TAB: "Tab"
  },
  d = new Set();
d.add(E.BACKSPACE), d.add(E.ENTER), d.add(E.SPACEBAR), d.add(E.PAGE_UP), d.add(E.PAGE_DOWN), d.add(E.END), d.add(E.HOME), d.add(E.ARROW_LEFT), d.add(E.ARROW_UP), d.add(E.ARROW_RIGHT), d.add(E.ARROW_DOWN), d.add(E.DELETE), d.add(E.ESCAPE), d.add(E.TAB);
var A = 8,
  R = 13,
  a = 32,
  e = 33,
  O = 34,
  P = 35,
  W = 36,
  t = 37,
  _ = 38,
  N = 39,
  r = 40,
  D = 46,
  T = 27,
  s = 9,
  n = new Map();
n.set(A, E.BACKSPACE), n.set(R, E.ENTER), n.set(a, E.SPACEBAR), n.set(e, E.PAGE_UP), n.set(O, E.PAGE_DOWN), n.set(P, E.END), n.set(W, E.HOME), n.set(t, E.ARROW_LEFT), n.set(_, E.ARROW_UP), n.set(N, E.ARROW_RIGHT), n.set(r, E.ARROW_DOWN), n.set(D, E.DELETE), n.set(T, E.ESCAPE), n.set(s, E.TAB);
var C = new Set();
function U(A) {
  var R = A.key;
  if (d.has(R)) return R;
  var a = n.get(A.keyCode);
  return a || E.UNKNOWN;
}
C.add(E.PAGE_UP), C.add(E.PAGE_DOWN), C.add(E.END), C.add(E.HOME), C.add(E.ARROW_LEFT), C.add(E.ARROW_UP), C.add(E.ARROW_RIGHT), C.add(E.ARROW_DOWN);
},{}],"../node_modules/@cosmograph/ui/ext/@material/list/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.strings = exports.numbers = exports.deprecatedClassNameMap = exports.cssClasses = void 0;
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var _,
  E,
  e = exports.cssClasses = {
    LIST_ITEM_ACTIVATED_CLASS: "mdc-list-item--activated",
    LIST_ITEM_CLASS: "mdc-list-item",
    LIST_ITEM_DISABLED_CLASS: "mdc-list-item--disabled",
    LIST_ITEM_SELECTED_CLASS: "mdc-list-item--selected",
    LIST_ITEM_TEXT_CLASS: "mdc-list-item__text",
    LIST_ITEM_PRIMARY_TEXT_CLASS: "mdc-list-item__primary-text",
    ROOT: "mdc-list"
  };
(_ = {})["" + e.LIST_ITEM_ACTIVATED_CLASS] = "mdc-list-item--activated", _["" + e.LIST_ITEM_CLASS] = "mdc-list-item", _["" + e.LIST_ITEM_DISABLED_CLASS] = "mdc-list-item--disabled", _["" + e.LIST_ITEM_SELECTED_CLASS] = "mdc-list-item--selected", _["" + e.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-list-item__primary-text", _["" + e.ROOT] = "mdc-list";
var t = exports.deprecatedClassNameMap = ((E = {})["" + e.LIST_ITEM_ACTIVATED_CLASS] = "mdc-deprecated-list-item--activated", E["" + e.LIST_ITEM_CLASS] = "mdc-deprecated-list-item", E["" + e.LIST_ITEM_DISABLED_CLASS] = "mdc-deprecated-list-item--disabled", E["" + e.LIST_ITEM_SELECTED_CLASS] = "mdc-deprecated-list-item--selected", E["" + e.LIST_ITEM_TEXT_CLASS] = "mdc-deprecated-list-item__text", E["" + e.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-deprecated-list-item__primary-text", E["" + e.ROOT] = "mdc-deprecated-list", E),
  T = exports.strings = {
    ACTION_EVENT: "MDCList:action",
    SELECTION_CHANGE_EVENT: "MDCList:selectionChange",
    ARIA_CHECKED: "aria-checked",
    ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
    ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
    ARIA_CURRENT: "aria-current",
    ARIA_DISABLED: "aria-disabled",
    ARIA_ORIENTATION: "aria-orientation",
    ARIA_ORIENTATION_HORIZONTAL: "horizontal",
    ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
    ARIA_SELECTED: "aria-selected",
    ARIA_INTERACTIVE_ROLES_SELECTOR: '[role="listbox"], [role="menu"]',
    ARIA_MULTI_SELECTABLE_SELECTOR: '[aria-multiselectable="true"]',
    CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"], input[type="radio"]',
    CHECKBOX_SELECTOR: 'input[type="checkbox"]',
    CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + e.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + e.LIST_ITEM_CLASS + " a,\n    ." + t[e.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + t[e.LIST_ITEM_CLASS] + " a\n  ",
    DEPRECATED_SELECTOR: ".mdc-deprecated-list",
    FOCUSABLE_CHILD_ELEMENTS: "\n    ." + e.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + e.LIST_ITEM_CLASS + " a,\n    ." + e.LIST_ITEM_CLASS + ' input[type="radio"]:not(:disabled),\n    .' + e.LIST_ITEM_CLASS + ' input[type="checkbox"]:not(:disabled),\n    .' + t[e.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + t[e.LIST_ITEM_CLASS] + " a,\n    ." + t[e.LIST_ITEM_CLASS] + ' input[type="radio"]:not(:disabled),\n    .' + t[e.LIST_ITEM_CLASS] + ' input[type="checkbox"]:not(:disabled)\n  ',
    RADIO_SELECTOR: 'input[type="radio"]',
    SELECTED_ITEM_SELECTOR: '[aria-selected="true"], [aria-current="true"]'
  },
  S = exports.numbers = {
    UNSET_INDEX: -1,
    TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS: 300
  };
},{}],"../node_modules/@cosmograph/ui/ext/@material/list/events.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.preventDefaultEvent = void 0;
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var t = ["input", "button", "textarea", "select"],
  e = function (e) {
    var a = e.target;
    if (a) {
      var r = ("" + a.tagName).toLowerCase();
      -1 === t.indexOf(r) && e.preventDefault();
    }
  };
exports.preventDefaultEvent = e;
},{}],"../node_modules/@cosmograph/ui/ext/@material/list/typeahead.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearBuffer = u;
exports.handleKeydown = a;
exports.initSortedIndex = o;
exports.initState = n;
exports.isTypingInProgress = s;
exports.matchItem = d;
var _keyboard = require("../dom/keyboard.js");
var _constants = require("./constants.js");
var _events = require("./events.js");
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function n() {
  return {
    bufferClearTimeout: 0,
    currentFirstChar: "",
    sortedIndexCursor: 0,
    typeaheadBuffer: ""
  };
}
function o(e, r) {
  for (var t = new Map(), n = 0; n < e; n++) {
    var o = r(n).trim();
    if (o) {
      var d = o[0].toLowerCase();
      t.has(d) || t.set(d, []), t.get(d).push({
        text: o.toLowerCase(),
        index: n
      });
    }
  }
  return t.forEach(function (e) {
    e.sort(function (e, r) {
      return e.index - r.index;
    });
  }), t;
}
function d(e, t) {
  var n,
    o = e.nextChar,
    d = e.focusItemAtIndex,
    s = e.sortedIndexByFirstChar,
    a = e.focusedItemIndex,
    f = e.skipFocus,
    i = e.isItemAtIndexDisabled;
  return clearTimeout(t.bufferClearTimeout), t.bufferClearTimeout = setTimeout(function () {
    u(t);
  }, _constants.numbers.TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS), t.typeaheadBuffer = t.typeaheadBuffer + o, n = 1 === t.typeaheadBuffer.length ? function (e, r, t, n) {
    var o = n.typeaheadBuffer[0],
      d = e.get(o);
    if (!d) return -1;
    if (o === n.currentFirstChar && d[n.sortedIndexCursor].index === r) {
      n.sortedIndexCursor = (n.sortedIndexCursor + 1) % d.length;
      var s = d[n.sortedIndexCursor].index;
      if (!t(s)) return s;
    }
    n.currentFirstChar = o;
    var u,
      a = -1;
    for (u = 0; u < d.length; u++) if (!t(d[u].index)) {
      a = u;
      break;
    }
    for (; u < d.length; u++) if (d[u].index > r && !t(d[u].index)) {
      a = u;
      break;
    }
    if (-1 !== a) return n.sortedIndexCursor = a, d[n.sortedIndexCursor].index;
    return -1;
  }(s, a, i, t) : function (e, r, t) {
    var n = t.typeaheadBuffer[0],
      o = e.get(n);
    if (!o) return -1;
    var d = o[t.sortedIndexCursor];
    if (0 === d.text.lastIndexOf(t.typeaheadBuffer, 0) && !r(d.index)) return d.index;
    var s = (t.sortedIndexCursor + 1) % o.length,
      u = -1;
    for (; s !== t.sortedIndexCursor;) {
      var a = o[s],
        f = 0 === a.text.lastIndexOf(t.typeaheadBuffer, 0),
        i = !r(a.index);
      if (f && i) {
        u = s;
        break;
      }
      s = (s + 1) % o.length;
    }
    if (-1 !== u) return t.sortedIndexCursor = u, o[t.sortedIndexCursor].index;
    return -1;
  }(s, i, t), -1 === n || f || d(n), n;
}
function s(e) {
  return e.typeaheadBuffer.length > 0;
}
function u(e) {
  e.typeaheadBuffer = "";
}
function a(r, n) {
  var o = r.event,
    u = r.isTargetListItem,
    a = r.focusedItemIndex,
    f = r.focusItemAtIndex,
    i = r.sortedIndexByFirstChar,
    x = r.isItemAtIndexDisabled,
    I = "ArrowLeft" === (0, _keyboard.normalizeKey)(o),
    h = "ArrowUp" === (0, _keyboard.normalizeKey)(o),
    c = "ArrowRight" === (0, _keyboard.normalizeKey)(o),
    C = "ArrowDown" === (0, _keyboard.normalizeKey)(o),
    m = "Home" === (0, _keyboard.normalizeKey)(o),
    p = "End" === (0, _keyboard.normalizeKey)(o),
    l = "Enter" === (0, _keyboard.normalizeKey)(o),
    y = "Spacebar" === (0, _keyboard.normalizeKey)(o);
  return o.altKey || o.ctrlKey || o.metaKey || I || h || c || C || m || p || l ? -1 : y || 1 !== o.key.length ? y ? (u && (0, _events.preventDefaultEvent)(o), u && s(n) ? d({
    focusItemAtIndex: f,
    focusedItemIndex: a,
    nextChar: " ",
    sortedIndexByFirstChar: i,
    skipFocus: !1,
    isItemAtIndexDisabled: x
  }, n) : -1) : -1 : ((0, _events.preventDefaultEvent)(o), d({
    focusItemAtIndex: f,
    focusedItemIndex: a,
    nextChar: o.key.toLowerCase(),
    sortedIndexByFirstChar: i,
    skipFocus: !1,
    isItemAtIndexDisabled: x
  }, n));
}
},{"../dom/keyboard.js":"../node_modules/@cosmograph/ui/ext/@material/dom/keyboard.js","./constants.js":"../node_modules/@cosmograph/ui/ext/@material/list/constants.js","./events.js":"../node_modules/@cosmograph/ui/ext/@material/list/events.js"}],"../node_modules/@cosmograph/ui/ext/@material/list/foundation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MDCListFoundation = void 0;
var _tslib = require("../../../_virtual/_tslib.js");
var _foundation = require("../base/foundation.js");
var _keyboard = require("../dom/keyboard.js");
var _constants = require("./constants.js");
var _events = require("./events.js");
var _typeahead = require("./typeahead.js");
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var p = ["Alt", "Control", "Meta", "Shift"];
function A(e) {
  var t = new Set(e ? p.filter(function (t) {
    return e.getModifierState(t);
  }) : []);
  return function (e) {
    return e.every(function (e) {
      return t.has(e);
    }) && e.length === t.size;
  };
}
var m = exports.default = exports.MDCListFoundation = function (n) {
  function p(e) {
    var i = n.call(this, (0, _tslib.__assign)((0, _tslib.__assign)({}, p.defaultAdapter), e)) || this;
    return i.wrapFocus = !1, i.isVertical = !0, i.isSingleSelectionList = !1, i.areDisabledItemsFocusable = !0, i.selectedIndex = _constants.numbers.UNSET_INDEX, i.focusedItemIndex = _constants.numbers.UNSET_INDEX, i.useActivatedClass = !1, i.useSelectedAttr = !1, i.ariaCurrentAttrValue = null, i.isCheckboxList = !1, i.isRadioList = !1, i.lastSelectedIndex = null, i.hasTypeahead = !1, i.typeaheadState = (0, _typeahead.initState)(), i.sortedIndexByFirstChar = new Map(), i;
  }
  return (0, _tslib.__extends)(p, n), Object.defineProperty(p, "strings", {
    get: function () {
      return _constants.strings;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(p, "cssClasses", {
    get: function () {
      return _constants.cssClasses;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(p, "numbers", {
    get: function () {
      return _constants.numbers;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(p, "defaultAdapter", {
    get: function () {
      return {
        addClassForElementIndex: function () {},
        focusItemAtIndex: function () {},
        getAttributeForElementIndex: function () {
          return null;
        },
        getFocusedElementIndex: function () {
          return 0;
        },
        getListItemCount: function () {
          return 0;
        },
        hasCheckboxAtIndex: function () {
          return !1;
        },
        hasRadioAtIndex: function () {
          return !1;
        },
        isCheckboxCheckedAtIndex: function () {
          return !1;
        },
        isFocusInsideList: function () {
          return !1;
        },
        isRootFocused: function () {
          return !1;
        },
        listItemAtIndexHasClass: function () {
          return !1;
        },
        notifyAction: function () {},
        notifySelectionChange: function () {},
        removeClassForElementIndex: function () {},
        setAttributeForElementIndex: function () {},
        setCheckedCheckboxOrRadioAtIndex: function () {},
        setTabIndexForListItemChildren: function () {},
        getPrimaryTextAtIndex: function () {
          return "";
        }
      };
    },
    enumerable: !1,
    configurable: !0
  }), p.prototype.layout = function () {
    0 !== this.adapter.getListItemCount() && (this.adapter.hasCheckboxAtIndex(0) ? this.isCheckboxList = !0 : this.adapter.hasRadioAtIndex(0) ? this.isRadioList = !0 : this.maybeInitializeSingleSelection(), this.hasTypeahead && (this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex()));
  }, p.prototype.getFocusedItemIndex = function () {
    return this.focusedItemIndex;
  }, p.prototype.setWrapFocus = function (e) {
    this.wrapFocus = e;
  }, p.prototype.setVerticalOrientation = function (e) {
    this.isVertical = e;
  }, p.prototype.setSingleSelection = function (e) {
    this.isSingleSelectionList = e, e && (this.maybeInitializeSingleSelection(), this.selectedIndex = this.getSelectedIndexFromDOM());
  }, p.prototype.setDisabledItemsFocusable = function (e) {
    this.areDisabledItemsFocusable = e;
  }, p.prototype.maybeInitializeSingleSelection = function () {
    var e = this.getSelectedIndexFromDOM();
    e !== _constants.numbers.UNSET_INDEX && (this.adapter.listItemAtIndexHasClass(e, _constants.cssClasses.LIST_ITEM_ACTIVATED_CLASS) && this.setUseActivatedClass(!0), this.isSingleSelectionList = !0, this.selectedIndex = e);
  }, p.prototype.getSelectedIndexFromDOM = function () {
    for (var e = _constants.numbers.UNSET_INDEX, t = this.adapter.getListItemCount(), i = 0; i < t; i++) {
      var s = this.adapter.listItemAtIndexHasClass(i, _constants.cssClasses.LIST_ITEM_SELECTED_CLASS),
        n = this.adapter.listItemAtIndexHasClass(i, _constants.cssClasses.LIST_ITEM_ACTIVATED_CLASS);
      if (s || n) {
        e = i;
        break;
      }
    }
    return e;
  }, p.prototype.setHasTypeahead = function (e) {
    this.hasTypeahead = e, e && (this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex());
  }, p.prototype.isTypeaheadInProgress = function () {
    return this.hasTypeahead && (0, _typeahead.isTypingInProgress)(this.typeaheadState);
  }, p.prototype.setUseActivatedClass = function (e) {
    this.useActivatedClass = e;
  }, p.prototype.setUseSelectedAttribute = function (e) {
    this.useSelectedAttr = e;
  }, p.prototype.getSelectedIndex = function () {
    return this.selectedIndex;
  }, p.prototype.setSelectedIndex = function (e, t) {
    void 0 === t && (t = {}), this.isIndexValid(e) && (this.isCheckboxList ? this.setCheckboxAtIndex(e, t) : this.isRadioList ? this.setRadioAtIndex(e, t) : this.setSingleSelectionAtIndex(e, t));
  }, p.prototype.handleFocusIn = function (e) {
    e >= 0 && (this.focusedItemIndex = e, this.adapter.setAttributeForElementIndex(e, "tabindex", "0"), this.adapter.setTabIndexForListItemChildren(e, "0"));
  }, p.prototype.handleFocusOut = function (e) {
    var t = this;
    e >= 0 && (this.adapter.setAttributeForElementIndex(e, "tabindex", "-1"), this.adapter.setTabIndexForListItemChildren(e, "-1")), setTimeout(function () {
      t.adapter.isFocusInsideList() || t.setTabindexToFirstSelectedOrFocusedItem();
    }, 0);
  }, p.prototype.isIndexDisabled = function (e) {
    return this.adapter.listItemAtIndexHasClass(e, _constants.cssClasses.LIST_ITEM_DISABLED_CLASS);
  }, p.prototype.handleKeydown = function (e, t, i) {
    var s,
      n = this,
      d = "ArrowLeft" === (0, _keyboard.normalizeKey)(e),
      a = "ArrowUp" === (0, _keyboard.normalizeKey)(e),
      c = "ArrowRight" === (0, _keyboard.normalizeKey)(e),
      l = "ArrowDown" === (0, _keyboard.normalizeKey)(e),
      u = "Home" === (0, _keyboard.normalizeKey)(e),
      x = "End" === (0, _keyboard.normalizeKey)(e),
      f = "Enter" === (0, _keyboard.normalizeKey)(e),
      p = "Spacebar" === (0, _keyboard.normalizeKey)(e),
      m = this.isVertical && l || !this.isVertical && c,
      S = this.isVertical && a || !this.isVertical && d,
      b = "A" === e.key || "a" === e.key,
      E = A(e);
    if (this.adapter.isRootFocused()) {
      if ((S || x) && E([])) e.preventDefault(), this.focusLastElement();else if ((m || u) && E([])) e.preventDefault(), this.focusFirstElement();else if (S && E(["Shift"]) && this.isCheckboxList) {
        e.preventDefault(), -1 !== (g = this.focusLastElement()) && this.setSelectedIndexOnAction(g, !1);
      } else if (m && E(["Shift"]) && this.isCheckboxList) {
        e.preventDefault(), -1 !== (g = this.focusFirstElement()) && this.setSelectedIndexOnAction(g, !1);
      }
      if (this.hasTypeahead) {
        var C = {
          event: e,
          focusItemAtIndex: function (e) {
            n.focusItemAtIndex(e);
          },
          focusedItemIndex: -1,
          isTargetListItem: t,
          sortedIndexByFirstChar: this.sortedIndexByFirstChar,
          isItemAtIndexDisabled: function (e) {
            return n.isIndexDisabled(e);
          }
        };
        (0, _typeahead.handleKeydown)(C, this.typeaheadState);
      }
    } else {
      var y = this.adapter.getFocusedElementIndex();
      if (!(-1 === y && (y = i) < 0)) {
        if (m && E([])) (0, _events.preventDefaultEvent)(e), this.focusNextElement(y);else if (S && E([])) (0, _events.preventDefaultEvent)(e), this.focusPrevElement(y);else if (m && E(["Shift"]) && this.isCheckboxList) {
          (0, _events.preventDefaultEvent)(e), -1 !== (g = this.focusNextElement(y)) && this.setSelectedIndexOnAction(g, !1);
        } else if (S && E(["Shift"]) && this.isCheckboxList) {
          var g;
          (0, _events.preventDefaultEvent)(e), -1 !== (g = this.focusPrevElement(y)) && this.setSelectedIndexOnAction(g, !1);
        } else if (u && E([])) (0, _events.preventDefaultEvent)(e), this.focusFirstElement();else if (x && E([])) (0, _events.preventDefaultEvent)(e), this.focusLastElement();else if (u && E(["Control", "Shift"]) && this.isCheckboxList) {
          if ((0, _events.preventDefaultEvent)(e), this.isIndexDisabled(y)) return;
          this.focusFirstElement(), this.toggleCheckboxRange(0, y, y);
        } else if (x && E(["Control", "Shift"]) && this.isCheckboxList) {
          if ((0, _events.preventDefaultEvent)(e), this.isIndexDisabled(y)) return;
          this.focusLastElement(), this.toggleCheckboxRange(y, this.adapter.getListItemCount() - 1, y);
        } else if (b && E(["Control"]) && this.isCheckboxList) e.preventDefault(), this.checkboxListToggleAll(this.selectedIndex === _constants.numbers.UNSET_INDEX ? [] : this.selectedIndex, !0);else if ((f || p) && E([])) {
          if (t) {
            if ((L = e.target) && "A" === L.tagName && f) return;
            if ((0, _events.preventDefaultEvent)(e), this.isIndexDisabled(y)) return;
            this.isTypeaheadInProgress() || (this.isSelectableList() && this.setSelectedIndexOnAction(y, !1), this.adapter.notifyAction(y));
          }
        } else if ((f || p) && E(["Shift"]) && this.isCheckboxList) {
          var L;
          if ((L = e.target) && "A" === L.tagName && f) return;
          if ((0, _events.preventDefaultEvent)(e), this.isIndexDisabled(y)) return;
          this.isTypeaheadInProgress() || (this.toggleCheckboxRange(null !== (s = this.lastSelectedIndex) && void 0 !== s ? s : y, y, y), this.adapter.notifyAction(y));
        }
        if (this.hasTypeahead) {
          C = {
            event: e,
            focusItemAtIndex: function (e) {
              n.focusItemAtIndex(e);
            },
            focusedItemIndex: this.focusedItemIndex,
            isTargetListItem: t,
            sortedIndexByFirstChar: this.sortedIndexByFirstChar,
            isItemAtIndexDisabled: function (e) {
              return n.isIndexDisabled(e);
            }
          };
          (0, _typeahead.handleKeydown)(C, this.typeaheadState);
        }
      }
    }
  }, p.prototype.handleClick = function (e, t, i) {
    var s,
      n = A(i);
    e !== _constants.numbers.UNSET_INDEX && (this.isIndexDisabled(e) || (n([]) ? (this.isSelectableList() && this.setSelectedIndexOnAction(e, t), this.adapter.notifyAction(e)) : this.isCheckboxList && n(["Shift"]) && (this.toggleCheckboxRange(null !== (s = this.lastSelectedIndex) && void 0 !== s ? s : e, e, e), this.adapter.notifyAction(e))));
  }, p.prototype.focusNextElement = function (e) {
    var t = this.adapter.getListItemCount(),
      i = e,
      s = null;
    do {
      if (++i >= t) {
        if (!this.wrapFocus) return e;
        i = 0;
      }
      if (i === s) return -1;
      s = null != s ? s : i;
    } while (!this.areDisabledItemsFocusable && this.isIndexDisabled(i));
    return this.focusItemAtIndex(i), i;
  }, p.prototype.focusPrevElement = function (e) {
    var t = this.adapter.getListItemCount(),
      i = e,
      s = null;
    do {
      if (--i < 0) {
        if (!this.wrapFocus) return e;
        i = t - 1;
      }
      if (i === s) return -1;
      s = null != s ? s : i;
    } while (!this.areDisabledItemsFocusable && this.isIndexDisabled(i));
    return this.focusItemAtIndex(i), i;
  }, p.prototype.focusFirstElement = function () {
    return this.focusNextElement(-1);
  }, p.prototype.focusLastElement = function () {
    return this.focusPrevElement(this.adapter.getListItemCount());
  }, p.prototype.focusInitialElement = function () {
    var e = this.getFirstSelectedOrFocusedItemIndex();
    return this.focusItemAtIndex(e), e;
  }, p.prototype.setEnabled = function (e, t) {
    this.isIndexValid(e, !1) && (t ? (this.adapter.removeClassForElementIndex(e, _constants.cssClasses.LIST_ITEM_DISABLED_CLASS), this.adapter.setAttributeForElementIndex(e, _constants.strings.ARIA_DISABLED, "false")) : (this.adapter.addClassForElementIndex(e, _constants.cssClasses.LIST_ITEM_DISABLED_CLASS), this.adapter.setAttributeForElementIndex(e, _constants.strings.ARIA_DISABLED, "true")));
  }, p.prototype.setSingleSelectionAtIndex = function (e, t) {
    if (void 0 === t && (t = {}), this.selectedIndex !== e || t.forceUpdate) {
      var i = _constants.cssClasses.LIST_ITEM_SELECTED_CLASS;
      this.useActivatedClass && (i = _constants.cssClasses.LIST_ITEM_ACTIVATED_CLASS), this.selectedIndex !== _constants.numbers.UNSET_INDEX && this.adapter.removeClassForElementIndex(this.selectedIndex, i), this.setAriaForSingleSelectionAtIndex(e), this.setTabindexAtIndex(e), e !== _constants.numbers.UNSET_INDEX && this.adapter.addClassForElementIndex(e, i), this.selectedIndex = e, t.isUserInteraction && !t.forceUpdate && this.adapter.notifySelectionChange([e]);
    }
  }, p.prototype.setAriaForSingleSelectionAtIndex = function (e) {
    this.selectedIndex === _constants.numbers.UNSET_INDEX && (this.ariaCurrentAttrValue = this.adapter.getAttributeForElementIndex(e, _constants.strings.ARIA_CURRENT));
    var t = null !== this.ariaCurrentAttrValue,
      i = t ? _constants.strings.ARIA_CURRENT : _constants.strings.ARIA_SELECTED;
    if (this.selectedIndex !== _constants.numbers.UNSET_INDEX && this.adapter.setAttributeForElementIndex(this.selectedIndex, i, "false"), e !== _constants.numbers.UNSET_INDEX) {
      var s = t ? this.ariaCurrentAttrValue : "true";
      this.adapter.setAttributeForElementIndex(e, i, s);
    }
  }, p.prototype.getSelectionAttribute = function () {
    return this.useSelectedAttr ? _constants.strings.ARIA_SELECTED : _constants.strings.ARIA_CHECKED;
  }, p.prototype.setRadioAtIndex = function (e, t) {
    void 0 === t && (t = {});
    var i = this.getSelectionAttribute();
    this.adapter.setCheckedCheckboxOrRadioAtIndex(e, !0), (this.selectedIndex !== e || t.forceUpdate) && (this.selectedIndex !== _constants.numbers.UNSET_INDEX && this.adapter.setAttributeForElementIndex(this.selectedIndex, i, "false"), this.adapter.setAttributeForElementIndex(e, i, "true"), this.selectedIndex = e, t.isUserInteraction && !t.forceUpdate && this.adapter.notifySelectionChange([e]));
  }, p.prototype.setCheckboxAtIndex = function (e, t) {
    void 0 === t && (t = {});
    for (var i = this.selectedIndex, s = t.isUserInteraction ? new Set(i === _constants.numbers.UNSET_INDEX ? [] : i) : null, n = this.getSelectionAttribute(), r = [], d = 0; d < this.adapter.getListItemCount(); d++) {
      var a = null == s ? void 0 : s.has(d),
        h = e.indexOf(d) >= 0;
      h !== a && r.push(d), this.adapter.setCheckedCheckboxOrRadioAtIndex(d, h), this.adapter.setAttributeForElementIndex(d, n, h ? "true" : "false");
    }
    this.selectedIndex = e, t.isUserInteraction && r.length && this.adapter.notifySelectionChange(r);
  }, p.prototype.toggleCheckboxRange = function (e, t, n) {
    this.lastSelectedIndex = n;
    for (var r = new Set(this.selectedIndex === _constants.numbers.UNSET_INDEX ? [] : this.selectedIndex), d = !(null == r ? void 0 : r.has(n)), a = (0, _tslib.__read)([e, t].sort(), 2), h = a[0], c = a[1], l = this.getSelectionAttribute(), I = [], u = h; u <= c; u++) {
      if (!this.isIndexDisabled(u)) d !== r.has(u) && (I.push(u), this.adapter.setCheckedCheckboxOrRadioAtIndex(u, d), this.adapter.setAttributeForElementIndex(u, l, "" + d), d ? r.add(u) : r.delete(u));
    }
    I.length && (this.selectedIndex = (0, _tslib.__spreadArray)([], (0, _tslib.__read)(r)), this.adapter.notifySelectionChange(I));
  }, p.prototype.setTabindexAtIndex = function (e) {
    this.focusedItemIndex === _constants.numbers.UNSET_INDEX && 0 !== e ? this.adapter.setAttributeForElementIndex(0, "tabindex", "-1") : this.focusedItemIndex >= 0 && this.focusedItemIndex !== e && this.adapter.setAttributeForElementIndex(this.focusedItemIndex, "tabindex", "-1"), this.selectedIndex instanceof Array || this.selectedIndex === e || this.adapter.setAttributeForElementIndex(this.selectedIndex, "tabindex", "-1"), e !== _constants.numbers.UNSET_INDEX && this.adapter.setAttributeForElementIndex(e, "tabindex", "0");
  }, p.prototype.isSelectableList = function () {
    return this.isSingleSelectionList || this.isCheckboxList || this.isRadioList;
  }, p.prototype.setTabindexToFirstSelectedOrFocusedItem = function () {
    var e = this.getFirstSelectedOrFocusedItemIndex();
    this.setTabindexAtIndex(e);
  }, p.prototype.getFirstSelectedOrFocusedItemIndex = function () {
    return this.isSelectableList() ? "number" == typeof this.selectedIndex && this.selectedIndex !== _constants.numbers.UNSET_INDEX ? this.selectedIndex : this.selectedIndex instanceof Array && this.selectedIndex.length > 0 ? this.selectedIndex.reduce(function (e, t) {
      return Math.min(e, t);
    }) : 0 : Math.max(this.focusedItemIndex, 0);
  }, p.prototype.isIndexValid = function (e, t) {
    var i = this;
    if (void 0 === t && (t = !0), e instanceof Array) {
      if (!this.isCheckboxList && t) throw new Error("MDCListFoundation: Array of index is only supported for checkbox based list");
      return 0 === e.length || e.some(function (e) {
        return i.isIndexInRange(e);
      });
    }
    if ("number" == typeof e) {
      if (this.isCheckboxList && t) throw new Error("MDCListFoundation: Expected array of index for checkbox based list but got number: " + e);
      return this.isIndexInRange(e) || this.isSingleSelectionList && e === _constants.numbers.UNSET_INDEX;
    }
    return !1;
  }, p.prototype.isIndexInRange = function (e) {
    var t = this.adapter.getListItemCount();
    return e >= 0 && e < t;
  }, p.prototype.setSelectedIndexOnAction = function (e, t) {
    this.lastSelectedIndex = e, this.isCheckboxList ? (this.toggleCheckboxAtIndex(e, t), this.adapter.notifySelectionChange([e])) : this.setSelectedIndex(e, {
      isUserInteraction: !0
    });
  }, p.prototype.toggleCheckboxAtIndex = function (e, t) {
    var i,
      s = this.getSelectionAttribute(),
      n = this.adapter.isCheckboxCheckedAtIndex(e);
    t ? i = n : (i = !n, this.adapter.setCheckedCheckboxOrRadioAtIndex(e, i)), this.adapter.setAttributeForElementIndex(e, s, i ? "true" : "false");
    var r = this.selectedIndex === _constants.numbers.UNSET_INDEX ? [] : this.selectedIndex.slice();
    i ? r.push(e) : r = r.filter(function (t) {
      return t !== e;
    }), this.selectedIndex = r;
  }, p.prototype.focusItemAtIndex = function (e) {
    this.adapter.focusItemAtIndex(e), this.focusedItemIndex = e;
  }, p.prototype.checkboxListToggleAll = function (e, t) {
    var i = this.adapter.getListItemCount();
    if (e.length === i) this.setCheckboxAtIndex([], {
      isUserInteraction: t
    });else {
      for (var s = [], n = 0; n < i; n++) (!this.isIndexDisabled(n) || e.indexOf(n) > -1) && s.push(n);
      this.setCheckboxAtIndex(s, {
        isUserInteraction: t
      });
    }
  }, p.prototype.typeaheadMatchItem = function (e, t, i) {
    var s = this;
    void 0 === i && (i = !1);
    var n = {
      focusItemAtIndex: function (e) {
        s.focusItemAtIndex(e);
      },
      focusedItemIndex: t || this.focusedItemIndex,
      nextChar: e,
      sortedIndexByFirstChar: this.sortedIndexByFirstChar,
      skipFocus: i,
      isItemAtIndexDisabled: function (e) {
        return s.isIndexDisabled(e);
      }
    };
    return (0, _typeahead.matchItem)(n, this.typeaheadState);
  }, p.prototype.typeaheadInitSortedIndex = function () {
    return (0, _typeahead.initSortedIndex)(this.adapter.getListItemCount(), this.adapter.getPrimaryTextAtIndex);
  }, p.prototype.clearTypeaheadBuffer = function () {
    (0, _typeahead.clearBuffer)(this.typeaheadState);
  }, p;
}(_foundation.MDCFoundation);
},{"../../../_virtual/_tslib.js":"../node_modules/@cosmograph/ui/_virtual/_tslib.js","../base/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/base/foundation.js","../dom/keyboard.js":"../node_modules/@cosmograph/ui/ext/@material/dom/keyboard.js","./constants.js":"../node_modules/@cosmograph/ui/ext/@material/list/constants.js","./events.js":"../node_modules/@cosmograph/ui/ext/@material/list/events.js","./typeahead.js":"../node_modules/@cosmograph/ui/ext/@material/list/typeahead.js"}],"../node_modules/@cosmograph/ui/ext/@smui/list/dist/List.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("../../../svelte/internal/index.mjs.js");
var M = _interopRequireWildcard(require("../../../@material/dom/ponyfill.js"));
var _classMap = require("../../common/dist/internal/classMap.js");
var _dispatch = require("../../common/dist/internal/dispatch.js");
var _forwardEventsBuilder = require("../../common/dist/internal/forwardEventsBuilder.js");
var _SmuiElementSvelte = _interopRequireDefault(require("../../common/dist/SmuiElement.svelte.js"));
var _foundation = require("../../../@material/list/foundation.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function j(e) {
  let t;
  const n = e[42].default,
    i = (0, _indexMjs.create_slot)(n, e, e[44], null);
  return {
    c() {
      i && i.c();
    },
    m(e, n) {
      i && i.m(e, n), t = !0;
    },
    p(e, s) {
      i && i.p && (!t || 8192 & s[1]) && (0, _indexMjs.update_slot_base)(i, n, e, e[44], t ? (0, _indexMjs.get_slot_changes)(n, e[44], s, null) : (0, _indexMjs.get_all_dirty_from_scope)(e[44]), null);
    },
    i(e) {
      t || ((0, _indexMjs.transition_in)(i, e), t = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(i, e), t = !1;
    },
    d(e) {
      i && i.d(e);
    }
  };
}
function O(e) {
  let t, n, h;
  const $ = [{
    tag: e[13]
  }, {
    use: [e[16], ...e[0]]
  }, {
    class: (0, _classMap.classMap)({
      [e[1]]: !0,
      "mdc-deprecated-list": !0,
      "mdc-deprecated-list--non-interactive": e[2],
      "mdc-deprecated-list--dense": e[3],
      "mdc-deprecated-list--textual-list": e[4],
      "mdc-deprecated-list--avatar-list": e[5] || e[17],
      "mdc-deprecated-list--icon-list": e[6],
      "mdc-deprecated-list--image-list": e[7],
      "mdc-deprecated-list--thumbnail-list": e[8],
      "mdc-deprecated-list--video-list": e[9],
      "mdc-deprecated-list--two-line": e[10],
      "smui-list--three-line": e[11] && !e[10]
    })
  }, {
    role: e[15]
  }, e[25]];
  var x = e[12];
  function v(e) {
    let t = {
      $$slots: {
        default: [j]
      },
      $$scope: {
        ctx: e
      }
    };
    for (let e = 0; e < $.length; e += 1) t = (0, _indexMjs.assign)(t, $[e]);
    return {
      props: t
    };
  }
  return x && (t = (0, _indexMjs.construct_svelte_component)(x, v(e)), e[43](t), t.$on("keydown", e[20]), t.$on("focusin", e[21]), t.$on("focusout", e[22]), t.$on("click", e[23]), t.$on("SMUIListItem:mount", e[18]), t.$on("SMUIListItem:unmount", e[19]), t.$on("SMUI:action", e[24])), {
    c() {
      t && (0, _indexMjs.create_component)(t.$$.fragment), n = (0, _indexMjs.empty)();
    },
    m(e, i) {
      t && (0, _indexMjs.mount_component)(t, e, i), (0, _indexMjs.insert)(e, n, i), h = !0;
    },
    p(e, o) {
      const d = 33796095 & o[0] ? (0, _indexMjs.get_spread_update)($, [8192 & o[0] && {
        tag: e[13]
      }, 65537 & o[0] && {
        use: [e[16], ...e[0]]
      }, 135166 & o[0] && {
        class: (0, _classMap.classMap)({
          [e[1]]: !0,
          "mdc-deprecated-list": !0,
          "mdc-deprecated-list--non-interactive": e[2],
          "mdc-deprecated-list--dense": e[3],
          "mdc-deprecated-list--textual-list": e[4],
          "mdc-deprecated-list--avatar-list": e[5] || e[17],
          "mdc-deprecated-list--icon-list": e[6],
          "mdc-deprecated-list--image-list": e[7],
          "mdc-deprecated-list--thumbnail-list": e[8],
          "mdc-deprecated-list--video-list": e[9],
          "mdc-deprecated-list--two-line": e[10],
          "smui-list--three-line": e[11] && !e[10]
        })
      }, 32768 & o[0] && {
        role: e[15]
      }, 33554432 & o[0] && (0, _indexMjs.get_spread_object)(e[25])]) : {};
      if (8192 & o[1] && (d.$$scope = {
        dirty: o,
        ctx: e
      }), 4096 & o[0] && x !== (x = e[12])) {
        if (t) {
          (0, _indexMjs.group_outros)();
          const e = t;
          (0, _indexMjs.transition_out)(e.$$.fragment, 1, 0, () => {
            (0, _indexMjs.destroy_component)(e, 1);
          }), (0, _indexMjs.check_outros)();
        }
        x ? (t = (0, _indexMjs.construct_svelte_component)(x, v(e)), e[43](t), t.$on("keydown", e[20]), t.$on("focusin", e[21]), t.$on("focusout", e[22]), t.$on("click", e[23]), t.$on("SMUIListItem:mount", e[18]), t.$on("SMUIListItem:unmount", e[19]), t.$on("SMUI:action", e[24]), (0, _indexMjs.create_component)(t.$$.fragment), (0, _indexMjs.transition_in)(t.$$.fragment, 1), (0, _indexMjs.mount_component)(t, n.parentNode, n)) : t = null;
      } else x && t.$set(d);
    },
    i(e) {
      h || (t && (0, _indexMjs.transition_in)(t.$$.fragment, e), h = !0);
    },
    o(e) {
      t && (0, _indexMjs.transition_out)(t.$$.fragment, e), h = !1;
    },
    d(i) {
      e[43](null), i && (0, _indexMjs.detach)(n), t && (0, _indexMjs.destroy_component)(t, i);
    }
  };
}
function R(e, t, n) {
  const i = ["use", "class", "nonInteractive", "dense", "textualList", "avatarList", "iconList", "imageList", "thumbnailList", "videoList", "twoLine", "threeLine", "vertical", "wrapFocus", "singleSelection", "disabledItemsFocusable", "selectedIndex", "radioList", "checkList", "hasTypeahead", "component", "tag", "layout", "setEnabled", "getTypeaheadInProgress", "getSelectedIndex", "getFocusedItemIndex", "focusItemAtIndex", "getElement"];
  let s = (0, _indexMjs.compute_rest_props)(t, i),
    {
      $$slots: o = {},
      $$scope: a
    } = t;
  var d;
  const {
      closest: l,
      matches: c
    } = M,
    r = (0, _forwardEventsBuilder.forwardEventsBuilder)((0, _indexMjs.get_current_component)());
  let u,
    m,
    {
      use: p = []
    } = t,
    {
      class: I = ""
    } = t,
    {
      nonInteractive: g = !1
    } = t,
    {
      dense: F = !1
    } = t,
    {
      textualList: k = !1
    } = t,
    {
      avatarList: A = !1
    } = t,
    {
      iconList: E = !1
    } = t,
    {
      imageList: w = !1
    } = t,
    {
      thumbnailList: j = !1
    } = t,
    {
      videoList: O = !1
    } = t,
    {
      twoLine: R = !1
    } = t,
    {
      threeLine: _ = !1
    } = t,
    {
      vertical: q = !0
    } = t,
    {
      wrapFocus: H = null !== (d = (0, _indexMjs.getContext)("SMUI:list:wrapFocus")) && void 0 !== d && d
    } = t,
    {
      singleSelection: W = !1
    } = t,
    {
      disabledItemsFocusable: B = !1
    } = t,
    {
      selectedIndex: D = -1
    } = t,
    {
      radioList: K = !1
    } = t,
    {
      checkList: N = !1
    } = t,
    {
      hasTypeahead: V = !1
    } = t,
    z = [],
    G = (0, _indexMjs.getContext)("SMUI:list:role"),
    J = (0, _indexMjs.getContext)("SMUI:list:nav");
  const Q = new WeakMap();
  let X,
    Y = (0, _indexMjs.getContext)("SMUI:dialog:selection"),
    Z = (0, _indexMjs.getContext)("SMUI:addLayoutListener"),
    {
      component: ee = _SmuiElementSvelte.default
    } = t,
    {
      tag: te = ee === _SmuiElementSvelte.default ? J ? "nav" : "ul" : void 0
    } = t;
  function ne() {
    return null == u ? [] : [...Ie().children].map(e => Q.get(e)).filter(e => e && e._smui_list_item_accessor);
  }
  function ie(e, t) {
    var n;
    const i = ne()[e];
    return null !== (n = i && i.hasClass(t)) && void 0 !== n && n;
  }
  function se(e, t) {
    const n = ne()[e];
    n && n.addClass(t);
  }
  function oe(e, t) {
    const n = ne()[e];
    n && n.removeClass(t);
  }
  function ae(e, t, n) {
    const i = ne()[e];
    i && i.addAttr(t, n);
  }
  function de(e, t) {
    const n = ne()[e];
    n && n.removeAttr(t);
  }
  function le(e, t) {
    const n = ne()[e];
    return n ? n.getAttr(t) : null;
  }
  function ce(e) {
    var t;
    const n = ne()[e];
    return null !== (t = n && n.getPrimaryText()) && void 0 !== t ? t : "";
  }
  function re(e) {
    const t = l(e, ".mdc-deprecated-list-item, .mdc-deprecated-list");
    return t && c(t, ".mdc-deprecated-list-item") ? ne().map(e => null == e ? void 0 : e.element).indexOf(t) : -1;
  }
  function ue() {
    return m.layout();
  }
  function me() {
    return m.getSelectedIndex();
  }
  function pe(e) {
    const t = ne()[e];
    t && "focus" in t.element && t.element.focus();
  }
  function Ie() {
    return u.getElement();
  }
  return (0, _indexMjs.setContext)("SMUI:list:nonInteractive", g), (0, _indexMjs.setContext)("SMUI:separator:context", "list"), G || (W ? (G = "listbox", (0, _indexMjs.setContext)("SMUI:list:item:role", "option")) : K ? (G = "radiogroup", (0, _indexMjs.setContext)("SMUI:list:item:role", "radio")) : N ? (G = "group", (0, _indexMjs.setContext)("SMUI:list:item:role", "checkbox")) : (G = "list", (0, _indexMjs.setContext)("SMUI:list:item:role", void 0))), Z && (X = Z(ue)), (0, _indexMjs.onMount)(() => {
    n(41, m = new _foundation.MDCListFoundation({
      addClassForElementIndex: se,
      focusItemAtIndex: pe,
      getAttributeForElementIndex: (e, t) => {
        var n, i;
        return null !== (i = null === (n = ne()[e]) || void 0 === n ? void 0 : n.getAttr(t)) && void 0 !== i ? i : null;
      },
      getFocusedElementIndex: () => document.activeElement ? ne().map(e => e.element).indexOf(document.activeElement) : -1,
      getListItemCount: () => z.length,
      getPrimaryTextAtIndex: ce,
      hasCheckboxAtIndex: e => {
        var t, n;
        return null !== (n = null === (t = ne()[e]) || void 0 === t ? void 0 : t.hasCheckbox) && void 0 !== n && n;
      },
      hasRadioAtIndex: e => {
        var t, n;
        return null !== (n = null === (t = ne()[e]) || void 0 === t ? void 0 : t.hasRadio) && void 0 !== n && n;
      },
      isCheckboxCheckedAtIndex: e => {
        var t;
        const n = ne()[e];
        return null !== (t = (null == n ? void 0 : n.hasCheckbox) && n.checked) && void 0 !== t && t;
      },
      isFocusInsideList: () => null != u && Ie() !== document.activeElement && Ie().contains(document.activeElement),
      isRootFocused: () => null != u && document.activeElement === Ie(),
      listItemAtIndexHasClass: ie,
      notifyAction: e => {
        n(26, D = e), null != u && (0, _dispatch.dispatch)(Ie(), "SMUIList:action", {
          index: e
        }, void 0, !0);
      },
      notifySelectionChange: e => {
        null != u && (0, _dispatch.dispatch)(Ie(), "SMUIList:selectionChange", {
          changedIndices: e
        });
      },
      removeClassForElementIndex: oe,
      setAttributeForElementIndex: ae,
      setCheckedCheckboxOrRadioAtIndex: (e, t) => {
        ne()[e].checked = t;
      },
      setTabIndexForListItemChildren: (e, t) => {
        const n = ne()[e];
        Array.prototype.forEach.call(n.element.querySelectorAll("button:not(:disabled), a"), e => {
          e.setAttribute("tabindex", t);
        });
      }
    }));
    const e = {
      get element() {
        return Ie();
      },
      get items() {
        return z;
      },
      get typeaheadInProgress() {
        return m.isTypeaheadInProgress();
      },
      typeaheadMatchItem: (e, t) => m.typeaheadMatchItem(e, t, !0),
      getOrderedList: ne,
      focusItemAtIndex: pe,
      addClassForElementIndex: se,
      removeClassForElementIndex: oe,
      setAttributeForElementIndex: ae,
      removeAttributeForElementIndex: de,
      getAttributeFromElementIndex: le,
      getPrimaryTextAtIndex: ce
    };
    return (0, _dispatch.dispatch)(Ie(), "SMUIList:mount", e), m.init(), m.layout(), () => {
      m.destroy();
    };
  }), (0, _indexMjs.onDestroy)(() => {
    X && X();
  }), e.$$set = e => {
    t = (0, _indexMjs.assign)((0, _indexMjs.assign)({}, t), (0, _indexMjs.exclude_internal_props)(e)), n(25, s = (0, _indexMjs.compute_rest_props)(t, i)), "use" in e && n(0, p = e.use), "class" in e && n(1, I = e.class), "nonInteractive" in e && n(2, g = e.nonInteractive), "dense" in e && n(3, F = e.dense), "textualList" in e && n(4, k = e.textualList), "avatarList" in e && n(5, A = e.avatarList), "iconList" in e && n(6, E = e.iconList), "imageList" in e && n(7, w = e.imageList), "thumbnailList" in e && n(8, j = e.thumbnailList), "videoList" in e && n(9, O = e.videoList), "twoLine" in e && n(10, R = e.twoLine), "threeLine" in e && n(11, _ = e.threeLine), "vertical" in e && n(27, q = e.vertical), "wrapFocus" in e && n(28, H = e.wrapFocus), "singleSelection" in e && n(29, W = e.singleSelection), "disabledItemsFocusable" in e && n(30, B = e.disabledItemsFocusable), "selectedIndex" in e && n(26, D = e.selectedIndex), "radioList" in e && n(31, K = e.radioList), "checkList" in e && n(32, N = e.checkList), "hasTypeahead" in e && n(33, V = e.hasTypeahead), "component" in e && n(12, ee = e.component), "tag" in e && n(13, te = e.tag), "$$scope" in e && n(44, a = e.$$scope);
  }, e.$$.update = () => {
    134217728 & e.$$.dirty[0] | 1024 & e.$$.dirty[1] && m && m.setVerticalOrientation(q), 268435456 & e.$$.dirty[0] | 1024 & e.$$.dirty[1] && m && m.setWrapFocus(H), 1028 & e.$$.dirty[1] && m && m.setHasTypeahead(V), 536870912 & e.$$.dirty[0] | 1024 & e.$$.dirty[1] && m && m.setSingleSelection(W), 1073741824 & e.$$.dirty[0] | 1024 & e.$$.dirty[1] && m && m.setDisabledItemsFocusable(B), 603979776 & e.$$.dirty[0] | 1024 & e.$$.dirty[1] && m && W && me() !== D && m.setSelectedIndex(D);
  }, [p, I, g, F, k, A, E, w, j, O, R, _, ee, te, u, G, r, Y, function (e) {
    z.push(e.detail), Q.set(e.detail.element, e.detail), W && e.detail.selected && n(26, D = re(e.detail.element)), e.stopPropagation();
  }, function (e) {
    var t;
    const n = null !== (t = e.detail && z.indexOf(e.detail)) && void 0 !== t ? t : -1;
    -1 !== n && (z.splice(n, 1), Q.delete(e.detail.element)), e.stopPropagation();
  }, function (e) {
    m && e.target && m.handleKeydown(e, e.target.classList.contains("mdc-deprecated-list-item"), re(e.target));
  }, function (e) {
    m && e.target && m.handleFocusIn(re(e.target));
  }, function (e) {
    m && e.target && m.handleFocusOut(re(e.target));
  }, function (e) {
    m && e.target && m.handleClick(re(e.target), !c(e.target, 'input[type="checkbox"], input[type="radio"]'), e);
  }, function (e) {
    if (K || N) {
      const t = re(e.target);
      if (-1 !== t) {
        const n = ne()[t];
        n && (K && !n.checked || N) && (c(e.detail.target, 'input[type="checkbox"], input[type="radio"]') || (n.checked = !n.checked), n.activateRipple(), window.requestAnimationFrame(() => {
          n.deactivateRipple();
        }));
      }
    }
  }, s, D, q, H, W, B, K, N, V, ue, function (e, t) {
    return m.setEnabled(e, t);
  }, function () {
    return m.isTypeaheadInProgress();
  }, me, function () {
    return m.getFocusedItemIndex();
  }, pe, Ie, m, o, function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      u = e, n(14, u);
    });
  }, a];
}
class _ extends _indexMjs.SvelteComponent {
  constructor(e) {
    super(), (0, _indexMjs.init)(this, e, R, O, _indexMjs.safe_not_equal, {
      use: 0,
      class: 1,
      nonInteractive: 2,
      dense: 3,
      textualList: 4,
      avatarList: 5,
      iconList: 6,
      imageList: 7,
      thumbnailList: 8,
      videoList: 9,
      twoLine: 10,
      threeLine: 11,
      vertical: 27,
      wrapFocus: 28,
      singleSelection: 29,
      disabledItemsFocusable: 30,
      selectedIndex: 26,
      radioList: 31,
      checkList: 32,
      hasTypeahead: 33,
      component: 12,
      tag: 13,
      layout: 34,
      setEnabled: 35,
      getTypeaheadInProgress: 36,
      getSelectedIndex: 37,
      getFocusedItemIndex: 38,
      focusItemAtIndex: 39,
      getElement: 40
    }, null, [-1, -1]);
  }
  get layout() {
    return this.$$.ctx[34];
  }
  get setEnabled() {
    return this.$$.ctx[35];
  }
  get getTypeaheadInProgress() {
    return this.$$.ctx[36];
  }
  get getSelectedIndex() {
    return this.$$.ctx[37];
  }
  get getFocusedItemIndex() {
    return this.$$.ctx[38];
  }
  get focusItemAtIndex() {
    return this.$$.ctx[39];
  }
  get getElement() {
    return this.$$.ctx[40];
  }
}
exports.default = _;
},{"../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../../../@material/dom/ponyfill.js":"../node_modules/@cosmograph/ui/ext/@material/dom/ponyfill.js","../../common/dist/internal/classMap.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/classMap.js","../../common/dist/internal/dispatch.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/dispatch.js","../../common/dist/internal/forwardEventsBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js","../../common/dist/SmuiElement.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/SmuiElement.svelte.js","../../../@material/list/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/list/foundation.js"}],"../node_modules/@cosmograph/ui/ext/@material/dom/events.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyPassive = t;
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function t(t) {
  return void 0 === t && (t = window), !!function (t) {
    void 0 === t && (t = window);
    var e = !1;
    try {
      var n = {
          get passive() {
            return e = !0, !1;
          }
        },
        r = function () {};
      t.document.addEventListener("test", r, n), t.document.removeEventListener("test", r, n);
    } catch (t) {
      e = !1;
    }
    return e;
  }(t) && {
    passive: !0
  };
}
},{}],"../node_modules/@cosmograph/ui/ext/@material/ripple/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.strings = exports.numbers = exports.cssClasses = void 0;
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var d = exports.cssClasses = {
    BG_FOCUSED: "mdc-ripple-upgraded--background-focused",
    FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation",
    FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation",
    ROOT: "mdc-ripple-upgraded",
    UNBOUNDED: "mdc-ripple-upgraded--unbounded"
  },
  p = exports.strings = {
    VAR_FG_SCALE: "--mdc-ripple-fg-scale",
    VAR_FG_SIZE: "--mdc-ripple-fg-size",
    VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end",
    VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start",
    VAR_LEFT: "--mdc-ripple-left",
    VAR_TOP: "--mdc-ripple-top"
  },
  e = exports.numbers = {
    DEACTIVATION_TIMEOUT_MS: 225,
    FG_DEACTIVATION_MS: 150,
    INITIAL_ORIGIN_SCALE: .6,
    PADDING: 10,
    TAP_DELAY_MS: 300
  };
},{}],"../node_modules/@cosmograph/ui/ext/@material/ripple/util.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNormalizedEventCoords = t;
exports.supportsCssVariables = e;
var r;
function e(e, t) {
  void 0 === t && (t = !1);
  var s,
    o = e.CSS;
  if ("boolean" == typeof r && !t) return r;
  if (!(o && "function" == typeof o.supports)) return !1;
  var p = o.supports("--css-vars", "yes"),
    a = o.supports("(--css-vars: yes)") && o.supports("color", "#00000000");
  return s = p || a, t || (r = s), s;
}
function t(r, e, t) {
  if (!r) return {
    x: 0,
    y: 0
  };
  var s,
    o,
    p = e.x,
    a = e.y,
    u = p + t.left,
    n = a + t.top;
  if ("touchstart" === r.type) {
    var c = r;
    s = c.changedTouches[0].pageX - u, o = c.changedTouches[0].pageY - n;
  } else {
    var f = r;
    s = f.pageX - u, o = f.pageY - n;
  }
  return {
    x: s,
    y: o
  };
}
},{}],"../node_modules/@cosmograph/ui/ext/@material/ripple/foundation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MDCRippleFoundation = void 0;
var _tslib = require("../../../_virtual/_tslib.js");
var _foundation = require("../base/foundation.js");
var _constants = require("./constants.js");
var _util = require("./util.js");
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var d = ["touchstart", "pointerdown", "mousedown", "keydown"],
  c = ["touchend", "pointerup", "mouseup", "contextmenu"],
  u = [],
  l = exports.default = exports.MDCRippleFoundation = function (i) {
    function l(t) {
      var a = i.call(this, (0, _tslib.__assign)((0, _tslib.__assign)({}, l.defaultAdapter), t)) || this;
      return a.activationAnimationHasEnded = !1, a.activationTimer = 0, a.fgDeactivationRemovalTimer = 0, a.fgScale = "0", a.frame = {
        width: 0,
        height: 0
      }, a.initialSize = 0, a.layoutFrame = 0, a.maxRadius = 0, a.unboundedCoords = {
        left: 0,
        top: 0
      }, a.activationState = a.defaultActivationState(), a.activationTimerCallback = function () {
        a.activationAnimationHasEnded = !0, a.runDeactivationUXLogicIfReady();
      }, a.activateHandler = function (t) {
        a.activateImpl(t);
      }, a.deactivateHandler = function () {
        a.deactivateImpl();
      }, a.focusHandler = function () {
        a.handleFocus();
      }, a.blurHandler = function () {
        a.handleBlur();
      }, a.resizeHandler = function () {
        a.layout();
      }, a;
    }
    return (0, _tslib.__extends)(l, i), Object.defineProperty(l, "cssClasses", {
      get: function () {
        return _constants.cssClasses;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l, "strings", {
      get: function () {
        return _constants.strings;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l, "numbers", {
      get: function () {
        return _constants.numbers;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(l, "defaultAdapter", {
      get: function () {
        return {
          addClass: function () {},
          browserSupportsCssVars: function () {
            return !0;
          },
          computeBoundingRect: function () {
            return {
              top: 0,
              right: 0,
              bottom: 0,
              left: 0,
              width: 0,
              height: 0
            };
          },
          containsEventTarget: function () {
            return !0;
          },
          deregisterDocumentInteractionHandler: function () {},
          deregisterInteractionHandler: function () {},
          deregisterResizeHandler: function () {},
          getWindowPageOffset: function () {
            return {
              x: 0,
              y: 0
            };
          },
          isSurfaceActive: function () {
            return !0;
          },
          isSurfaceDisabled: function () {
            return !0;
          },
          isUnbounded: function () {
            return !0;
          },
          registerDocumentInteractionHandler: function () {},
          registerInteractionHandler: function () {},
          registerResizeHandler: function () {},
          removeClass: function () {},
          updateCssVariable: function () {}
        };
      },
      enumerable: !1,
      configurable: !0
    }), l.prototype.init = function () {
      var t = this,
        e = this.supportsPressRipple();
      if (this.registerRootHandlers(e), e) {
        var a = l.cssClasses,
          i = a.ROOT,
          r = a.UNBOUNDED;
        requestAnimationFrame(function () {
          t.adapter.addClass(i), t.adapter.isUnbounded() && (t.adapter.addClass(r), t.layoutInternal());
        });
      }
    }, l.prototype.destroy = function () {
      var t = this;
      if (this.supportsPressRipple()) {
        this.activationTimer && (clearTimeout(this.activationTimer), this.activationTimer = 0, this.adapter.removeClass(l.cssClasses.FG_ACTIVATION)), this.fgDeactivationRemovalTimer && (clearTimeout(this.fgDeactivationRemovalTimer), this.fgDeactivationRemovalTimer = 0, this.adapter.removeClass(l.cssClasses.FG_DEACTIVATION));
        var e = l.cssClasses,
          a = e.ROOT,
          i = e.UNBOUNDED;
        requestAnimationFrame(function () {
          t.adapter.removeClass(a), t.adapter.removeClass(i), t.removeCssVars();
        });
      }
      this.deregisterRootHandlers(), this.deregisterDeactivationHandlers();
    }, l.prototype.activate = function (t) {
      this.activateImpl(t);
    }, l.prototype.deactivate = function () {
      this.deactivateImpl();
    }, l.prototype.layout = function () {
      var t = this;
      this.layoutFrame && cancelAnimationFrame(this.layoutFrame), this.layoutFrame = requestAnimationFrame(function () {
        t.layoutInternal(), t.layoutFrame = 0;
      });
    }, l.prototype.setUnbounded = function (t) {
      var e = l.cssClasses.UNBOUNDED;
      t ? this.adapter.addClass(e) : this.adapter.removeClass(e);
    }, l.prototype.handleFocus = function () {
      var t = this;
      requestAnimationFrame(function () {
        return t.adapter.addClass(l.cssClasses.BG_FOCUSED);
      });
    }, l.prototype.handleBlur = function () {
      var t = this;
      requestAnimationFrame(function () {
        return t.adapter.removeClass(l.cssClasses.BG_FOCUSED);
      });
    }, l.prototype.supportsPressRipple = function () {
      return this.adapter.browserSupportsCssVars();
    }, l.prototype.defaultActivationState = function () {
      return {
        activationEvent: void 0,
        hasDeactivationUXRun: !1,
        isActivated: !1,
        isProgrammatic: !1,
        wasActivatedByPointer: !1,
        wasElementMadeActive: !1
      };
    }, l.prototype.registerRootHandlers = function (t) {
      var e, i;
      if (t) {
        try {
          for (var r = (0, _tslib.__values)(d), n = r.next(); !n.done; n = r.next()) {
            var s = n.value;
            this.adapter.registerInteractionHandler(s, this.activateHandler);
          }
        } catch (t) {
          e = {
            error: t
          };
        } finally {
          try {
            n && !n.done && (i = r.return) && i.call(r);
          } finally {
            if (e) throw e.error;
          }
        }
        this.adapter.isUnbounded() && this.adapter.registerResizeHandler(this.resizeHandler);
      }
      this.adapter.registerInteractionHandler("focus", this.focusHandler), this.adapter.registerInteractionHandler("blur", this.blurHandler);
    }, l.prototype.registerDeactivationHandlers = function (t) {
      var e, i;
      if ("keydown" === t.type) this.adapter.registerInteractionHandler("keyup", this.deactivateHandler);else try {
        for (var r = (0, _tslib.__values)(c), n = r.next(); !n.done; n = r.next()) {
          var s = n.value;
          this.adapter.registerDocumentInteractionHandler(s, this.deactivateHandler);
        }
      } catch (t) {
        e = {
          error: t
        };
      } finally {
        try {
          n && !n.done && (i = r.return) && i.call(r);
        } finally {
          if (e) throw e.error;
        }
      }
    }, l.prototype.deregisterRootHandlers = function () {
      var t, e;
      try {
        for (var i = (0, _tslib.__values)(d), r = i.next(); !r.done; r = i.next()) {
          var n = r.value;
          this.adapter.deregisterInteractionHandler(n, this.activateHandler);
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          r && !r.done && (e = i.return) && e.call(i);
        } finally {
          if (t) throw t.error;
        }
      }
      this.adapter.deregisterInteractionHandler("focus", this.focusHandler), this.adapter.deregisterInteractionHandler("blur", this.blurHandler), this.adapter.isUnbounded() && this.adapter.deregisterResizeHandler(this.resizeHandler);
    }, l.prototype.deregisterDeactivationHandlers = function () {
      var t, e;
      this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler);
      try {
        for (var i = (0, _tslib.__values)(c), r = i.next(); !r.done; r = i.next()) {
          var n = r.value;
          this.adapter.deregisterDocumentInteractionHandler(n, this.deactivateHandler);
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          r && !r.done && (e = i.return) && e.call(i);
        } finally {
          if (t) throw t.error;
        }
      }
    }, l.prototype.removeCssVars = function () {
      var t = this,
        e = l.strings;
      Object.keys(e).forEach(function (a) {
        0 === a.indexOf("VAR_") && t.adapter.updateCssVariable(e[a], null);
      });
    }, l.prototype.activateImpl = function (t) {
      var e = this;
      if (!this.adapter.isSurfaceDisabled()) {
        var a = this.activationState;
        if (!a.isActivated) {
          var i = this.previousActivationEvent;
          if (!(i && void 0 !== t && i.type !== t.type)) a.isActivated = !0, a.isProgrammatic = void 0 === t, a.activationEvent = t, a.wasActivatedByPointer = !a.isProgrammatic && void 0 !== t && ("mousedown" === t.type || "touchstart" === t.type || "pointerdown" === t.type), void 0 !== t && u.length > 0 && u.some(function (t) {
            return e.adapter.containsEventTarget(t);
          }) ? this.resetActivationState() : (void 0 !== t && (u.push(t.target), this.registerDeactivationHandlers(t)), a.wasElementMadeActive = this.checkElementMadeActive(t), a.wasElementMadeActive && this.animateActivation(), requestAnimationFrame(function () {
            u = [], a.wasElementMadeActive || void 0 === t || " " !== t.key && 32 !== t.keyCode || (a.wasElementMadeActive = e.checkElementMadeActive(t), a.wasElementMadeActive && e.animateActivation()), a.wasElementMadeActive || (e.activationState = e.defaultActivationState());
          }));
        }
      }
    }, l.prototype.checkElementMadeActive = function (t) {
      return void 0 === t || "keydown" !== t.type || this.adapter.isSurfaceActive();
    }, l.prototype.animateActivation = function () {
      var t = this,
        e = l.strings,
        a = e.VAR_FG_TRANSLATE_START,
        i = e.VAR_FG_TRANSLATE_END,
        r = l.cssClasses,
        n = r.FG_DEACTIVATION,
        s = r.FG_ACTIVATION,
        o = l.numbers.DEACTIVATION_TIMEOUT_MS;
      this.layoutInternal();
      var d = "",
        c = "";
      if (!this.adapter.isUnbounded()) {
        var u = this.getFgTranslationCoordinates(),
          h = u.startPoint,
          v = u.endPoint;
        d = h.x + "px, " + h.y + "px", c = v.x + "px, " + v.y + "px";
      }
      this.adapter.updateCssVariable(a, d), this.adapter.updateCssVariable(i, c), clearTimeout(this.activationTimer), clearTimeout(this.fgDeactivationRemovalTimer), this.rmBoundedActivationClasses(), this.adapter.removeClass(n), this.adapter.computeBoundingRect(), this.adapter.addClass(s), this.activationTimer = setTimeout(function () {
        t.activationTimerCallback();
      }, o);
    }, l.prototype.getFgTranslationCoordinates = function () {
      var t,
        e = this.activationState,
        a = e.activationEvent;
      return {
        startPoint: t = {
          x: (t = e.wasActivatedByPointer ? (0, _util.getNormalizedEventCoords)(a, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect()) : {
            x: this.frame.width / 2,
            y: this.frame.height / 2
          }).x - this.initialSize / 2,
          y: t.y - this.initialSize / 2
        },
        endPoint: {
          x: this.frame.width / 2 - this.initialSize / 2,
          y: this.frame.height / 2 - this.initialSize / 2
        }
      };
    }, l.prototype.runDeactivationUXLogicIfReady = function () {
      var t = this,
        e = l.cssClasses.FG_DEACTIVATION,
        a = this.activationState,
        i = a.hasDeactivationUXRun,
        r = a.isActivated;
      (i || !r) && this.activationAnimationHasEnded && (this.rmBoundedActivationClasses(), this.adapter.addClass(e), this.fgDeactivationRemovalTimer = setTimeout(function () {
        t.adapter.removeClass(e);
      }, _constants.numbers.FG_DEACTIVATION_MS));
    }, l.prototype.rmBoundedActivationClasses = function () {
      var t = l.cssClasses.FG_ACTIVATION;
      this.adapter.removeClass(t), this.activationAnimationHasEnded = !1, this.adapter.computeBoundingRect();
    }, l.prototype.resetActivationState = function () {
      var t = this;
      this.previousActivationEvent = this.activationState.activationEvent, this.activationState = this.defaultActivationState(), setTimeout(function () {
        return t.previousActivationEvent = void 0;
      }, l.numbers.TAP_DELAY_MS);
    }, l.prototype.deactivateImpl = function () {
      var t = this,
        a = this.activationState;
      if (a.isActivated) {
        var i = (0, _tslib.__assign)({}, a);
        a.isProgrammatic ? (requestAnimationFrame(function () {
          t.animateDeactivation(i);
        }), this.resetActivationState()) : (this.deregisterDeactivationHandlers(), requestAnimationFrame(function () {
          t.activationState.hasDeactivationUXRun = !0, t.animateDeactivation(i), t.resetActivationState();
        }));
      }
    }, l.prototype.animateDeactivation = function (t) {
      var e = t.wasActivatedByPointer,
        a = t.wasElementMadeActive;
      (e || a) && this.runDeactivationUXLogicIfReady();
    }, l.prototype.layoutInternal = function () {
      var t = this;
      this.frame = this.adapter.computeBoundingRect();
      var e = Math.max(this.frame.height, this.frame.width);
      this.maxRadius = this.adapter.isUnbounded() ? e : Math.sqrt(Math.pow(t.frame.width, 2) + Math.pow(t.frame.height, 2)) + l.numbers.PADDING;
      var a = Math.floor(e * l.numbers.INITIAL_ORIGIN_SCALE);
      this.adapter.isUnbounded() && a % 2 != 0 ? this.initialSize = a - 1 : this.initialSize = a, this.fgScale = "" + this.maxRadius / this.initialSize, this.updateLayoutCssVars();
    }, l.prototype.updateLayoutCssVars = function () {
      var t = l.strings,
        e = t.VAR_FG_SIZE,
        a = t.VAR_LEFT,
        i = t.VAR_TOP,
        r = t.VAR_FG_SCALE;
      this.adapter.updateCssVariable(e, this.initialSize + "px"), this.adapter.updateCssVariable(r, this.fgScale), this.adapter.isUnbounded() && (this.unboundedCoords = {
        left: Math.round(this.frame.width / 2 - this.initialSize / 2),
        top: Math.round(this.frame.height / 2 - this.initialSize / 2)
      }, this.adapter.updateCssVariable(a, this.unboundedCoords.left + "px"), this.adapter.updateCssVariable(i, this.unboundedCoords.top + "px"));
    }, l;
  }(_foundation.MDCFoundation);
},{"../../../_virtual/_tslib.js":"../node_modules/@cosmograph/ui/_virtual/_tslib.js","../base/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/base/foundation.js","./constants.js":"../node_modules/@cosmograph/ui/ext/@material/ripple/constants.js","./util.js":"../node_modules/@cosmograph/ui/ext/@material/ripple/util.js"}],"../node_modules/@cosmograph/ui/ext/@smui/ripple/dist/Ripple.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = d;
var e = _interopRequireWildcard(require("../../../@material/dom/events.js"));
var r = _interopRequireWildcard(require("../../../@material/dom/ponyfill.js"));
var _indexMjs = require("../../../svelte/internal/index.mjs.js");
var _foundation = require("../../../@material/ripple/foundation.js");
var _util = require("../../../@material/ripple/util.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const {
    applyPassive: a
  } = e,
  {
    matches: n
  } = r;
function d(e, {
  ripple: r = !0,
  surface: d = !1,
  unbounded: o = !1,
  disabled: l = !1,
  color: p,
  active: c,
  rippleElement: m,
  eventTarget: u,
  activeTarget: v,
  addClass: f = r => e.classList.add(r),
  removeClass: y = r => e.classList.remove(r),
  addStyle: g = (r, i) => e.style.setProperty(r, i),
  initPromise: b = Promise.resolve()
} = {}) {
  let w,
    E,
    L = (0, _indexMjs.getContext)("SMUI:addLayoutListener"),
    C = c,
    P = u,
    j = v;
  function S() {
    d ? (f("mdc-ripple-surface"), "primary" === p ? (f("smui-ripple-surface--primary"), y("smui-ripple-surface--secondary")) : "secondary" === p ? (y("smui-ripple-surface--primary"), f("smui-ripple-surface--secondary")) : (y("smui-ripple-surface--primary"), y("smui-ripple-surface--secondary"))) : (y("mdc-ripple-surface"), y("smui-ripple-surface--primary"), y("smui-ripple-surface--secondary")), w && C !== c && (C = c, c ? w.activate() : !1 === c && w.deactivate()), r && !w ? (w = new _foundation.MDCRippleFoundation({
      addClass: f,
      browserSupportsCssVars: () => (0, _util.supportsCssVariables)(window),
      computeBoundingRect: () => (m || e).getBoundingClientRect(),
      containsEventTarget: r => e.contains(r),
      deregisterDocumentInteractionHandler: (e, r) => document.documentElement.removeEventListener(e, r, a()),
      deregisterInteractionHandler: (r, i) => (u || e).removeEventListener(r, i, a()),
      deregisterResizeHandler: e => window.removeEventListener("resize", e),
      getWindowPageOffset: () => ({
        x: window.pageXOffset,
        y: window.pageYOffset
      }),
      isSurfaceActive: () => null == c ? n(v || e, ":active") : c,
      isSurfaceDisabled: () => !!l,
      isUnbounded: () => !!o,
      registerDocumentInteractionHandler: (e, r) => document.documentElement.addEventListener(e, r, a()),
      registerInteractionHandler: (r, i) => (u || e).addEventListener(r, i, a()),
      registerResizeHandler: e => window.addEventListener("resize", e),
      removeClass: y,
      updateCssVariable: g
    }), b.then(() => {
      w && (w.init(), w.setUnbounded(o));
    })) : w && !r && b.then(() => {
      w && (w.destroy(), w = void 0);
    }), !w || P === u && j === v || (P = u, j = v, w.destroy(), requestAnimationFrame(() => {
      w && (w.init(), w.setUnbounded(o));
    })), !r && o && f("mdc-ripple-upgraded--unbounded");
  }
  return S(), L && (E = L(function () {
    w && w.layout();
  })), {
    update(i) {
      ({
        ripple: r,
        surface: d,
        unbounded: o,
        disabled: l,
        color: p,
        active: c,
        rippleElement: m,
        eventTarget: u,
        activeTarget: v,
        addClass: f,
        removeClass: y,
        addStyle: g,
        initPromise: b
      } = Object.assign({
        ripple: !0,
        surface: !1,
        unbounded: !1,
        disabled: !1,
        color: void 0,
        active: void 0,
        rippleElement: void 0,
        eventTarget: void 0,
        activeTarget: void 0,
        addClass: r => e.classList.add(r),
        removeClass: r => e.classList.remove(r),
        addStyle: (r, i) => e.style.setProperty(r, i),
        initPromise: Promise.resolve()
      }, i)), S();
    },
    destroy() {
      w && (w.destroy(), w = void 0, y("mdc-ripple-surface"), y("smui-ripple-surface--primary"), y("smui-ripple-surface--secondary")), E && E();
    }
  };
}
},{"../../../@material/dom/events.js":"../node_modules/@cosmograph/ui/ext/@material/dom/events.js","../../../@material/dom/ponyfill.js":"../node_modules/@cosmograph/ui/ext/@material/dom/ponyfill.js","../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../../../@material/ripple/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/ripple/foundation.js","../../../@material/ripple/util.js":"../node_modules/@cosmograph/ui/ext/@material/ripple/util.js"}],"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Item.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("../../../svelte/internal/index.mjs.js");
var _classMap = require("../../common/dist/internal/classMap.js");
var _dispatch = require("../../common/dist/internal/dispatch.js");
var _forwardEventsBuilder = require("../../common/dist/internal/forwardEventsBuilder.js");
var _Ripple = _interopRequireDefault(require("../../ripple/dist/Ripple.js"));
var _SmuiElementSvelte = _interopRequireDefault(require("../../common/dist/SmuiElement.svelte.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function T(e) {
  let t;
  return {
    c() {
      t = (0, _indexMjs.element)("span"), (0, _indexMjs.attr)(t, "class", "mdc-deprecated-list-item__ripple");
    },
    m(e, i) {
      (0, _indexMjs.insert)(e, t, i);
    },
    d(e) {
      e && (0, _indexMjs.detach)(t);
    }
  };
}
function G(e) {
  let t,
    i,
    n = e[7] && T();
  const r = e[34].default,
    c = (0, _indexMjs.create_slot)(r, e, e[37], null);
  return {
    c() {
      n && n.c(), t = (0, _indexMjs.empty)(), c && c.c();
    },
    m(e, r) {
      n && n.m(e, r), (0, _indexMjs.insert)(e, t, r), c && c.m(e, r), i = !0;
    },
    p(e, s) {
      e[7] ? n || (n = T(), n.c(), n.m(t.parentNode, t)) : n && (n.d(1), n = null), c && c.p && (!i || 64 & s[1]) && (0, _indexMjs.update_slot_base)(c, r, e, e[37], i ? (0, _indexMjs.get_slot_changes)(r, e[37], s, null) : (0, _indexMjs.get_all_dirty_from_scope)(e[37]), null);
    },
    i(e) {
      i || ((0, _indexMjs.transition_in)(c, e), i = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(c, e), i = !1;
    },
    d(e) {
      n && n.d(e), e && (0, _indexMjs.detach)(t), c && c.d(e);
    }
  };
}
function P(e) {
  let t, i, $;
  const g = [{
    tag: e[14]
  }, {
    use: [...(e[6] ? [] : [[_Ripple.default, {
      ripple: !e[16],
      unbounded: !1,
      color: (e[1] || e[0]) && null == e[5] ? "primary" : e[5],
      disabled: e[10],
      addClass: e[24],
      removeClass: e[25],
      addStyle: e[26]
    }]]), e[22], ...e[2]]
  }, {
    class: (0, _classMap.classMap)({
      [e[3]]: !0,
      "mdc-deprecated-list-item": !e[8],
      "mdc-deprecated-list-item__wrapper": e[8],
      "mdc-deprecated-list-item--activated": e[1],
      "mdc-deprecated-list-item--selected": e[0],
      "mdc-deprecated-list-item--disabled": e[10],
      "mdc-menu-item--selected": !e[23] && "menuitem" === e[9] && e[0],
      "smui-menu-item--non-interactive": e[6],
      ...e[18]
    })
  }, {
    style: Object.entries(e[19]).map(N).concat([e[4]]).join(" ")
  }, e[23] && e[1] ? {
    "aria-current": "page"
  } : {}, !e[23] || e[8] ? {
    role: e[9]
  } : {}, e[23] || "option" !== e[9] ? {} : {
    "aria-selected": e[0] ? "true" : "false"
  }, e[23] || "radio" !== e[9] && "checkbox" !== e[9] ? {} : {
    "aria-checked": e[16] && e[16].checked ? "true" : "false"
  }, e[23] ? {} : {
    "aria-disabled": e[10] ? "true" : "false"
  }, {
    "data-menu-item-skip-restore-focus": e[11] || void 0
  }, {
    tabindex: e[21]
  }, {
    href: e[12]
  }, e[20], e[29]];
  var b = e[13];
  function x(e) {
    let t = {
      $$slots: {
        default: [G]
      },
      $$scope: {
        ctx: e
      }
    };
    for (let e = 0; e < g.length; e += 1) t = (0, _indexMjs.assign)(t, g[e]);
    return {
      props: t
    };
  }
  return b && (t = (0, _indexMjs.construct_svelte_component)(b, x(e)), e[35](t), t.$on("click", e[15]), t.$on("keydown", e[27]), t.$on("SMUIGenericInput:mount", e[28]), t.$on("SMUIGenericInput:unmount", e[36])), {
    c() {
      t && (0, _indexMjs.create_component)(t.$$.fragment), i = (0, _indexMjs.empty)();
    },
    m(e, n) {
      t && (0, _indexMjs.mount_component)(t, e, n), (0, _indexMjs.insert)(e, i, n), $ = !0;
    },
    p(e, s) {
      const a = 670916479 & s[0] ? (0, _indexMjs.get_spread_update)(g, [16384 & s[0] && {
        tag: e[14]
      }, 121701479 & s[0] && {
        use: [...(e[6] ? [] : [[_Ripple.default, {
          ripple: !e[16],
          unbounded: !1,
          color: (e[1] || e[0]) && null == e[5] ? "primary" : e[5],
          disabled: e[10],
          addClass: e[24],
          removeClass: e[25],
          addStyle: e[26]
        }]]), e[22], ...e[2]]
      }, 8652619 & s[0] && {
        class: (0, _classMap.classMap)({
          [e[3]]: !0,
          "mdc-deprecated-list-item": !e[8],
          "mdc-deprecated-list-item__wrapper": e[8],
          "mdc-deprecated-list-item--activated": e[1],
          "mdc-deprecated-list-item--selected": e[0],
          "mdc-deprecated-list-item--disabled": e[10],
          "mdc-menu-item--selected": !e[23] && "menuitem" === e[9] && e[0],
          "smui-menu-item--non-interactive": e[6],
          ...e[18]
        })
      }, 524304 & s[0] && {
        style: Object.entries(e[19]).map(N).concat([e[4]]).join(" ")
      }, 8388610 & s[0] && (0, _indexMjs.get_spread_object)(e[23] && e[1] ? {
        "aria-current": "page"
      } : {}), 8389376 & s[0] && (0, _indexMjs.get_spread_object)(!e[23] || e[8] ? {
        role: e[9]
      } : {}), 8389121 & s[0] && (0, _indexMjs.get_spread_object)(e[23] || "option" !== e[9] ? {} : {
        "aria-selected": e[0] ? "true" : "false"
      }), 8454656 & s[0] && (0, _indexMjs.get_spread_object)(e[23] || "radio" !== e[9] && "checkbox" !== e[9] ? {} : {
        "aria-checked": e[16] && e[16].checked ? "true" : "false"
      }), 8389632 & s[0] && (0, _indexMjs.get_spread_object)(e[23] ? {} : {
        "aria-disabled": e[10] ? "true" : "false"
      }), 2048 & s[0] && {
        "data-menu-item-skip-restore-focus": e[11] || void 0
      }, 2097152 & s[0] && {
        tabindex: e[21]
      }, 4096 & s[0] && {
        href: e[12]
      }, 1048576 & s[0] && (0, _indexMjs.get_spread_object)(e[20]), 536870912 & s[0] && (0, _indexMjs.get_spread_object)(e[29])]) : {};
      if (128 & s[0] | 64 & s[1] && (a.$$scope = {
        dirty: s,
        ctx: e
      }), 8192 & s[0] && b !== (b = e[13])) {
        if (t) {
          (0, _indexMjs.group_outros)();
          const e = t;
          (0, _indexMjs.transition_out)(e.$$.fragment, 1, 0, () => {
            (0, _indexMjs.destroy_component)(e, 1);
          }), (0, _indexMjs.check_outros)();
        }
        b ? (t = (0, _indexMjs.construct_svelte_component)(b, x(e)), e[35](t), t.$on("click", e[15]), t.$on("keydown", e[27]), t.$on("SMUIGenericInput:mount", e[28]), t.$on("SMUIGenericInput:unmount", e[36]), (0, _indexMjs.create_component)(t.$$.fragment), (0, _indexMjs.transition_in)(t.$$.fragment, 1), (0, _indexMjs.mount_component)(t, i.parentNode, i)) : t = null;
      } else b && t.$set(a);
    },
    i(e) {
      $ || (t && (0, _indexMjs.transition_in)(t.$$.fragment, e), $ = !0);
    },
    o(e) {
      t && (0, _indexMjs.transition_out)(t.$$.fragment, e), $ = !1;
    },
    d(n) {
      e[35](null), n && (0, _indexMjs.detach)(i), t && (0, _indexMjs.destroy_component)(t, n);
    }
  };
}
let q = 0;
const N = ([e, t]) => `${e}: ${t};`;
function O(e, t, i) {
  let n;
  const r = ["use", "class", "style", "color", "nonInteractive", "ripple", "wrapper", "activated", "role", "selected", "disabled", "skipRestoreFocus", "tabindex", "inputId", "href", "component", "tag", "action", "getPrimaryText", "getElement"];
  let s = (0, _indexMjs.compute_rest_props)(t, r),
    {
      $$slots: c = {},
      $$scope: a
    } = t;
  var o;
  const l = (0, _forwardEventsBuilder.forwardEventsBuilder)((0, _indexMjs.get_current_component)());
  let d = () => {};
  let {
      use: u = []
    } = t,
    {
      class: m = ""
    } = t,
    {
      style: p = ""
    } = t,
    {
      color: f
    } = t,
    {
      nonInteractive: v = null !== (o = (0, _indexMjs.getContext)("SMUI:list:nonInteractive")) && void 0 !== o && o
    } = t;
  (0, _indexMjs.setContext)("SMUI:list:nonInteractive", void 0);
  let {
      ripple: S = !v
    } = t,
    {
      wrapper: M = !1
    } = t,
    {
      activated: U = !1
    } = t,
    {
      role: w = M ? "presentation" : (0, _indexMjs.getContext)("SMUI:list:item:role")
    } = t;
  (0, _indexMjs.setContext)("SMUI:list:item:role", void 0);
  let j,
    C,
    R,
    {
      selected: A = !1
    } = t,
    {
      disabled: T = !1
    } = t,
    {
      skipRestoreFocus: G = !1
    } = t,
    {
      tabindex: P = d
    } = t,
    {
      inputId: N = "SMUI-form-field-list-" + q++
    } = t,
    {
      href: O
    } = t,
    B = {},
    V = {},
    z = {},
    D = (0, _indexMjs.getContext)("SMUI:list:item:nav"),
    {
      component: H = _SmuiElementSvelte.default
    } = t,
    {
      tag: J = H === _SmuiElementSvelte.default ? D ? O ? "a" : "span" : "li" : void 0
    } = t;
  function K(e) {
    return e in B ? B[e] : ie().classList.contains(e);
  }
  function Q(e) {
    B[e] || i(18, B[e] = !0, B);
  }
  function W(e) {
    e in B && !B[e] || i(18, B[e] = !1, B);
  }
  function X(e) {
    var t;
    return e in z ? null !== (t = z[e]) && void 0 !== t ? t : null : ie().getAttribute(e);
  }
  function Y(e, t) {
    z[e] !== t && i(20, z[e] = t, z);
  }
  function Z(e) {
    e in z && null == z[e] || i(20, z[e] = void 0, z);
  }
  function ee(e) {
    T || (0, _dispatch.dispatch)(ie(), "SMUI:action", e);
  }
  function te() {
    var e, t, i;
    const n = ie(),
      r = n.querySelector(".mdc-deprecated-list-item__primary-text");
    if (r) return null !== (e = r.textContent) && void 0 !== e ? e : "";
    const s = n.querySelector(".mdc-deprecated-list-item__text");
    return s ? null !== (t = s.textContent) && void 0 !== t ? t : "" : null !== (i = n.textContent) && void 0 !== i ? i : "";
  }
  function ie() {
    return j.getElement();
  }
  (0, _indexMjs.setContext)("SMUI:generic:input:props", {
    id: N
  }), (0, _indexMjs.setContext)("SMUI:separator:context", void 0), (0, _indexMjs.onMount)(() => {
    if (!A && !v) {
      let e = !0,
        t = j.getElement();
      for (; t.previousSibling;) if (t = t.previousSibling, 1 === t.nodeType && t.classList.contains("mdc-deprecated-list-item") && !t.classList.contains("mdc-deprecated-list-item--disabled")) {
        e = !1;
        break;
      }
      e && (R = window.requestAnimationFrame(() => function (e) {
        let t = !0;
        for (; e.nextElementSibling;) if (1 === (e = e.nextElementSibling).nodeType && e.classList.contains("mdc-deprecated-list-item")) {
          const i = e.attributes.getNamedItem("tabindex");
          if (i && "0" === i.value) {
            t = !1;
            break;
          }
        }
        t && i(21, n = 0);
      }(t)));
    }
    const e = {
      _smui_list_item_accessor: !0,
      get element() {
        return ie();
      },
      get selected() {
        return A;
      },
      set selected(e) {
        i(0, A = e);
      },
      hasClass: K,
      addClass: Q,
      removeClass: W,
      getAttr: X,
      addAttr: Y,
      removeAttr: Z,
      getPrimaryText: te,
      get checked() {
        var e;
        return null !== (e = C && C.checked) && void 0 !== e && e;
      },
      set checked(e) {
        C && i(16, C.checked = !!e, C);
      },
      get hasCheckbox() {
        return !(!C || !("_smui_checkbox_accessor" in C));
      },
      get hasRadio() {
        return !(!C || !("_smui_radio_accessor" in C));
      },
      activateRipple() {
        C && C.activateRipple();
      },
      deactivateRipple() {
        C && C.deactivateRipple();
      },
      getValue: () => s.value,
      action: ee,
      get tabindex() {
        return n;
      },
      set tabindex(e) {
        i(30, P = e);
      },
      get disabled() {
        return T;
      },
      get activated() {
        return U;
      },
      set activated(e) {
        i(1, U = e);
      }
    };
    return (0, _dispatch.dispatch)(ie(), "SMUIListItem:mount", e), () => {
      (0, _dispatch.dispatch)(ie(), "SMUIListItem:unmount", e);
    };
  }), (0, _indexMjs.onDestroy)(() => {
    R && window.cancelAnimationFrame(R);
  });
  return e.$$set = e => {
    t = (0, _indexMjs.assign)((0, _indexMjs.assign)({}, t), (0, _indexMjs.exclude_internal_props)(e)), i(29, s = (0, _indexMjs.compute_rest_props)(t, r)), "use" in e && i(2, u = e.use), "class" in e && i(3, m = e.class), "style" in e && i(4, p = e.style), "color" in e && i(5, f = e.color), "nonInteractive" in e && i(6, v = e.nonInteractive), "ripple" in e && i(7, S = e.ripple), "wrapper" in e && i(8, M = e.wrapper), "activated" in e && i(1, U = e.activated), "role" in e && i(9, w = e.role), "selected" in e && i(0, A = e.selected), "disabled" in e && i(10, T = e.disabled), "skipRestoreFocus" in e && i(11, G = e.skipRestoreFocus), "tabindex" in e && i(30, P = e.tabindex), "inputId" in e && i(31, N = e.inputId), "href" in e && i(12, O = e.href), "component" in e && i(13, H = e.component), "tag" in e && i(14, J = e.tag), "$$scope" in e && i(37, a = e.$$scope);
  }, e.$$.update = () => {
    1073808449 & e.$$.dirty[0] && i(21, n = P === d ? v || T || !(A || C && C.checked) ? -1 : 0 : P);
  }, [A, U, u, m, p, f, v, S, M, w, T, G, O, H, J, ee, C, j, B, V, z, n, l, D, Q, W, function (e, t) {
    V[e] != t && ("" === t || null == t ? (delete V[e], i(19, V)) : i(19, V[e] = t, V));
  }, function (e) {
    const t = "Enter" === e.key,
      i = "Space" === e.key;
    (t || i) && ee(e);
  }, function (e) {
    ("_smui_checkbox_accessor" in e.detail || "_smui_radio_accessor" in e.detail) && i(16, C = e.detail);
  }, s, P, N, te, ie, c, function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      j = e, i(17, j);
    });
  }, () => i(16, C = void 0), a];
}
class B extends _indexMjs.SvelteComponent {
  constructor(e) {
    super(), (0, _indexMjs.init)(this, e, O, P, _indexMjs.safe_not_equal, {
      use: 2,
      class: 3,
      style: 4,
      color: 5,
      nonInteractive: 6,
      ripple: 7,
      wrapper: 8,
      activated: 1,
      role: 9,
      selected: 0,
      disabled: 10,
      skipRestoreFocus: 11,
      tabindex: 30,
      inputId: 31,
      href: 12,
      component: 13,
      tag: 14,
      action: 15,
      getPrimaryText: 32,
      getElement: 33
    }, null, [-1, -1]);
  }
  get action() {
    return this.$$.ctx[15];
  }
  get getPrimaryText() {
    return this.$$.ctx[32];
  }
  get getElement() {
    return this.$$.ctx[33];
  }
}
exports.default = B;
},{"../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../../common/dist/internal/classMap.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/classMap.js","../../common/dist/internal/dispatch.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/dispatch.js","../../common/dist/internal/forwardEventsBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js","../../ripple/dist/Ripple.js":"../node_modules/@cosmograph/ui/ext/@smui/ripple/dist/Ripple.js","../../common/dist/SmuiElement.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/SmuiElement.svelte.js"}],"../node_modules/@cosmograph/ui/ext/@smui/common/dist/classadder/ClassAdder.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.internals = exports.default = void 0;
var _indexMjs = require("../../../../svelte/internal/index.mjs.js");
var _classMap = require("../internal/classMap.js");
var _forwardEventsBuilder = require("../internal/forwardEventsBuilder.js");
var _SmuiElementSvelte = _interopRequireDefault(require("../SmuiElement.svelte.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function k(t) {
  let e;
  const s = t[11].default,
    n = (0, _indexMjs.create_slot)(s, t, t[13], null);
  return {
    c() {
      n && n.c();
    },
    m(t, s) {
      n && n.m(t, s), e = !0;
    },
    p(t, o) {
      n && n.p && (!e || 8192 & o) && (0, _indexMjs.update_slot_base)(n, s, t, t[13], e ? (0, _indexMjs.get_slot_changes)(s, t[13], o, null) : (0, _indexMjs.get_all_dirty_from_scope)(t[13]), null);
    },
    i(t) {
      e || ((0, _indexMjs.transition_in)(n, t), e = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(n, t), e = !1;
    },
    d(t) {
      n && n.d(t);
    }
  };
}
function q(t) {
  let e, s, g;
  const d = [{
    tag: t[3]
  }, {
    use: [t[8], ...t[0]]
  }, {
    class: (0, _classMap.classMap)({
      [t[1]]: !0,
      [t[6]]: !0,
      ...t[5]
    })
  }, t[7], t[9]];
  var h = t[2];
  function x(t) {
    let e = {
      $$slots: {
        default: [k]
      },
      $$scope: {
        ctx: t
      }
    };
    for (let t = 0; t < d.length; t += 1) e = (0, _indexMjs.assign)(e, d[t]);
    return {
      props: e
    };
  }
  return h && (e = (0, _indexMjs.construct_svelte_component)(h, x(t)), t[12](e)), {
    c() {
      e && (0, _indexMjs.create_component)(e.$$.fragment), s = (0, _indexMjs.empty)();
    },
    m(t, n) {
      e && (0, _indexMjs.mount_component)(e, t, n), (0, _indexMjs.insert)(t, s, n), g = !0;
    },
    p(t, [c]) {
      const l = 1003 & c ? (0, _indexMjs.get_spread_update)(d, [8 & c && {
        tag: t[3]
      }, 257 & c && {
        use: [t[8], ...t[0]]
      }, 98 & c && {
        class: (0, _classMap.classMap)({
          [t[1]]: !0,
          [t[6]]: !0,
          ...t[5]
        })
      }, 128 & c && (0, _indexMjs.get_spread_object)(t[7]), 512 & c && (0, _indexMjs.get_spread_object)(t[9])]) : {};
      if (8192 & c && (l.$$scope = {
        dirty: c,
        ctx: t
      }), 4 & c && h !== (h = t[2])) {
        if (e) {
          (0, _indexMjs.group_outros)();
          const t = e;
          (0, _indexMjs.transition_out)(t.$$.fragment, 1, 0, () => {
            (0, _indexMjs.destroy_component)(t, 1);
          }), (0, _indexMjs.check_outros)();
        }
        h ? (e = (0, _indexMjs.construct_svelte_component)(h, x(t)), t[12](e), (0, _indexMjs.create_component)(e.$$.fragment), (0, _indexMjs.transition_in)(e.$$.fragment, 1), (0, _indexMjs.mount_component)(e, s.parentNode, s)) : e = null;
      } else h && e.$set(l);
    },
    i(t) {
      g || (e && (0, _indexMjs.transition_in)(e.$$.fragment, t), g = !0);
    },
    o(t) {
      e && (0, _indexMjs.transition_out)(e.$$.fragment, t), g = !1;
    },
    d(n) {
      t[12](null), n && (0, _indexMjs.detach)(s), e && (0, _indexMjs.destroy_component)(e, n);
    }
  };
}
const z = exports.internals = {
  component: _SmuiElementSvelte.default,
  tag: "div",
  class: "",
  classMap: {},
  contexts: {},
  props: {}
};
function A(t, e, s) {
  const n = ["use", "class", "component", "tag", "getElement"];
  let o,
    c = (0, _indexMjs.compute_rest_props)(e, n),
    {
      $$slots: r = {},
      $$scope: l
    } = e,
    {
      use: a = []
    } = e,
    {
      class: i = ""
    } = e;
  const u = z.class,
    p = {},
    m = [],
    $ = z.contexts,
    f = z.props;
  let {
      component: b = z.component
    } = e,
    {
      tag: w = b === _SmuiElementSvelte.default ? z.tag : void 0
    } = e;
  Object.entries(z.classMap).forEach(([t, e]) => {
    const n = (0, _indexMjs.getContext)(e);
    n && "subscribe" in n && m.push(n.subscribe(e => {
      s(5, p[t] = e, p);
    }));
  });
  const y = (0, _forwardEventsBuilder.forwardEventsBuilder)((0, _indexMjs.get_current_component)());
  for (let t in $) $.hasOwnProperty(t) && (0, _indexMjs.setContext)(t, $[t]);
  return (0, _indexMjs.onDestroy)(() => {
    for (const t of m) t();
  }), t.$$set = t => {
    e = (0, _indexMjs.assign)((0, _indexMjs.assign)({}, e), (0, _indexMjs.exclude_internal_props)(t)), s(9, c = (0, _indexMjs.compute_rest_props)(e, n)), "use" in t && s(0, a = t.use), "class" in t && s(1, i = t.class), "component" in t && s(2, b = t.component), "tag" in t && s(3, w = t.tag), "$$scope" in t && s(13, l = t.$$scope);
  }, [a, i, b, w, o, p, u, f, y, c, function () {
    return o.getElement();
  }, r, function (t) {
    _indexMjs.binding_callbacks[t ? "unshift" : "push"](() => {
      o = t, s(4, o);
    });
  }, l];
}
class C extends _indexMjs.SvelteComponent {
  constructor(t) {
    super(), (0, _indexMjs.init)(this, t, A, q, _indexMjs.safe_not_equal, {
      use: 0,
      class: 1,
      component: 2,
      tag: 3,
      getElement: 10
    });
  }
  get getElement() {
    return this.$$.ctx[10];
  }
}
exports.default = C;
},{"../../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../internal/classMap.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/classMap.js","../internal/forwardEventsBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js","../SmuiElement.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/SmuiElement.svelte.js"}],"../node_modules/@cosmograph/ui/ext/@smui/common/dist/classadder/classAdderBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.classAdderBuilder = r;
var _ClassAdderSvelte = _interopRequireWildcard(require("./ClassAdder.svelte.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const e = Object.assign({}, _ClassAdderSvelte.internals);
function r(r) {
  return new Proxy(_ClassAdderSvelte.default, {
    construct: function (n, s) {
      return Object.assign(_ClassAdderSvelte.internals, e, r), new n(...s);
    },
    get: function (n, s) {
      return Object.assign(_ClassAdderSvelte.internals, e, r), n[s];
    }
  });
}
},{"./ClassAdder.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/classadder/ClassAdder.svelte.js"}],"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Text.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _classAdderBuilder = require("../../common/dist/classadder/classAdderBuilder.js");
var a = exports.default = (0, _classAdderBuilder.classAdderBuilder)({
  class: "mdc-deprecated-list-item__text",
  tag: "span"
});
},{"../../common/dist/classadder/classAdderBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/classadder/classAdderBuilder.js"}],"../node_modules/@cosmograph/ui/ext/@smui/list/dist/PrimaryText.js":[function(require,module,exports) {
"use strict";

var _classAdderBuilder = require("../../common/dist/classadder/classAdderBuilder.js");
(0, _classAdderBuilder.classAdderBuilder)({
  class: "mdc-deprecated-list-item__primary-text",
  tag: "span"
});
},{"../../common/dist/classadder/classAdderBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/classadder/classAdderBuilder.js"}],"../node_modules/@cosmograph/ui/ext/@smui/list/dist/SecondaryText.js":[function(require,module,exports) {
"use strict";

var _classAdderBuilder = require("../../common/dist/classadder/classAdderBuilder.js");
(0, _classAdderBuilder.classAdderBuilder)({
  class: "mdc-deprecated-list-item__secondary-text",
  tag: "span"
});
},{"../../common/dist/classadder/classAdderBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/classadder/classAdderBuilder.js"}],"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Meta.js":[function(require,module,exports) {
"use strict";

var _classAdderBuilder = require("../../common/dist/classadder/classAdderBuilder.js");
(0, _classAdderBuilder.classAdderBuilder)({
  class: "mdc-deprecated-list-item__meta",
  tag: "span"
});
},{"../../common/dist/classadder/classAdderBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/classadder/classAdderBuilder.js"}],"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Group.js":[function(require,module,exports) {
"use strict";

var _classAdderBuilder = require("../../common/dist/classadder/classAdderBuilder.js");
(0, _classAdderBuilder.classAdderBuilder)({
  class: "mdc-deprecated-list-group",
  tag: "div"
});
},{"../../common/dist/classadder/classAdderBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/classadder/classAdderBuilder.js"}],"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Subheader.js":[function(require,module,exports) {
"use strict";

var _classAdderBuilder = require("../../common/dist/classadder/classAdderBuilder.js");
(0, _classAdderBuilder.classAdderBuilder)({
  class: "mdc-deprecated-list-group__subheader",
  tag: "h3"
});
},{"../../common/dist/classadder/classAdderBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/classadder/classAdderBuilder.js"}],"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/exclude.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exclude = e;
function e(e, t) {
  let n = Object.getOwnPropertyNames(e);
  const r = {};
  for (let o = 0; o < n.length; o++) {
    const f = n[o],
      i = f.indexOf("$");
    -1 !== i && -1 !== t.indexOf(f.substring(0, i + 1)) || -1 === t.indexOf(f) && (r[f] = e[f]);
  }
  return r;
}
},{}],"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/prefixFilter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prefixFilter = t;
function t(t, e) {
  let n = Object.getOwnPropertyNames(t);
  const r = {};
  for (let s = 0; s < n.length; s++) {
    const g = n[s];
    g.substring(0, e.length) === e && (r[g.substring(e.length)] = t[g]);
  }
  return r;
}
},{}],"../node_modules/@cosmograph/ui/ext/svelte/store/index.mjs.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writable = o;
var _indexMjs = require("../internal/index.mjs.js");
const e = [];
function o(o, s = _indexMjs.noop) {
  let i;
  const r = new Set();
  function c(n) {
    if ((0, _indexMjs.safe_not_equal)(o, n) && (o = n, i)) {
      const n = !e.length;
      for (const n of r) n[1](), e.push(n, o);
      if (n) {
        for (let n = 0; n < e.length; n += 2) e[n][0](e[n + 1]);
        e.length = 0;
      }
    }
  }
  return {
    set: c,
    update: function (n) {
      c(n(o));
    },
    subscribe: function (t, e = _indexMjs.noop) {
      const f = [t, e];
      return r.add(f), 1 === r.size && (i = s(c) || _indexMjs.noop), t(o), () => {
        r.delete(f), 0 === r.size && i && (i(), i = null);
      };
    }
  };
}
},{"../internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js"}],"../node_modules/@cosmograph/ui/ext/@smui/common/dist/ContextFragment.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("../../../svelte/internal/index.mjs.js");
var _indexMjs2 = require("../../../svelte/store/index.mjs.js");
function m(e) {
  let t;
  const s = e[4].default,
    $ = (0, _indexMjs.create_slot)(s, e, e[3], null);
  return {
    c() {
      $ && $.c();
    },
    m(e, s) {
      $ && $.m(e, s), t = !0;
    },
    p(e, [n]) {
      $ && $.p && (!t || 8 & n) && (0, _indexMjs.update_slot_base)($, s, e, e[3], t ? (0, _indexMjs.get_slot_changes)(s, e[3], n, null) : (0, _indexMjs.get_all_dirty_from_scope)(e[3]), null);
    },
    i(e) {
      t || ((0, _indexMjs.transition_in)($, e), t = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)($, e), t = !1;
    },
    d(e) {
      $ && $.d(e);
    }
  };
}
function v(e, t, s) {
  let n,
    {
      $$slots: l = {},
      $$scope: o
    } = t,
    {
      key: u
    } = t,
    {
      value: r
    } = t;
  const i = (0, _indexMjs2.writable)(r);
  return (0, _indexMjs.component_subscribe)(e, i, e => s(5, n = e)), (0, _indexMjs.setContext)(u, i), (0, _indexMjs.onDestroy)(() => {
    i.set(void 0);
  }), e.$$set = e => {
    "key" in e && s(1, u = e.key), "value" in e && s(2, r = e.value), "$$scope" in e && s(3, o = e.$$scope);
  }, e.$$.update = () => {
    4 & e.$$.dirty && (0, _indexMjs.set_store_value)(i, n = r, n);
  }, [i, u, r, o, l];
}
class f extends _indexMjs.SvelteComponent {
  constructor(e) {
    super(), (0, _indexMjs.init)(this, e, v, m, _indexMjs.safe_not_equal, {
      key: 1,
      value: 2
    });
  }
}
exports.default = f;
},{"../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../../../svelte/store/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/store/index.mjs.js"}],"../node_modules/@cosmograph/ui/ext/@material/floating-label/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cssClasses = void 0;
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var l = exports.cssClasses = {
  LABEL_FLOAT_ABOVE: "mdc-floating-label--float-above",
  LABEL_REQUIRED: "mdc-floating-label--required",
  LABEL_SHAKE: "mdc-floating-label--shake",
  ROOT: "mdc-floating-label"
};
},{}],"../node_modules/@cosmograph/ui/ext/@material/floating-label/foundation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MDCFloatingLabelFoundation = void 0;
var _tslib = require("../../../_virtual/_tslib.js");
var _foundation = require("../base/foundation.js");
var _constants = require("./constants.js");
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var r = exports.default = exports.MDCFloatingLabelFoundation = function (a) {
  function r(t) {
    var n = a.call(this, (0, _tslib.__assign)((0, _tslib.__assign)({}, r.defaultAdapter), t)) || this;
    return n.shakeAnimationEndHandler = function () {
      n.handleShakeAnimationEnd();
    }, n;
  }
  return (0, _tslib.__extends)(r, a), Object.defineProperty(r, "cssClasses", {
    get: function () {
      return _constants.cssClasses;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(r, "defaultAdapter", {
    get: function () {
      return {
        addClass: function () {},
        removeClass: function () {},
        getWidth: function () {
          return 0;
        },
        registerInteractionHandler: function () {},
        deregisterInteractionHandler: function () {}
      };
    },
    enumerable: !1,
    configurable: !0
  }), r.prototype.init = function () {
    this.adapter.registerInteractionHandler("animationend", this.shakeAnimationEndHandler);
  }, r.prototype.destroy = function () {
    this.adapter.deregisterInteractionHandler("animationend", this.shakeAnimationEndHandler);
  }, r.prototype.getWidth = function () {
    return this.adapter.getWidth();
  }, r.prototype.shake = function (t) {
    var e = r.cssClasses.LABEL_SHAKE;
    t ? this.adapter.addClass(e) : this.adapter.removeClass(e);
  }, r.prototype.float = function (t) {
    var e = r.cssClasses,
      a = e.LABEL_FLOAT_ABOVE,
      n = e.LABEL_SHAKE;
    t ? this.adapter.addClass(a) : (this.adapter.removeClass(a), this.adapter.removeClass(n));
  }, r.prototype.setRequired = function (t) {
    var e = r.cssClasses.LABEL_REQUIRED;
    t ? this.adapter.addClass(e) : this.adapter.removeClass(e);
  }, r.prototype.handleShakeAnimationEnd = function () {
    var t = r.cssClasses.LABEL_SHAKE;
    this.adapter.removeClass(t);
  }, r;
}(_foundation.MDCFoundation);
},{"../../../_virtual/_tslib.js":"../node_modules/@cosmograph/ui/_virtual/_tslib.js","../base/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/base/foundation.js","./constants.js":"../node_modules/@cosmograph/ui/ext/@material/floating-label/constants.js"}],"../node_modules/@cosmograph/ui/ext/@smui/floating-label/dist/FloatingLabel.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("../../../svelte/internal/index.mjs.js");
var _classMap = require("../../common/dist/internal/classMap.js");
var _dispatch = require("../../common/dist/internal/dispatch.js");
var _forwardEventsBuilder = require("../../common/dist/internal/forwardEventsBuilder.js");
var _useActions = require("../../common/dist/internal/useActions.js");
var _foundation = require("../../../@material/floating-label/foundation.js");
function C(e) {
  let t, l, n, a, r, d, u, f;
  const m = e[22].default,
    g = (0, _indexMjs.create_slot)(m, e, e[21], null);
  let b = [{
      class: l = (0, _classMap.classMap)({
        [e[3]]: !0,
        "mdc-floating-label": !0,
        "mdc-floating-label--float-above": e[0],
        "mdc-floating-label--required": e[1],
        ...e[8]
      })
    }, {
      style: n = Object.entries(e[9]).map(R).concat([e[4]]).join(" ")
    }, {
      for: a = e[5] || (e[11] ? e[11].id : void 0)
    }, e[12]],
    W = {};
  for (let e = 0; e < b.length; e += 1) W = (0, _indexMjs.assign)(W, b[e]);
  return {
    c() {
      t = (0, _indexMjs.element)("label"), g && g.c(), (0, _indexMjs.set_attributes)(t, W);
    },
    m(l, n) {
      (0, _indexMjs.insert)(l, t, n), g && g.m(t, null), e[24](t), d = !0, u || (f = [(0, _indexMjs.action_destroyer)(r = _useActions.useActions.call(null, t, e[2])), (0, _indexMjs.action_destroyer)(e[10].call(null, t))], u = !0);
    },
    p(e, o) {
      g && g.p && (!d || 2097152 & o) && (0, _indexMjs.update_slot_base)(g, m, e, e[21], d ? (0, _indexMjs.get_slot_changes)(m, e[21], o, null) : (0, _indexMjs.get_all_dirty_from_scope)(e[21]), null), (0, _indexMjs.set_attributes)(t, W = (0, _indexMjs.get_spread_update)(b, [(!d || 267 & o && l !== (l = (0, _classMap.classMap)({
        [e[3]]: !0,
        "mdc-floating-label": !0,
        "mdc-floating-label--float-above": e[0],
        "mdc-floating-label--required": e[1],
        ...e[8]
      }))) && {
        class: l
      }, (!d || 528 & o && n !== (n = Object.entries(e[9]).map(R).concat([e[4]]).join(" "))) && {
        style: n
      }, (!d || 32 & o && a !== (a = e[5] || (e[11] ? e[11].id : void 0))) && {
        for: a
      }, 4096 & o && e[12]])), r && (0, _indexMjs.is_function)(r.update) && 4 & o && r.update.call(null, e[2]);
    },
    i(e) {
      d || ((0, _indexMjs.transition_in)(g, e), d = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(g, e), d = !1;
    },
    d(l) {
      l && (0, _indexMjs.detach)(t), g && g.d(l), e[24](null), u = !1, (0, _indexMjs.run_all)(f);
    }
  };
}
function M(e) {
  let t, l, n, a, r, d, u;
  const f = e[22].default,
    m = (0, _indexMjs.create_slot)(f, e, e[21], null);
  let g = [{
      class: l = (0, _classMap.classMap)({
        [e[3]]: !0,
        "mdc-floating-label": !0,
        "mdc-floating-label--float-above": e[0],
        "mdc-floating-label--required": e[1],
        ...e[8]
      })
    }, {
      style: n = Object.entries(e[9]).map(O).concat([e[4]]).join(" ")
    }, e[12]],
    b = {};
  for (let e = 0; e < g.length; e += 1) b = (0, _indexMjs.assign)(b, g[e]);
  return {
    c() {
      t = (0, _indexMjs.element)("span"), m && m.c(), (0, _indexMjs.set_attributes)(t, b);
    },
    m(l, n) {
      (0, _indexMjs.insert)(l, t, n), m && m.m(t, null), e[23](t), r = !0, d || (u = [(0, _indexMjs.action_destroyer)(a = _useActions.useActions.call(null, t, e[2])), (0, _indexMjs.action_destroyer)(e[10].call(null, t))], d = !0);
    },
    p(e, o) {
      m && m.p && (!r || 2097152 & o) && (0, _indexMjs.update_slot_base)(m, f, e, e[21], r ? (0, _indexMjs.get_slot_changes)(f, e[21], o, null) : (0, _indexMjs.get_all_dirty_from_scope)(e[21]), null), (0, _indexMjs.set_attributes)(t, b = (0, _indexMjs.get_spread_update)(g, [(!r || 267 & o && l !== (l = (0, _classMap.classMap)({
        [e[3]]: !0,
        "mdc-floating-label": !0,
        "mdc-floating-label--float-above": e[0],
        "mdc-floating-label--required": e[1],
        ...e[8]
      }))) && {
        class: l
      }, (!r || 528 & o && n !== (n = Object.entries(e[9]).map(O).concat([e[4]]).join(" "))) && {
        style: n
      }, 4096 & o && e[12]])), a && (0, _indexMjs.is_function)(a.update) && 4 & o && a.update.call(null, e[2]);
    },
    i(e) {
      r || ((0, _indexMjs.transition_in)(m, e), r = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(m, e), r = !1;
    },
    d(l) {
      l && (0, _indexMjs.detach)(t), m && m.d(l), e[23](null), d = !1, (0, _indexMjs.run_all)(u);
    }
  };
}
function N(e) {
  let t, l, d, u;
  const f = [M, C],
    m = [];
  function p(e, t) {
    return e[6] ? 0 : 1;
  }
  return t = p(e), l = m[t] = f[t](e), {
    c() {
      l.c(), d = (0, _indexMjs.empty)();
    },
    m(e, l) {
      m[t].m(e, l), (0, _indexMjs.insert)(e, d, l), u = !0;
    },
    p(e, [n]) {
      let o = t;
      t = p(e), t === o ? m[t].p(e, n) : ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(m[o], 1, 1, () => {
        m[o] = null;
      }), (0, _indexMjs.check_outros)(), l = m[t], l ? l.p(e, n) : (l = m[t] = f[t](e), l.c()), (0, _indexMjs.transition_in)(l, 1), l.m(d.parentNode, d));
    },
    i(e) {
      u || ((0, _indexMjs.transition_in)(l), u = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(l), u = !1;
    },
    d(e) {
      m[t].d(e), e && (0, _indexMjs.detach)(d);
    }
  };
}
const O = ([e, t]) => `${e}: ${t};`,
  R = ([e, t]) => `${e}: ${t};`;
function U(e, t, l) {
  const n = ["use", "class", "style", "for", "floatAbove", "required", "wrapped", "shake", "float", "setRequired", "getWidth", "getElement"];
  let o = (0, _indexMjs.compute_rest_props)(t, n),
    {
      $$slots: a = {},
      $$scope: i
    } = t;
  var r;
  const s = (0, _forwardEventsBuilder.forwardEventsBuilder)((0, _indexMjs.get_current_component)());
  let c,
    $,
    {
      use: v = []
    } = t,
    {
      class: h = ""
    } = t,
    {
      style: j = ""
    } = t,
    {
      for: y
    } = t,
    {
      floatAbove: q = !1
    } = t,
    {
      required: x = !1
    } = t,
    {
      wrapped: w = !1
    } = t,
    L = {},
    A = {},
    E = null !== (r = (0, _indexMjs.getContext)("SMUI:generic:input:props")) && void 0 !== r ? r : {},
    S = q,
    C = x;
  function M(e) {
    L[e] || l(8, L[e] = !0, L);
  }
  function N(e) {
    e in L && !L[e] || l(8, L[e] = !1, L);
  }
  function O(e, t) {
    A[e] != t && ("" === t || null == t ? (delete A[e], l(9, A)) : l(9, A[e] = t, A));
  }
  function R(e) {
    e in A && (delete A[e], l(9, A));
  }
  function U() {
    return c;
  }
  return (0, _indexMjs.onMount)(() => {
    l(18, $ = new _foundation.MDCFloatingLabelFoundation({
      addClass: M,
      removeClass: N,
      getWidth: () => {
        var e, t;
        const l = U(),
          n = l.cloneNode(!0);
        null === (e = l.parentNode) || void 0 === e || e.appendChild(n), n.classList.add("smui-floating-label--remove-transition"), n.classList.add("smui-floating-label--force-size"), n.classList.remove("mdc-floating-label--float-above");
        const o = n.scrollWidth;
        return null === (t = l.parentNode) || void 0 === t || t.removeChild(n), o;
      },
      registerInteractionHandler: (e, t) => U().addEventListener(e, t),
      deregisterInteractionHandler: (e, t) => U().removeEventListener(e, t)
    }));
    const e = {
      get element() {
        return U();
      },
      addStyle: O,
      removeStyle: R
    };
    return (0, _dispatch.dispatch)(c, "SMUIFloatingLabel:mount", e), $.init(), () => {
      (0, _dispatch.dispatch)(c, "SMUIFloatingLabel:unmount", e), $.destroy();
    };
  }), e.$$set = e => {
    t = (0, _indexMjs.assign)((0, _indexMjs.assign)({}, t), (0, _indexMjs.exclude_internal_props)(e)), l(12, o = (0, _indexMjs.compute_rest_props)(t, n)), "use" in e && l(2, v = e.use), "class" in e && l(3, h = e.class), "style" in e && l(4, j = e.style), "for" in e && l(5, y = e.for), "floatAbove" in e && l(0, q = e.floatAbove), "required" in e && l(1, x = e.required), "wrapped" in e && l(6, w = e.wrapped), "$$scope" in e && l(21, i = e.$$scope);
  }, e.$$.update = () => {
    786433 & e.$$.dirty && $ && S !== q && (l(19, S = q), $.float(q)), 1310722 & e.$$.dirty && $ && C !== x && (l(20, C = x), $.setRequired(x));
  }, [q, x, v, h, j, y, w, c, L, A, s, E, o, function (e) {
    $.shake(e);
  }, function (e) {
    l(0, q = e);
  }, function (e) {
    l(1, x = e);
  }, function () {
    return $.getWidth();
  }, U, $, S, C, i, a, function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      c = e, l(7, c);
    });
  }, function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      c = e, l(7, c);
    });
  }];
}
class F extends _indexMjs.SvelteComponent {
  constructor(e) {
    super(), (0, _indexMjs.init)(this, e, U, N, _indexMjs.safe_not_equal, {
      use: 2,
      class: 3,
      style: 4,
      for: 5,
      floatAbove: 0,
      required: 1,
      wrapped: 6,
      shake: 13,
      float: 14,
      setRequired: 15,
      getWidth: 16,
      getElement: 17
    });
  }
  get shake() {
    return this.$$.ctx[13];
  }
  get float() {
    return this.$$.ctx[14];
  }
  get setRequired() {
    return this.$$.ctx[15];
  }
  get getWidth() {
    return this.$$.ctx[16];
  }
  get getElement() {
    return this.$$.ctx[17];
  }
}
exports.default = F;
},{"../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../../common/dist/internal/classMap.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/classMap.js","../../common/dist/internal/dispatch.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/dispatch.js","../../common/dist/internal/forwardEventsBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js","../../common/dist/internal/useActions.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/useActions.js","../../../@material/floating-label/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/floating-label/foundation.js"}],"../node_modules/@cosmograph/ui/ext/@material/line-ripple/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cssClasses = void 0;
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var e = exports.cssClasses = {
  LINE_RIPPLE_ACTIVE: "mdc-line-ripple--active",
  LINE_RIPPLE_DEACTIVATING: "mdc-line-ripple--deactivating"
};
},{}],"../node_modules/@cosmograph/ui/ext/@material/line-ripple/foundation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MDCLineRippleFoundation = void 0;
var _tslib = require("../../../_virtual/_tslib.js");
var _foundation = require("../base/foundation.js");
var _constants = require("./constants.js");
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var a = exports.default = exports.MDCLineRippleFoundation = function (n) {
  function a(t) {
    var r = n.call(this, (0, _tslib.__assign)((0, _tslib.__assign)({}, a.defaultAdapter), t)) || this;
    return r.transitionEndHandler = function (t) {
      r.handleTransitionEnd(t);
    }, r;
  }
  return (0, _tslib.__extends)(a, n), Object.defineProperty(a, "cssClasses", {
    get: function () {
      return _constants.cssClasses;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(a, "defaultAdapter", {
    get: function () {
      return {
        addClass: function () {},
        removeClass: function () {},
        hasClass: function () {
          return !1;
        },
        setStyle: function () {},
        registerEventHandler: function () {},
        deregisterEventHandler: function () {}
      };
    },
    enumerable: !1,
    configurable: !0
  }), a.prototype.init = function () {
    this.adapter.registerEventHandler("transitionend", this.transitionEndHandler);
  }, a.prototype.destroy = function () {
    this.adapter.deregisterEventHandler("transitionend", this.transitionEndHandler);
  }, a.prototype.activate = function () {
    this.adapter.removeClass(_constants.cssClasses.LINE_RIPPLE_DEACTIVATING), this.adapter.addClass(_constants.cssClasses.LINE_RIPPLE_ACTIVE);
  }, a.prototype.setRippleCenter = function (t) {
    this.adapter.setStyle("transform-origin", t + "px center");
  }, a.prototype.deactivate = function () {
    this.adapter.addClass(_constants.cssClasses.LINE_RIPPLE_DEACTIVATING);
  }, a.prototype.handleTransitionEnd = function (t) {
    var e = this.adapter.hasClass(_constants.cssClasses.LINE_RIPPLE_DEACTIVATING);
    "opacity" === t.propertyName && e && (this.adapter.removeClass(_constants.cssClasses.LINE_RIPPLE_ACTIVE), this.adapter.removeClass(_constants.cssClasses.LINE_RIPPLE_DEACTIVATING));
  }, a;
}(_foundation.MDCFoundation);
},{"../../../_virtual/_tslib.js":"../node_modules/@cosmograph/ui/_virtual/_tslib.js","../base/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/base/foundation.js","./constants.js":"../node_modules/@cosmograph/ui/ext/@material/line-ripple/constants.js"}],"../node_modules/@cosmograph/ui/ext/@smui/line-ripple/dist/LineRipple.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("../../../svelte/internal/index.mjs.js");
var _classMap = require("../../common/dist/internal/classMap.js");
var _forwardEventsBuilder = require("../../common/dist/internal/forwardEventsBuilder.js");
var _useActions = require("../../common/dist/internal/useActions.js");
var _foundation = require("../../../@material/line-ripple/foundation.js");
function x(e) {
  let t,
    n,
    m,
    v,
    f,
    $,
    g = [{
      class: n = (0, _classMap.classMap)({
        [e[1]]: !0,
        "mdc-line-ripple": !0,
        "mdc-line-ripple--active": e[3],
        ...e[5]
      })
    }, {
      style: m = Object.entries(e[6]).map(C).concat([e[2]]).join(" ")
    }, e[8]],
    h = {};
  for (let e = 0; e < g.length; e += 1) h = (0, _indexMjs.assign)(h, g[e]);
  return {
    c() {
      t = (0, _indexMjs.element)("div"), (0, _indexMjs.set_attributes)(t, h);
    },
    m(n, i) {
      (0, _indexMjs.insert)(n, t, i), e[13](t), f || ($ = [(0, _indexMjs.action_destroyer)(v = _useActions.useActions.call(null, t, e[0])), (0, _indexMjs.action_destroyer)(e[7].call(null, t))], f = !0);
    },
    p(e, [i]) {
      (0, _indexMjs.set_attributes)(t, h = (0, _indexMjs.get_spread_update)(g, [42 & i && n !== (n = (0, _classMap.classMap)({
        [e[1]]: !0,
        "mdc-line-ripple": !0,
        "mdc-line-ripple--active": e[3],
        ...e[5]
      })) && {
        class: n
      }, 68 & i && m !== (m = Object.entries(e[6]).map(C).concat([e[2]]).join(" ")) && {
        style: m
      }, 256 & i && e[8]])), v && (0, _indexMjs.is_function)(v.update) && 1 & i && v.update.call(null, e[0]);
    },
    i: _indexMjs.noop,
    o: _indexMjs.noop,
    d(n) {
      n && (0, _indexMjs.detach)(t), e[13](null), f = !1, (0, _indexMjs.run_all)($);
    }
  };
}
const C = ([e, t]) => `${e}: ${t};`;
function R(e, t, n) {
  const s = ["use", "class", "style", "active", "activate", "deactivate", "setRippleCenter", "getElement"];
  let l = (0, _indexMjs.compute_rest_props)(t, s);
  const c = (0, _forwardEventsBuilder.forwardEventsBuilder)((0, _indexMjs.get_current_component)());
  let a,
    r,
    {
      use: o = []
    } = t,
    {
      class: u = ""
    } = t,
    {
      style: p = ""
    } = t,
    {
      active: d = !1
    } = t,
    j = {},
    y = {};
  function x(e) {
    return e in j ? j[e] : b().classList.contains(e);
  }
  function C(e) {
    j[e] || n(5, j[e] = !0, j);
  }
  function R(e) {
    e in j && !j[e] || n(5, j[e] = !1, j);
  }
  function L(e, t) {
    y[e] != t && ("" === t || null == t ? (delete y[e], n(6, y)) : n(6, y[e] = t, y));
  }
  function b() {
    return a;
  }
  return (0, _indexMjs.onMount)(() => (r = new _foundation.MDCLineRippleFoundation({
    addClass: C,
    removeClass: R,
    hasClass: x,
    setStyle: L,
    registerEventHandler: (e, t) => b().addEventListener(e, t),
    deregisterEventHandler: (e, t) => b().removeEventListener(e, t)
  }), r.init(), () => {
    r.destroy();
  })), e.$$set = e => {
    t = (0, _indexMjs.assign)((0, _indexMjs.assign)({}, t), (0, _indexMjs.exclude_internal_props)(e)), n(8, l = (0, _indexMjs.compute_rest_props)(t, s)), "use" in e && n(0, o = e.use), "class" in e && n(1, u = e.class), "style" in e && n(2, p = e.style), "active" in e && n(3, d = e.active);
  }, [o, u, p, d, a, j, y, c, l, function () {
    r.activate();
  }, function () {
    r.deactivate();
  }, function (e) {
    r.setRippleCenter(e);
  }, b, function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      a = e, n(4, a);
    });
  }];
}
class L extends _indexMjs.SvelteComponent {
  constructor(e) {
    super(), (0, _indexMjs.init)(this, e, R, x, _indexMjs.safe_not_equal, {
      use: 0,
      class: 1,
      style: 2,
      active: 3,
      activate: 9,
      deactivate: 10,
      setRippleCenter: 11,
      getElement: 12
    });
  }
  get activate() {
    return this.$$.ctx[9];
  }
  get deactivate() {
    return this.$$.ctx[10];
  }
  get setRippleCenter() {
    return this.$$.ctx[11];
  }
  get getElement() {
    return this.$$.ctx[12];
  }
}
exports.default = L;
},{"../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../../common/dist/internal/classMap.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/classMap.js","../../common/dist/internal/forwardEventsBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js","../../common/dist/internal/useActions.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/useActions.js","../../../@material/line-ripple/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/line-ripple/foundation.js"}],"../node_modules/@cosmograph/ui/ext/@material/notched-outline/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.strings = exports.numbers = exports.cssClasses = void 0;
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var E = exports.strings = {
    NOTCH_ELEMENT_SELECTOR: ".mdc-notched-outline__notch"
  },
  e = exports.numbers = {
    NOTCH_ELEMENT_PADDING: 8
  },
  o = exports.cssClasses = {
    NO_LABEL: "mdc-notched-outline--no-label",
    OUTLINE_NOTCHED: "mdc-notched-outline--notched",
    OUTLINE_UPGRADED: "mdc-notched-outline--upgraded"
  };
},{}],"../node_modules/@cosmograph/ui/ext/@material/notched-outline/foundation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MDCNotchedOutlineFoundation = void 0;
var _tslib = require("../../../_virtual/_tslib.js");
var _foundation = require("../base/foundation.js");
var _constants = require("./constants.js");
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var a = exports.default = exports.MDCNotchedOutlineFoundation = function (r) {
  function a(t) {
    return r.call(this, (0, _tslib.__assign)((0, _tslib.__assign)({}, a.defaultAdapter), t)) || this;
  }
  return (0, _tslib.__extends)(a, r), Object.defineProperty(a, "strings", {
    get: function () {
      return _constants.strings;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(a, "cssClasses", {
    get: function () {
      return _constants.cssClasses;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(a, "numbers", {
    get: function () {
      return _constants.numbers;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(a, "defaultAdapter", {
    get: function () {
      return {
        addClass: function () {},
        removeClass: function () {},
        setNotchWidthProperty: function () {},
        removeNotchWidthProperty: function () {}
      };
    },
    enumerable: !1,
    configurable: !0
  }), a.prototype.notch = function (t) {
    var e = a.cssClasses.OUTLINE_NOTCHED;
    t > 0 && (t += _constants.numbers.NOTCH_ELEMENT_PADDING), this.adapter.setNotchWidthProperty(t), this.adapter.addClass(e);
  }, a.prototype.closeNotch = function () {
    var t = a.cssClasses.OUTLINE_NOTCHED;
    this.adapter.removeClass(t), this.adapter.removeNotchWidthProperty();
  }, a;
}(_foundation.MDCFoundation);
},{"../../../_virtual/_tslib.js":"../node_modules/@cosmograph/ui/_virtual/_tslib.js","../base/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/base/foundation.js","./constants.js":"../node_modules/@cosmograph/ui/ext/@material/notched-outline/constants.js"}],"../node_modules/@cosmograph/ui/ext/@smui/notched-outline/dist/NotchedOutline.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("../../../svelte/internal/index.mjs.js");
var _classMap = require("../../common/dist/internal/classMap.js");
var _forwardEventsBuilder = require("../../common/dist/internal/forwardEventsBuilder.js");
var _useActions = require("../../common/dist/internal/useActions.js");
var _foundation = require("../../../@material/notched-outline/foundation.js");
function I(t) {
  let n, e, o;
  const c = t[15].default,
    s = (0, _indexMjs.create_slot)(c, t, t[14], null);
  return {
    c() {
      n = (0, _indexMjs.element)("div"), s && s.c(), (0, _indexMjs.attr)(n, "class", "mdc-notched-outline__notch"), (0, _indexMjs.attr)(n, "style", e = Object.entries(t[7]).map(P).join(" "));
    },
    m(t, e) {
      (0, _indexMjs.insert)(t, n, e), s && s.m(n, null), o = !0;
    },
    p(t, l) {
      s && s.p && (!o || 16384 & l) && (0, _indexMjs.update_slot_base)(s, c, t, t[14], o ? (0, _indexMjs.get_slot_changes)(c, t[14], l, null) : (0, _indexMjs.get_all_dirty_from_scope)(t[14]), null), (!o || 128 & l && e !== (e = Object.entries(t[7]).map(P).join(" "))) && (0, _indexMjs.attr)(n, "style", e);
    },
    i(t) {
      o || ((0, _indexMjs.transition_in)(s, t), o = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(s, t), o = !1;
    },
    d(t) {
      t && (0, _indexMjs.detach)(n), s && s.d(t);
    }
  };
}
function O(t) {
  let n,
    e,
    j,
    y,
    x,
    L,
    N,
    _,
    w,
    E,
    S = !t[3] && I(t),
    M = [{
      class: L = (0, _classMap.classMap)({
        [t[1]]: !0,
        "mdc-notched-outline": !0,
        "mdc-notched-outline--notched": t[2],
        "mdc-notched-outline--no-label": t[3],
        ...t[6]
      })
    }, t[10]],
    C = {};
  for (let t = 0; t < M.length; t += 1) C = (0, _indexMjs.assign)(C, M[t]);
  return {
    c() {
      n = (0, _indexMjs.element)("div"), e = (0, _indexMjs.element)("div"), j = (0, _indexMjs.space)(), S && S.c(), y = (0, _indexMjs.space)(), x = (0, _indexMjs.element)("div"), (0, _indexMjs.attr)(e, "class", "mdc-notched-outline__leading"), (0, _indexMjs.attr)(x, "class", "mdc-notched-outline__trailing"), (0, _indexMjs.set_attributes)(n, C);
    },
    m(o, l) {
      (0, _indexMjs.insert)(o, n, l), (0, _indexMjs.append)(n, e), (0, _indexMjs.append)(n, j), S && S.m(n, null), (0, _indexMjs.append)(n, y), (0, _indexMjs.append)(n, x), t[16](n), _ = !0, w || (E = [(0, _indexMjs.action_destroyer)(N = _useActions.useActions.call(null, n, t[0])), (0, _indexMjs.action_destroyer)(t[8].call(null, n)), (0, _indexMjs.listen)(n, "SMUIFloatingLabel:mount", t[9]), (0, _indexMjs.listen)(n, "SMUIFloatingLabel:unmount", t[17])], w = !0);
    },
    p(t, [e]) {
      t[3] ? S && ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(S, 1, 1, () => {
        S = null;
      }), (0, _indexMjs.check_outros)()) : S ? (S.p(t, e), 8 & e && (0, _indexMjs.transition_in)(S, 1)) : (S = I(t), S.c(), (0, _indexMjs.transition_in)(S, 1), S.m(n, y)), (0, _indexMjs.set_attributes)(n, C = (0, _indexMjs.get_spread_update)(M, [(!_ || 78 & e && L !== (L = (0, _classMap.classMap)({
        [t[1]]: !0,
        "mdc-notched-outline": !0,
        "mdc-notched-outline--notched": t[2],
        "mdc-notched-outline--no-label": t[3],
        ...t[6]
      }))) && {
        class: L
      }, 1024 & e && t[10]])), N && (0, _indexMjs.is_function)(N.update) && 1 & e && N.update.call(null, t[0]);
    },
    i(t) {
      _ || ((0, _indexMjs.transition_in)(S), _ = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(S), _ = !1;
    },
    d(e) {
      e && (0, _indexMjs.detach)(n), S && S.d(), t[16](null), w = !1, (0, _indexMjs.run_all)(E);
    }
  };
}
const P = ([t, n]) => `${t}: ${n};`;
function U(t, n, e) {
  const l = ["use", "class", "notched", "noLabel", "notch", "closeNotch", "getElement"];
  let c = (0, _indexMjs.compute_rest_props)(n, l),
    {
      $$slots: i = {},
      $$scope: s
    } = n;
  const d = (0, _forwardEventsBuilder.forwardEventsBuilder)((0, _indexMjs.get_current_component)());
  let u,
    r,
    a,
    {
      use: m = []
    } = n,
    {
      class: h = ""
    } = n,
    {
      notched: p = !1
    } = n,
    {
      noLabel: $ = !1
    } = n,
    f = {},
    g = {};
  function v(t) {
    f[t] || e(6, f[t] = !0, f);
  }
  function b(t) {
    t in f && !f[t] || e(6, f[t] = !1, f);
  }
  (0, _indexMjs.onMount)(() => (r = new _foundation.MDCNotchedOutlineFoundation({
    addClass: v,
    removeClass: b,
    setNotchWidthProperty: t => {
      return o = t + "px", void (g[n = "width"] != o && ("" === o || null == o ? (delete g[n], e(7, g)) : e(7, g[n] = o, g)));
      var n, o;
    },
    removeNotchWidthProperty: () => {
      var t;
      (t = "width") in g && (delete g[t], e(7, g));
    }
  }), r.init(), () => {
    r.destroy();
  }));
  return t.$$set = t => {
    n = (0, _indexMjs.assign)((0, _indexMjs.assign)({}, n), (0, _indexMjs.exclude_internal_props)(t)), e(10, c = (0, _indexMjs.compute_rest_props)(n, l)), "use" in t && e(0, m = t.use), "class" in t && e(1, h = t.class), "notched" in t && e(2, p = t.notched), "noLabel" in t && e(3, $ = t.noLabel), "$$scope" in t && e(14, s = t.$$scope);
  }, t.$$.update = () => {
    16 & t.$$.dirty && (a ? (a.addStyle("transition-duration", "0s"), v("mdc-notched-outline--upgraded"), requestAnimationFrame(() => {
      a && a.removeStyle("transition-duration");
    })) : b("mdc-notched-outline--upgraded"));
  }, [m, h, p, $, a, u, f, g, d, function (t) {
    e(4, a = t.detail);
  }, c, function (t) {
    r.notch(t);
  }, function () {
    r.closeNotch();
  }, function () {
    return u;
  }, s, i, function (t) {
    _indexMjs.binding_callbacks[t ? "unshift" : "push"](() => {
      u = t, e(5, u);
    });
  }, () => e(4, a = void 0)];
}
class W extends _indexMjs.SvelteComponent {
  constructor(t) {
    super(), (0, _indexMjs.init)(this, t, U, O, _indexMjs.safe_not_equal, {
      use: 0,
      class: 1,
      notched: 2,
      noLabel: 3,
      notch: 11,
      closeNotch: 12,
      getElement: 13
    });
  }
  get notch() {
    return this.$$.ctx[11];
  }
  get closeNotch() {
    return this.$$.ctx[12];
  }
  get getElement() {
    return this.$$.ctx[13];
  }
}
exports.default = W;
},{"../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../../common/dist/internal/classMap.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/classMap.js","../../common/dist/internal/forwardEventsBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js","../../common/dist/internal/useActions.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/useActions.js","../../../@material/notched-outline/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/notched-outline/foundation.js"}],"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/HelperLine.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _classAdderBuilder = require("../../common/dist/classadder/classAdderBuilder.js");
var e = exports.default = (0, _classAdderBuilder.classAdderBuilder)({
  class: "mdc-text-field-helper-line",
  tag: "div"
});
},{"../../common/dist/classadder/classAdderBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/classadder/classAdderBuilder.js"}],"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/Prefix.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _classAdderBuilder = require("../../common/dist/classadder/classAdderBuilder.js");
var d = exports.default = (0, _classAdderBuilder.classAdderBuilder)({
  class: "mdc-text-field__affix mdc-text-field__affix--prefix",
  tag: "span"
});
},{"../../common/dist/classadder/classAdderBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/classadder/classAdderBuilder.js"}],"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/Suffix.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _classAdderBuilder = require("../../common/dist/classadder/classAdderBuilder.js");
var d = exports.default = (0, _classAdderBuilder.classAdderBuilder)({
  class: "mdc-text-field__affix mdc-text-field__affix--suffix",
  tag: "span"
});
},{"../../common/dist/classadder/classAdderBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/classadder/classAdderBuilder.js"}],"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/Input.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("../../../svelte/internal/index.mjs.js");
var _classMap = require("../../common/dist/internal/classMap.js");
var _forwardEventsBuilder = require("../../common/dist/internal/forwardEventsBuilder.js");
var _useActions = require("../../common/dist/internal/useActions.js");
function b(e) {
  let t,
    l,
    m,
    v,
    h,
    y = [{
      class: l = (0, _classMap.classMap)({
        [e[1]]: !0,
        "mdc-text-field__input": !0
      })
    }, {
      type: e[2]
    }, {
      placeholder: e[3]
    }, e[4], e[6], e[10]],
    g = {};
  for (let e = 0; e < y.length; e += 1) g = (0, _indexMjs.assign)(g, y[e]);
  return {
    c() {
      t = (0, _indexMjs.element)("input"), (0, _indexMjs.set_attributes)(t, g);
    },
    m(l, n) {
      (0, _indexMjs.insert)(l, t, n), t.autofocus && t.focus(), e[26](t), v || (h = [(0, _indexMjs.action_destroyer)(m = _useActions.useActions.call(null, t, e[0])), (0, _indexMjs.action_destroyer)(e[7].call(null, t)), (0, _indexMjs.listen)(t, "input", e[27]), (0, _indexMjs.listen)(t, "change", e[9]), (0, _indexMjs.listen)(t, "blur", e[24]), (0, _indexMjs.listen)(t, "focus", e[25])], v = !0);
    },
    p(e, [n]) {
      (0, _indexMjs.set_attributes)(t, g = (0, _indexMjs.get_spread_update)(y, [2 & n && l !== (l = (0, _classMap.classMap)({
        [e[1]]: !0,
        "mdc-text-field__input": !0
      })) && {
        class: l
      }, 4 & n && {
        type: e[2]
      }, 8 & n && {
        placeholder: e[3]
      }, 16 & n && e[4], 64 & n && e[6], 1024 & n && e[10]])), m && (0, _indexMjs.is_function)(m.update) && 1 & n && m.update.call(null, e[0]);
    },
    i: _indexMjs.noop,
    o: _indexMjs.noop,
    d(l) {
      l && (0, _indexMjs.detach)(t), e[26](null), v = !1, (0, _indexMjs.run_all)(h);
    }
  };
}
function N(e, t, l) {
  const u = ["use", "class", "type", "placeholder", "value", "files", "dirty", "invalid", "updateInvalid", "emptyValueNull", "emptyValueUndefined", "getAttr", "addAttr", "removeAttr", "focus", "blur", "getElement"];
  let i = (0, _indexMjs.compute_rest_props)(t, u);
  const r = (0, _forwardEventsBuilder.forwardEventsBuilder)((0, _indexMjs.get_current_component)());
  let a = () => {};
  let {
      use: s = []
    } = t,
    {
      class: c = ""
    } = t,
    {
      type: d = "text"
    } = t,
    {
      placeholder: o = " "
    } = t,
    {
      value: f = a
    } = t;
  const p = function (e) {
    return e === a;
  }(f);
  p && (f = "");
  let {
      files: x = null
    } = t,
    {
      dirty: V = !1
    } = t,
    {
      invalid: b = !1
    } = t,
    {
      updateInvalid: N = !0
    } = t,
    {
      emptyValueNull: j = null === f
    } = t;
  p && j && (f = null);
  let I,
    {
      emptyValueUndefined: T = void 0 === f
    } = t;
  p && T && (f = void 0);
  let U = {},
    E = {};
  function _(e) {
    if ("file" !== d) {
      if ("" === e.currentTarget.value && j) l(11, f = null);else if ("" === e.currentTarget.value && T) l(11, f = void 0);else switch (d) {
        case "number":
        case "range":
          l(11, f = function (e) {
            return "" === e ? Number.NaN : +e;
          }(e.currentTarget.value));
          break;
        default:
          l(11, f = e.currentTarget.value);
      }
    } else l(12, x = e.currentTarget.files);
  }
  function w() {
    return I;
  }
  (0, _indexMjs.onMount)(() => {
    N && l(14, b = I.matches(":invalid"));
  });
  return e.$$set = e => {
    t = (0, _indexMjs.assign)((0, _indexMjs.assign)({}, t), (0, _indexMjs.exclude_internal_props)(e)), l(10, i = (0, _indexMjs.compute_rest_props)(t, u)), "use" in e && l(0, s = e.use), "class" in e && l(1, c = e.class), "type" in e && l(2, d = e.type), "placeholder" in e && l(3, o = e.placeholder), "value" in e && l(11, f = e.value), "files" in e && l(12, x = e.files), "dirty" in e && l(13, V = e.dirty), "invalid" in e && l(14, b = e.invalid), "updateInvalid" in e && l(15, N = e.updateInvalid), "emptyValueNull" in e && l(16, j = e.emptyValueNull), "emptyValueUndefined" in e && l(17, T = e.emptyValueUndefined);
  }, e.$$.update = () => {
    2068 & e.$$.dirty && ("file" === d ? (delete E.value, l(4, E), l(2, d), l(11, f)) : l(4, E.value = null == f ? "" : f, E));
  }, [s, c, d, o, E, I, U, r, _, function (e) {
    "file" !== d && "range" !== d || _(e), l(13, V = !0), N && l(14, b = I.matches(":invalid"));
  }, i, f, x, V, b, N, j, T, function (e) {
    var t;
    return e in U ? null !== (t = U[e]) && void 0 !== t ? t : null : w().getAttribute(e);
  }, function (e, t) {
    U[e] !== t && l(6, U[e] = t, U);
  }, function (e) {
    e in U && null == U[e] || l(6, U[e] = void 0, U);
  }, function () {
    w().focus();
  }, function () {
    w().blur();
  }, w, function (t) {
    _indexMjs.bubble.call(this, e, t);
  }, function (t) {
    _indexMjs.bubble.call(this, e, t);
  }, function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      I = e, l(5, I);
    });
  }, e => "file" !== d && _(e)];
}
class j extends _indexMjs.SvelteComponent {
  constructor(e) {
    super(), (0, _indexMjs.init)(this, e, N, b, _indexMjs.safe_not_equal, {
      use: 0,
      class: 1,
      type: 2,
      placeholder: 3,
      value: 11,
      files: 12,
      dirty: 13,
      invalid: 14,
      updateInvalid: 15,
      emptyValueNull: 16,
      emptyValueUndefined: 17,
      getAttr: 18,
      addAttr: 19,
      removeAttr: 20,
      focus: 21,
      blur: 22,
      getElement: 23
    });
  }
  get getAttr() {
    return this.$$.ctx[18];
  }
  get addAttr() {
    return this.$$.ctx[19];
  }
  get removeAttr() {
    return this.$$.ctx[20];
  }
  get focus() {
    return this.$$.ctx[21];
  }
  get blur() {
    return this.$$.ctx[22];
  }
  get getElement() {
    return this.$$.ctx[23];
  }
}
exports.default = j;
},{"../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../../common/dist/internal/classMap.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/classMap.js","../../common/dist/internal/forwardEventsBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js","../../common/dist/internal/useActions.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/useActions.js"}],"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/Textarea.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("../../../svelte/internal/index.mjs.js");
var _classMap = require("../../common/dist/internal/classMap.js");
var _forwardEventsBuilder = require("../../common/dist/internal/forwardEventsBuilder.js");
var _useActions = require("../../common/dist/internal/useActions.js");
function j(t) {
  let e,
    n,
    p,
    $,
    h,
    g,
    x = [{
      class: n = (0, _classMap.classMap)({
        [t[2]]: !0,
        "mdc-text-field__input": !0
      })
    }, {
      style: p = `${t[4] ? "" : "resize: none; "}${t[3]}`
    }, t[6], t[9]],
    y = {};
  for (let t = 0; t < x.length; t += 1) y = (0, _indexMjs.assign)(y, x[t]);
  return {
    c() {
      e = (0, _indexMjs.element)("textarea"), (0, _indexMjs.set_attributes)(e, y);
    },
    m(n, i) {
      (0, _indexMjs.insert)(n, e, i), e.autofocus && e.focus(), t[21](e), (0, _indexMjs.set_input_value)(e, t[0]), h || (g = [(0, _indexMjs.action_destroyer)($ = _useActions.useActions.call(null, e, t[1])), (0, _indexMjs.action_destroyer)(t[7].call(null, e)), (0, _indexMjs.listen)(e, "change", t[8]), (0, _indexMjs.listen)(e, "blur", t[19]), (0, _indexMjs.listen)(e, "focus", t[20]), (0, _indexMjs.listen)(e, "input", t[22])], h = !0);
    },
    p(t, [i]) {
      (0, _indexMjs.set_attributes)(e, y = (0, _indexMjs.get_spread_update)(x, [4 & i && n !== (n = (0, _classMap.classMap)({
        [t[2]]: !0,
        "mdc-text-field__input": !0
      })) && {
        class: n
      }, 24 & i && p !== (p = `${t[4] ? "" : "resize: none; "}${t[3]}`) && {
        style: p
      }, 64 & i && t[6], 512 & i && t[9]])), $ && (0, _indexMjs.is_function)($.update) && 2 & i && $.update.call(null, t[1]), 1 & i && (0, _indexMjs.set_input_value)(e, t[0]);
    },
    i: _indexMjs.noop,
    o: _indexMjs.noop,
    d(n) {
      n && (0, _indexMjs.detach)(e), t[21](null), h = !1, (0, _indexMjs.run_all)(g);
    }
  };
}
function I(t, e, n) {
  const l = ["use", "class", "style", "value", "dirty", "invalid", "updateInvalid", "resizable", "getAttr", "addAttr", "removeAttr", "focus", "blur", "getElement"];
  let s = (0, _indexMjs.compute_rest_props)(e, l);
  const r = (0, _forwardEventsBuilder.forwardEventsBuilder)((0, _indexMjs.get_current_component)());
  let u,
    {
      use: a = []
    } = e,
    {
      class: c = ""
    } = e,
    {
      style: o = ""
    } = e,
    {
      value: d = ""
    } = e,
    {
      dirty: f = !1
    } = e,
    {
      invalid: m = !1
    } = e,
    {
      updateInvalid: v = !0
    } = e,
    {
      resizable: b = !0
    } = e,
    z = {};
  function j() {
    return u;
  }
  return (0, _indexMjs.onMount)(() => {
    v && n(11, m = u.matches(":invalid"));
  }), t.$$set = t => {
    e = (0, _indexMjs.assign)((0, _indexMjs.assign)({}, e), (0, _indexMjs.exclude_internal_props)(t)), n(9, s = (0, _indexMjs.compute_rest_props)(e, l)), "use" in t && n(1, a = t.use), "class" in t && n(2, c = t.class), "style" in t && n(3, o = t.style), "value" in t && n(0, d = t.value), "dirty" in t && n(10, f = t.dirty), "invalid" in t && n(11, m = t.invalid), "updateInvalid" in t && n(12, v = t.updateInvalid), "resizable" in t && n(4, b = t.resizable);
  }, [d, a, c, o, b, u, z, r, function () {
    n(10, f = !0), v && n(11, m = u.matches(":invalid"));
  }, s, f, m, v, function (t) {
    var e;
    return t in z ? null !== (e = z[t]) && void 0 !== e ? e : null : j().getAttribute(t);
  }, function (t, e) {
    z[t] !== e && n(6, z[t] = e, z);
  }, function (t) {
    t in z && null == z[t] || n(6, z[t] = void 0, z);
  }, function () {
    j().focus();
  }, function () {
    j().blur();
  }, j, function (e) {
    _indexMjs.bubble.call(this, t, e);
  }, function (e) {
    _indexMjs.bubble.call(this, t, e);
  }, function (t) {
    _indexMjs.binding_callbacks[t ? "unshift" : "push"](() => {
      u = t, n(5, u);
    });
  }, function () {
    d = this.value, n(0, d);
  }];
}
class E extends _indexMjs.SvelteComponent {
  constructor(t) {
    super(), (0, _indexMjs.init)(this, t, I, j, _indexMjs.safe_not_equal, {
      use: 1,
      class: 2,
      style: 3,
      value: 0,
      dirty: 10,
      invalid: 11,
      updateInvalid: 12,
      resizable: 4,
      getAttr: 13,
      addAttr: 14,
      removeAttr: 15,
      focus: 16,
      blur: 17,
      getElement: 18
    });
  }
  get getAttr() {
    return this.$$.ctx[13];
  }
  get addAttr() {
    return this.$$.ctx[14];
  }
  get removeAttr() {
    return this.$$.ctx[15];
  }
  get focus() {
    return this.$$.ctx[16];
  }
  get blur() {
    return this.$$.ctx[17];
  }
  get getElement() {
    return this.$$.ctx[18];
  }
}
exports.default = E;
},{"../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../../common/dist/internal/classMap.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/classMap.js","../../common/dist/internal/forwardEventsBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js","../../common/dist/internal/useActions.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/useActions.js"}],"../node_modules/@cosmograph/ui/ext/@material/textfield/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.strings = exports.numbers = exports.cssClasses = exports.VALIDATION_ATTR_WHITELIST = exports.ALWAYS_FLOAT_TYPES = void 0;
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var e = exports.strings = {
    ARIA_CONTROLS: "aria-controls",
    ARIA_DESCRIBEDBY: "aria-describedby",
    INPUT_SELECTOR: ".mdc-text-field__input",
    LABEL_SELECTOR: ".mdc-floating-label",
    LEADING_ICON_SELECTOR: ".mdc-text-field__icon--leading",
    LINE_RIPPLE_SELECTOR: ".mdc-line-ripple",
    OUTLINE_SELECTOR: ".mdc-notched-outline",
    PREFIX_SELECTOR: ".mdc-text-field__affix--prefix",
    SUFFIX_SELECTOR: ".mdc-text-field__affix--suffix",
    TRAILING_ICON_SELECTOR: ".mdc-text-field__icon--trailing"
  },
  t = exports.cssClasses = {
    DISABLED: "mdc-text-field--disabled",
    FOCUSED: "mdc-text-field--focused",
    HELPER_LINE: "mdc-text-field-helper-line",
    INVALID: "mdc-text-field--invalid",
    LABEL_FLOATING: "mdc-text-field--label-floating",
    NO_LABEL: "mdc-text-field--no-label",
    OUTLINED: "mdc-text-field--outlined",
    ROOT: "mdc-text-field",
    TEXTAREA: "mdc-text-field--textarea",
    WITH_LEADING_ICON: "mdc-text-field--with-leading-icon",
    WITH_TRAILING_ICON: "mdc-text-field--with-trailing-icon",
    WITH_INTERNAL_COUNTER: "mdc-text-field--with-internal-counter"
  },
  i = exports.numbers = {
    LABEL_SCALE: .75
  },
  d = exports.VALIDATION_ATTR_WHITELIST = ["pattern", "min", "max", "required", "step", "minlength", "maxlength"],
  l = exports.ALWAYS_FLOAT_TYPES = ["color", "date", "datetime-local", "month", "range", "time", "week"];
},{}],"../node_modules/@cosmograph/ui/ext/@material/textfield/foundation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MDCTextFieldFoundation = void 0;
var _tslib = require("../../../_virtual/_tslib.js");
var _foundation = require("../base/foundation.js");
var _constants = require("./constants.js");
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var u = ["mousedown", "touchstart"],
  h = ["click", "keydown"],
  d = exports.default = exports.MDCTextFieldFoundation = function (a) {
    function d(t, e) {
      void 0 === e && (e = {});
      var n = a.call(this, (0, _tslib.__assign)((0, _tslib.__assign)({}, d.defaultAdapter), t)) || this;
      return n.isFocused = !1, n.receivedUserInput = !1, n.valid = !0, n.useNativeValidation = !0, n.validateOnValueChange = !0, n.helperText = e.helperText, n.characterCounter = e.characterCounter, n.leadingIcon = e.leadingIcon, n.trailingIcon = e.trailingIcon, n.inputFocusHandler = function () {
        n.activateFocus();
      }, n.inputBlurHandler = function () {
        n.deactivateFocus();
      }, n.inputInputHandler = function () {
        n.handleInput();
      }, n.setPointerXOffset = function (t) {
        n.setTransformOrigin(t);
      }, n.textFieldInteractionHandler = function () {
        n.handleTextFieldInteraction();
      }, n.validationAttributeChangeHandler = function (t) {
        n.handleValidationAttributeChange(t);
      }, n;
    }
    return (0, _tslib.__extends)(d, a), Object.defineProperty(d, "cssClasses", {
      get: function () {
        return _constants.cssClasses;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(d, "strings", {
      get: function () {
        return _constants.strings;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(d, "numbers", {
      get: function () {
        return _constants.numbers;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(d.prototype, "shouldAlwaysFloat", {
      get: function () {
        var t = this.getNativeInput().type;
        return _constants.ALWAYS_FLOAT_TYPES.indexOf(t) >= 0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(d.prototype, "shouldFloat", {
      get: function () {
        return this.shouldAlwaysFloat || this.isFocused || !!this.getValue() || this.isBadInput();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(d.prototype, "shouldShake", {
      get: function () {
        return !this.isFocused && !this.isValid() && !!this.getValue();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(d, "defaultAdapter", {
      get: function () {
        return {
          addClass: function () {},
          removeClass: function () {},
          hasClass: function () {
            return !0;
          },
          setInputAttr: function () {},
          removeInputAttr: function () {},
          registerTextFieldInteractionHandler: function () {},
          deregisterTextFieldInteractionHandler: function () {},
          registerInputInteractionHandler: function () {},
          deregisterInputInteractionHandler: function () {},
          registerValidationAttributeChangeHandler: function () {
            return new MutationObserver(function () {});
          },
          deregisterValidationAttributeChangeHandler: function () {},
          getNativeInput: function () {
            return null;
          },
          isFocused: function () {
            return !1;
          },
          activateLineRipple: function () {},
          deactivateLineRipple: function () {},
          setLineRippleTransformOrigin: function () {},
          shakeLabel: function () {},
          floatLabel: function () {},
          setLabelRequired: function () {},
          hasLabel: function () {
            return !1;
          },
          getLabelWidth: function () {
            return 0;
          },
          hasOutline: function () {
            return !1;
          },
          notchOutline: function () {},
          closeOutline: function () {}
        };
      },
      enumerable: !1,
      configurable: !0
    }), d.prototype.init = function () {
      var t, i, a, n;
      this.adapter.hasLabel() && this.getNativeInput().required && this.adapter.setLabelRequired(!0), this.adapter.isFocused() ? this.inputFocusHandler() : this.adapter.hasLabel() && this.shouldFloat && (this.notchOutline(!0), this.adapter.floatLabel(!0), this.styleFloating(!0)), this.adapter.registerInputInteractionHandler("focus", this.inputFocusHandler), this.adapter.registerInputInteractionHandler("blur", this.inputBlurHandler), this.adapter.registerInputInteractionHandler("input", this.inputInputHandler);
      try {
        for (var r = (0, _tslib.__values)(u), s = r.next(); !s.done; s = r.next()) {
          var o = s.value;
          this.adapter.registerInputInteractionHandler(o, this.setPointerXOffset);
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          s && !s.done && (i = r.return) && i.call(r);
        } finally {
          if (t) throw t.error;
        }
      }
      try {
        for (var l = (0, _tslib.__values)(h), d = l.next(); !d.done; d = l.next()) {
          o = d.value;
          this.adapter.registerTextFieldInteractionHandler(o, this.textFieldInteractionHandler);
        }
      } catch (t) {
        a = {
          error: t
        };
      } finally {
        try {
          d && !d.done && (n = l.return) && n.call(l);
        } finally {
          if (a) throw a.error;
        }
      }
      this.validationObserver = this.adapter.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler), this.setcharacterCounter(this.getValue().length);
    }, d.prototype.destroy = function () {
      var t, i, a, n;
      this.adapter.deregisterInputInteractionHandler("focus", this.inputFocusHandler), this.adapter.deregisterInputInteractionHandler("blur", this.inputBlurHandler), this.adapter.deregisterInputInteractionHandler("input", this.inputInputHandler);
      try {
        for (var r = (0, _tslib.__values)(u), s = r.next(); !s.done; s = r.next()) {
          var o = s.value;
          this.adapter.deregisterInputInteractionHandler(o, this.setPointerXOffset);
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          s && !s.done && (i = r.return) && i.call(r);
        } finally {
          if (t) throw t.error;
        }
      }
      try {
        for (var l = (0, _tslib.__values)(h), d = l.next(); !d.done; d = l.next()) {
          o = d.value;
          this.adapter.deregisterTextFieldInteractionHandler(o, this.textFieldInteractionHandler);
        }
      } catch (t) {
        a = {
          error: t
        };
      } finally {
        try {
          d && !d.done && (n = l.return) && n.call(l);
        } finally {
          if (a) throw a.error;
        }
      }
      this.adapter.deregisterValidationAttributeChangeHandler(this.validationObserver);
    }, d.prototype.handleTextFieldInteraction = function () {
      var t = this.adapter.getNativeInput();
      t && t.disabled || (this.receivedUserInput = !0);
    }, d.prototype.handleValidationAttributeChange = function (t) {
      var e = this;
      t.some(function (t) {
        return _constants.VALIDATION_ATTR_WHITELIST.indexOf(t) > -1 && (e.styleValidity(!0), e.adapter.setLabelRequired(e.getNativeInput().required), !0);
      }), t.indexOf("maxlength") > -1 && this.setcharacterCounter(this.getValue().length);
    }, d.prototype.notchOutline = function (t) {
      if (this.adapter.hasOutline() && this.adapter.hasLabel()) if (t) {
        var e = this.adapter.getLabelWidth() * _constants.numbers.LABEL_SCALE;
        this.adapter.notchOutline(e);
      } else this.adapter.closeOutline();
    }, d.prototype.activateFocus = function () {
      this.isFocused = !0, this.styleFocused(this.isFocused), this.adapter.activateLineRipple(), this.adapter.hasLabel() && (this.notchOutline(this.shouldFloat), this.adapter.floatLabel(this.shouldFloat), this.styleFloating(this.shouldFloat), this.adapter.shakeLabel(this.shouldShake)), !this.helperText || !this.helperText.isPersistent() && this.helperText.isValidation() && this.valid || this.helperText.showToScreenReader();
    }, d.prototype.setTransformOrigin = function (t) {
      if (!this.isDisabled() && !this.adapter.hasOutline()) {
        var e = t.touches,
          i = e ? e[0] : t,
          a = i.target.getBoundingClientRect(),
          n = i.clientX - a.left;
        this.adapter.setLineRippleTransformOrigin(n);
      }
    }, d.prototype.handleInput = function () {
      this.autoCompleteFocus(), this.setcharacterCounter(this.getValue().length);
    }, d.prototype.autoCompleteFocus = function () {
      this.receivedUserInput || this.activateFocus();
    }, d.prototype.deactivateFocus = function () {
      this.isFocused = !1, this.adapter.deactivateLineRipple();
      var t = this.isValid();
      this.styleValidity(t), this.styleFocused(this.isFocused), this.adapter.hasLabel() && (this.notchOutline(this.shouldFloat), this.adapter.floatLabel(this.shouldFloat), this.styleFloating(this.shouldFloat), this.adapter.shakeLabel(this.shouldShake)), this.shouldFloat || (this.receivedUserInput = !1);
    }, d.prototype.getValue = function () {
      return this.getNativeInput().value;
    }, d.prototype.setValue = function (t) {
      if (this.getValue() !== t && (this.getNativeInput().value = t), this.setcharacterCounter(t.length), this.validateOnValueChange) {
        var e = this.isValid();
        this.styleValidity(e);
      }
      this.adapter.hasLabel() && (this.notchOutline(this.shouldFloat), this.adapter.floatLabel(this.shouldFloat), this.styleFloating(this.shouldFloat), this.validateOnValueChange && this.adapter.shakeLabel(this.shouldShake));
    }, d.prototype.isValid = function () {
      return this.useNativeValidation ? this.isNativeInputValid() : this.valid;
    }, d.prototype.setValid = function (t) {
      this.valid = t, this.styleValidity(t);
      var e = !t && !this.isFocused && !!this.getValue();
      this.adapter.hasLabel() && this.adapter.shakeLabel(e);
    }, d.prototype.setValidateOnValueChange = function (t) {
      this.validateOnValueChange = t;
    }, d.prototype.getValidateOnValueChange = function () {
      return this.validateOnValueChange;
    }, d.prototype.setUseNativeValidation = function (t) {
      this.useNativeValidation = t;
    }, d.prototype.isDisabled = function () {
      return this.getNativeInput().disabled;
    }, d.prototype.setDisabled = function (t) {
      this.getNativeInput().disabled = t, this.styleDisabled(t);
    }, d.prototype.setHelperTextContent = function (t) {
      this.helperText && this.helperText.setContent(t);
    }, d.prototype.setLeadingIconAriaLabel = function (t) {
      this.leadingIcon && this.leadingIcon.setAriaLabel(t);
    }, d.prototype.setLeadingIconContent = function (t) {
      this.leadingIcon && this.leadingIcon.setContent(t);
    }, d.prototype.setTrailingIconAriaLabel = function (t) {
      this.trailingIcon && this.trailingIcon.setAriaLabel(t);
    }, d.prototype.setTrailingIconContent = function (t) {
      this.trailingIcon && this.trailingIcon.setContent(t);
    }, d.prototype.setcharacterCounter = function (t) {
      if (this.characterCounter) {
        var e = this.getNativeInput().maxLength;
        if (-1 === e) throw new Error("MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.");
        this.characterCounter.setCounterValue(t, e);
      }
    }, d.prototype.isBadInput = function () {
      return this.getNativeInput().validity.badInput || !1;
    }, d.prototype.isNativeInputValid = function () {
      return this.getNativeInput().validity.valid;
    }, d.prototype.styleValidity = function (t) {
      var e = d.cssClasses.INVALID;
      if (t ? this.adapter.removeClass(e) : this.adapter.addClass(e), this.helperText) {
        if (this.helperText.setValidity(t), !this.helperText.isValidation()) return;
        var i = this.helperText.isVisible(),
          a = this.helperText.getId();
        i && a ? this.adapter.setInputAttr(_constants.strings.ARIA_DESCRIBEDBY, a) : this.adapter.removeInputAttr(_constants.strings.ARIA_DESCRIBEDBY);
      }
    }, d.prototype.styleFocused = function (t) {
      var e = d.cssClasses.FOCUSED;
      t ? this.adapter.addClass(e) : this.adapter.removeClass(e);
    }, d.prototype.styleDisabled = function (t) {
      var e = d.cssClasses,
        i = e.DISABLED,
        a = e.INVALID;
      t ? (this.adapter.addClass(i), this.adapter.removeClass(a)) : this.adapter.removeClass(i), this.leadingIcon && this.leadingIcon.setDisabled(t), this.trailingIcon && this.trailingIcon.setDisabled(t);
    }, d.prototype.styleFloating = function (t) {
      var e = d.cssClasses.LABEL_FLOATING;
      t ? this.adapter.addClass(e) : this.adapter.removeClass(e);
    }, d.prototype.getNativeInput = function () {
      return (this.adapter ? this.adapter.getNativeInput() : null) || {
        disabled: !1,
        maxLength: -1,
        required: !1,
        type: "input",
        validity: {
          badInput: !1,
          valid: !0
        },
        value: ""
      };
    }, d;
  }(_foundation.MDCFoundation);
},{"../../../_virtual/_tslib.js":"../node_modules/@cosmograph/ui/_virtual/_tslib.js","../base/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/base/foundation.js","./constants.js":"../node_modules/@cosmograph/ui/ext/@material/textfield/constants.js"}],"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/Textfield.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("../../../svelte/internal/index.mjs.js");
var _ = _interopRequireWildcard(require("../../../@material/dom/events.js"));
var _classMap = require("../../common/dist/internal/classMap.js");
var _dispatch = require("../../common/dist/internal/dispatch.js");
var _exclude = require("../../common/dist/internal/exclude.js");
var _forwardEventsBuilder = require("../../common/dist/internal/forwardEventsBuilder.js");
var _prefixFilter = require("../../common/dist/internal/prefixFilter.js");
var _useActions = require("../../common/dist/internal/useActions.js");
var _ContextFragmentSvelte = _interopRequireDefault(require("../../common/dist/ContextFragment.svelte.js"));
var _Ripple = _interopRequireDefault(require("../../ripple/dist/Ripple.js"));
var _FloatingLabelSvelte = _interopRequireDefault(require("../../floating-label/dist/FloatingLabel.svelte.js"));
var _LineRippleSvelte = _interopRequireDefault(require("../../line-ripple/dist/LineRipple.svelte.js"));
var _NotchedOutlineSvelte = _interopRequireDefault(require("../../notched-outline/dist/NotchedOutline.svelte.js"));
var _HelperLine = _interopRequireDefault(require("./HelperLine.js"));
var _Prefix = _interopRequireDefault(require("./Prefix.js"));
var _Suffix = _interopRequireDefault(require("./Suffix.js"));
var _InputSvelte = _interopRequireDefault(require("./Input.svelte.js"));
var _TextareaSvelte = _interopRequireDefault(require("./Textarea.svelte.js"));
var _foundation = require("../../../@material/textfield/foundation.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const de = e => ({}),
  oe = e => ({}),
  re = e => ({}),
  ue = e => ({}),
  ce = e => ({}),
  se = e => ({}),
  fe = e => ({}),
  pe = e => ({}),
  me = e => ({}),
  $e = e => ({}),
  ge = e => ({}),
  xe = e => ({}),
  ve = e => ({}),
  be = e => ({}),
  he = e => ({}),
  Ie = e => ({}),
  ye = e => ({}),
  we = e => ({}),
  Le = e => ({}),
  Te = e => ({}),
  Ce = e => ({}),
  je = e => ({}),
  Se = e => ({}),
  Me = e => ({});
function Ne(e) {
  let t, n, i, o, u, s, f, p, m, $, g, x, b, w;
  const T = e[56].label,
    A = (0, _indexMjs.create_slot)(T, e, e[87], $e);
  i = new _ContextFragmentSvelte.default({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: !0,
      $$slots: {
        default: [Oe]
      },
      $$scope: {
        ctx: e
      }
    }
  });
  const H = e[56].default,
    z = (0, _indexMjs.create_slot)(H, e, e[87], null);
  s = new _ContextFragmentSvelte.default({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: !1,
      $$slots: {
        default: [Ve]
      },
      $$scope: {
        ctx: e
      }
    }
  });
  const F = e[56].ripple,
    k = (0, _indexMjs.create_slot)(F, e, e[87], ue);
  let _ = [{
      class: p = (0, _classMap.classMap)({
        [e[9]]: !0,
        "mdc-text-field": !0,
        "mdc-text-field--disabled": e[12],
        "mdc-text-field--textarea": e[14],
        "mdc-text-field--filled": "filled" === e[15],
        "mdc-text-field--outlined": "outlined" === e[15],
        "smui-text-field--standard": "standard" === e[15] && !e[14],
        "mdc-text-field--no-label": e[16] || !e[47].label,
        "mdc-text-field--with-leading-icon": e[47].leadingIcon,
        "mdc-text-field--with-trailing-icon": e[47].trailingIcon,
        "mdc-text-field--invalid": e[1],
        ...e[25]
      })
    }, {
      style: m = Object.entries(e[26]).map(tt).concat([e[10]]).join(" ")
    }, (0, _exclude.exclude)(e[46], ["input$", "label$", "ripple$", "outline$", "helperLine$"])],
    W = {};
  for (let e = 0; e < _.length; e += 1) W = (0, _indexMjs.assign)(W, _[e]);
  return {
    c() {
      t = (0, _indexMjs.element)("div"), A && A.c(), n = (0, _indexMjs.space)(), (0, _indexMjs.create_component)(i.$$.fragment), o = (0, _indexMjs.space)(), z && z.c(), u = (0, _indexMjs.space)(), (0, _indexMjs.create_component)(s.$$.fragment), f = (0, _indexMjs.space)(), k && k.c(), (0, _indexMjs.set_attributes)(t, W);
    },
    m(l, d) {
      (0, _indexMjs.insert)(l, t, d), A && A.m(t, null), (0, _indexMjs.append)(t, n), (0, _indexMjs.mount_component)(i, t, null), (0, _indexMjs.append)(t, o), z && z.m(t, null), (0, _indexMjs.append)(t, u), (0, _indexMjs.mount_component)(s, t, null), (0, _indexMjs.append)(t, f), k && k.m(t, null), e[82](t), x = !0, b || (w = [(0, _indexMjs.action_destroyer)($ = _Ripple.default.call(null, t, {
        ripple: e[11],
        unbounded: !1,
        addClass: e[43],
        removeClass: e[44],
        addStyle: e[45]
      })), (0, _indexMjs.action_destroyer)(g = _useActions.useActions.call(null, t, e[8])), (0, _indexMjs.action_destroyer)(e[34].call(null, t)), (0, _indexMjs.listen)(t, "SMUITextfieldLeadingIcon:mount", e[38]), (0, _indexMjs.listen)(t, "SMUITextfieldLeadingIcon:unmount", e[83]), (0, _indexMjs.listen)(t, "SMUITextfieldTrailingIcon:mount", e[39]), (0, _indexMjs.listen)(t, "SMUITextfieldTrailingIcon:unmount", e[84])], b = !0);
    },
    p(e, n) {
      A && A.p && (!x || 33554432 & n[2]) && (0, _indexMjs.update_slot_base)(A, T, e, e[87], x ? (0, _indexMjs.get_slot_changes)(T, e[87], n, me) : (0, _indexMjs.get_all_dirty_from_scope)(e[87]), $e);
      const l = {};
      33554432 & n[2] && (l.$$scope = {
        dirty: n,
        ctx: e
      }), i.$set(l), z && z.p && (!x || 33554432 & n[2]) && (0, _indexMjs.update_slot_base)(z, H, e, e[87], x ? (0, _indexMjs.get_slot_changes)(H, e[87], n, null) : (0, _indexMjs.get_all_dirty_from_scope)(e[87]), null);
      const a = {};
      33554432 & n[2] && (a.$$scope = {
        dirty: n,
        ctx: e
      }), s.$set(a), k && k.p && (!x || 33554432 & n[2]) && (0, _indexMjs.update_slot_base)(k, F, e, e[87], x ? (0, _indexMjs.get_slot_changes)(F, e[87], n, re) : (0, _indexMjs.get_all_dirty_from_scope)(e[87]), ue), (0, _indexMjs.set_attributes)(t, W = (0, _indexMjs.get_spread_update)(_, [(!x || 33673730 & n[0] | 65536 & n[1] && p !== (p = (0, _classMap.classMap)({
        [e[9]]: !0,
        "mdc-text-field": !0,
        "mdc-text-field--disabled": e[12],
        "mdc-text-field--textarea": e[14],
        "mdc-text-field--filled": "filled" === e[15],
        "mdc-text-field--outlined": "outlined" === e[15],
        "smui-text-field--standard": "standard" === e[15] && !e[14],
        "mdc-text-field--no-label": e[16] || !e[47].label,
        "mdc-text-field--with-leading-icon": e[47].leadingIcon,
        "mdc-text-field--with-trailing-icon": e[47].trailingIcon,
        "mdc-text-field--invalid": e[1],
        ...e[25]
      }))) && {
        class: p
      }, (!x || 67109888 & n[0] && m !== (m = Object.entries(e[26]).map(tt).concat([e[10]]).join(" "))) && {
        style: m
      }, 32768 & n[1] && (0, _exclude.exclude)(e[46], ["input$", "label$", "ripple$", "outline$", "helperLine$"])])), $ && (0, _indexMjs.is_function)($.update) && 2048 & n[0] && $.update.call(null, {
        ripple: e[11],
        unbounded: !1,
        addClass: e[43],
        removeClass: e[44],
        addStyle: e[45]
      }), g && (0, _indexMjs.is_function)(g.update) && 256 & n[0] && g.update.call(null, e[8]);
    },
    i(e) {
      x || ((0, _indexMjs.transition_in)(A, e), (0, _indexMjs.transition_in)(i.$$.fragment, e), (0, _indexMjs.transition_in)(z, e), (0, _indexMjs.transition_in)(s.$$.fragment, e), (0, _indexMjs.transition_in)(k, e), x = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(A, e), (0, _indexMjs.transition_out)(i.$$.fragment, e), (0, _indexMjs.transition_out)(z, e), (0, _indexMjs.transition_out)(s.$$.fragment, e), (0, _indexMjs.transition_out)(k, e), x = !1;
    },
    d(n) {
      n && (0, _indexMjs.detach)(t), A && A.d(n), (0, _indexMjs.destroy_component)(i), z && z.d(n), (0, _indexMjs.destroy_component)(s), k && k.d(n), e[82](null), b = !1, (0, _indexMjs.run_all)(w);
    }
  };
}
function Ue(e) {
  let t,
    n,
    i,
    s,
    f,
    p,
    m,
    $,
    g,
    x,
    b,
    w,
    T,
    A,
    H,
    z,
    F,
    k,
    _ = !e[14] && "outlined" !== e[15] && Ee(e),
    W = (e[14] || "outlined" === e[15]) && He(e);
  s = new _ContextFragmentSvelte.default({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: !0,
      $$slots: {
        default: [_e]
      },
      $$scope: {
        ctx: e
      }
    }
  });
  const D = e[56].default,
    G = (0, _indexMjs.create_slot)(D, e, e[87], null),
    X = [We, Pe],
    Y = [];
  function Z(e, t) {
    return e[14] && "string" == typeof e[0] ? 0 : 1;
  }
  m = Z(e), $ = Y[m] = X[m](e), x = new _ContextFragmentSvelte.default({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: !1,
      $$slots: {
        default: [Ke]
      },
      $$scope: {
        ctx: e
      }
    }
  });
  let ee = !e[14] && "outlined" !== e[15] && e[11] && Qe(e),
    te = [{
      class: w = (0, _classMap.classMap)({
        [e[9]]: !0,
        "mdc-text-field": !0,
        "mdc-text-field--disabled": e[12],
        "mdc-text-field--textarea": e[14],
        "mdc-text-field--filled": "filled" === e[15],
        "mdc-text-field--outlined": "outlined" === e[15],
        "smui-text-field--standard": "standard" === e[15] && !e[14],
        "mdc-text-field--no-label": e[16] || null == e[17] && !e[47].label,
        "mdc-text-field--label-floating": e[28] || null != e[0] && "" !== e[0],
        "mdc-text-field--with-leading-icon": e[35](e[22]) ? e[47].leadingIcon : e[22],
        "mdc-text-field--with-trailing-icon": e[35](e[23]) ? e[47].trailingIcon : e[23],
        "mdc-text-field--with-internal-counter": e[14] && e[47].internalCounter,
        "mdc-text-field--invalid": e[1],
        ...e[25]
      })
    }, {
      style: T = Object.entries(e[26]).map(et).concat([e[10]]).join(" ")
    }, {
      for: void 0
    }, (0, _exclude.exclude)(e[46], ["input$", "label$", "ripple$", "outline$", "helperLine$"])],
    ne = {};
  for (let e = 0; e < te.length; e += 1) ne = (0, _indexMjs.assign)(ne, te[e]);
  return {
    c() {
      t = (0, _indexMjs.element)("label"), _ && _.c(), n = (0, _indexMjs.space)(), W && W.c(), i = (0, _indexMjs.space)(), (0, _indexMjs.create_component)(s.$$.fragment), f = (0, _indexMjs.space)(), G && G.c(), p = (0, _indexMjs.space)(), $.c(), g = (0, _indexMjs.space)(), (0, _indexMjs.create_component)(x.$$.fragment), b = (0, _indexMjs.space)(), ee && ee.c(), (0, _indexMjs.set_attributes)(t, ne);
    },
    m(l, d) {
      (0, _indexMjs.insert)(l, t, d), _ && _.m(t, null), (0, _indexMjs.append)(t, n), W && W.m(t, null), (0, _indexMjs.append)(t, i), (0, _indexMjs.mount_component)(s, t, null), (0, _indexMjs.append)(t, f), G && G.m(t, null), (0, _indexMjs.append)(t, p), Y[m].m(t, null), (0, _indexMjs.append)(t, g), (0, _indexMjs.mount_component)(x, t, null), (0, _indexMjs.append)(t, b), ee && ee.m(t, null), e[78](t), z = !0, F || (k = [(0, _indexMjs.action_destroyer)(A = _Ripple.default.call(null, t, {
        ripple: !e[14] && "filled" === e[15],
        unbounded: !1,
        addClass: e[43],
        removeClass: e[44],
        addStyle: e[45],
        eventTarget: e[33],
        activeTarget: e[33],
        initPromise: e[37]
      })), (0, _indexMjs.action_destroyer)(H = _useActions.useActions.call(null, t, e[8])), (0, _indexMjs.action_destroyer)(e[34].call(null, t)), (0, _indexMjs.listen)(t, "SMUITextfieldLeadingIcon:mount", e[38]), (0, _indexMjs.listen)(t, "SMUITextfieldLeadingIcon:unmount", e[79]), (0, _indexMjs.listen)(t, "SMUITextfieldTrailingIcon:mount", e[39]), (0, _indexMjs.listen)(t, "SMUITextfieldTrailingIcon:unmount", e[80]), (0, _indexMjs.listen)(t, "SMUITextfieldCharacterCounter:mount", e[40]), (0, _indexMjs.listen)(t, "SMUITextfieldCharacterCounter:unmount", e[81])], F = !0);
    },
    p(e, l) {
      e[14] || "outlined" === e[15] ? _ && ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(_, 1, 1, () => {
        _ = null;
      }), (0, _indexMjs.check_outros)()) : _ ? (_.p(e, l), 49152 & l[0] && (0, _indexMjs.transition_in)(_, 1)) : (_ = Ee(e), _.c(), (0, _indexMjs.transition_in)(_, 1), _.m(t, n)), e[14] || "outlined" === e[15] ? W ? (W.p(e, l), 49152 & l[0] && (0, _indexMjs.transition_in)(W, 1)) : (W = He(e), W.c(), (0, _indexMjs.transition_in)(W, 1), W.m(t, i)) : W && ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(W, 1, 1, () => {
        W = null;
      }), (0, _indexMjs.check_outros)());
      const a = {};
      33554432 & l[2] && (a.$$scope = {
        dirty: l,
        ctx: e
      }), s.$set(a), G && G.p && (!z || 33554432 & l[2]) && (0, _indexMjs.update_slot_base)(G, D, e, e[87], z ? (0, _indexMjs.get_slot_changes)(D, e[87], l, null) : (0, _indexMjs.get_all_dirty_from_scope)(e[87]), null);
      let c = m;
      m = Z(e), m === c ? Y[m].p(e, l) : ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(Y[c], 1, 1, () => {
        Y[c] = null;
      }), (0, _indexMjs.check_outros)(), $ = Y[m], $ ? $.p(e, l) : ($ = Y[m] = X[m](e), $.c()), (0, _indexMjs.transition_in)($, 1), $.m(t, g));
      const f = {};
      33554432 & l[2] && (f.$$scope = {
        dirty: l,
        ctx: e
      }), x.$set(f), !e[14] && "outlined" !== e[15] && e[11] ? ee ? (ee.p(e, l), 51200 & l[0] && (0, _indexMjs.transition_in)(ee, 1)) : (ee = Qe(e), ee.c(), (0, _indexMjs.transition_in)(ee, 1), ee.m(t, null)) : ee && ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(ee, 1, 1, () => {
        ee = null;
      }), (0, _indexMjs.check_outros)()), (0, _indexMjs.set_attributes)(t, ne = (0, _indexMjs.get_spread_update)(te, [(!z || 314823171 & l[0] | 65536 & l[1] && w !== (w = (0, _classMap.classMap)({
        [e[9]]: !0,
        "mdc-text-field": !0,
        "mdc-text-field--disabled": e[12],
        "mdc-text-field--textarea": e[14],
        "mdc-text-field--filled": "filled" === e[15],
        "mdc-text-field--outlined": "outlined" === e[15],
        "smui-text-field--standard": "standard" === e[15] && !e[14],
        "mdc-text-field--no-label": e[16] || null == e[17] && !e[47].label,
        "mdc-text-field--label-floating": e[28] || null != e[0] && "" !== e[0],
        "mdc-text-field--with-leading-icon": e[35](e[22]) ? e[47].leadingIcon : e[22],
        "mdc-text-field--with-trailing-icon": e[35](e[23]) ? e[47].trailingIcon : e[23],
        "mdc-text-field--with-internal-counter": e[14] && e[47].internalCounter,
        "mdc-text-field--invalid": e[1],
        ...e[25]
      }))) && {
        class: w
      }, (!z || 67109888 & l[0] && T !== (T = Object.entries(e[26]).map(et).concat([e[10]]).join(" "))) && {
        style: T
      }, {
        for: void 0
      }, 32768 & l[1] && (0, _exclude.exclude)(e[46], ["input$", "label$", "ripple$", "outline$", "helperLine$"])])), A && (0, _indexMjs.is_function)(A.update) && 49152 & l[0] | 4 & l[1] && A.update.call(null, {
        ripple: !e[14] && "filled" === e[15],
        unbounded: !1,
        addClass: e[43],
        removeClass: e[44],
        addStyle: e[45],
        eventTarget: e[33],
        activeTarget: e[33],
        initPromise: e[37]
      }), H && (0, _indexMjs.is_function)(H.update) && 256 & l[0] && H.update.call(null, e[8]);
    },
    i(e) {
      z || ((0, _indexMjs.transition_in)(_), (0, _indexMjs.transition_in)(W), (0, _indexMjs.transition_in)(s.$$.fragment, e), (0, _indexMjs.transition_in)(G, e), (0, _indexMjs.transition_in)($), (0, _indexMjs.transition_in)(x.$$.fragment, e), (0, _indexMjs.transition_in)(ee), z = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(_), (0, _indexMjs.transition_out)(W), (0, _indexMjs.transition_out)(s.$$.fragment, e), (0, _indexMjs.transition_out)(G, e), (0, _indexMjs.transition_out)($), (0, _indexMjs.transition_out)(x.$$.fragment, e), (0, _indexMjs.transition_out)(ee), z = !1;
    },
    d(n) {
      n && (0, _indexMjs.detach)(t), _ && _.d(), W && W.d(), (0, _indexMjs.destroy_component)(s), G && G.d(n), Y[m].d(), (0, _indexMjs.destroy_component)(x), ee && ee.d(), e[78](null), F = !1, (0, _indexMjs.run_all)(k);
    }
  };
}
function Oe(e) {
  let t;
  const n = e[56].leadingIcon,
    l = (0, _indexMjs.create_slot)(n, e, e[87], pe);
  return {
    c() {
      l && l.c();
    },
    m(e, n) {
      l && l.m(e, n), t = !0;
    },
    p(e, i) {
      l && l.p && (!t || 33554432 & i[2]) && (0, _indexMjs.update_slot_base)(l, n, e, e[87], t ? (0, _indexMjs.get_slot_changes)(n, e[87], i, fe) : (0, _indexMjs.get_all_dirty_from_scope)(e[87]), pe);
    },
    i(e) {
      t || ((0, _indexMjs.transition_in)(l, e), t = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(l, e), t = !1;
    },
    d(e) {
      l && l.d(e);
    }
  };
}
function Ve(e) {
  let t;
  const n = e[56].trailingIcon,
    l = (0, _indexMjs.create_slot)(n, e, e[87], se);
  return {
    c() {
      l && l.c();
    },
    m(e, n) {
      l && l.m(e, n), t = !0;
    },
    p(e, i) {
      l && l.p && (!t || 33554432 & i[2]) && (0, _indexMjs.update_slot_base)(l, n, e, e[87], t ? (0, _indexMjs.get_slot_changes)(n, e[87], i, ce) : (0, _indexMjs.get_all_dirty_from_scope)(e[87]), se);
    },
    i(e) {
      t || ((0, _indexMjs.transition_in)(l, e), t = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(l, e), t = !1;
    },
    d(e) {
      l && l.d(e);
    }
  };
}
function Ee(e) {
  let t,
    n,
    s,
    f = "filled" === e[15] && qe(),
    p = !e[16] && (null != e[17] || e[47].label) && Re(e);
  return {
    c() {
      f && f.c(), t = (0, _indexMjs.space)(), p && p.c(), n = (0, _indexMjs.empty)();
    },
    m(e, l) {
      f && f.m(e, l), (0, _indexMjs.insert)(e, t, l), p && p.m(e, l), (0, _indexMjs.insert)(e, n, l), s = !0;
    },
    p(e, l) {
      "filled" === e[15] ? f || (f = qe(), f.c(), f.m(t.parentNode, t)) : f && (f.d(1), f = null), e[16] || null == e[17] && !e[47].label ? p && ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(p, 1, 1, () => {
        p = null;
      }), (0, _indexMjs.check_outros)()) : p ? (p.p(e, l), 196608 & l[0] | 65536 & l[1] && (0, _indexMjs.transition_in)(p, 1)) : (p = Re(e), p.c(), (0, _indexMjs.transition_in)(p, 1), p.m(n.parentNode, n));
    },
    i(e) {
      s || ((0, _indexMjs.transition_in)(p), s = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(p), s = !1;
    },
    d(e) {
      f && f.d(e), e && (0, _indexMjs.detach)(t), p && p.d(e), e && (0, _indexMjs.detach)(n);
    }
  };
}
function qe(e) {
  let t;
  return {
    c() {
      t = (0, _indexMjs.element)("span"), (0, _indexMjs.attr)(t, "class", "mdc-text-field__ripple");
    },
    m(e, n) {
      (0, _indexMjs.insert)(e, t, n);
    },
    d(e) {
      e && (0, _indexMjs.detach)(t);
    }
  };
}
function Re(e) {
  let t, n;
  const l = [{
    floatAbove: e[28] || null != e[0] && "" !== e[0] && ("number" != typeof e[0] || !isNaN(e[0]))
  }, {
    required: e[13]
  }, {
    wrapped: !0
  }, (0, _prefixFilter.prefixFilter)(e[46], "label$")];
  let i = {
    $$slots: {
      default: [Ae]
    },
    $$scope: {
      ctx: e
    }
  };
  for (let e = 0; e < l.length; e += 1) i = (0, _indexMjs.assign)(i, l[e]);
  return t = new _FloatingLabelSvelte.default({
    props: i
  }), e[57](t), {
    c() {
      (0, _indexMjs.create_component)(t.$$.fragment);
    },
    m(e, l) {
      (0, _indexMjs.mount_component)(t, e, l), n = !0;
    },
    p(e, n) {
      const i = 268443649 & n[0] | 32768 & n[1] ? (0, _indexMjs.get_spread_update)(l, [268435457 & n[0] && {
        floatAbove: e[28] || null != e[0] && "" !== e[0] && ("number" != typeof e[0] || !isNaN(e[0]))
      }, 8192 & n[0] && {
        required: e[13]
      }, l[2], 32768 & n[1] && (0, _indexMjs.get_spread_object)((0, _prefixFilter.prefixFilter)(e[46], "label$"))]) : {};
      131072 & n[0] | 33554432 & n[2] && (i.$$scope = {
        dirty: n,
        ctx: e
      }), t.$set(i);
    },
    i(e) {
      n || ((0, _indexMjs.transition_in)(t.$$.fragment, e), n = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(t.$$.fragment, e), n = !1;
    },
    d(n) {
      e[57](null), (0, _indexMjs.destroy_component)(t, n);
    }
  };
}
function Ae(e) {
  let t,
    n,
    l = (null == e[17] ? "" : e[17]) + "";
  const i = e[56].label,
    o = (0, _indexMjs.create_slot)(i, e, e[87], Me);
  return {
    c() {
      t = (0, _indexMjs.text)(l), o && o.c();
    },
    m(e, l) {
      (0, _indexMjs.insert)(e, t, l), o && o.m(e, l), n = !0;
    },
    p(e, a) {
      (!n || 131072 & a[0]) && l !== (l = (null == e[17] ? "" : e[17]) + "") && (0, _indexMjs.set_data)(t, l), o && o.p && (!n || 33554432 & a[2]) && (0, _indexMjs.update_slot_base)(o, i, e, e[87], n ? (0, _indexMjs.get_slot_changes)(i, e[87], a, Se) : (0, _indexMjs.get_all_dirty_from_scope)(e[87]), Me);
    },
    i(e) {
      n || ((0, _indexMjs.transition_in)(o, e), n = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(o, e), n = !1;
    },
    d(e) {
      e && (0, _indexMjs.detach)(t), o && o.d(e);
    }
  };
}
function He(e) {
  let t, n;
  const l = [{
    noLabel: e[16] || null == e[17] && !e[47].label
  }, (0, _prefixFilter.prefixFilter)(e[46], "outline$")];
  let i = {
    $$slots: {
      default: [ke]
    },
    $$scope: {
      ctx: e
    }
  };
  for (let e = 0; e < l.length; e += 1) i = (0, _indexMjs.assign)(i, l[e]);
  return t = new _NotchedOutlineSvelte.default({
    props: i
  }), e[59](t), {
    c() {
      (0, _indexMjs.create_component)(t.$$.fragment);
    },
    m(e, l) {
      (0, _indexMjs.mount_component)(t, e, l), n = !0;
    },
    p(e, n) {
      const i = 196608 & n[0] | 98304 & n[1] ? (0, _indexMjs.get_spread_update)(l, [196608 & n[0] | 65536 & n[1] && {
        noLabel: e[16] || null == e[17] && !e[47].label
      }, 32768 & n[1] && (0, _indexMjs.get_spread_object)((0, _prefixFilter.prefixFilter)(e[46], "outline$"))]) : {};
      268640289 & n[0] | 98304 & n[1] | 33554432 & n[2] && (i.$$scope = {
        dirty: n,
        ctx: e
      }), t.$set(i);
    },
    i(e) {
      n || ((0, _indexMjs.transition_in)(t.$$.fragment, e), n = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(t.$$.fragment, e), n = !1;
    },
    d(n) {
      e[59](null), (0, _indexMjs.destroy_component)(t, n);
    }
  };
}
function ze(e) {
  let t, n;
  const l = [{
    floatAbove: e[28] || null != e[0] && "" !== e[0] && ("number" != typeof e[0] || !isNaN(e[0]))
  }, {
    required: e[13]
  }, {
    wrapped: !0
  }, (0, _prefixFilter.prefixFilter)(e[46], "label$")];
  let i = {
    $$slots: {
      default: [Fe]
    },
    $$scope: {
      ctx: e
    }
  };
  for (let e = 0; e < l.length; e += 1) i = (0, _indexMjs.assign)(i, l[e]);
  return t = new _FloatingLabelSvelte.default({
    props: i
  }), e[58](t), {
    c() {
      (0, _indexMjs.create_component)(t.$$.fragment);
    },
    m(e, l) {
      (0, _indexMjs.mount_component)(t, e, l), n = !0;
    },
    p(e, n) {
      const i = 268443649 & n[0] | 32768 & n[1] ? (0, _indexMjs.get_spread_update)(l, [268435457 & n[0] && {
        floatAbove: e[28] || null != e[0] && "" !== e[0] && ("number" != typeof e[0] || !isNaN(e[0]))
      }, 8192 & n[0] && {
        required: e[13]
      }, l[2], 32768 & n[1] && (0, _indexMjs.get_spread_object)((0, _prefixFilter.prefixFilter)(e[46], "label$"))]) : {};
      131072 & n[0] | 33554432 & n[2] && (i.$$scope = {
        dirty: n,
        ctx: e
      }), t.$set(i);
    },
    i(e) {
      n || ((0, _indexMjs.transition_in)(t.$$.fragment, e), n = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(t.$$.fragment, e), n = !1;
    },
    d(n) {
      e[58](null), (0, _indexMjs.destroy_component)(t, n);
    }
  };
}
function Fe(e) {
  let t,
    n,
    l = (null == e[17] ? "" : e[17]) + "";
  const i = e[56].label,
    o = (0, _indexMjs.create_slot)(i, e, e[87], je);
  return {
    c() {
      t = (0, _indexMjs.text)(l), o && o.c();
    },
    m(e, l) {
      (0, _indexMjs.insert)(e, t, l), o && o.m(e, l), n = !0;
    },
    p(e, a) {
      (!n || 131072 & a[0]) && l !== (l = (null == e[17] ? "" : e[17]) + "") && (0, _indexMjs.set_data)(t, l), o && o.p && (!n || 33554432 & a[2]) && (0, _indexMjs.update_slot_base)(o, i, e, e[87], n ? (0, _indexMjs.get_slot_changes)(i, e[87], a, Ce) : (0, _indexMjs.get_all_dirty_from_scope)(e[87]), je);
    },
    i(e) {
      n || ((0, _indexMjs.transition_in)(o, e), n = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(o, e), n = !1;
    },
    d(e) {
      e && (0, _indexMjs.detach)(t), o && o.d(e);
    }
  };
}
function ke(e) {
  let t,
    n,
    l = !e[16] && (null != e[17] || e[47].label) && ze(e);
  return {
    c() {
      l && l.c(), t = (0, _indexMjs.empty)();
    },
    m(e, i) {
      l && l.m(e, i), (0, _indexMjs.insert)(e, t, i), n = !0;
    },
    p(e, n) {
      e[16] || null == e[17] && !e[47].label ? l && ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(l, 1, 1, () => {
        l = null;
      }), (0, _indexMjs.check_outros)()) : l ? (l.p(e, n), 196608 & n[0] | 65536 & n[1] && (0, _indexMjs.transition_in)(l, 1)) : (l = ze(e), l.c(), (0, _indexMjs.transition_in)(l, 1), l.m(t.parentNode, t));
    },
    i(e) {
      n || ((0, _indexMjs.transition_in)(l), n = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(l), n = !1;
    },
    d(e) {
      l && l.d(e), e && (0, _indexMjs.detach)(t);
    }
  };
}
function _e(e) {
  let t;
  const n = e[56].leadingIcon,
    l = (0, _indexMjs.create_slot)(n, e, e[87], Te);
  return {
    c() {
      l && l.c();
    },
    m(e, n) {
      l && l.m(e, n), t = !0;
    },
    p(e, i) {
      l && l.p && (!t || 33554432 & i[2]) && (0, _indexMjs.update_slot_base)(l, n, e, e[87], t ? (0, _indexMjs.get_slot_changes)(n, e[87], i, Le) : (0, _indexMjs.get_all_dirty_from_scope)(e[87]), Te);
    },
    i(e) {
      t || ((0, _indexMjs.transition_in)(l, e), t = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(l, e), t = !1;
    },
    d(e) {
      l && l.d(e);
    }
  };
}
function Pe(e) {
  let t, n, i, s, f, p, m, $, g, x;
  const b = e[56].prefix,
    j = (0, _indexMjs.create_slot)(b, e, e[87], Ie);
  let S = null != e[20] && Be(e);
  const M = [{
    type: e[18]
  }, {
    disabled: e[12]
  }, {
    required: e[13]
  }, {
    updateInvalid: e[19]
  }, {
    "aria-controls": e[27]
  }, {
    "aria-describedby": e[27]
  }, e[16] && null != e[17] ? {
    placeholder: e[17]
  } : {}, (0, _prefixFilter.prefixFilter)(e[46], "input$")];
  function N(t) {
    e[69](t);
  }
  function U(t) {
    e[70](t);
  }
  function q(t) {
    e[71](t);
  }
  function R(t) {
    e[72](t);
  }
  let A = {};
  for (let e = 0; e < M.length; e += 1) A = (0, _indexMjs.assign)(A, M[e]);
  void 0 !== e[0] && (A.value = e[0]), void 0 !== e[3] && (A.files = e[3]), void 0 !== e[4] && (A.dirty = e[4]), void 0 !== e[1] && (A.invalid = e[1]), i = new _InputSvelte.default({
    props: A
  }), e[68](i), _indexMjs.binding_callbacks.push(() => (0, _indexMjs.bind)(i, "value", N)), _indexMjs.binding_callbacks.push(() => (0, _indexMjs.bind)(i, "files", U)), _indexMjs.binding_callbacks.push(() => (0, _indexMjs.bind)(i, "dirty", q)), _indexMjs.binding_callbacks.push(() => (0, _indexMjs.bind)(i, "invalid", R)), i.$on("blur", e[73]), i.$on("focus", e[74]), i.$on("blur", e[75]), i.$on("focus", e[76]);
  let H = null != e[21] && Ge(e);
  const z = e[56].suffix,
    _ = (0, _indexMjs.create_slot)(z, e, e[87], be);
  return {
    c() {
      j && j.c(), t = (0, _indexMjs.space)(), S && S.c(), n = (0, _indexMjs.space)(), (0, _indexMjs.create_component)(i.$$.fragment), $ = (0, _indexMjs.space)(), H && H.c(), g = (0, _indexMjs.space)(), _ && _.c();
    },
    m(e, l) {
      j && j.m(e, l), (0, _indexMjs.insert)(e, t, l), S && S.m(e, l), (0, _indexMjs.insert)(e, n, l), (0, _indexMjs.mount_component)(i, e, l), (0, _indexMjs.insert)(e, $, l), H && H.m(e, l), (0, _indexMjs.insert)(e, g, l), _ && _.m(e, l), x = !0;
    },
    p(e, t) {
      j && j.p && (!x || 33554432 & t[2]) && (0, _indexMjs.update_slot_base)(j, b, e, e[87], x ? (0, _indexMjs.get_slot_changes)(b, e[87], t, he) : (0, _indexMjs.get_all_dirty_from_scope)(e[87]), Ie), null != e[20] ? S ? (S.p(e, t), 1048576 & t[0] && (0, _indexMjs.transition_in)(S, 1)) : (S = Be(e), S.c(), (0, _indexMjs.transition_in)(S, 1), S.m(n.parentNode, n)) : S && ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(S, 1, 1, () => {
        S = null;
      }), (0, _indexMjs.check_outros)());
      const l = 135213056 & t[0] | 32768 & t[1] ? (0, _indexMjs.get_spread_update)(M, [262144 & t[0] && {
        type: e[18]
      }, 4096 & t[0] && {
        disabled: e[12]
      }, 8192 & t[0] && {
        required: e[13]
      }, 524288 & t[0] && {
        updateInvalid: e[19]
      }, 134217728 & t[0] && {
        "aria-controls": e[27]
      }, 134217728 & t[0] && {
        "aria-describedby": e[27]
      }, 196608 & t[0] && (0, _indexMjs.get_spread_object)(e[16] && null != e[17] ? {
        placeholder: e[17]
      } : {}), 32768 & t[1] && (0, _indexMjs.get_spread_object)((0, _prefixFilter.prefixFilter)(e[46], "input$"))]) : {};
      !s && 1 & t[0] && (s = !0, l.value = e[0], (0, _indexMjs.add_flush_callback)(() => s = !1)), !f && 8 & t[0] && (f = !0, l.files = e[3], (0, _indexMjs.add_flush_callback)(() => f = !1)), !p && 16 & t[0] && (p = !0, l.dirty = e[4], (0, _indexMjs.add_flush_callback)(() => p = !1)), !m && 2 & t[0] && (m = !0, l.invalid = e[1], (0, _indexMjs.add_flush_callback)(() => m = !1)), i.$set(l), null != e[21] ? H ? (H.p(e, t), 2097152 & t[0] && (0, _indexMjs.transition_in)(H, 1)) : (H = Ge(e), H.c(), (0, _indexMjs.transition_in)(H, 1), H.m(g.parentNode, g)) : H && ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(H, 1, 1, () => {
        H = null;
      }), (0, _indexMjs.check_outros)()), _ && _.p && (!x || 33554432 & t[2]) && (0, _indexMjs.update_slot_base)(_, z, e, e[87], x ? (0, _indexMjs.get_slot_changes)(z, e[87], t, ve) : (0, _indexMjs.get_all_dirty_from_scope)(e[87]), be);
    },
    i(e) {
      x || ((0, _indexMjs.transition_in)(j, e), (0, _indexMjs.transition_in)(S), (0, _indexMjs.transition_in)(i.$$.fragment, e), (0, _indexMjs.transition_in)(H), (0, _indexMjs.transition_in)(_, e), x = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(j, e), (0, _indexMjs.transition_out)(S), (0, _indexMjs.transition_out)(i.$$.fragment, e), (0, _indexMjs.transition_out)(H), (0, _indexMjs.transition_out)(_, e), x = !1;
    },
    d(l) {
      j && j.d(l), l && (0, _indexMjs.detach)(t), S && S.d(l), l && (0, _indexMjs.detach)(n), e[68](null), (0, _indexMjs.destroy_component)(i, l), l && (0, _indexMjs.detach)($), H && H.d(l), l && (0, _indexMjs.detach)(g), _ && _.d(l);
    }
  };
}
function We(e) {
  let t, n, i, o, u, s, f, p;
  const m = [{
    disabled: e[12]
  }, {
    required: e[13]
  }, {
    updateInvalid: e[19]
  }, {
    "aria-controls": e[27]
  }, {
    "aria-describedby": e[27]
  }, (0, _prefixFilter.prefixFilter)(e[46], "input$")];
  function $(t) {
    e[61](t);
  }
  function g(t) {
    e[62](t);
  }
  function x(t) {
    e[63](t);
  }
  let b = {};
  for (let e = 0; e < m.length; e += 1) b = (0, _indexMjs.assign)(b, m[e]);
  void 0 !== e[0] && (b.value = e[0]), void 0 !== e[4] && (b.dirty = e[4]), void 0 !== e[1] && (b.invalid = e[1]), n = new _TextareaSvelte.default({
    props: b
  }), e[60](n), _indexMjs.binding_callbacks.push(() => (0, _indexMjs.bind)(n, "value", $)), _indexMjs.binding_callbacks.push(() => (0, _indexMjs.bind)(n, "dirty", g)), _indexMjs.binding_callbacks.push(() => (0, _indexMjs.bind)(n, "invalid", x)), n.$on("blur", e[64]), n.$on("focus", e[65]), n.$on("blur", e[66]), n.$on("focus", e[67]);
  const S = e[56].internalCounter,
    N = (0, _indexMjs.create_slot)(S, e, e[87], we);
  return {
    c() {
      t = (0, _indexMjs.element)("span"), (0, _indexMjs.create_component)(n.$$.fragment), s = (0, _indexMjs.space)(), N && N.c(), (0, _indexMjs.attr)(t, "class", f = (0, _classMap.classMap)({
        "mdc-text-field__resizer": !("input$resizable" in e[46]) || e[46].input$resizable
      }));
    },
    m(e, l) {
      (0, _indexMjs.insert)(e, t, l), (0, _indexMjs.mount_component)(n, t, null), (0, _indexMjs.append)(t, s), N && N.m(t, null), p = !0;
    },
    p(e, l) {
      const a = 134754304 & l[0] | 32768 & l[1] ? (0, _indexMjs.get_spread_update)(m, [4096 & l[0] && {
        disabled: e[12]
      }, 8192 & l[0] && {
        required: e[13]
      }, 524288 & l[0] && {
        updateInvalid: e[19]
      }, 134217728 & l[0] && {
        "aria-controls": e[27]
      }, 134217728 & l[0] && {
        "aria-describedby": e[27]
      }, 32768 & l[1] && (0, _indexMjs.get_spread_object)((0, _prefixFilter.prefixFilter)(e[46], "input$"))]) : {};
      !i && 1 & l[0] && (i = !0, a.value = e[0], (0, _indexMjs.add_flush_callback)(() => i = !1)), !o && 16 & l[0] && (o = !0, a.dirty = e[4], (0, _indexMjs.add_flush_callback)(() => o = !1)), !u && 2 & l[0] && (u = !0, a.invalid = e[1], (0, _indexMjs.add_flush_callback)(() => u = !1)), n.$set(a), N && N.p && (!p || 33554432 & l[2]) && (0, _indexMjs.update_slot_base)(N, S, e, e[87], p ? (0, _indexMjs.get_slot_changes)(S, e[87], l, ye) : (0, _indexMjs.get_all_dirty_from_scope)(e[87]), we), (!p || 32768 & l[1] && f !== (f = (0, _classMap.classMap)({
        "mdc-text-field__resizer": !("input$resizable" in e[46]) || e[46].input$resizable
      }))) && (0, _indexMjs.attr)(t, "class", f);
    },
    i(e) {
      p || ((0, _indexMjs.transition_in)(n.$$.fragment, e), (0, _indexMjs.transition_in)(N, e), p = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(n.$$.fragment, e), (0, _indexMjs.transition_out)(N, e), p = !1;
    },
    d(l) {
      l && (0, _indexMjs.detach)(t), e[60](null), (0, _indexMjs.destroy_component)(n), N && N.d(l);
    }
  };
}
function Be(e) {
  let t, n;
  return t = new _Prefix.default({
    props: {
      $$slots: {
        default: [De]
      },
      $$scope: {
        ctx: e
      }
    }
  }), {
    c() {
      (0, _indexMjs.create_component)(t.$$.fragment);
    },
    m(e, l) {
      (0, _indexMjs.mount_component)(t, e, l), n = !0;
    },
    p(e, n) {
      const l = {};
      1048576 & n[0] | 33554432 & n[2] && (l.$$scope = {
        dirty: n,
        ctx: e
      }), t.$set(l);
    },
    i(e) {
      n || ((0, _indexMjs.transition_in)(t.$$.fragment, e), n = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(t.$$.fragment, e), n = !1;
    },
    d(e) {
      (0, _indexMjs.destroy_component)(t, e);
    }
  };
}
function De(e) {
  let t;
  return {
    c() {
      t = (0, _indexMjs.text)(e[20]);
    },
    m(e, n) {
      (0, _indexMjs.insert)(e, t, n);
    },
    p(e, n) {
      1048576 & n[0] && (0, _indexMjs.set_data)(t, e[20]);
    },
    d(e) {
      e && (0, _indexMjs.detach)(t);
    }
  };
}
function Ge(e) {
  let t, n;
  return t = new _Suffix.default({
    props: {
      $$slots: {
        default: [Je]
      },
      $$scope: {
        ctx: e
      }
    }
  }), {
    c() {
      (0, _indexMjs.create_component)(t.$$.fragment);
    },
    m(e, l) {
      (0, _indexMjs.mount_component)(t, e, l), n = !0;
    },
    p(e, n) {
      const l = {};
      2097152 & n[0] | 33554432 & n[2] && (l.$$scope = {
        dirty: n,
        ctx: e
      }), t.$set(l);
    },
    i(e) {
      n || ((0, _indexMjs.transition_in)(t.$$.fragment, e), n = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(t.$$.fragment, e), n = !1;
    },
    d(e) {
      (0, _indexMjs.destroy_component)(t, e);
    }
  };
}
function Je(e) {
  let t;
  return {
    c() {
      t = (0, _indexMjs.text)(e[21]);
    },
    m(e, n) {
      (0, _indexMjs.insert)(e, t, n);
    },
    p(e, n) {
      2097152 & n[0] && (0, _indexMjs.set_data)(t, e[21]);
    },
    d(e) {
      e && (0, _indexMjs.detach)(t);
    }
  };
}
function Ke(e) {
  let t;
  const n = e[56].trailingIcon,
    l = (0, _indexMjs.create_slot)(n, e, e[87], xe);
  return {
    c() {
      l && l.c();
    },
    m(e, n) {
      l && l.m(e, n), t = !0;
    },
    p(e, i) {
      l && l.p && (!t || 33554432 & i[2]) && (0, _indexMjs.update_slot_base)(l, n, e, e[87], t ? (0, _indexMjs.get_slot_changes)(n, e[87], i, ge) : (0, _indexMjs.get_all_dirty_from_scope)(e[87]), xe);
    },
    i(e) {
      t || ((0, _indexMjs.transition_in)(l, e), t = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(l, e), t = !1;
    },
    d(e) {
      l && l.d(e);
    }
  };
}
function Qe(e) {
  let t, n;
  const l = [(0, _prefixFilter.prefixFilter)(e[46], "ripple$")];
  let i = {};
  for (let e = 0; e < l.length; e += 1) i = (0, _indexMjs.assign)(i, l[e]);
  return t = new _LineRippleSvelte.default({
    props: i
  }), e[77](t), {
    c() {
      (0, _indexMjs.create_component)(t.$$.fragment);
    },
    m(e, l) {
      (0, _indexMjs.mount_component)(t, e, l), n = !0;
    },
    p(e, n) {
      const i = 32768 & n[1] ? (0, _indexMjs.get_spread_update)(l, [(0, _indexMjs.get_spread_object)((0, _prefixFilter.prefixFilter)(e[46], "ripple$"))]) : {};
      t.$set(i);
    },
    i(e) {
      n || ((0, _indexMjs.transition_in)(t.$$.fragment, e), n = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(t.$$.fragment, e), n = !1;
    },
    d(n) {
      e[77](null), (0, _indexMjs.destroy_component)(t, n);
    }
  };
}
function Xe(e) {
  let t, n;
  const l = [(0, _prefixFilter.prefixFilter)(e[46], "helperLine$")];
  let i = {
    $$slots: {
      default: [Ye]
    },
    $$scope: {
      ctx: e
    }
  };
  for (let e = 0; e < l.length; e += 1) i = (0, _indexMjs.assign)(i, l[e]);
  return t = new _HelperLine.default({
    props: i
  }), t.$on("SMUITextfieldHelperText:id", e[41]), t.$on("SMUITextfieldHelperText:mount", e[42]), t.$on("SMUITextfieldHelperText:unmount", e[85]), t.$on("SMUITextfieldCharacterCounter:mount", e[40]), t.$on("SMUITextfieldCharacterCounter:unmount", e[86]), {
    c() {
      (0, _indexMjs.create_component)(t.$$.fragment);
    },
    m(e, l) {
      (0, _indexMjs.mount_component)(t, e, l), n = !0;
    },
    p(e, n) {
      const i = 32768 & n[1] ? (0, _indexMjs.get_spread_update)(l, [(0, _indexMjs.get_spread_object)((0, _prefixFilter.prefixFilter)(e[46], "helperLine$"))]) : {};
      33554432 & n[2] && (i.$$scope = {
        dirty: n,
        ctx: e
      }), t.$set(i);
    },
    i(e) {
      n || ((0, _indexMjs.transition_in)(t.$$.fragment, e), n = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(t.$$.fragment, e), n = !1;
    },
    d(e) {
      (0, _indexMjs.destroy_component)(t, e);
    }
  };
}
function Ye(e) {
  let t;
  const n = e[56].helper,
    l = (0, _indexMjs.create_slot)(n, e, e[87], oe);
  return {
    c() {
      l && l.c();
    },
    m(e, n) {
      l && l.m(e, n), t = !0;
    },
    p(e, i) {
      l && l.p && (!t || 33554432 & i[2]) && (0, _indexMjs.update_slot_base)(l, n, e, e[87], t ? (0, _indexMjs.get_slot_changes)(n, e[87], i, de) : (0, _indexMjs.get_all_dirty_from_scope)(e[87]), oe);
    },
    i(e) {
      t || ((0, _indexMjs.transition_in)(l, e), t = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(l, e), t = !1;
    },
    d(e) {
      l && l.d(e);
    }
  };
}
function Ze(e) {
  let t, n, s, f, p;
  const m = [Ue, Ne],
    $ = [];
  t = function (e, t) {
    return e[36] ? 0 : 1;
  }(e), n = $[t] = m[t](e);
  let g = e[47].helper && Xe(e);
  return {
    c() {
      n.c(), s = (0, _indexMjs.space)(), g && g.c(), f = (0, _indexMjs.empty)();
    },
    m(e, n) {
      $[t].m(e, n), (0, _indexMjs.insert)(e, s, n), g && g.m(e, n), (0, _indexMjs.insert)(e, f, n), p = !0;
    },
    p(e, t) {
      n.p(e, t), e[47].helper ? g ? (g.p(e, t), 65536 & t[1] && (0, _indexMjs.transition_in)(g, 1)) : (g = Xe(e), g.c(), (0, _indexMjs.transition_in)(g, 1), g.m(f.parentNode, f)) : g && ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(g, 1, 1, () => {
        g = null;
      }), (0, _indexMjs.check_outros)());
    },
    i(e) {
      p || ((0, _indexMjs.transition_in)(n), (0, _indexMjs.transition_in)(g), p = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(n), (0, _indexMjs.transition_out)(g), p = !1;
    },
    d(e) {
      $[t].d(e), e && (0, _indexMjs.detach)(s), g && g.d(e), e && (0, _indexMjs.detach)(f);
    }
  };
}
const et = ([e, t]) => `${e}: ${t};`,
  tt = ([e, t]) => `${e}: ${t};`;
function nt(e, t, n) {
  let l;
  const i = ["use", "class", "style", "ripple", "disabled", "required", "textarea", "variant", "noLabel", "label", "type", "value", "files", "invalid", "updateInvalid", "dirty", "prefix", "suffix", "validateOnValueChange", "useNativeValidation", "withLeadingIcon", "withTrailingIcon", "input", "floatingLabel", "lineRipple", "notchedOutline", "focus", "blur", "layout", "getElement"];
  let a = (0, _indexMjs.compute_rest_props)(t, i),
    {
      $$slots: d = {},
      $$scope: o
    } = t;
  const r = (0, _indexMjs.compute_slots)(d),
    {
      applyPassive: u
    } = _,
    c = (0, _forwardEventsBuilder.forwardEventsBuilder)((0, _indexMjs.get_current_component)());
  let h = () => {};
  function I(e) {
    return e === h;
  }
  let {
      use: y = []
    } = t,
    {
      class: w = ""
    } = t,
    {
      style: L = ""
    } = t,
    {
      ripple: C = !0
    } = t,
    {
      disabled: j = !1
    } = t,
    {
      required: S = !1
    } = t,
    {
      textarea: M = !1
    } = t,
    {
      variant: N = M ? "outlined" : "standard"
    } = t,
    {
      noLabel: U = !1
    } = t,
    {
      label: O
    } = t,
    {
      type: V = "text"
    } = t,
    {
      value: E = a.input$emptyValueUndefined ? void 0 : h
    } = t,
    {
      files: q = h
    } = t;
  const R = !I(E) || !I(q);
  I(E) && (E = void 0), I(q) && (q = null);
  let {
      invalid: A = h
    } = t,
    {
      updateInvalid: H = I(A)
    } = t;
  I(A) && (A = !1);
  let z,
    F,
    k,
    P,
    B,
    G,
    J,
    K,
    Q,
    {
      dirty: X = !1
    } = t,
    {
      prefix: Y
    } = t,
    {
      suffix: Z
    } = t,
    {
      validateOnValueChange: ee = H
    } = t,
    {
      useNativeValidation: te = H
    } = t,
    {
      withLeadingIcon: ne = h
    } = t,
    {
      withTrailingIcon: le = h
    } = t,
    {
      input: ie
    } = t,
    {
      floatingLabel: de
    } = t,
    {
      lineRipple: oe
    } = t,
    {
      notchedOutline: re
    } = t,
    ue = {},
    ce = {},
    se = !1,
    fe = (0, _indexMjs.getContext)("SMUI:addLayoutListener"),
    pe = new Promise(e => B = e),
    me = E;
  function $e(e) {
    var t;
    return e in ue ? null !== (t = ue[e]) && void 0 !== t ? t : null : be().classList.contains(e);
  }
  function ge(e) {
    ue[e] || n(25, ue[e] = !0, ue);
  }
  function xe(e) {
    e in ue && !ue[e] || n(25, ue[e] = !1, ue);
  }
  function ve() {
    if (F) {
      const e = F.shouldFloat;
      F.notchOutline(e);
    }
  }
  function be() {
    return z;
  }
  fe && (P = fe(ve)), (0, _indexMjs.onMount)(() => {
    if (n(54, F = new _foundation.MDCTextFieldFoundation({
      addClass: ge,
      removeClass: xe,
      hasClass: $e,
      registerTextFieldInteractionHandler: (e, t) => be().addEventListener(e, t),
      deregisterTextFieldInteractionHandler: (e, t) => be().removeEventListener(e, t),
      registerValidationAttributeChangeHandler: e => {
        const t = new MutationObserver(t => {
            te && e((e => e.map(e => e.attributeName).filter(e => e))(t));
          }),
          n = {
            attributes: !0
          };
        return ie && t.observe(ie.getElement(), n), t;
      },
      deregisterValidationAttributeChangeHandler: e => {
        e.disconnect();
      },
      getNativeInput: () => {
        var e;
        return null !== (e = null == ie ? void 0 : ie.getElement()) && void 0 !== e ? e : null;
      },
      setInputAttr: (e, t) => {
        null == ie || ie.addAttr(e, t);
      },
      removeInputAttr: e => {
        null == ie || ie.removeAttr(e);
      },
      isFocused: () => document.activeElement === (null == ie ? void 0 : ie.getElement()),
      registerInputInteractionHandler: (e, t) => {
        null == ie || ie.getElement().addEventListener(e, t, u());
      },
      deregisterInputInteractionHandler: (e, t) => {
        null == ie || ie.getElement().removeEventListener(e, t, u());
      },
      floatLabel: e => de && de.float(e),
      getLabelWidth: () => de ? de.getWidth() : 0,
      hasLabel: () => !!de,
      shakeLabel: e => de && de.shake(e),
      setLabelRequired: e => de && de.setRequired(e),
      activateLineRipple: () => oe && oe.activate(),
      deactivateLineRipple: () => oe && oe.deactivate(),
      setLineRippleTransformOrigin: e => oe && oe.setRippleCenter(e),
      closeOutline: () => re && re.closeNotch(),
      hasOutline: () => !!re,
      notchOutline: e => re && re.notch(e)
    }, {
      get helperText() {
        return K;
      },
      get characterCounter() {
        return Q;
      },
      get leadingIcon() {
        return G;
      },
      get trailingIcon() {
        return J;
      }
    })), R) {
      if (null == ie) throw new Error("SMUI Textfield initialized without Input component.");
      F.init();
    } else (0, _indexMjs.tick)().then(() => {
      if (null == ie) throw new Error("SMUI Textfield initialized without Input component.");
      F.init();
    });
    return B(), () => {
      F.destroy();
    };
  }), (0, _indexMjs.onDestroy)(() => {
    P && P();
  });
  return e.$$set = e => {
    t = (0, _indexMjs.assign)((0, _indexMjs.assign)({}, t), (0, _indexMjs.exclude_internal_props)(e)), n(46, a = (0, _indexMjs.compute_rest_props)(t, i)), "use" in e && n(8, y = e.use), "class" in e && n(9, w = e.class), "style" in e && n(10, L = e.style), "ripple" in e && n(11, C = e.ripple), "disabled" in e && n(12, j = e.disabled), "required" in e && n(13, S = e.required), "textarea" in e && n(14, M = e.textarea), "variant" in e && n(15, N = e.variant), "noLabel" in e && n(16, U = e.noLabel), "label" in e && n(17, O = e.label), "type" in e && n(18, V = e.type), "value" in e && n(0, E = e.value), "files" in e && n(3, q = e.files), "invalid" in e && n(1, A = e.invalid), "updateInvalid" in e && n(19, H = e.updateInvalid), "dirty" in e && n(4, X = e.dirty), "prefix" in e && n(20, Y = e.prefix), "suffix" in e && n(21, Z = e.suffix), "validateOnValueChange" in e && n(48, ee = e.validateOnValueChange), "useNativeValidation" in e && n(49, te = e.useNativeValidation), "withLeadingIcon" in e && n(22, ne = e.withLeadingIcon), "withTrailingIcon" in e && n(23, le = e.withTrailingIcon), "input" in e && n(2, ie = e.input), "floatingLabel" in e && n(5, de = e.floatingLabel), "lineRipple" in e && n(6, oe = e.lineRipple), "notchedOutline" in e && n(7, re = e.notchedOutline), "$$scope" in e && n(87, o = e.$$scope);
  }, e.$$.update = () => {
    if (4 & e.$$.dirty[0] && n(33, l = ie && ie.getElement()), 524290 & e.$$.dirty[0] | 8388608 & e.$$.dirty[1] && F && F.isValid() !== !A && (H ? n(1, A = !F.isValid()) : F.setValid(!A)), 8519680 & e.$$.dirty[1] && F && F.getValidateOnValueChange() !== ee && F.setValidateOnValueChange(!I(ee) && ee), 8650752 & e.$$.dirty[1] && F && F.setUseNativeValidation(!!I(te) || te), 4096 & e.$$.dirty[0] | 8388608 & e.$$.dirty[1] && F && F.setDisabled(j), 1 & e.$$.dirty[0] | 25165824 & e.$$.dirty[1] && F && R && me !== E) {
      n(55, me = E);
      const e = `${E}`;
      F.getValue() !== e && F.setValue(e);
    }
  }, [E, A, ie, q, X, de, oe, re, y, w, L, C, j, S, M, N, U, O, V, H, Y, Z, ne, le, z, ue, ce, k, se, G, J, K, Q, l, c, I, R, pe, function (e) {
    n(29, G = e.detail);
  }, function (e) {
    n(30, J = e.detail);
  }, function (e) {
    n(32, Q = e.detail);
  }, function (e) {
    n(27, k = e.detail);
  }, function (e) {
    n(31, K = e.detail);
  }, ge, xe, function (e, t) {
    ce[e] != t && ("" === t || null == t ? (delete ce[e], n(26, ce)) : n(26, ce[e] = t, ce));
  }, a, r, ee, te, function () {
    null == ie || ie.focus();
  }, function () {
    null == ie || ie.blur();
  }, ve, be, F, me, d, function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      de = e, n(5, de);
    });
  }, function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      de = e, n(5, de);
    });
  }, function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      re = e, n(7, re);
    });
  }, function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      ie = e, n(2, ie);
    });
  }, function (e) {
    E = e, n(0, E);
  }, function (e) {
    X = e, n(4, X);
  }, function (e) {
    A = e, n(1, A), n(54, F), n(19, H);
  }, () => n(28, se = !1), () => n(28, se = !0), e => (0, _dispatch.dispatch)(z, "blur", e), e => (0, _dispatch.dispatch)(z, "focus", e), function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      ie = e, n(2, ie);
    });
  }, function (e) {
    E = e, n(0, E);
  }, function (e) {
    q = e, n(3, q);
  }, function (e) {
    X = e, n(4, X);
  }, function (e) {
    A = e, n(1, A), n(54, F), n(19, H);
  }, () => n(28, se = !1), () => n(28, se = !0), e => (0, _dispatch.dispatch)(z, "blur", e), e => (0, _dispatch.dispatch)(z, "focus", e), function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      oe = e, n(6, oe);
    });
  }, function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      z = e, n(24, z);
    });
  }, () => n(29, G = void 0), () => n(30, J = void 0), () => n(32, Q = void 0), function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      z = e, n(24, z);
    });
  }, () => n(29, G = void 0), () => n(30, J = void 0), () => {
    n(27, k = void 0), n(31, K = void 0);
  }, () => n(32, Q = void 0), o];
}
class lt extends _indexMjs.SvelteComponent {
  constructor(e) {
    super(), (0, _indexMjs.init)(this, e, nt, Ze, _indexMjs.safe_not_equal, {
      use: 8,
      class: 9,
      style: 10,
      ripple: 11,
      disabled: 12,
      required: 13,
      textarea: 14,
      variant: 15,
      noLabel: 16,
      label: 17,
      type: 18,
      value: 0,
      files: 3,
      invalid: 1,
      updateInvalid: 19,
      dirty: 4,
      prefix: 20,
      suffix: 21,
      validateOnValueChange: 48,
      useNativeValidation: 49,
      withLeadingIcon: 22,
      withTrailingIcon: 23,
      input: 2,
      floatingLabel: 5,
      lineRipple: 6,
      notchedOutline: 7,
      focus: 50,
      blur: 51,
      layout: 52,
      getElement: 53
    }, null, [-1, -1, -1, -1]);
  }
  get focus() {
    return this.$$.ctx[50];
  }
  get blur() {
    return this.$$.ctx[51];
  }
  get layout() {
    return this.$$.ctx[52];
  }
  get getElement() {
    return this.$$.ctx[53];
  }
}
exports.default = lt;
},{"../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../../../@material/dom/events.js":"../node_modules/@cosmograph/ui/ext/@material/dom/events.js","../../common/dist/internal/classMap.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/classMap.js","../../common/dist/internal/dispatch.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/dispatch.js","../../common/dist/internal/exclude.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/exclude.js","../../common/dist/internal/forwardEventsBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js","../../common/dist/internal/prefixFilter.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/prefixFilter.js","../../common/dist/internal/useActions.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/useActions.js","../../common/dist/ContextFragment.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/ContextFragment.svelte.js","../../ripple/dist/Ripple.js":"../node_modules/@cosmograph/ui/ext/@smui/ripple/dist/Ripple.js","../../floating-label/dist/FloatingLabel.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/floating-label/dist/FloatingLabel.svelte.js","../../line-ripple/dist/LineRipple.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/line-ripple/dist/LineRipple.svelte.js","../../notched-outline/dist/NotchedOutline.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/notched-outline/dist/NotchedOutline.svelte.js","./HelperLine.js":"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/HelperLine.js","./Prefix.js":"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/Prefix.js","./Suffix.js":"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/Suffix.js","./Input.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/Input.svelte.js","./Textarea.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/Textarea.svelte.js","../../../@material/textfield/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/textfield/foundation.js"}],"../node_modules/@cosmograph/ui/ext/@material/textfield/icon/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.strings = exports.cssClasses = void 0;
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var t = exports.strings = {
    ICON_EVENT: "MDCTextField:icon",
    ICON_ROLE: "button"
  },
  e = exports.cssClasses = {
    ROOT: "mdc-text-field__icon"
  };
},{}],"../node_modules/@cosmograph/ui/ext/@material/textfield/icon/foundation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MDCTextFieldIconFoundation = void 0;
var _tslib = require("../../../../_virtual/_tslib.js");
var _foundation = require("../../base/foundation.js");
var _constants = require("./constants.js");
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var o = ["click", "keydown"],
  s = exports.default = exports.MDCTextFieldIconFoundation = function (n) {
    function s(t) {
      var r = n.call(this, (0, _tslib.__assign)((0, _tslib.__assign)({}, s.defaultAdapter), t)) || this;
      return r.savedTabIndex = null, r.interactionHandler = function (t) {
        r.handleInteraction(t);
      }, r;
    }
    return (0, _tslib.__extends)(s, n), Object.defineProperty(s, "strings", {
      get: function () {
        return _constants.strings;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(s, "cssClasses", {
      get: function () {
        return _constants.cssClasses;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(s, "defaultAdapter", {
      get: function () {
        return {
          getAttr: function () {
            return null;
          },
          setAttr: function () {},
          removeAttr: function () {},
          setContent: function () {},
          registerInteractionHandler: function () {},
          deregisterInteractionHandler: function () {},
          notifyIconAction: function () {}
        };
      },
      enumerable: !1,
      configurable: !0
    }), s.prototype.init = function () {
      var t, e;
      this.savedTabIndex = this.adapter.getAttr("tabindex");
      try {
        for (var n = (0, _tslib.__values)(o), a = n.next(); !a.done; a = n.next()) {
          var i = a.value;
          this.adapter.registerInteractionHandler(i, this.interactionHandler);
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          a && !a.done && (e = n.return) && e.call(n);
        } finally {
          if (t) throw t.error;
        }
      }
    }, s.prototype.destroy = function () {
      var t, e;
      try {
        for (var n = (0, _tslib.__values)(o), a = n.next(); !a.done; a = n.next()) {
          var i = a.value;
          this.adapter.deregisterInteractionHandler(i, this.interactionHandler);
        }
      } catch (e) {
        t = {
          error: e
        };
      } finally {
        try {
          a && !a.done && (e = n.return) && e.call(n);
        } finally {
          if (t) throw t.error;
        }
      }
    }, s.prototype.setDisabled = function (t) {
      this.savedTabIndex && (t ? (this.adapter.setAttr("tabindex", "-1"), this.adapter.removeAttr("role")) : (this.adapter.setAttr("tabindex", this.savedTabIndex), this.adapter.setAttr("role", _constants.strings.ICON_ROLE)));
    }, s.prototype.setAriaLabel = function (t) {
      this.adapter.setAttr("aria-label", t);
    }, s.prototype.setContent = function (t) {
      this.adapter.setContent(t);
    }, s.prototype.handleInteraction = function (t) {
      var e = "Enter" === t.key || 13 === t.keyCode;
      ("click" === t.type || e) && (t.preventDefault(), this.adapter.notifyIconAction());
    }, s;
  }(_foundation.MDCFoundation);
},{"../../../../_virtual/_tslib.js":"../node_modules/@cosmograph/ui/_virtual/_tslib.js","../../base/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/base/foundation.js","./constants.js":"../node_modules/@cosmograph/ui/ext/@material/textfield/icon/constants.js"}],"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/icon/Icon.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("../../../../svelte/internal/index.mjs.js");
var _classMap = require("../../../common/dist/internal/classMap.js");
var _dispatch = require("../../../common/dist/internal/dispatch.js");
var _forwardEventsBuilder = require("../../../common/dist/internal/forwardEventsBuilder.js");
var _useActions = require("../../../common/dist/internal/useActions.js");
var _foundation = require("../../../../@material/textfield/icon/foundation.js");
function C(t) {
  let e;
  return {
    c() {
      e = (0, _indexMjs.text)(t[7]);
    },
    m(t, n) {
      (0, _indexMjs.insert)(t, e, n);
    },
    p(t, n) {
      128 & n && (0, _indexMjs.set_data)(e, t[7]);
    },
    i: _indexMjs.noop,
    o: _indexMjs.noop,
    d(t) {
      t && (0, _indexMjs.detach)(e);
    }
  };
}
function F(t) {
  let e;
  const n = t[15].default,
    i = (0, _indexMjs.create_slot)(n, t, t[14], null);
  return {
    c() {
      i && i.c();
    },
    m(t, n) {
      i && i.m(t, n), e = !0;
    },
    p(t, l) {
      i && i.p && (!e || 16384 & l) && (0, _indexMjs.update_slot_base)(i, n, t, t[14], e ? (0, _indexMjs.get_slot_changes)(n, t[14], l, null) : (0, _indexMjs.get_all_dirty_from_scope)(t[14]), null);
    },
    i(t) {
      e || ((0, _indexMjs.transition_in)(i, t), e = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(i, t), e = !1;
    },
    d(t) {
      i && i.d(t);
    }
  };
}
function k(t) {
  let e, n, g, b, $, v, I, _, h, j;
  const M = [F, C],
    T = [];
  function A(t, e) {
    return null == t[7] ? 0 : 1;
  }
  n = A(t), g = T[n] = M[n](t);
  let E = [{
      class: b = (0, _classMap.classMap)({
        [t[1]]: !0,
        "mdc-text-field__icon": !0,
        "mdc-text-field__icon--leading": t[11],
        "mdc-text-field__icon--trailing": !t[11]
      })
    }, {
      "aria-hidden": $ = -1 === t[3] ? "true" : "false"
    }, {
      "aria-disabled": v = "button" === t[2] ? t[4] ? "true" : "false" : void 0
    }, t[8], t[6], t[12]],
    S = {};
  for (let t = 0; t < E.length; t += 1) S = (0, _indexMjs.assign)(S, E[t]);
  return {
    c() {
      e = (0, _indexMjs.element)("i"), g.c(), (0, _indexMjs.set_attributes)(e, S);
    },
    m(i, l) {
      (0, _indexMjs.insert)(i, e, l), T[n].m(e, null), t[16](e), _ = !0, h || (j = [(0, _indexMjs.action_destroyer)(I = _useActions.useActions.call(null, e, t[0])), (0, _indexMjs.action_destroyer)(t[9].call(null, e))], h = !0);
    },
    p(t, [i]) {
      let l = n;
      n = A(t), n === l ? T[n].p(t, i) : ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(T[l], 1, 1, () => {
        T[l] = null;
      }), (0, _indexMjs.check_outros)(), g = T[n], g ? g.p(t, i) : (g = T[n] = M[n](t), g.c()), (0, _indexMjs.transition_in)(g, 1), g.m(e, null)), (0, _indexMjs.set_attributes)(e, S = (0, _indexMjs.get_spread_update)(E, [(!_ || 2 & i && b !== (b = (0, _classMap.classMap)({
        [t[1]]: !0,
        "mdc-text-field__icon": !0,
        "mdc-text-field__icon--leading": t[11],
        "mdc-text-field__icon--trailing": !t[11]
      }))) && {
        class: b
      }, (!_ || 8 & i && $ !== ($ = -1 === t[3] ? "true" : "false")) && {
        "aria-hidden": $
      }, (!_ || 20 & i && v !== (v = "button" === t[2] ? t[4] ? "true" : "false" : void 0)) && {
        "aria-disabled": v
      }, 256 & i && t[8], 64 & i && t[6], 4096 & i && t[12]])), I && (0, _indexMjs.is_function)(I.update) && 1 & i && I.update.call(null, t[0]);
    },
    i(t) {
      _ || ((0, _indexMjs.transition_in)(g), _ = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(g), _ = !1;
    },
    d(i) {
      i && (0, _indexMjs.detach)(e), T[n].d(), t[16](null), h = !1, (0, _indexMjs.run_all)(j);
    }
  };
}
function q(t, e, n) {
  let l;
  const o = ["use", "class", "role", "tabindex", "disabled", "getElement"];
  let d,
    r = (0, _indexMjs.compute_rest_props)(e, o),
    {
      $$slots: s = {},
      $$scope: a
    } = e;
  const c = (0, _forwardEventsBuilder.forwardEventsBuilder)((0, _indexMjs.get_current_component)());
  let u,
    m,
    {
      use: f = []
    } = e,
    {
      class: p = ""
    } = e,
    {
      role: x
    } = e,
    {
      tabindex: j = "button" === x ? 0 : -1
    } = e,
    {
      disabled: M = !1
    } = e,
    T = {};
  const A = (0, _indexMjs.getContext)("SMUI:textfield:icon:leading");
  (0, _indexMjs.component_subscribe)(t, A, t => n(18, d = t));
  const E = d;
  let S;
  function U(t) {
    var e;
    return t in T ? null !== (e = T[t]) && void 0 !== e ? e : null : C().getAttribute(t);
  }
  function L(t, e) {
    T[t] !== e && n(6, T[t] = e, T);
  }
  function H(t) {
    t in T && null == T[t] || n(6, T[t] = void 0, T);
  }
  function C() {
    return u;
  }
  return (0, _indexMjs.onMount)(() => (m = new _foundation.MDCTextFieldIconFoundation({
    getAttr: U,
    setAttr: L,
    removeAttr: H,
    setContent: t => {
      n(7, S = t);
    },
    registerInteractionHandler: (t, e) => C().addEventListener(t, e),
    deregisterInteractionHandler: (t, e) => C().removeEventListener(t, e),
    notifyIconAction: () => (0, _dispatch.dispatch)(C(), "SMUITextField:icon", void 0, void 0, !0)
  }), (0, _dispatch.dispatch)(C(), E ? "SMUITextfieldLeadingIcon:mount" : "SMUITextfieldTrailingIcon:mount", m), m.init(), () => {
    (0, _dispatch.dispatch)(C(), E ? "SMUITextfieldLeadingIcon:unmount" : "SMUITextfieldTrailingIcon:unmount", m), m.destroy();
  })), t.$$set = t => {
    e = (0, _indexMjs.assign)((0, _indexMjs.assign)({}, e), (0, _indexMjs.exclude_internal_props)(t)), n(12, r = (0, _indexMjs.compute_rest_props)(e, o)), "use" in t && n(0, f = t.use), "class" in t && n(1, p = t.class), "role" in t && n(2, x = t.role), "tabindex" in t && n(3, j = t.tabindex), "disabled" in t && n(4, M = t.disabled), "$$scope" in t && n(14, a = t.$$scope);
  }, t.$$.update = () => {
    12 & t.$$.dirty && n(8, l = {
      role: x,
      tabindex: j
    });
  }, [f, p, x, j, M, u, T, S, l, c, A, E, r, C, a, s, function (t) {
    _indexMjs.binding_callbacks[t ? "unshift" : "push"](() => {
      u = t, n(5, u);
    });
  }];
}
class z extends _indexMjs.SvelteComponent {
  constructor(t) {
    super(), (0, _indexMjs.init)(this, t, q, k, _indexMjs.safe_not_equal, {
      use: 0,
      class: 1,
      role: 2,
      tabindex: 3,
      disabled: 4,
      getElement: 13
    });
  }
  get getElement() {
    return this.$$.ctx[13];
  }
}
exports.default = z;
},{"../../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../../../common/dist/internal/classMap.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/classMap.js","../../../common/dist/internal/dispatch.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/dispatch.js","../../../common/dist/internal/forwardEventsBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js","../../../common/dist/internal/useActions.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/useActions.js","../../../../@material/textfield/icon/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/textfield/icon/foundation.js"}],"../node_modules/@cosmograph/ui/ext/@material/menu-surface/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.strings = exports.numbers = exports.cssClasses = exports.CornerBit = exports.Corner = void 0;
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var T,
  O,
  e = exports.cssClasses = {
    ANCHOR: "mdc-menu-surface--anchor",
    ANIMATING_CLOSED: "mdc-menu-surface--animating-closed",
    ANIMATING_OPEN: "mdc-menu-surface--animating-open",
    FIXED: "mdc-menu-surface--fixed",
    IS_OPEN_BELOW: "mdc-menu-surface--is-open-below",
    OPEN: "mdc-menu-surface--open",
    ROOT: "mdc-menu-surface"
  },
  E = exports.strings = {
    CLOSED_EVENT: "MDCMenuSurface:closed",
    CLOSING_EVENT: "MDCMenuSurface:closing",
    OPENED_EVENT: "MDCMenuSurface:opened",
    OPENING_EVENT: "MDCMenuSurface:opening",
    FOCUSABLE_ELEMENTS: ["button:not(:disabled)", '[href]:not([aria-disabled="true"])', "input:not(:disabled)", "select:not(:disabled)", "textarea:not(:disabled)", '[tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'].join(", ")
  },
  _ = exports.numbers = {
    TRANSITION_OPEN_DURATION: 120,
    TRANSITION_CLOSE_DURATION: 75,
    MARGIN_TO_EDGE: 32,
    ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: .67,
    TOUCH_EVENT_WAIT_MS: 30
  };
!function (T) {
  T[T.BOTTOM = 1] = "BOTTOM", T[T.CENTER = 2] = "CENTER", T[T.RIGHT = 4] = "RIGHT", T[T.FLIP_RTL = 8] = "FLIP_RTL";
}(T || (exports.CornerBit = T = {})), function (T) {
  T[T.TOP_LEFT = 0] = "TOP_LEFT", T[T.TOP_RIGHT = 4] = "TOP_RIGHT", T[T.BOTTOM_LEFT = 1] = "BOTTOM_LEFT", T[T.BOTTOM_RIGHT = 5] = "BOTTOM_RIGHT", T[T.TOP_START = 8] = "TOP_START", T[T.TOP_END = 12] = "TOP_END", T[T.BOTTOM_START = 9] = "BOTTOM_START", T[T.BOTTOM_END = 13] = "BOTTOM_END";
}(O || (exports.Corner = O = {}));
},{}],"../node_modules/@cosmograph/ui/ext/@material/menu-surface/foundation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MDCMenuSurfaceFoundation = void 0;
var _tslib = require("../../../_virtual/_tslib.js");
var _foundation = require("../base/foundation.js");
var _constants = require("./constants.js");
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var c = exports.default = exports.MDCMenuSurfaceFoundation = function (n) {
  function c(t) {
    var e = n.call(this, (0, _tslib.__assign)((0, _tslib.__assign)({}, c.defaultAdapter), t)) || this;
    return e.isSurfaceOpen = !1, e.isQuickOpen = !1, e.isHoistedElement = !1, e.isFixedPosition = !1, e.isHorizontallyCenteredOnViewport = !1, e.maxHeight = 0, e.openBottomBias = 0, e.openAnimationEndTimerId = 0, e.closeAnimationEndTimerId = 0, e.animationRequestId = 0, e.anchorCorner = _constants.Corner.TOP_START, e.originCorner = _constants.Corner.TOP_START, e.anchorMargin = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, e.position = {
      x: 0,
      y: 0
    }, e;
  }
  return (0, _tslib.__extends)(c, n), Object.defineProperty(c, "cssClasses", {
    get: function () {
      return _constants.cssClasses;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(c, "strings", {
    get: function () {
      return _constants.strings;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(c, "numbers", {
    get: function () {
      return _constants.numbers;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(c, "Corner", {
    get: function () {
      return _constants.Corner;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(c, "defaultAdapter", {
    get: function () {
      return {
        addClass: function () {},
        removeClass: function () {},
        hasClass: function () {
          return !1;
        },
        hasAnchor: function () {
          return !1;
        },
        isElementInContainer: function () {
          return !1;
        },
        isFocused: function () {
          return !1;
        },
        isRtl: function () {
          return !1;
        },
        getInnerDimensions: function () {
          return {
            height: 0,
            width: 0
          };
        },
        getAnchorDimensions: function () {
          return null;
        },
        getWindowDimensions: function () {
          return {
            height: 0,
            width: 0
          };
        },
        getBodyDimensions: function () {
          return {
            height: 0,
            width: 0
          };
        },
        getWindowScroll: function () {
          return {
            x: 0,
            y: 0
          };
        },
        setPosition: function () {},
        setMaxHeight: function () {},
        setTransformOrigin: function () {},
        saveFocus: function () {},
        restoreFocus: function () {},
        notifyClose: function () {},
        notifyClosing: function () {},
        notifyOpen: function () {},
        notifyOpening: function () {}
      };
    },
    enumerable: !1,
    configurable: !0
  }), c.prototype.init = function () {
    var t = c.cssClasses,
      i = t.ROOT,
      e = t.OPEN;
    if (!this.adapter.hasClass(i)) throw new Error(i + " class required in root element.");
    this.adapter.hasClass(e) && (this.isSurfaceOpen = !0);
  }, c.prototype.destroy = function () {
    clearTimeout(this.openAnimationEndTimerId), clearTimeout(this.closeAnimationEndTimerId), cancelAnimationFrame(this.animationRequestId);
  }, c.prototype.setAnchorCorner = function (t) {
    this.anchorCorner = t;
  }, c.prototype.flipCornerHorizontally = function () {
    this.originCorner = this.originCorner ^ _constants.CornerBit.RIGHT;
  }, c.prototype.setAnchorMargin = function (t) {
    this.anchorMargin.top = t.top || 0, this.anchorMargin.right = t.right || 0, this.anchorMargin.bottom = t.bottom || 0, this.anchorMargin.left = t.left || 0;
  }, c.prototype.setIsHoisted = function (t) {
    this.isHoistedElement = t;
  }, c.prototype.setFixedPosition = function (t) {
    this.isFixedPosition = t;
  }, c.prototype.isFixed = function () {
    return this.isFixedPosition;
  }, c.prototype.setAbsolutePosition = function (t, i) {
    this.position.x = this.isFinite(t) ? t : 0, this.position.y = this.isFinite(i) ? i : 0;
  }, c.prototype.setIsHorizontallyCenteredOnViewport = function (t) {
    this.isHorizontallyCenteredOnViewport = t;
  }, c.prototype.setQuickOpen = function (t) {
    this.isQuickOpen = t;
  }, c.prototype.setMaxHeight = function (t) {
    this.maxHeight = t;
  }, c.prototype.setOpenBottomBias = function (t) {
    this.openBottomBias = t;
  }, c.prototype.isOpen = function () {
    return this.isSurfaceOpen;
  }, c.prototype.open = function () {
    var t = this;
    this.isSurfaceOpen || (this.adapter.notifyOpening(), this.adapter.saveFocus(), this.isQuickOpen ? (this.isSurfaceOpen = !0, this.adapter.addClass(c.cssClasses.OPEN), this.dimensions = this.adapter.getInnerDimensions(), this.autoposition(), this.adapter.notifyOpen()) : (this.adapter.addClass(c.cssClasses.ANIMATING_OPEN), this.animationRequestId = requestAnimationFrame(function () {
      t.dimensions = t.adapter.getInnerDimensions(), t.autoposition(), t.adapter.addClass(c.cssClasses.OPEN), t.openAnimationEndTimerId = setTimeout(function () {
        t.openAnimationEndTimerId = 0, t.adapter.removeClass(c.cssClasses.ANIMATING_OPEN), t.adapter.notifyOpen();
      }, _constants.numbers.TRANSITION_OPEN_DURATION);
    }), this.isSurfaceOpen = !0));
  }, c.prototype.close = function (t) {
    var i = this;
    if (void 0 === t && (t = !1), this.isSurfaceOpen) {
      if (this.adapter.notifyClosing(), this.isQuickOpen) return this.isSurfaceOpen = !1, t || this.maybeRestoreFocus(), this.adapter.removeClass(c.cssClasses.OPEN), this.adapter.removeClass(c.cssClasses.IS_OPEN_BELOW), void this.adapter.notifyClose();
      this.adapter.addClass(c.cssClasses.ANIMATING_CLOSED), requestAnimationFrame(function () {
        i.adapter.removeClass(c.cssClasses.OPEN), i.adapter.removeClass(c.cssClasses.IS_OPEN_BELOW), i.closeAnimationEndTimerId = setTimeout(function () {
          i.closeAnimationEndTimerId = 0, i.adapter.removeClass(c.cssClasses.ANIMATING_CLOSED), i.adapter.notifyClose();
        }, _constants.numbers.TRANSITION_CLOSE_DURATION);
      }), this.isSurfaceOpen = !1, t || this.maybeRestoreFocus();
    }
  }, c.prototype.handleBodyClick = function (t) {
    var i = t.target;
    this.adapter.isElementInContainer(i) || this.close();
  }, c.prototype.handleKeydown = function (t) {
    var i = t.keyCode;
    ("Escape" === t.key || 27 === i) && this.close();
  }, c.prototype.autoposition = function () {
    var t;
    this.measurements = this.getAutoLayoutmeasurements();
    var i = this.getoriginCorner(),
      e = this.getMenuSurfaceMaxHeight(i),
      n = this.hasBit(i, _constants.CornerBit.BOTTOM) ? "bottom" : "top",
      s = this.hasBit(i, _constants.CornerBit.RIGHT) ? "right" : "left",
      o = this.getHorizontalOriginOffset(i),
      r = this.getVerticalOriginOffset(i),
      u = this.measurements,
      p = u.anchorSize,
      d = u.surfaceSize,
      f = ((t = {})[s] = o, t[n] = r, t);
    p.width / d.width > _constants.numbers.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO && (s = "center"), (this.isHoistedElement || this.isFixedPosition) && this.adjustPositionForHoistedElement(f), this.adapter.setTransformOrigin(s + " " + n), this.adapter.setPosition(f), this.adapter.setMaxHeight(e ? e + "px" : ""), this.hasBit(i, _constants.CornerBit.BOTTOM) || this.adapter.addClass(c.cssClasses.IS_OPEN_BELOW);
  }, c.prototype.getAutoLayoutmeasurements = function () {
    var t = this.adapter.getAnchorDimensions(),
      i = this.adapter.getBodyDimensions(),
      e = this.adapter.getWindowDimensions(),
      n = this.adapter.getWindowScroll();
    return t || (t = {
      top: this.position.y,
      right: this.position.x,
      bottom: this.position.y,
      left: this.position.x,
      width: 0,
      height: 0
    }), {
      anchorSize: t,
      bodySize: i,
      surfaceSize: this.dimensions,
      viewportDistance: {
        top: t.top,
        right: e.width - t.right,
        bottom: e.height - t.bottom,
        left: t.left
      },
      viewportSize: e,
      windowScroll: n
    };
  }, c.prototype.getoriginCorner = function () {
    var t,
      i,
      e = this.originCorner,
      n = this.measurements,
      s = n.viewportDistance,
      o = n.anchorSize,
      r = n.surfaceSize,
      a = c.numbers.MARGIN_TO_EDGE;
    this.hasBit(this.anchorCorner, _constants.CornerBit.BOTTOM) ? (t = s.top - a + this.anchorMargin.bottom, i = s.bottom - a - this.anchorMargin.bottom) : (t = s.top - a + this.anchorMargin.top, i = s.bottom - a + o.height - this.anchorMargin.top), !(i - r.height > 0) && t > i + this.openBottomBias && (e = this.setBit(e, _constants.CornerBit.BOTTOM));
    var u,
      p,
      d = this.adapter.isRtl(),
      f = this.hasBit(this.anchorCorner, _constants.CornerBit.FLIP_RTL),
      m = this.hasBit(this.anchorCorner, _constants.CornerBit.RIGHT) || this.hasBit(e, _constants.CornerBit.RIGHT),
      l = !1;
    (l = d && f ? !m : m) ? (u = s.left + o.width + this.anchorMargin.right, p = s.right - this.anchorMargin.right) : (u = s.left + this.anchorMargin.left, p = s.right + o.width - this.anchorMargin.left);
    var g = u - r.width > 0,
      O = p - r.width > 0,
      y = this.hasBit(e, _constants.CornerBit.FLIP_RTL) && this.hasBit(e, _constants.CornerBit.RIGHT);
    return O && y && d || !g && y ? e = this.unsetBit(e, _constants.CornerBit.RIGHT) : (g && l && d || g && !l && m || !O && u >= p) && (e = this.setBit(e, _constants.CornerBit.RIGHT)), e;
  }, c.prototype.getMenuSurfaceMaxHeight = function (t) {
    if (this.maxHeight > 0) return this.maxHeight;
    var i = this.measurements.viewportDistance,
      e = 0,
      n = this.hasBit(t, _constants.CornerBit.BOTTOM),
      s = this.hasBit(this.anchorCorner, _constants.CornerBit.BOTTOM),
      o = c.numbers.MARGIN_TO_EDGE;
    return n ? (e = i.top + this.anchorMargin.top - o, s || (e += this.measurements.anchorSize.height)) : (e = i.bottom - this.anchorMargin.bottom + this.measurements.anchorSize.height - o, s && (e -= this.measurements.anchorSize.height)), e;
  }, c.prototype.getHorizontalOriginOffset = function (t) {
    var i = this.measurements.anchorSize,
      e = this.hasBit(t, _constants.CornerBit.RIGHT),
      n = this.hasBit(this.anchorCorner, _constants.CornerBit.RIGHT);
    if (e) {
      var s = n ? i.width - this.anchorMargin.left : this.anchorMargin.right;
      return this.isHoistedElement || this.isFixedPosition ? s - (this.measurements.viewportSize.width - this.measurements.bodySize.width) : s;
    }
    return n ? i.width - this.anchorMargin.right : this.anchorMargin.left;
  }, c.prototype.getVerticalOriginOffset = function (t) {
    var i = this.measurements.anchorSize,
      e = this.hasBit(t, _constants.CornerBit.BOTTOM),
      n = this.hasBit(this.anchorCorner, _constants.CornerBit.BOTTOM);
    return e ? n ? i.height - this.anchorMargin.top : -this.anchorMargin.bottom : n ? i.height + this.anchorMargin.bottom : this.anchorMargin.top;
  }, c.prototype.adjustPositionForHoistedElement = function (t) {
    var i,
      n,
      s = this.measurements,
      o = s.windowScroll,
      r = s.viewportDistance,
      a = s.surfaceSize,
      h = s.viewportSize,
      c = Object.keys(t);
    try {
      for (var u = (0, _tslib.__values)(c), p = u.next(); !p.done; p = u.next()) {
        var d = p.value,
          f = t[d] || 0;
        !this.isHorizontallyCenteredOnViewport || "left" !== d && "right" !== d ? (f += r[d], this.isFixedPosition || ("top" === d ? f += o.y : "bottom" === d ? f -= o.y : "left" === d ? f += o.x : f -= o.x), t[d] = f) : t[d] = (h.width - a.width) / 2;
      }
    } catch (t) {
      i = {
        error: t
      };
    } finally {
      try {
        p && !p.done && (n = u.return) && n.call(u);
      } finally {
        if (i) throw i.error;
      }
    }
  }, c.prototype.maybeRestoreFocus = function () {
    var t = this,
      i = this.adapter.isFocused(),
      e = this.adapter.getOwnerDocument ? this.adapter.getOwnerDocument() : document,
      n = e.activeElement && this.adapter.isElementInContainer(e.activeElement);
    (i || n) && setTimeout(function () {
      t.adapter.restoreFocus();
    }, _constants.numbers.TOUCH_EVENT_WAIT_MS);
  }, c.prototype.hasBit = function (t, i) {
    return Boolean(t & i);
  }, c.prototype.setBit = function (t, i) {
    return t | i;
  }, c.prototype.unsetBit = function (t, i) {
    return t ^ i;
  }, c.prototype.isFinite = function (t) {
    return "number" == typeof t && isFinite(t);
  }, c;
}(_foundation.MDCFoundation);
},{"../../../_virtual/_tslib.js":"../node_modules/@cosmograph/ui/_virtual/_tslib.js","../base/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/base/foundation.js","./constants.js":"../node_modules/@cosmograph/ui/ext/@material/menu-surface/constants.js"}],"../node_modules/@cosmograph/ui/ext/@smui/menu-surface/dist/MenuSurface.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("../../../svelte/internal/index.mjs.js");
var _classMap = require("../../common/dist/internal/classMap.js");
var _dispatch = require("../../common/dist/internal/dispatch.js");
var _forwardEventsBuilder = require("../../common/dist/internal/forwardEventsBuilder.js");
var _useActions = require("../../common/dist/internal/useActions.js");
var _foundation = require("../../../@material/menu-surface/foundation.js");
var _constants = require("../../../@material/menu-surface/constants.js");
const {
  document: W
} = _indexMjs.globals;
function k(e) {
  let n, t, x, O, w, C, M, E;
  const B = e[34].default,
    H = (0, _indexMjs.create_slot)(B, e, e[33], null);
  let I = [{
      class: x = (0, _classMap.classMap)({
        [e[1]]: !0,
        "mdc-menu-surface": !0,
        "mdc-menu-surface--fixed": e[4],
        "mdc-menu-surface--open": e[3],
        "smui-menu-surface--static": e[3],
        "mdc-menu-surface--fullwidth": e[5],
        ...e[8]
      })
    }, {
      style: O = Object.entries(e[9]).map(P).concat([e[2]]).join(" ")
    }, e[12]],
    S = {};
  for (let e = 0; e < I.length; e += 1) S = (0, _indexMjs.assign)(S, I[e]);
  return {
    c() {
      n = (0, _indexMjs.space)(), t = (0, _indexMjs.element)("div"), H && H.c(), (0, _indexMjs.set_attributes)(t, S);
    },
    m(i, o) {
      (0, _indexMjs.insert)(i, n, o), (0, _indexMjs.insert)(i, t, o), H && H.m(t, null), e[35](t), C = !0, M || (E = [(0, _indexMjs.listen)(W.body, "click", e[11], !0), (0, _indexMjs.action_destroyer)(w = _useActions.useActions.call(null, t, e[0])), (0, _indexMjs.action_destroyer)(e[10].call(null, t)), (0, _indexMjs.listen)(t, "keydown", function () {
        (0, _indexMjs.is_function)(e[7] && e[7].handleKeydown.bind(e[7])) && (e[7] && e[7].handleKeydown.bind(e[7])).apply(this, arguments);
      })], M = !0);
    },
    p(n, i) {
      e = n, H && H.p && (!C || 4 & i[1]) && (0, _indexMjs.update_slot_base)(H, B, e, e[33], C ? (0, _indexMjs.get_slot_changes)(B, e[33], i, null) : (0, _indexMjs.get_all_dirty_from_scope)(e[33]), null), (0, _indexMjs.set_attributes)(t, S = (0, _indexMjs.get_spread_update)(I, [(!C || 314 & i[0] && x !== (x = (0, _classMap.classMap)({
        [e[1]]: !0,
        "mdc-menu-surface": !0,
        "mdc-menu-surface--fixed": e[4],
        "mdc-menu-surface--open": e[3],
        "smui-menu-surface--static": e[3],
        "mdc-menu-surface--fullwidth": e[5],
        ...e[8]
      }))) && {
        class: x
      }, (!C || 516 & i[0] && O !== (O = Object.entries(e[9]).map(P).concat([e[2]]).join(" "))) && {
        style: O
      }, 4096 & i[0] && e[12]])), w && (0, _indexMjs.is_function)(w.update) && 1 & i[0] && w.update.call(null, e[0]);
    },
    i(e) {
      C || ((0, _indexMjs.transition_in)(H, e), C = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(H, e), C = !1;
    },
    d(i) {
      i && (0, _indexMjs.detach)(n), i && (0, _indexMjs.detach)(t), H && H.d(i), e[35](null), M = !1, (0, _indexMjs.run_all)(E);
    }
  };
}
const P = ([e, n]) => `${e}: ${n};`;
function R(e, n, t) {
  const i = ["use", "class", "style", "static", "anchor", "fixed", "open", "managed", "fullWidth", "quickOpen", "anchorElement", "anchorCorner", "anchorMargin", "maxHeight", "horizontallyCenteredOnViewport", "openBottomBias", "neverRestoreFocus", "isOpen", "setOpen", "setAbsolutePosition", "setIsHoisted", "isFixed", "getElement"];
  let s = (0, _indexMjs.compute_rest_props)(n, i),
    {
      $$slots: r = {},
      $$scope: c
    } = n;
  var a, l, u;
  const d = (0, _forwardEventsBuilder.forwardEventsBuilder)((0, _indexMjs.get_current_component)());
  let m,
    h,
    f,
    {
      use: p = []
    } = n,
    {
      class: g = ""
    } = n,
    {
      style: $ = ""
    } = n,
    {
      static: y = !1
    } = n,
    {
      anchor: v = !0
    } = n,
    {
      fixed: B = !1
    } = n,
    {
      open: b = y
    } = n,
    {
      managed: F = !1
    } = n,
    {
      fullWidth: W = !1
    } = n,
    {
      quickOpen: k = !1
    } = n,
    {
      anchorElement: P
    } = n,
    {
      anchorCorner: R
    } = n,
    {
      anchorMargin: U = {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    } = n,
    {
      maxHeight: V = 0
    } = n,
    {
      horizontallyCenteredOnViewport: z = !1
    } = n,
    {
      openBottomBias: q = 0
    } = n,
    {
      neverRestoreFocus: D = !1
    } = n,
    L = {},
    K = {};
  (0, _indexMjs.setContext)("SMUI:list:role", "menu"), (0, _indexMjs.setContext)("SMUI:list:item:role", "menuitem");
  const N = _constants.Corner;
  function Q(e) {
    return e in L ? L[e] : G().classList.contains(e);
  }
  function T(e) {
    L[e] || t(8, L[e] = !0, L);
  }
  function X(e) {
    e in L && !L[e] || t(8, L[e] = !1, L);
  }
  function Y(e) {
    h.close(e), t(13, b = !1);
  }
  function G() {
    return m;
  }
  return (0, _indexMjs.onMount)(() => {
    t(7, h = new _foundation.MDCMenuSurfaceFoundation({
      addClass: T,
      removeClass: X,
      hasClass: Q,
      hasAnchor: () => !!P,
      notifyClose: () => {
        F || t(13, b = y), b || (0, _dispatch.dispatch)(m, "SMUIMenuSurface:closed", void 0, void 0, !0);
      },
      notifyClosing: () => {
        F || t(13, b = y), b || (0, _dispatch.dispatch)(m, "SMUIMenuSurface:closing", void 0, void 0, !0);
      },
      notifyOpen: () => {
        F || t(13, b = !0), b && (0, _dispatch.dispatch)(m, "SMUIMenuSurface:opened", void 0, void 0, !0);
      },
      notifyOpening: () => {
        b || (0, _dispatch.dispatch)(m, "SMUIMenuSurface:opening", void 0, void 0, !0);
      },
      isElementInContainer: e => m.contains(e),
      isRtl: () => "rtl" === getComputedStyle(m).getPropertyValue("direction"),
      setTransformOrigin: e => {
        t(9, K["transform-origin"] = e, K);
      },
      isFocused: () => document.activeElement === m,
      saveFocus: () => {
        var e;
        f = null !== (e = document.activeElement) && void 0 !== e ? e : void 0;
      },
      restoreFocus: () => {
        !D && (!m || m.contains(document.activeElement)) && f && document.contains(f) && "focus" in f && f.focus();
      },
      getInnerDimensions: () => ({
        width: m.offsetWidth,
        height: m.offsetHeight
      }),
      getAnchorDimensions: () => P ? P.getBoundingClientRect() : null,
      getWindowDimensions: () => ({
        width: window.innerWidth,
        height: window.innerHeight
      }),
      getBodyDimensions: () => ({
        width: document.body.clientWidth,
        height: document.body.clientHeight
      }),
      getWindowScroll: () => ({
        x: window.pageXOffset,
        y: window.pageYOffset
      }),
      setPosition: e => {
        t(9, K.left = "left" in e ? `${e.left}px` : "", K), t(9, K.right = "right" in e ? `${e.right}px` : "", K), t(9, K.top = "top" in e ? `${e.top}px` : "", K), t(9, K.bottom = "bottom" in e ? `${e.bottom}px` : "", K);
      },
      setMaxHeight: e => {
        t(9, K["max-height"] = e, K);
      }
    }));
    return (0, _dispatch.dispatch)(m, "SMUIMenuSurface:mount", {
      get open() {
        return b;
      },
      set open(e) {
        t(13, b = e);
      },
      closeProgrammatic: Y
    }), h.init(), () => {
      var e;
      const n = h.isHoistedElement;
      h.destroy(), n && (null === (e = m.parentNode) || void 0 === e || e.removeChild(m));
    };
  }), (0, _indexMjs.onDestroy)(() => {
    var e;
    v && m && (null === (e = m.parentElement) || void 0 === e || e.classList.remove("mdc-menu-surface--anchor"));
  }), e.$$set = e => {
    n = (0, _indexMjs.assign)((0, _indexMjs.assign)({}, n), (0, _indexMjs.exclude_internal_props)(e)), t(12, s = (0, _indexMjs.compute_rest_props)(n, i)), "use" in e && t(0, p = e.use), "class" in e && t(1, g = e.class), "style" in e && t(2, $ = e.style), "static" in e && t(3, y = e.static), "anchor" in e && t(15, v = e.anchor), "fixed" in e && t(4, B = e.fixed), "open" in e && t(13, b = e.open), "managed" in e && t(16, F = e.managed), "fullWidth" in e && t(5, W = e.fullWidth), "quickOpen" in e && t(17, k = e.quickOpen), "anchorElement" in e && t(14, P = e.anchorElement), "anchorCorner" in e && t(18, R = e.anchorCorner), "anchorMargin" in e && t(19, U = e.anchorMargin), "maxHeight" in e && t(20, V = e.maxHeight), "horizontallyCenteredOnViewport" in e && t(21, z = e.horizontallyCenteredOnViewport), "openBottomBias" in e && t(22, q = e.openBottomBias), "neverRestoreFocus" in e && t(23, D = e.neverRestoreFocus), "$$scope" in e && t(33, c = e.$$scope);
  }, e.$$.update = () => {
    1073774656 & e.$$.dirty[0] | 3 & e.$$.dirty[1] && m && v && !(null === t(30, a = m.parentElement) || void 0 === a ? void 0 : a.classList.contains("mdc-menu-surface--anchor")) && (null === t(31, l = m.parentElement) || void 0 === l || l.classList.add("mdc-menu-surface--anchor"), t(14, P = null !== t(32, u = m.parentElement) && void 0 !== u ? u : void 0)), 8320 & e.$$.dirty[0] && h && h.isOpen() !== b && (b ? h.open() : h.close()), 131200 & e.$$.dirty[0] && h && h.setQuickOpen(k), 144 & e.$$.dirty[0] && h && h.setFixedPosition(B), 1048704 & e.$$.dirty[0] && h && h.setMaxHeight(V), 2097280 & e.$$.dirty[0] && h && h.setIsHorizontallyCenteredOnViewport(z), 262272 & e.$$.dirty[0] && h && null != R && ("string" == typeof R ? h.setAnchorCorner(N[R]) : h.setAnchorCorner(R)), 524416 & e.$$.dirty[0] && h && h.setAnchorMargin(U), 4194432 & e.$$.dirty[0] && h && h.setOpenBottomBias(q);
  }, [p, g, $, y, B, W, m, h, L, K, d, function (e) {
    h && b && !F && h.handleBodyClick(e);
  }, s, b, P, v, F, k, R, U, V, z, q, D, function () {
    return b;
  }, function (e) {
    t(13, b = e);
  }, function (e, n) {
    return h.setAbsolutePosition(e, n);
  }, function (e) {
    return h.setIsHoisted(e);
  }, function () {
    return h.isFixed();
  }, G, a, l, u, c, r, function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      m = e, t(6, m);
    });
  }];
}
class U extends _indexMjs.SvelteComponent {
  constructor(e) {
    super(), (0, _indexMjs.init)(this, e, R, k, _indexMjs.safe_not_equal, {
      use: 0,
      class: 1,
      style: 2,
      static: 3,
      anchor: 15,
      fixed: 4,
      open: 13,
      managed: 16,
      fullWidth: 5,
      quickOpen: 17,
      anchorElement: 14,
      anchorCorner: 18,
      anchorMargin: 19,
      maxHeight: 20,
      horizontallyCenteredOnViewport: 21,
      openBottomBias: 22,
      neverRestoreFocus: 23,
      isOpen: 24,
      setOpen: 25,
      setAbsolutePosition: 26,
      setIsHoisted: 27,
      isFixed: 28,
      getElement: 29
    }, null, [-1, -1]);
  }
  get isOpen() {
    return this.$$.ctx[24];
  }
  get setOpen() {
    return this.$$.ctx[25];
  }
  get setAbsolutePosition() {
    return this.$$.ctx[26];
  }
  get setIsHoisted() {
    return this.$$.ctx[27];
  }
  get isFixed() {
    return this.$$.ctx[28];
  }
  get getElement() {
    return this.$$.ctx[29];
  }
}
exports.default = U;
},{"../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../../common/dist/internal/classMap.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/classMap.js","../../common/dist/internal/dispatch.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/dispatch.js","../../common/dist/internal/forwardEventsBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js","../../common/dist/internal/useActions.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/useActions.js","../../../@material/menu-surface/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/menu-surface/foundation.js","../../../@material/menu-surface/constants.js":"../node_modules/@cosmograph/ui/ext/@material/menu-surface/constants.js"}],"../node_modules/@cosmograph/ui/ext/@material/menu/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.strings = exports.numbers = exports.cssClasses = exports.DefaultFocusState = void 0;
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var E,
  T = exports.cssClasses = {
    MENU_SELECTED_LIST_ITEM: "mdc-menu-item--selected",
    MENU_SELECTION_GROUP: "mdc-menu__selection-group",
    ROOT: "mdc-menu"
  },
  e = exports.strings = {
    ARIA_CHECKED_ATTR: "aria-checked",
    ARIA_DISABLED_ATTR: "aria-disabled",
    CHECKBOX_SELECTOR: 'input[type="checkbox"]',
    LIST_SELECTOR: ".mdc-list,.mdc-deprecated-list",
    SELECTED_EVENT: "MDCMenu:selected",
    SKIP_RESTORE_FOCUS: "data-menu-item-skip-restore-focus"
  },
  _ = exports.numbers = {
    FOCUS_ROOT_INDEX: -1
  };
!function (E) {
  E[E.NONE = 0] = "NONE", E[E.LIST_ROOT = 1] = "LIST_ROOT", E[E.FIRST_ITEM = 2] = "FIRST_ITEM", E[E.LAST_ITEM = 3] = "LAST_ITEM";
}(E || (exports.DefaultFocusState = E = {}));
},{}],"../node_modules/@cosmograph/ui/ext/@material/menu/foundation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MDCMenuFoundation = void 0;
var _tslib = require("../../../_virtual/_tslib.js");
var _foundation = require("../base/foundation.js");
var _constants = require("../list/constants.js");
var _foundation2 = require("../menu-surface/foundation.js");
var _constants2 = require("./constants.js");
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var u = exports.default = exports.MDCMenuFoundation = function (n) {
  function u(e) {
    var r = n.call(this, (0, _tslib.__assign)((0, _tslib.__assign)({}, u.defaultAdapter), e)) || this;
    return r.closeAnimationEndTimerId = 0, r.defaultFocusState = _constants2.DefaultFocusState.LIST_ROOT, r.selectedIndex = -1, r;
  }
  return (0, _tslib.__extends)(u, n), Object.defineProperty(u, "cssClasses", {
    get: function () {
      return _constants2.cssClasses;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(u, "strings", {
    get: function () {
      return _constants2.strings;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(u, "numbers", {
    get: function () {
      return _constants2.numbers;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(u, "defaultAdapter", {
    get: function () {
      return {
        addClassToElementAtIndex: function () {},
        removeClassFromElementAtIndex: function () {},
        addAttributeToElementAtIndex: function () {},
        removeAttributeFromElementAtIndex: function () {},
        getAttributeFromElementAtIndex: function () {
          return null;
        },
        elementContainsClass: function () {
          return !1;
        },
        closeSurface: function () {},
        getElementIndex: function () {
          return -1;
        },
        notifySelected: function () {},
        getMenuItemCount: function () {
          return 0;
        },
        focusItemAtIndex: function () {},
        focusListRoot: function () {},
        getSelectedSiblingOfItemAtIndex: function () {
          return -1;
        },
        isSelectableItemAtIndex: function () {
          return !1;
        }
      };
    },
    enumerable: !1,
    configurable: !0
  }), u.prototype.destroy = function () {
    this.closeAnimationEndTimerId && clearTimeout(this.closeAnimationEndTimerId), this.adapter.closeSurface();
  }, u.prototype.handleKeydown = function (e) {
    var t = e.key,
      n = e.keyCode;
    ("Tab" === t || 9 === n) && this.adapter.closeSurface(!0);
  }, u.prototype.handleItemAction = function (e) {
    var t = this,
      n = this.adapter.getElementIndex(e);
    if (!(n < 0)) {
      this.adapter.notifySelected({
        index: n
      });
      var r = "true" === this.adapter.getAttributeFromElementAtIndex(n, _constants2.strings.SKIP_RESTORE_FOCUS);
      this.adapter.closeSurface(r), this.closeAnimationEndTimerId = setTimeout(function () {
        var n = t.adapter.getElementIndex(e);
        n >= 0 && t.adapter.isSelectableItemAtIndex(n) && t.setSelectedIndex(n);
      }, _foundation2.MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
    }
  }, u.prototype.handleMenuSurfaceOpened = function () {
    switch (this.defaultFocusState) {
      case _constants2.DefaultFocusState.FIRST_ITEM:
        this.adapter.focusItemAtIndex(0);
        break;
      case _constants2.DefaultFocusState.LAST_ITEM:
        this.adapter.focusItemAtIndex(this.adapter.getMenuItemCount() - 1);
        break;
      case _constants2.DefaultFocusState.NONE:
        break;
      default:
        this.adapter.focusListRoot();
    }
  }, u.prototype.setDefaultFocusState = function (e) {
    this.defaultFocusState = e;
  }, u.prototype.getSelectedIndex = function () {
    return this.selectedIndex;
  }, u.prototype.setSelectedIndex = function (e) {
    if (this.validatedIndex(e), !this.adapter.isSelectableItemAtIndex(e)) throw new Error("MDCMenuFoundation: No selection group at specified index.");
    var t = this.adapter.getSelectedSiblingOfItemAtIndex(e);
    t >= 0 && (this.adapter.removeAttributeFromElementAtIndex(t, _constants2.strings.ARIA_CHECKED_ATTR), this.adapter.removeClassFromElementAtIndex(t, _constants2.cssClasses.MENU_SELECTED_LIST_ITEM)), this.adapter.addClassToElementAtIndex(e, _constants2.cssClasses.MENU_SELECTED_LIST_ITEM), this.adapter.addAttributeToElementAtIndex(e, _constants2.strings.ARIA_CHECKED_ATTR, "true"), this.selectedIndex = e;
  }, u.prototype.setEnabled = function (e, t) {
    this.validatedIndex(e), t ? (this.adapter.removeClassFromElementAtIndex(e, _constants.cssClasses.LIST_ITEM_DISABLED_CLASS), this.adapter.addAttributeToElementAtIndex(e, _constants2.strings.ARIA_DISABLED_ATTR, "false")) : (this.adapter.addClassToElementAtIndex(e, _constants.cssClasses.LIST_ITEM_DISABLED_CLASS), this.adapter.addAttributeToElementAtIndex(e, _constants2.strings.ARIA_DISABLED_ATTR, "true"));
  }, u.prototype.validatedIndex = function (e) {
    var t = this.adapter.getMenuItemCount();
    if (!(e >= 0 && e < t)) throw new Error("MDCMenuFoundation: No list item at specified index.");
  }, u;
}(_foundation.MDCFoundation);
},{"../../../_virtual/_tslib.js":"../node_modules/@cosmograph/ui/_virtual/_tslib.js","../base/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/base/foundation.js","../list/constants.js":"../node_modules/@cosmograph/ui/ext/@material/list/constants.js","../menu-surface/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/menu-surface/foundation.js","./constants.js":"../node_modules/@cosmograph/ui/ext/@material/menu/constants.js"}],"../node_modules/@cosmograph/ui/ext/@smui/menu/dist/Menu.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("../../../svelte/internal/index.mjs.js");
var O = _interopRequireWildcard(require("../../../@material/dom/ponyfill.js"));
var _classMap = require("../../common/dist/internal/classMap.js");
var _dispatch = require("../../common/dist/internal/dispatch.js");
var _forwardEventsBuilder = require("../../common/dist/internal/forwardEventsBuilder.js");
var _MenuSurfaceSvelte = _interopRequireDefault(require("../../menu-surface/dist/MenuSurface.svelte.js"));
var _foundation = require("../../../@material/menu/foundation.js");
var _constants = require("../../../@material/menu/constants.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function C(e) {
  let t;
  const n = e[17].default,
    s = (0, _indexMjs.create_slot)(n, e, e[22], null);
  return {
    c() {
      s && s.c();
    },
    m(e, n) {
      s && s.m(e, n), t = !0;
    },
    p(e, o) {
      s && s.p && (!t || 4194304 & o) && (0, _indexMjs.update_slot_base)(s, n, e, e[22], t ? (0, _indexMjs.get_slot_changes)(n, e[22], o, null) : (0, _indexMjs.get_all_dirty_from_scope)(e[22]), null);
    },
    i(e) {
      t || ((0, _indexMjs.transition_in)(s, e), t = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(s, e), t = !1;
    },
    d(e) {
      s && s.d(e);
    }
  };
}
function j(e) {
  let t, n, $;
  const p = [{
    use: e[5]
  }, {
    class: (0, _classMap.classMap)({
      [e[1]]: !0,
      "mdc-menu": !0
    })
  }, e[9]];
  function x(t) {
    e[19](t);
  }
  let I = {
    $$slots: {
      default: [C]
    },
    $$scope: {
      ctx: e
    }
  };
  for (let e = 0; e < p.length; e += 1) I = (0, _indexMjs.assign)(I, p[e]);
  return void 0 !== e[0] && (I.open = e[0]), t = new _MenuSurfaceSvelte.default({
    props: I
  }), e[18](t), _indexMjs.binding_callbacks.push(() => (0, _indexMjs.bind)(t, "open", x)), t.$on("SMUIMenuSurface:mount", e[7]), t.$on("SMUIList:mount", e[8]), t.$on("SMUIMenuSurface:opened", e[20]), t.$on("keydown", e[6]), t.$on("SMUIList:action", e[21]), {
    c() {
      (0, _indexMjs.create_component)(t.$$.fragment);
    },
    m(e, n) {
      (0, _indexMjs.mount_component)(t, e, n), $ = !0;
    },
    p(e, [s]) {
      const o = 546 & s ? (0, _indexMjs.get_spread_update)(p, [32 & s && {
        use: e[5]
      }, 2 & s && {
        class: (0, _classMap.classMap)({
          [e[1]]: !0,
          "mdc-menu": !0
        })
      }, 512 & s && (0, _indexMjs.get_spread_object)(e[9])]) : {};
      4194304 & s && (o.$$scope = {
        dirty: s,
        ctx: e
      }), !n && 1 & s && (n = !0, o.open = e[0], (0, _indexMjs.add_flush_callback)(() => n = !1)), t.$set(o);
    },
    i(e) {
      $ || ((0, _indexMjs.transition_in)(t.$$.fragment, e), $ = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(t.$$.fragment, e), $ = !1;
    },
    d(n) {
      e[18](null), (0, _indexMjs.destroy_component)(t, n);
    }
  };
}
function y(e, t, n) {
  let r;
  const l = ["use", "class", "open", "isOpen", "setOpen", "setDefaultFocusState", "getSelectedIndex", "getMenuSurface", "getElement"];
  let u = (0, _indexMjs.compute_rest_props)(t, l),
    {
      $$slots: i = {},
      $$scope: c
    } = t;
  const {
      closest: m
    } = O,
    d = (0, _forwardEventsBuilder.forwardEventsBuilder)((0, _indexMjs.get_current_component)());
  let a,
    f,
    g,
    S,
    {
      use: E = []
    } = t,
    {
      class: M = ""
    } = t,
    {
      open: h = !1
    } = t;
  function F() {
    return a.getElement();
  }
  (0, _indexMjs.onMount)(() => (n(3, f = new _foundation.MDCMenuFoundation({
    addClassToElementAtIndex: (e, t) => {
      S.addClassForElementIndex(e, t);
    },
    removeClassFromElementAtIndex: (e, t) => {
      S.removeClassForElementIndex(e, t);
    },
    addAttributeToElementAtIndex: (e, t, n) => {
      S.setAttributeForElementIndex(e, t, n);
    },
    removeAttributeFromElementAtIndex: (e, t) => {
      S.removeAttributeForElementIndex(e, t);
    },
    getAttributeFromElementAtIndex: (e, t) => S.getAttributeFromElementIndex(e, t),
    elementContainsClass: (e, t) => e.classList.contains(t),
    closeSurface: e => {
      g.closeProgrammatic(e), (0, _dispatch.dispatch)(F(), "SMUIMenu:closedProgrammatically");
    },
    getElementIndex: e => S.getOrderedList().map(e => e.element).indexOf(e),
    notifySelected: e => (0, _dispatch.dispatch)(F(), "SMUIMenu:selected", {
      index: e.index,
      item: S.getOrderedList()[e.index].element
    }, void 0, !0),
    getMenuItemCount: () => S.items.length,
    focusItemAtIndex: e => S.focusItemAtIndex(e),
    focusListRoot: () => "focus" in S.element && S.element.focus(),
    isSelectableItemAtIndex: e => !!m(S.getOrderedList()[e].element, `.${_constants.cssClasses.MENU_SELECTION_GROUP}`),
    getSelectedSiblingOfItemAtIndex: e => {
      const t = S.getOrderedList(),
        n = m(t[e].element, `.${_constants.cssClasses.MENU_SELECTION_GROUP}`),
        s = null == n ? void 0 : n.querySelector(`.${_constants.cssClasses.MENU_SELECTED_LIST_ITEM}`);
      return s ? t.map(e => e.element).indexOf(s) : -1;
    }
  })), (0, _dispatch.dispatch)(F(), "SMUIMenu:mount", f), f.init(), () => {
    f.destroy();
  }));
  return e.$$set = e => {
    t = (0, _indexMjs.assign)((0, _indexMjs.assign)({}, t), (0, _indexMjs.exclude_internal_props)(e)), n(9, u = (0, _indexMjs.compute_rest_props)(t, l)), "use" in e && n(10, E = e.use), "class" in e && n(1, M = e.class), "open" in e && n(0, h = e.open), "$$scope" in e && n(22, c = e.$$scope);
  }, e.$$.update = () => {
    1024 & e.$$.dirty && n(5, r = [d, ...E]);
  }, [h, M, a, f, S, r, function (e) {
    f && f.handleKeydown(e);
  }, function (e) {
    g || (g = e.detail);
  }, function (e) {
    S || n(4, S = e.detail);
  }, u, E, function () {
    return h;
  }, function (e) {
    n(0, h = e);
  }, function (e) {
    f.setDefaultFocusState(e);
  }, function () {
    return f.getSelectedIndex();
  }, function () {
    return a;
  }, F, i, function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      a = e, n(2, a);
    });
  }, function (e) {
    h = e, n(0, h);
  }, () => f && f.handleMenuSurfaceOpened(), e => f && f.handleItemAction(S.getOrderedList()[e.detail.index].element), c];
}
class b extends _indexMjs.SvelteComponent {
  constructor(e) {
    super(), (0, _indexMjs.init)(this, e, y, j, _indexMjs.safe_not_equal, {
      use: 10,
      class: 1,
      open: 0,
      isOpen: 11,
      setOpen: 12,
      setDefaultFocusState: 13,
      getSelectedIndex: 14,
      getMenuSurface: 15,
      getElement: 16
    });
  }
  get isOpen() {
    return this.$$.ctx[11];
  }
  get setOpen() {
    return this.$$.ctx[12];
  }
  get setDefaultFocusState() {
    return this.$$.ctx[13];
  }
  get getSelectedIndex() {
    return this.$$.ctx[14];
  }
  get getMenuSurface() {
    return this.$$.ctx[15];
  }
  get getElement() {
    return this.$$.ctx[16];
  }
}
exports.default = b;
},{"../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../../../@material/dom/ponyfill.js":"../node_modules/@cosmograph/ui/ext/@material/dom/ponyfill.js","../../common/dist/internal/classMap.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/classMap.js","../../common/dist/internal/dispatch.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/dispatch.js","../../common/dist/internal/forwardEventsBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js","../../menu-surface/dist/MenuSurface.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/menu-surface/dist/MenuSurface.svelte.js","../../../@material/menu/foundation.js":"../node_modules/@cosmograph/ui/ext/@material/menu/foundation.js","../../../@material/menu/constants.js":"../node_modules/@cosmograph/ui/ext/@material/menu/constants.js"}],"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Graphic.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("../../../svelte/internal/index.mjs.js");
var _classMap = require("../../common/dist/internal/classMap.js");
var _forwardEventsBuilder = require("../../common/dist/internal/forwardEventsBuilder.js");
var _useActions = require("../../common/dist/internal/useActions.js");
function B(e) {
  let t, s, _, j, x, E;
  const v = e[8].default,
    w = (0, _indexMjs.create_slot)(v, e, e[7], null);
  let B = [{
      class: s = (0, _classMap.classMap)({
        [e[1]]: !0,
        "mdc-deprecated-list-item__graphic": !0,
        "mdc-menu__selection-group-icon": e[4]
      })
    }, e[5]],
    I = {};
  for (let e = 0; e < B.length; e += 1) I = (0, _indexMjs.assign)(I, B[e]);
  return {
    c() {
      t = (0, _indexMjs.element)("span"), w && w.c(), (0, _indexMjs.set_attributes)(t, I);
    },
    m(s, n) {
      (0, _indexMjs.insert)(s, t, n), w && w.m(t, null), e[9](t), j = !0, x || (E = [(0, _indexMjs.action_destroyer)(_ = _useActions.useActions.call(null, t, e[0])), (0, _indexMjs.action_destroyer)(e[3].call(null, t))], x = !0);
    },
    p(e, [n]) {
      w && w.p && (!j || 128 & n) && (0, _indexMjs.update_slot_base)(w, v, e, e[7], j ? (0, _indexMjs.get_slot_changes)(v, e[7], n, null) : (0, _indexMjs.get_all_dirty_from_scope)(e[7]), null), (0, _indexMjs.set_attributes)(t, I = (0, _indexMjs.get_spread_update)(B, [(!j || 2 & n && s !== (s = (0, _classMap.classMap)({
        [e[1]]: !0,
        "mdc-deprecated-list-item__graphic": !0,
        "mdc-menu__selection-group-icon": e[4]
      }))) && {
        class: s
      }, 32 & n && e[5]])), _ && (0, _indexMjs.is_function)(_.update) && 1 & n && _.update.call(null, e[0]);
    },
    i(e) {
      j || ((0, _indexMjs.transition_in)(w, e), j = !0);
    },
    o(e) {
      (0, _indexMjs.transition_out)(w, e), j = !1;
    },
    d(s) {
      s && (0, _indexMjs.detach)(t), w && w.d(s), e[9](null), x = !1, (0, _indexMjs.run_all)(E);
    }
  };
}
function I(e, t, s) {
  const n = ["use", "class", "getElement"];
  let c = (0, _indexMjs.compute_rest_props)(t, n),
    {
      $$slots: o = {},
      $$scope: i
    } = t;
  const u = (0, _forwardEventsBuilder.forwardEventsBuilder)((0, _indexMjs.get_current_component)());
  let r,
    {
      use: a = []
    } = t,
    {
      class: m = ""
    } = t,
    p = (0, _indexMjs.getContext)("SMUI:list:graphic:menu-selection-group");
  return e.$$set = e => {
    t = (0, _indexMjs.assign)((0, _indexMjs.assign)({}, t), (0, _indexMjs.exclude_internal_props)(e)), s(5, c = (0, _indexMjs.compute_rest_props)(t, n)), "use" in e && s(0, a = e.use), "class" in e && s(1, m = e.class), "$$scope" in e && s(7, i = e.$$scope);
  }, [a, m, r, u, p, c, function () {
    return r;
  }, i, o, function (e) {
    _indexMjs.binding_callbacks[e ? "unshift" : "push"](() => {
      r = e, s(2, r);
    });
  }];
}
class S extends _indexMjs.SvelteComponent {
  constructor(e) {
    super(), (0, _indexMjs.init)(this, e, I, B, _indexMjs.safe_not_equal, {
      use: 0,
      class: 1,
      getElement: 6
    });
  }
  get getElement() {
    return this.$$.ctx[6];
  }
}
exports.default = S;
},{"../../../svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","../../common/dist/internal/classMap.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/classMap.js","../../common/dist/internal/forwardEventsBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/forwardEventsBuilder.js","../../common/dist/internal/useActions.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/internal/useActions.js"}],"../node_modules/@cosmograph/ui/ext/@smui/menu/dist/SelectionGroupIcon.js":[function(require,module,exports) {
"use strict";

var _classAdderBuilder = require("../../common/dist/classadder/classAdderBuilder.js");
require("../../list/dist/Text.js");
require("../../list/dist/PrimaryText.js");
require("../../list/dist/SecondaryText.js");
var _GraphicSvelte = _interopRequireDefault(require("../../list/dist/Graphic.svelte.js"));
require("../../list/dist/Meta.js");
require("../../list/dist/Group.js");
require("../../list/dist/Subheader.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
(0, _classAdderBuilder.classAdderBuilder)({
  class: "mdc-menu__selection-group-icon",
  component: _GraphicSvelte.default
});
},{"../../common/dist/classadder/classAdderBuilder.js":"../node_modules/@cosmograph/ui/ext/@smui/common/dist/classadder/classAdderBuilder.js","../../list/dist/Text.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Text.js","../../list/dist/PrimaryText.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/PrimaryText.js","../../list/dist/SecondaryText.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/SecondaryText.js","../../list/dist/Graphic.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Graphic.svelte.js","../../list/dist/Meta.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Meta.js","../../list/dist/Group.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Group.js","../../list/dist/Subheader.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Subheader.js"}],"../node_modules/@cosmograph/ui/modules/search/search-svg.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("./../../ext/svelte/internal/index.mjs.js");
function d(e) {
  let s, t;
  return {
    c() {
      s = (0, _indexMjs.svg_element)("svg"), t = (0, _indexMjs.svg_element)("path"), (0, _indexMjs.attr)(t, "fill", "currentColor"), (0, _indexMjs.attr)(t, "d", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"), (0, _indexMjs.attr)(s, "aria-hidden", "true"), (0, _indexMjs.attr)(s, "focusable", "false"), (0, _indexMjs.attr)(s, "data-prefix", "fas"), (0, _indexMjs.attr)(s, "data-icon", "search"), (0, _indexMjs.attr)(s, "class", "svg-inline--fa fa-search fa-w-16"), (0, _indexMjs.attr)(s, "role", "img"), (0, _indexMjs.attr)(s, "xmlns", "http://www.w3.org/2000/svg"), (0, _indexMjs.set_style)(s, "width", "16px"), (0, _indexMjs.set_style)(s, "height", "16px"), (0, _indexMjs.attr)(s, "viewBox", "0 0 512 512");
    },
    m(e, a) {
      (0, _indexMjs.insert)(e, s, a), (0, _indexMjs.append)(s, t);
    },
    p: _indexMjs.noop,
    i: _indexMjs.noop,
    o: _indexMjs.noop,
    d(e) {
      e && (0, _indexMjs.detach)(s);
    }
  };
}
class f extends _indexMjs.SvelteComponent {
  constructor(e) {
    super(), (0, _indexMjs.init)(this, e, null, d, _indexMjs.safe_not_equal, {});
  }
}
exports.default = f;
},{"./../../ext/svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js"}],"../node_modules/@cosmograph/ui/modules/search/smui.css.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.css = void 0;
var _injectCss = _interopRequireDefault(require("./../../ext/rollup-plugin-styles/dist/runtime/inject-css.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var e = exports.default = exports.css = '.mdc-floating-label{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;cursor:text;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);left:0;letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);line-height:1.15rem;overflow:hidden;position:absolute;text-align:left;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-overflow:ellipsis;text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit);-webkit-transform-origin:left top;transform-origin:left top;transition:transform .15s cubic-bezier(.4,0,.2,1),color .15s cubic-bezier(.4,0,.2,1);white-space:nowrap;will-change:transform}.mdc-floating-label[dir=rtl],[dir=rtl] .mdc-floating-label{left:auto;right:0;text-align:right;-webkit-transform-origin:right top;transform-origin:right top}.mdc-floating-label--float-above{cursor:auto}.mdc-floating-label--required:after{content:"*";margin-left:1px;margin-right:0}.mdc-floating-label--required[dir=rtl]:after,[dir=rtl] .mdc-floating-label--required:after{margin-left:0;margin-right:1px}.mdc-floating-label--float-above{transform:translateY(-106%) scale(.75)}.mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-standard .25s 1}@keyframes mdc-floating-label-shake-float-above-standard{0%{transform:translateX(0) translateY(-106%) scale(.75)}33%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translateX(4%) translateY(-106%) scale(.75)}66%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translateX(-4%) translateY(-106%) scale(.75)}to{transform:translateX(0) translateY(-106%) scale(.75)}}.smui-floating-label--remove-transition{transition:unset!important}.smui-floating-label--force-size{position:absolute!important;transform:unset!important}.mdc-line-ripple:after,.mdc-line-ripple:before{border-bottom-style:solid;bottom:0;content:"";left:0;position:absolute;width:100%}.mdc-line-ripple:before{border-bottom-width:1px;z-index:1}.mdc-line-ripple:after{border-bottom-width:2px;opacity:0;transform:scaleX(0);transition:transform .18s cubic-bezier(.4,0,.2,1),opacity .18s cubic-bezier(.4,0,.2,1);z-index:2}.mdc-line-ripple--active:after{opacity:1;transform:scaleX(1)}.mdc-line-ripple--deactivating:after{opacity:0}.mdc-deprecated-list{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;color:rgba(0,0,0,.87);color:var(--mdc-theme-text-primary-on-background,rgba(0,0,0,.87));font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);line-height:1.75rem;line-height:var(--mdc-typography-subtitle1-line-height,1.75rem);line-height:1.5rem;list-style-type:none;margin:0;padding:8px 0;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit)}.mdc-deprecated-list:focus{outline:none}.mdc-deprecated-list-item__secondary-text{color:rgba(0,0,0,.54);color:var(--mdc-theme-text-secondary-on-background,rgba(0,0,0,.54))}.mdc-deprecated-list-item__graphic{background-color:transparent;color:rgba(0,0,0,.38);color:var(--mdc-theme-text-icon-on-background,rgba(0,0,0,.38))}.mdc-deprecated-list-item__meta{color:rgba(0,0,0,.38);color:var(--mdc-theme-text-hint-on-background,rgba(0,0,0,.38))}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__text{opacity:.38}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__primary-text,.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__secondary-text,.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__text{color:#000;color:var(--mdc-theme-on-surface,#000)}.mdc-deprecated-list-item--activated,.mdc-deprecated-list-item--activated .mdc-deprecated-list-item__graphic,.mdc-deprecated-list-item--selected,.mdc-deprecated-list-item--selected .mdc-deprecated-list-item__graphic{color:#6200ee;color:var(--mdc-theme-primary,#6200ee)}.mdc-deprecated-list--dense{font-size:.812rem;padding-bottom:4px;padding-top:4px}.mdc-deprecated-list-item__wrapper{display:block}.mdc-deprecated-list-item{align-items:center;display:flex;height:48px;justify-content:flex-start;overflow:hidden;padding:0 16px;position:relative}.mdc-deprecated-list-item:focus{outline:none}.mdc-deprecated-list-item.mdc-ripple-upgraded--background-focused:before,.mdc-deprecated-list-item:not(.mdc-deprecated-list-item--selected):focus:before{border:1px solid transparent;border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}@media screen and (forced-colors:active){.mdc-deprecated-list-item.mdc-ripple-upgraded--background-focused:before,.mdc-deprecated-list-item:not(.mdc-deprecated-list-item--selected):focus:before{border-color:CanvasText}}.mdc-deprecated-list-item.mdc-deprecated-list-item--selected:before{border:3px double transparent;border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}@media screen and (forced-colors:active){.mdc-deprecated-list-item.mdc-deprecated-list-item--selected:before{border-color:CanvasText}}.mdc-deprecated-list-item[dir=rtl],[dir=rtl] .mdc-deprecated-list-item{padding-left:16px;padding-right:16px}.mdc-deprecated-list--icon-list .mdc-deprecated-list-item{height:56px;padding-left:16px;padding-right:16px}.mdc-deprecated-list--icon-list .mdc-deprecated-list-item[dir=rtl],[dir=rtl] .mdc-deprecated-list--icon-list .mdc-deprecated-list-item{padding-left:16px;padding-right:16px}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item{height:56px;padding-left:16px;padding-right:16px}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item[dir=rtl],[dir=rtl] .mdc-deprecated-list--avatar-list .mdc-deprecated-list-item{padding-left:16px;padding-right:16px}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item{height:56px;padding-left:16px;padding-right:16px}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item[dir=rtl],[dir=rtl] .mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item{padding-left:16px;padding-right:16px}.mdc-deprecated-list--image-list .mdc-deprecated-list-item{height:72px;padding-left:16px;padding-right:16px}.mdc-deprecated-list--image-list .mdc-deprecated-list-item[dir=rtl],[dir=rtl] .mdc-deprecated-list--image-list .mdc-deprecated-list-item{padding-left:16px;padding-right:16px}.mdc-deprecated-list--video-list .mdc-deprecated-list-item{height:72px;padding-left:0;padding-right:16px}.mdc-deprecated-list--video-list .mdc-deprecated-list-item[dir=rtl],[dir=rtl] .mdc-deprecated-list--video-list .mdc-deprecated-list-item{padding-left:16px;padding-right:0}.mdc-deprecated-list--dense .mdc-deprecated-list-item__graphic{height:20px;margin-left:0;margin-right:16px;width:20px}.mdc-deprecated-list--dense .mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list--dense .mdc-deprecated-list-item__graphic{margin-left:16px;margin-right:0}.mdc-deprecated-list-item__graphic{fill:currentColor;align-items:center;flex-shrink:0;height:24px;justify-content:center;margin-left:0;margin-right:32px;object-fit:cover;width:24px}.mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list-item__graphic{margin-left:32px;margin-right:0}.mdc-deprecated-list--icon-list .mdc-deprecated-list-item__graphic{height:24px;margin-left:0;margin-right:32px;width:24px}.mdc-deprecated-list--icon-list .mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list--icon-list .mdc-deprecated-list-item__graphic{margin-left:32px;margin-right:0}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item__graphic{border-radius:50%;height:40px;margin-left:0;margin-right:16px;width:40px}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list--avatar-list .mdc-deprecated-list-item__graphic{margin-left:16px;margin-right:0}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item__graphic{height:40px;margin-left:0;margin-right:16px;width:40px}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item__graphic{margin-left:16px;margin-right:0}.mdc-deprecated-list--image-list .mdc-deprecated-list-item__graphic{height:56px;margin-left:0;margin-right:16px;width:56px}.mdc-deprecated-list--image-list .mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list--image-list .mdc-deprecated-list-item__graphic{margin-left:16px;margin-right:0}.mdc-deprecated-list--video-list .mdc-deprecated-list-item__graphic{height:56px;margin-left:0;margin-right:16px;width:100px}.mdc-deprecated-list--video-list .mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list--video-list .mdc-deprecated-list-item__graphic{margin-left:16px;margin-right:0}.mdc-deprecated-list .mdc-deprecated-list-item__graphic{display:inline-flex}.mdc-deprecated-list-item__meta{margin-left:auto;margin-right:0}.mdc-deprecated-list-item__meta:not(.material-icons){-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-caption-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:.75rem;font-size:var(--mdc-typography-caption-font-size,.75rem);font-weight:400;font-weight:var(--mdc-typography-caption-font-weight,400);letter-spacing:.0333333333em;letter-spacing:var(--mdc-typography-caption-letter-spacing,.0333333333em);line-height:1.25rem;line-height:var(--mdc-typography-caption-line-height,1.25rem);text-decoration:inherit;text-decoration:var(--mdc-typography-caption-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-caption-text-transform,inherit)}.mdc-deprecated-list-item[dir=rtl] .mdc-deprecated-list-item__meta,[dir=rtl] .mdc-deprecated-list-item .mdc-deprecated-list-item__meta{margin-left:0;margin-right:auto}.mdc-deprecated-list-item__text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mdc-deprecated-list-item__text[for]{pointer-events:none}.mdc-deprecated-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mdc-deprecated-list-item__primary-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-deprecated-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item__primary-text,.mdc-deprecated-list--icon-list .mdc-deprecated-list-item__primary-text,.mdc-deprecated-list--image-list .mdc-deprecated-list-item__primary-text,.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item__primary-text,.mdc-deprecated-list--video-list .mdc-deprecated-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item__primary-text:before,.mdc-deprecated-list--icon-list .mdc-deprecated-list-item__primary-text:before,.mdc-deprecated-list--image-list .mdc-deprecated-list-item__primary-text:before,.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item__primary-text:before,.mdc-deprecated-list--video-list .mdc-deprecated-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item__primary-text:after,.mdc-deprecated-list--icon-list .mdc-deprecated-list-item__primary-text:after,.mdc-deprecated-list--image-list .mdc-deprecated-list-item__primary-text:after,.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item__primary-text:after,.mdc-deprecated-list--video-list .mdc-deprecated-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-deprecated-list--dense .mdc-deprecated-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-deprecated-list--dense .mdc-deprecated-list-item__primary-text:before{content:"";display:inline-block;height:24px;vertical-align:0;width:0}.mdc-deprecated-list--dense .mdc-deprecated-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-deprecated-list-item__secondary-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-body2-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:.875rem;font-size:var(--mdc-typography-body2-font-size,.875rem);font-weight:400;font-weight:var(--mdc-typography-body2-font-weight,400);letter-spacing:.0178571429em;letter-spacing:var(--mdc-typography-body2-letter-spacing,.0178571429em);line-height:1.25rem;line-height:var(--mdc-typography-body2-line-height,1.25rem);line-height:normal;margin-top:0;overflow:hidden;text-decoration:inherit;text-decoration:var(--mdc-typography-body2-text-decoration,inherit);text-overflow:ellipsis;text-transform:inherit;text-transform:var(--mdc-typography-body2-text-transform,inherit);white-space:nowrap}.mdc-deprecated-list-item__secondary-text:before{content:"";display:inline-block;height:20px;vertical-align:0;width:0}.mdc-deprecated-list--dense .mdc-deprecated-list-item__secondary-text{font-size:inherit}.mdc-deprecated-list--dense .mdc-deprecated-list-item{height:40px}.mdc-deprecated-list--two-line .mdc-deprecated-list-item__text{align-self:flex-start}.mdc-deprecated-list--two-line .mdc-deprecated-list-item{height:64px}.mdc-deprecated-list--two-line.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item,.mdc-deprecated-list--two-line.mdc-deprecated-list--icon-list .mdc-deprecated-list-item,.mdc-deprecated-list--two-line.mdc-deprecated-list--image-list .mdc-deprecated-list-item,.mdc-deprecated-list--two-line.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item,.mdc-deprecated-list--two-line.mdc-deprecated-list--video-list .mdc-deprecated-list-item{height:72px}.mdc-deprecated-list--two-line.mdc-deprecated-list--icon-list .mdc-deprecated-list-item__graphic{align-self:flex-start;margin-top:16px}.mdc-deprecated-list--avatar-list.mdc-deprecated-list--dense .mdc-deprecated-list-item,.mdc-deprecated-list--two-line.mdc-deprecated-list--dense .mdc-deprecated-list-item{height:60px}.mdc-deprecated-list--avatar-list.mdc-deprecated-list--dense .mdc-deprecated-list-item__graphic{height:36px;margin-left:0;margin-right:16px;width:36px}.mdc-deprecated-list--avatar-list.mdc-deprecated-list--dense .mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list--avatar-list.mdc-deprecated-list--dense .mdc-deprecated-list-item__graphic{margin-left:16px;margin-right:0}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item{cursor:pointer}a.mdc-deprecated-list-item{color:inherit;text-decoration:none}.mdc-deprecated-list-divider{border:none;border-bottom:1px solid;border-bottom-color:rgba(0,0,0,.12);height:0;margin:0}.mdc-deprecated-list-divider--padded{margin-left:16px;margin-right:0;width:calc(100% - 32px)}.mdc-deprecated-list-divider--padded[dir=rtl],[dir=rtl] .mdc-deprecated-list-divider--padded{margin-left:0;margin-right:16px}.mdc-deprecated-list-divider--inset{margin-left:72px;margin-right:0;width:calc(100% - 72px)}.mdc-deprecated-list-divider--inset[dir=rtl],[dir=rtl] .mdc-deprecated-list-divider--inset{margin-left:0;margin-right:72px}.mdc-deprecated-list-divider--inset.mdc-deprecated-list-divider--padded{margin-left:72px;margin-right:0;width:calc(100% - 88px)}.mdc-deprecated-list-divider--inset.mdc-deprecated-list-divider--padded[dir=rtl],[dir=rtl] .mdc-deprecated-list-divider--inset.mdc-deprecated-list-divider--padded{margin-left:0;margin-right:72px}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading{margin-left:16px;margin-right:0;width:calc(100% - 16px)}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading[dir=rtl],[dir=rtl] .mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading{margin-left:0;margin-right:16px}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-trailing{width:calc(100% - 16px)}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:16px;margin-right:0;width:calc(100% - 32px)}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing[dir=rtl],[dir=rtl] .mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:0;margin-right:16px}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:16px;margin-right:0;width:calc(100% - 16px)}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding[dir=rtl],[dir=rtl] .mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:0;margin-right:16px}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:16px;margin-right:0;width:calc(100% - 32px)}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding[dir=rtl],[dir=rtl] .mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading{margin-left:72px;margin-right:0;width:calc(100% - 72px)}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading[dir=rtl],[dir=rtl] .mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading{margin-left:0;margin-right:72px}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-trailing{width:calc(100% - 16px)}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:72px;margin-right:0;width:calc(100% - 88px)}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing[dir=rtl],[dir=rtl] .mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:0;margin-right:72px}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:16px;margin-right:0;width:calc(100% - 16px)}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:16px;margin-right:0;width:calc(100% - 32px)}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading{margin-left:72px;margin-right:0;width:calc(100% - 72px)}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading[dir=rtl],[dir=rtl] .mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading{margin-left:0;margin-right:72px}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-trailing{width:calc(100% - 16px)}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:72px;margin-right:0;width:calc(100% - 88px)}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing[dir=rtl],[dir=rtl] .mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:0;margin-right:72px}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:16px;margin-right:0;width:calc(100% - 16px)}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:16px;margin-right:0;width:calc(100% - 32px)}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading{margin-left:72px;margin-right:0;width:calc(100% - 72px)}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading[dir=rtl],[dir=rtl] .mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading{margin-left:0;margin-right:72px}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-trailing{width:calc(100% - 16px)}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:72px;margin-right:0;width:calc(100% - 88px)}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing[dir=rtl],[dir=rtl] .mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:0;margin-right:72px}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:16px;margin-right:0;width:calc(100% - 16px)}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:16px;margin-right:0;width:calc(100% - 32px)}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading{margin-left:88px;margin-right:0;width:calc(100% - 88px)}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading[dir=rtl],[dir=rtl] .mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading{margin-left:0;margin-right:88px}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-trailing{width:calc(100% - 16px)}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:88px;margin-right:0;width:calc(100% - 104px)}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing[dir=rtl],[dir=rtl] .mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:0;margin-right:88px}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:16px;margin-right:0;width:calc(100% - 16px)}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:16px;margin-right:0;width:calc(100% - 32px)}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading{margin-left:116px;margin-right:0;width:calc(100% - 116px)}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading[dir=rtl],[dir=rtl] .mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading{margin-left:0;margin-right:116px}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-trailing{width:calc(100% - 16px)}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:116px;margin-right:0;width:calc(100% - 132px)}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing[dir=rtl],[dir=rtl] .mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:0;margin-right:116px}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:0;margin-right:0;width:100%}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:0;margin-right:0}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:0;margin-right:0;width:calc(100% - 16px)}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:0;margin-right:0}.mdc-deprecated-list-group .mdc-deprecated-list{padding:0}.mdc-deprecated-list-group__subheader{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);line-height:1.75rem;line-height:var(--mdc-typography-subtitle1-line-height,1.75rem);margin:.75rem 16px;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit)}.mdc-list-item__primary-text{color:rgba(0,0,0,.87);color:var(--mdc-theme-text-primary-on-background,rgba(0,0,0,.87))}.mdc-list-item__secondary-text{color:rgba(0,0,0,.54);color:var(--mdc-theme-text-secondary-on-background,rgba(0,0,0,.54))}.mdc-list-item__overline-text{color:rgba(0,0,0,.38);color:var(--mdc-theme-text-hint-on-background,rgba(0,0,0,.38))}.mdc-list-item--with-leading-icon .mdc-list-item__start,.mdc-list-item--with-trailing-icon .mdc-list-item__end{background-color:transparent;color:rgba(0,0,0,.38);color:var(--mdc-theme-text-icon-on-background,rgba(0,0,0,.38))}.mdc-list-item__end{color:rgba(0,0,0,.38);color:var(--mdc-theme-text-hint-on-background,rgba(0,0,0,.38))}.mdc-list-item--disabled .mdc-list-item__content,.mdc-list-item--disabled .mdc-list-item__end,.mdc-list-item--disabled .mdc-list-item__start{opacity:.38}.mdc-list-item--disabled .mdc-list-item__overline-text,.mdc-list-item--disabled .mdc-list-item__primary-text,.mdc-list-item--disabled .mdc-list-item__secondary-text,.mdc-list-item--disabled.mdc-list-item--with-leading-icon .mdc-list-item__start,.mdc-list-item--disabled.mdc-list-item--with-trailing-icon .mdc-list-item__end,.mdc-list-item--disabled.mdc-list-item--with-trailing-meta .mdc-list-item__end{color:#000;color:var(--mdc-theme-on-surface,#000)}.mdc-list-item--activated .mdc-list-item__primary-text,.mdc-list-item--activated.mdc-list-item--with-leading-icon .mdc-list-item__start,.mdc-list-item--selected .mdc-list-item__primary-text,.mdc-list-item--selected.mdc-list-item--with-leading-icon .mdc-list-item__start{color:#6200ee;color:var(--mdc-theme-primary,#6200ee)}.mdc-deprecated-list-group__subheader{color:rgba(0,0,0,.87);color:var(--mdc-theme-text-primary-on-background,rgba(0,0,0,.87))}@media (-ms-high-contrast:active),screen and (forced-colors:active){.mdc-list-divider:after{border-bottom:1px solid #fff;content:"";display:block}}.mdc-list{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);line-height:1.75rem;line-height:var(--mdc-typography-subtitle1-line-height,1.75rem);line-height:1.5rem;list-style-type:none;margin:0;padding:8px 0;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit)}.mdc-list:focus{outline:none}.mdc-list-item__wrapper{display:block}.mdc-list-item{align-items:center;align-items:stretch;cursor:pointer;display:flex;justify-content:flex-start;overflow:hidden;padding:0;position:relative}.mdc-list-item:focus{outline:none}.mdc-list-item.mdc-list-item--with-one-line{height:48px}.mdc-list-item.mdc-list-item--with-two-lines{height:64px}.mdc-list-item.mdc-list-item--with-three-lines{height:88px}.mdc-list-item.mdc-list-item--with-one-line .mdc-list-item__start{align-self:center;margin-top:0}.mdc-list-item.mdc-list-item--with-three-lines .mdc-list-item__start,.mdc-list-item.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:16px}.mdc-list-item.mdc-list-item--with-one-line .mdc-list-item__end,.mdc-list-item.mdc-list-item--with-two-lines .mdc-list-item__end{align-self:center;margin-top:0}.mdc-list-item.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:16px}.mdc-list-item.mdc-list-item--disabled,.mdc-list-item.mdc-list-item--non-interactive{cursor:auto}.mdc-list-item.mdc-ripple-upgraded--background-focused:before,.mdc-list-item:not(.mdc-list-item--selected):focus:before{border:1px solid transparent;border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}@media screen and (forced-colors:active){.mdc-list-item.mdc-ripple-upgraded--background-focused:before,.mdc-list-item:not(.mdc-list-item--selected):focus:before{border-color:CanvasText}}.mdc-list-item.mdc-list-item--selected:before{border:3px double transparent;border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}@media screen and (forced-colors:active){.mdc-list-item.mdc-list-item--selected:before{border-color:CanvasText}}.mdc-list-item.mdc-list-item--selected:focus:before{border:3px solid transparent;border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}@media screen and (forced-colors:active){.mdc-list-item.mdc-list-item--selected:focus:before{border-color:CanvasText}}a.mdc-list-item{color:inherit;text-decoration:none}.mdc-list-item__start{fill:currentColor}.mdc-list-item__end,.mdc-list-item__start{flex-shrink:0;pointer-events:none}.mdc-list-item__content{align-self:center;flex:1;overflow:hidden;pointer-events:none;text-overflow:ellipsis;white-space:nowrap}.mdc-list-item--with-three-lines .mdc-list-item__content,.mdc-list-item--with-two-lines .mdc-list-item__content{align-self:stretch}.mdc-list-item__content[for]{pointer-events:none}.mdc-list-item__primary-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);line-height:1.75rem;line-height:var(--mdc-typography-subtitle1-line-height,1.75rem);overflow:hidden;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-overflow:ellipsis;text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit);white-space:nowrap}.mdc-list-item--with-three-lines .mdc-list-item__primary-text,.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-three-lines .mdc-list-item__primary-text:before,.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-three-lines .mdc-list-item__primary-text:after,.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item__secondary-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-body2-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:.875rem;font-size:var(--mdc-typography-body2-font-size,.875rem);font-weight:400;font-weight:var(--mdc-typography-body2-font-weight,400);letter-spacing:.0178571429em;letter-spacing:var(--mdc-typography-body2-letter-spacing,.0178571429em);line-height:1.25rem;line-height:var(--mdc-typography-body2-line-height,1.25rem);line-height:normal;margin-top:0;overflow:hidden;text-decoration:inherit;text-decoration:var(--mdc-typography-body2-text-decoration,inherit);text-overflow:ellipsis;text-transform:inherit;text-transform:var(--mdc-typography-body2-text-transform,inherit);white-space:nowrap}.mdc-list-item__secondary-text:before{content:"";display:inline-block;height:20px;vertical-align:0;width:0}.mdc-list-item--with-three-lines .mdc-list-item__secondary-text{line-height:20px;white-space:normal}.mdc-list-item--with-overline .mdc-list-item__secondary-text{line-height:auto;white-space:nowrap}.mdc-list-item__overline-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-overline-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:.75rem;font-size:var(--mdc-typography-overline-font-size,.75rem);font-weight:500;font-weight:var(--mdc-typography-overline-font-weight,500);letter-spacing:.1666666667em;letter-spacing:var(--mdc-typography-overline-letter-spacing,.1666666667em);line-height:2rem;line-height:var(--mdc-typography-overline-line-height,2rem);overflow:hidden;text-decoration:none;text-decoration:var(--mdc-typography-overline-text-decoration,none);text-overflow:ellipsis;text-transform:uppercase;text-transform:var(--mdc-typography-overline-text-transform,uppercase);white-space:nowrap}.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:24px;vertical-align:0;width:0}.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-three-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-three-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-three-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-avatar.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-avatar.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-avatar.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-avatar .mdc-list-item__start,.mdc-list-item--with-leading-avatar .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-avatar .mdc-list-item__start{margin-left:16px;margin-right:16px}.mdc-list-item--with-leading-avatar .mdc-list-item__start{height:40px;width:40px}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-avatar .mdc-list-item__start{border-radius:50%}.mdc-list-item--with-leading-icon .mdc-list-item__start{height:24px;width:24px}.mdc-list-item--with-leading-icon.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-icon.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-icon.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-icon .mdc-list-item__start{margin-left:16px;margin-right:32px}.mdc-list-item--with-leading-icon .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-icon .mdc-list-item__start{margin-left:32px;margin-right:16px}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-thumbnail.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-thumbnail.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-thumbnail.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-thumbnail .mdc-list-item__start,.mdc-list-item--with-leading-thumbnail .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-thumbnail .mdc-list-item__start{margin-left:16px;margin-right:16px}.mdc-list-item--with-leading-thumbnail .mdc-list-item__start{height:40px;width:40px}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-image.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-image.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-image.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-image .mdc-list-item__start,.mdc-list-item--with-leading-image .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-image .mdc-list-item__start{margin-left:16px;margin-right:16px}.mdc-list-item--with-leading-image .mdc-list-item__start{height:56px;width:56px}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-image.mdc-list-item--with-one-line,.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:8px}.mdc-list-item--with-leading-video.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-video.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-video.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-video .mdc-list-item__start{margin-left:0;margin-right:16px}.mdc-list-item--with-leading-video .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-video .mdc-list-item__start{margin-left:16px;margin-right:0}.mdc-list-item--with-leading-video .mdc-list-item__start{height:56px;width:100px}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-video.mdc-list-item--with-one-line,.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-checkbox.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-checkbox.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-checkbox.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-checkbox .mdc-list-item__start{margin-left:8px;margin-right:24px}.mdc-list-item--with-leading-checkbox .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-checkbox .mdc-list-item__start{margin-left:24px;margin-right:8px}.mdc-list-item--with-leading-checkbox .mdc-list-item__start{height:40px;width:40px}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:8px}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-radio.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-radio.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-radio.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-radio .mdc-list-item__start{margin-left:8px;margin-right:24px}.mdc-list-item--with-leading-radio .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-radio .mdc-list-item__start{margin-left:24px;margin-right:8px}.mdc-list-item--with-leading-radio .mdc-list-item__start{height:40px;width:40px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:8px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-switch.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-switch.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-switch.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-switch .mdc-list-item__start,.mdc-list-item--with-leading-switch .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-switch .mdc-list-item__start{margin-left:16px;margin-right:16px}.mdc-list-item--with-leading-switch .mdc-list-item__start{height:20px;width:36px}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:16px}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-trailing-icon.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-trailing-icon.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-icon.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-icon .mdc-list-item__end,.mdc-list-item--with-trailing-icon .mdc-list-item__end[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-icon .mdc-list-item__end{margin-left:16px;margin-right:16px}.mdc-list-item--with-trailing-icon .mdc-list-item__end{height:24px;width:24px}.mdc-list-item--with-trailing-meta.mdc-list-item--with-three-lines .mdc-list-item__end,.mdc-list-item--with-trailing-meta.mdc-list-item--with-two-lines .mdc-list-item__end{align-self:flex-start}.mdc-list-item--with-trailing-meta.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-trailing-meta.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-meta.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-meta .mdc-list-item__end{margin-left:28px;margin-right:16px}.mdc-list-item--with-trailing-meta .mdc-list-item__end[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-meta .mdc-list-item__end{margin-left:16px;margin-right:28px}.mdc-list-item--with-trailing-meta.mdc-list-item--with-two-lines .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-trailing-meta.mdc-list-item--with-two-lines .mdc-list-item__end:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-trailing-meta.mdc-list-item--with-three-lines .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-trailing-meta.mdc-list-item--with-three-lines .mdc-list-item__end:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-trailing-meta .mdc-list-item__end{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-caption-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:.75rem;font-size:var(--mdc-typography-caption-font-size,.75rem);font-weight:400;font-weight:var(--mdc-typography-caption-font-weight,400);letter-spacing:.0333333333em;letter-spacing:var(--mdc-typography-caption-letter-spacing,.0333333333em);line-height:1.25rem;line-height:var(--mdc-typography-caption-line-height,1.25rem);text-decoration:inherit;text-decoration:var(--mdc-typography-caption-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-caption-text-transform,inherit)}.mdc-list-item--with-trailing-checkbox.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-trailing-checkbox.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-checkbox.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-checkbox .mdc-list-item__end{margin-left:24px;margin-right:8px}.mdc-list-item--with-trailing-checkbox .mdc-list-item__end[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-checkbox .mdc-list-item__end{margin-left:8px;margin-right:24px}.mdc-list-item--with-trailing-checkbox .mdc-list-item__end{height:40px;width:40px}.mdc-list-item--with-trailing-checkbox.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:8px}.mdc-list-item--with-trailing-radio.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-trailing-radio.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-radio.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-radio .mdc-list-item__end{margin-left:24px;margin-right:8px}.mdc-list-item--with-trailing-radio .mdc-list-item__end[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-radio .mdc-list-item__end{margin-left:8px;margin-right:24px}.mdc-list-item--with-trailing-radio .mdc-list-item__end{height:40px;width:40px}.mdc-list-item--with-trailing-radio.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:8px}.mdc-list-item--with-trailing-switch.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-trailing-switch.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-switch.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-switch .mdc-list-item__end,.mdc-list-item--with-trailing-switch .mdc-list-item__end[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-switch .mdc-list-item__end{margin-left:16px;margin-right:16px}.mdc-list-item--with-trailing-switch .mdc-list-item__end{height:20px;width:36px}.mdc-list-item--with-trailing-switch.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:16px}.mdc-list-item--with-overline.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-overline.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:20px;vertical-align:0;width:0}.mdc-list-item--with-overline.mdc-list-item--with-three-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-overline.mdc-list-item--with-three-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:20px;vertical-align:0;width:0}.mdc-list-item,.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item{padding-left:16px;padding-right:16px}.mdc-list-group .mdc-deprecated-list{padding:0}.mdc-list-group__subheader{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);line-height:1.75rem;line-height:var(--mdc-typography-subtitle1-line-height,1.75rem);margin:.75rem 16px;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit)}.mdc-list-divider{background-clip:content-box;background-color:rgba(0,0,0,.12);height:1px;padding:0}.mdc-list-divider--with-leading-avatar.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-icon.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-image.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-radio.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-switch.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-text.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-leading-inset,.mdc-list-divider.mdc-list-divider--with-leading-inset{padding-left:16px;padding-right:auto}.mdc-list-divider--with-leading-avatar.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-avatar.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-icon.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-icon.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-image.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-image.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-radio.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-radio.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-switch.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-switch.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-text.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-text.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-trailing-inset,.mdc-list-divider.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-avatar.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-icon.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-image.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-radio.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-switch.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-text.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider.mdc-list-divider--with-leading-inset{padding-left:auto;padding-right:16px}.mdc-list-divider--with-leading-avatar.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-icon.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-image.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-radio.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-switch.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-text.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider.mdc-list-divider--with-trailing-inset[dir=rtl],[dir=rtl] .mdc-list-divider--with-leading-avatar.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-icon.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-image.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-radio.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-switch.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-text.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider.mdc-list-divider--with-trailing-inset{padding-left:16px;padding-right:auto}.mdc-list-divider--with-leading-video.mdc-list-divider--with-leading-inset{padding-left:0;padding-right:auto}.mdc-list-divider--with-leading-video.mdc-list-divider--with-leading-inset[dir=rtl],[dir=rtl] .mdc-list-divider--with-leading-video.mdc-list-divider--with-leading-inset{padding-left:auto;padding-right:0}.mdc-list-divider[dir=rtl],[dir=rtl] .mdc-list-divider{padding:0}@keyframes mdc-ripple-fg-radius-in{0%{animation-timing-function:cubic-bezier(.4,0,.2,1);transform:translate(var(--mdc-ripple-fg-translate-start,0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}}@keyframes mdc-ripple-fg-opacity-in{0%{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity,0)}}@keyframes mdc-ripple-fg-opacity-out{0%{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity,0)}to{opacity:0}}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded .mdc-deprecated-list-item__ripple:before{transform:scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded .mdc-deprecated-list-item__ripple:after{left:0;top:0;transform:scale(0);transform-origin:center center}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--unbounded .mdc-deprecated-list-item__ripple:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--foreground-activation .mdc-deprecated-list-item__ripple:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--foreground-deactivation .mdc-deprecated-list-item__ripple:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded .mdc-list-item__ripple:before{transform:scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded .mdc-list-item__ripple:after{left:0;top:0;transform:scale(0);transform-origin:center center}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--unbounded .mdc-list-item__ripple:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--foreground-activation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--foreground-deactivation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:before{height:200%;left:-50%;top:-50%;width:200%}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded .mdc-deprecated-list-item__ripple:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:before{height:200%;left:-50%;top:-50%;width:200%}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded .mdc-list-item__ripple:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:before{background-color:#000;background-color:var(--mdc-ripple-color,#000)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-surface--hover .mdc-deprecated-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:hover .mdc-deprecated-list-item__ripple:before{opacity:.04;opacity:var(--mdc-ripple-hover-opacity,.04)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--background-focused .mdc-deprecated-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:not(.mdc-ripple-upgraded):focus .mdc-deprecated-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:not(.mdc-ripple-upgraded) .mdc-deprecated-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:not(.mdc-ripple-upgraded):active .mdc-deprecated-list-item__ripple:after{opacity:.12;opacity:var(--mdc-ripple-press-opacity,.12);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:before{background-color:#000;background-color:var(--mdc-ripple-color,#000)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-surface--hover .mdc-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:hover .mdc-list-item__ripple:before{opacity:.04;opacity:var(--mdc-ripple-hover-opacity,.04)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:not(.mdc-ripple-upgraded) .mdc-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:not(.mdc-ripple-upgraded):active .mdc-list-item__ripple:after{opacity:.12;opacity:var(--mdc-ripple-press-opacity,.12);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.12)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated .mdc-deprecated-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-activated-opacity,.12)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated .mdc-deprecated-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated .mdc-deprecated-list-item__ripple:before{background-color:#6200ee;background-color:var(--mdc-ripple-color,var(--mdc-theme-primary,#6200ee))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated.mdc-ripple-surface--hover .mdc-deprecated-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:hover .mdc-deprecated-list-item__ripple:before{opacity:.16;opacity:var(--mdc-ripple-hover-opacity,.16)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated.mdc-ripple-upgraded--background-focused .mdc-deprecated-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:not(.mdc-ripple-upgraded):focus .mdc-deprecated-list-item__ripple:before{opacity:.24;opacity:var(--mdc-ripple-focus-opacity,.24);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:not(.mdc-ripple-upgraded) .mdc-deprecated-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:not(.mdc-ripple-upgraded):active .mdc-deprecated-list-item__ripple:after{opacity:.24;opacity:var(--mdc-ripple-press-opacity,.24);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-activated-opacity,.12)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated .mdc-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated .mdc-list-item__ripple:before{background-color:#6200ee;background-color:var(--mdc-ripple-color,var(--mdc-theme-primary,#6200ee))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated.mdc-ripple-surface--hover .mdc-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:hover .mdc-list-item__ripple:before{opacity:.16;opacity:var(--mdc-ripple-hover-opacity,.16)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.24;opacity:var(--mdc-ripple-focus-opacity,.24);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:not(.mdc-ripple-upgraded) .mdc-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:not(.mdc-ripple-upgraded):active .mdc-list-item__ripple:after{opacity:.24;opacity:var(--mdc-ripple-press-opacity,.24);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.24)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected .mdc-deprecated-list-item__ripple:before{opacity:.08;opacity:var(--mdc-ripple-selected-opacity,.08)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected .mdc-deprecated-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected .mdc-deprecated-list-item__ripple:before{background-color:#6200ee;background-color:var(--mdc-ripple-color,var(--mdc-theme-primary,#6200ee))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected.mdc-ripple-surface--hover .mdc-deprecated-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:hover .mdc-deprecated-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-hover-opacity,.12)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected.mdc-ripple-upgraded--background-focused .mdc-deprecated-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded):focus .mdc-deprecated-list-item__ripple:before{opacity:.2;opacity:var(--mdc-ripple-focus-opacity,.2);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded) .mdc-deprecated-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded):active .mdc-deprecated-list-item__ripple:after{opacity:.2;opacity:var(--mdc-ripple-press-opacity,.2);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected .mdc-list-item__ripple:before{opacity:.08;opacity:var(--mdc-ripple-selected-opacity,.08)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected .mdc-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected .mdc-list-item__ripple:before{background-color:#6200ee;background-color:var(--mdc-ripple-color,var(--mdc-theme-primary,#6200ee))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected.mdc-ripple-surface--hover .mdc-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:hover .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-hover-opacity,.12)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.2;opacity:var(--mdc-ripple-focus-opacity,.2);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded) .mdc-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded):active .mdc-list-item__ripple:after{opacity:.2;opacity:var(--mdc-ripple-press-opacity,.2);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.2)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple{height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.mdc-deprecated-list-item--disabled{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:after,.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded .mdc-deprecated-list-item__ripple:before{transform:scale(var(--mdc-ripple-fg-scale,1))}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded .mdc-deprecated-list-item__ripple:after{left:0;top:0;transform:scale(0);transform-origin:center center}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--unbounded .mdc-deprecated-list-item__ripple:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--foreground-activation .mdc-deprecated-list-item__ripple:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--foreground-deactivation .mdc-deprecated-list-item__ripple:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:after,.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded .mdc-list-item__ripple:before{transform:scale(var(--mdc-ripple-fg-scale,1))}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded .mdc-list-item__ripple:after{left:0;top:0;transform:scale(0);transform-origin:center center}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--unbounded .mdc-list-item__ripple:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--foreground-activation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--foreground-deactivation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:after,.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:before{height:200%;left:-50%;top:-50%;width:200%}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded .mdc-deprecated-list-item__ripple:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:after,.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:before{height:200%;left:-50%;top:-50%;width:200%}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded .mdc-list-item__ripple:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:after,.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:before,.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:after,.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:before{background-color:#000;background-color:var(--mdc-ripple-color,#000)}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--background-focused .mdc-deprecated-list-item__ripple:before,.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,.mdc-deprecated-list-item--disabled:not(.mdc-ripple-upgraded):focus .mdc-deprecated-list-item__ripple:before,.mdc-deprecated-list-item--disabled:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple,.mdc-deprecated-list-item--disabled .mdc-list-item__ripple{height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}:not(.mdc-list-item--disabled).mdc-list-item{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity}:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:after,:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded .mdc-list-item__ripple:before{transform:scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded .mdc-list-item__ripple:after{left:0;top:0;transform:scale(0);transform-origin:center center}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded--unbounded .mdc-list-item__ripple:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded--foreground-activation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded--foreground-deactivation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:after,:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:before{height:200%;left:-50%;top:-50%;width:200%}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded .mdc-list-item__ripple:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:after,:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:before{background-color:#000;background-color:var(--mdc-ripple-color,#000)}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-surface--hover .mdc-list-item__ripple:before,:not(.mdc-list-item--disabled).mdc-list-item:hover .mdc-list-item__ripple:before{opacity:.04;opacity:var(--mdc-ripple-hover-opacity,.04)}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,:not(.mdc-list-item--disabled).mdc-list-item:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}:not(.mdc-list-item--disabled).mdc-list-item:not(.mdc-ripple-upgraded) .mdc-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-list-item--disabled).mdc-list-item:not(.mdc-ripple-upgraded):active .mdc-list-item__ripple:after{opacity:.12;opacity:var(--mdc-ripple-press-opacity,.12);transition-duration:75ms}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.12)}:not(.mdc-list-item--disabled).mdc-list-item--activated .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-activated-opacity,.12)}:not(.mdc-list-item--disabled).mdc-list-item--activated .mdc-list-item__ripple:after,:not(.mdc-list-item--disabled).mdc-list-item--activated .mdc-list-item__ripple:before{background-color:#6200ee;background-color:var(--mdc-ripple-color,var(--mdc-theme-primary,#6200ee))}:not(.mdc-list-item--disabled).mdc-list-item--activated.mdc-ripple-surface--hover .mdc-list-item__ripple:before,:not(.mdc-list-item--disabled).mdc-list-item--activated:hover .mdc-list-item__ripple:before{opacity:.16;opacity:var(--mdc-ripple-hover-opacity,.16)}:not(.mdc-list-item--disabled).mdc-list-item--activated.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,:not(.mdc-list-item--disabled).mdc-list-item--activated:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.24;opacity:var(--mdc-ripple-focus-opacity,.24);transition-duration:75ms}:not(.mdc-list-item--disabled).mdc-list-item--activated:not(.mdc-ripple-upgraded) .mdc-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-list-item--disabled).mdc-list-item--activated:not(.mdc-ripple-upgraded):active .mdc-list-item__ripple:after{opacity:.24;opacity:var(--mdc-ripple-press-opacity,.24);transition-duration:75ms}:not(.mdc-list-item--disabled).mdc-list-item--activated.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.24)}:not(.mdc-list-item--disabled).mdc-list-item--selected .mdc-list-item__ripple:before{opacity:.08;opacity:var(--mdc-ripple-selected-opacity,.08)}:not(.mdc-list-item--disabled).mdc-list-item--selected .mdc-list-item__ripple:after,:not(.mdc-list-item--disabled).mdc-list-item--selected .mdc-list-item__ripple:before{background-color:#6200ee;background-color:var(--mdc-ripple-color,var(--mdc-theme-primary,#6200ee))}:not(.mdc-list-item--disabled).mdc-list-item--selected.mdc-ripple-surface--hover .mdc-list-item__ripple:before,:not(.mdc-list-item--disabled).mdc-list-item--selected:hover .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-hover-opacity,.12)}:not(.mdc-list-item--disabled).mdc-list-item--selected.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,:not(.mdc-list-item--disabled).mdc-list-item--selected:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.2;opacity:var(--mdc-ripple-focus-opacity,.2);transition-duration:75ms}:not(.mdc-list-item--disabled).mdc-list-item--selected:not(.mdc-ripple-upgraded) .mdc-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-list-item--disabled).mdc-list-item--selected:not(.mdc-ripple-upgraded):active .mdc-list-item__ripple:after{opacity:.2;opacity:var(--mdc-ripple-press-opacity,.2);transition-duration:75ms}:not(.mdc-list-item--disabled).mdc-list-item--selected.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.2)}:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple{height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.mdc-list-item--disabled{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity}.mdc-list-item--disabled .mdc-list-item__ripple:after,.mdc-list-item--disabled .mdc-list-item__ripple:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}.mdc-list-item--disabled .mdc-list-item__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}.mdc-list-item--disabled .mdc-list-item__ripple:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}.mdc-list-item--disabled.mdc-ripple-upgraded .mdc-list-item__ripple:before{transform:scale(var(--mdc-ripple-fg-scale,1))}.mdc-list-item--disabled.mdc-ripple-upgraded .mdc-list-item__ripple:after{left:0;top:0;transform:scale(0);transform-origin:center center}.mdc-list-item--disabled.mdc-ripple-upgraded--unbounded .mdc-list-item__ripple:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}.mdc-list-item--disabled.mdc-ripple-upgraded--foreground-activation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-list-item--disabled.mdc-ripple-upgraded--foreground-deactivation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}.mdc-list-item--disabled .mdc-list-item__ripple:after,.mdc-list-item--disabled .mdc-list-item__ripple:before{height:200%;left:-50%;top:-50%;width:200%}.mdc-list-item--disabled.mdc-ripple-upgraded .mdc-list-item__ripple:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}.mdc-list-item--disabled .mdc-list-item__ripple:after,.mdc-list-item--disabled .mdc-list-item__ripple:before{background-color:#000;background-color:var(--mdc-ripple-color,#000)}.mdc-list-item--disabled.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,.mdc-list-item--disabled:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}.mdc-list-item--disabled .mdc-list-item__ripple{height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.mdc-ripple-surface{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);outline:none;overflow:hidden;position:relative;will-change:transform,opacity}.mdc-ripple-surface:after,.mdc-ripple-surface:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}.mdc-ripple-surface:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}.mdc-ripple-surface:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}.mdc-ripple-surface.mdc-ripple-upgraded:before{transform:scale(var(--mdc-ripple-fg-scale,1))}.mdc-ripple-surface.mdc-ripple-upgraded:after{left:0;top:0;transform:scale(0);transform-origin:center center}.mdc-ripple-surface.mdc-ripple-upgraded--unbounded:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}.mdc-ripple-surface.mdc-ripple-upgraded--foreground-activation:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-ripple-surface.mdc-ripple-upgraded--foreground-deactivation:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}.mdc-ripple-surface:after,.mdc-ripple-surface:before{height:200%;left:-50%;top:-50%;width:200%}.mdc-ripple-surface.mdc-ripple-upgraded:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}.mdc-ripple-surface[data-mdc-ripple-is-unbounded],.mdc-ripple-upgraded--unbounded{overflow:visible}.mdc-ripple-surface[data-mdc-ripple-is-unbounded]:after,.mdc-ripple-surface[data-mdc-ripple-is-unbounded]:before,.mdc-ripple-upgraded--unbounded:after,.mdc-ripple-upgraded--unbounded:before{height:100%;left:0;top:0;width:100%}.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded:after,.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded:before,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded:after,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded:before{height:var(--mdc-ripple-fg-size,100%);left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0);width:var(--mdc-ripple-fg-size,100%)}.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded:after,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}.mdc-ripple-surface:after,.mdc-ripple-surface:before{background-color:#000;background-color:var(--mdc-ripple-color,#000)}.mdc-ripple-surface.mdc-ripple-surface--hover:before,.mdc-ripple-surface:hover:before{opacity:.04;opacity:var(--mdc-ripple-hover-opacity,.04)}.mdc-ripple-surface.mdc-ripple-upgraded--background-focused:before,.mdc-ripple-surface:not(.mdc-ripple-upgraded):focus:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}.mdc-ripple-surface:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.mdc-ripple-surface:not(.mdc-ripple-upgraded):active:after{opacity:.12;opacity:var(--mdc-ripple-press-opacity,.12);transition-duration:75ms}.mdc-ripple-surface.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.12)}.smui-ripple-surface--primary:after,.smui-ripple-surface--primary:before{background-color:#6200ee;background-color:var(--mdc-ripple-color,var(--mdc-theme-primary,#6200ee))}.smui-ripple-surface--primary.mdc-ripple-surface--hover:before,.smui-ripple-surface--primary:hover:before{opacity:.04;opacity:var(--mdc-ripple-hover-opacity,.04)}.smui-ripple-surface--primary.mdc-ripple-upgraded--background-focused:before,.smui-ripple-surface--primary:not(.mdc-ripple-upgraded):focus:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}.smui-ripple-surface--primary:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.smui-ripple-surface--primary:not(.mdc-ripple-upgraded):active:after{opacity:.12;opacity:var(--mdc-ripple-press-opacity,.12);transition-duration:75ms}.smui-ripple-surface--primary.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.12)}.smui-ripple-surface--secondary:after,.smui-ripple-surface--secondary:before{background-color:#018786;background-color:var(--mdc-ripple-color,var(--mdc-theme-secondary,#018786))}.smui-ripple-surface--secondary.mdc-ripple-surface--hover:before,.smui-ripple-surface--secondary:hover:before{opacity:.04;opacity:var(--mdc-ripple-hover-opacity,.04)}.smui-ripple-surface--secondary.mdc-ripple-upgraded--background-focused:before,.smui-ripple-surface--secondary:not(.mdc-ripple-upgraded):focus:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}.smui-ripple-surface--secondary:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.smui-ripple-surface--secondary:not(.mdc-ripple-upgraded):active:after{opacity:.12;opacity:var(--mdc-ripple-press-opacity,.12);transition-duration:75ms}.smui-ripple-surface--secondary.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.12)}.smui-list--three-line .mdc-deprecated-list-item__text{align-self:flex-start}.smui-list--three-line .mdc-deprecated-list-item{height:88px}.smui-list--three-line.mdc-deprecated-list--dense .mdc-deprecated-list-item{height:76px}.mdc-deprecated-list-item.smui-menu-item--non-interactive{cursor:auto}.mdc-elevation-overlay{background-color:#fff;background-color:var(--mdc-elevation-overlay-color,#fff);border-radius:inherit;opacity:0;opacity:var(--mdc-elevation-overlay-opacity,0);pointer-events:none;position:absolute;transition:opacity .28s cubic-bezier(.4,0,.2,1)}.mdc-menu{min-width:112px;min-width:var(--mdc-menu-min-width,112px)}.mdc-menu .mdc-deprecated-list-item__graphic,.mdc-menu .mdc-deprecated-list-item__meta{color:rgba(0,0,0,.87)}.mdc-menu .mdc-menu-item--submenu-open .mdc-deprecated-list-item__ripple:before,.mdc-menu .mdc-menu-item--submenu-open .mdc-list-item__ripple:before{opacity:.04}.mdc-menu .mdc-deprecated-list{color:rgba(0,0,0,.87)}.mdc-menu .mdc-deprecated-list,.mdc-menu .mdc-list{position:relative}.mdc-menu .mdc-deprecated-list .mdc-elevation-overlay,.mdc-menu .mdc-list .mdc-elevation-overlay{height:100%;left:0;top:0;width:100%}.mdc-menu .mdc-deprecated-list-divider{margin:8px 0}.mdc-menu .mdc-deprecated-list-item{user-select:none}.mdc-menu .mdc-deprecated-list-item--disabled{cursor:auto}.mdc-menu a.mdc-deprecated-list-item .mdc-deprecated-list-item__graphic,.mdc-menu a.mdc-deprecated-list-item .mdc-deprecated-list-item__text{pointer-events:none}.mdc-menu__selection-group{fill:currentColor;padding:0}.mdc-menu__selection-group .mdc-deprecated-list-item{padding-left:56px;padding-right:16px}.mdc-menu__selection-group .mdc-deprecated-list-item[dir=rtl],[dir=rtl] .mdc-menu__selection-group .mdc-deprecated-list-item{padding-left:16px;padding-right:56px}.mdc-menu__selection-group .mdc-menu__selection-group-icon{display:none;left:16px;position:absolute;right:auto;top:50%;transform:translateY(-50%)}.mdc-menu__selection-group .mdc-menu__selection-group-icon[dir=rtl],[dir=rtl] .mdc-menu__selection-group .mdc-menu__selection-group-icon{left:auto;right:16px}.mdc-menu-item--selected .mdc-menu__selection-group-icon{display:inline}.mdc-menu-surface{transform-origin-left:top left;transform-origin-right:top right;background-color:#fff;background-color:var(--mdc-theme-surface,#fff);border-radius:4px;border-radius:var(--mdc-shape-medium,4px);box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);box-sizing:border-box;color:#000;color:var(--mdc-theme-on-surface,#000);display:none;margin:0;max-height:calc(100vh - 32px);max-height:var(--mdc-menu-max-height,calc(100vh - 32px));max-width:calc(100vw - 32px);max-width:var(--mdc-menu-max-width,calc(100vw - 32px));opacity:0;overflow:auto;padding:0;position:absolute;transform:scale(1);transform-origin:top left;transition:opacity .03s linear,transform .12s cubic-bezier(0,0,.2,1),height .25s cubic-bezier(0,0,.2,1);will-change:transform,opacity;z-index:8}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--animating-open{display:inline-block;opacity:0;transform:scale(.8)}.mdc-menu-surface--open{display:inline-block;opacity:1;transform:scale(1)}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0;transition:opacity 75ms linear}.mdc-menu-surface[dir=rtl],[dir=rtl] .mdc-menu-surface{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{overflow:visible;position:relative}.mdc-menu-surface--fixed{position:fixed}.mdc-menu-surface--fullwidth{width:100%}.smui-menu-surface--static{display:inline-block;opacity:1;position:static;transform:scale(1);z-index:0}.mdc-menu__selection-group .mdc-list-item__graphic.mdc-menu__selection-group-icon{display:none}.mdc-menu-item--selected .mdc-list-item__graphic.mdc-menu__selection-group-icon{display:inline}.mdc-notched-outline{box-sizing:border-box;display:flex;height:100%;left:0;max-width:100%;pointer-events:none;position:absolute;right:0;text-align:left;top:0;width:100%}.mdc-notched-outline[dir=rtl],[dir=rtl] .mdc-notched-outline{text-align:right}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{border-bottom:1px solid;border-top:1px solid;box-sizing:border-box;height:100%;pointer-events:none}.mdc-notched-outline__leading{border-left:1px solid;border-right:none;width:12px}.mdc-notched-outline__leading[dir=rtl],.mdc-notched-outline__trailing,[dir=rtl] .mdc-notched-outline__leading{border-left:none;border-right:1px solid}.mdc-notched-outline__trailing{flex-grow:1}.mdc-notched-outline__trailing[dir=rtl],[dir=rtl] .mdc-notched-outline__trailing{border-left:1px solid;border-right:none}.mdc-notched-outline__notch{flex:0 0 auto;max-width:calc(100% - 24px);width:auto}.mdc-notched-outline .mdc-floating-label{display:inline-block;max-width:100%;position:relative}.mdc-notched-outline .mdc-floating-label--float-above{text-overflow:clip}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:133.3333333333%}.mdc-notched-outline--notched .mdc-notched-outline__notch{border-top:none;padding-left:0;padding-right:8px}.mdc-notched-outline--notched .mdc-notched-outline__notch[dir=rtl],[dir=rtl] .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:8px;padding-right:0}.mdc-notched-outline--no-label .mdc-notched-outline__notch{display:none}.mdc-text-field--filled{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity}.mdc-text-field--filled .mdc-text-field__ripple:after,.mdc-text-field--filled .mdc-text-field__ripple:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}.mdc-text-field--filled .mdc-text-field__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}.mdc-text-field--filled .mdc-text-field__ripple:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}.mdc-text-field--filled.mdc-ripple-upgraded .mdc-text-field__ripple:before{transform:scale(var(--mdc-ripple-fg-scale,1))}.mdc-text-field--filled.mdc-ripple-upgraded .mdc-text-field__ripple:after{left:0;top:0;transform:scale(0);transform-origin:center center}.mdc-text-field--filled.mdc-ripple-upgraded--unbounded .mdc-text-field__ripple:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}.mdc-text-field--filled.mdc-ripple-upgraded--foreground-activation .mdc-text-field__ripple:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-text-field--filled.mdc-ripple-upgraded--foreground-deactivation .mdc-text-field__ripple:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}.mdc-text-field--filled .mdc-text-field__ripple:after,.mdc-text-field--filled .mdc-text-field__ripple:before{height:200%;left:-50%;top:-50%;width:200%}.mdc-text-field--filled.mdc-ripple-upgraded .mdc-text-field__ripple:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}.mdc-text-field__ripple{height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.mdc-text-field{align-items:baseline;border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small,4px);border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small,4px);box-sizing:border-box;display:inline-flex;overflow:hidden;padding:0 16px;position:relative;will-change:opacity,transform,color}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-floating-label{color:rgba(0,0,0,.6)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input{color:rgba(0,0,0,.87)}@media{.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:rgba(0,0,0,.54)}}@media{.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:rgba(0,0,0,.54)}}.mdc-text-field .mdc-text-field__input{caret-color:#6200ee;caret-color:var(--mdc-theme-primary,#6200ee)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field-character-counter,.mdc-text-field:not(.mdc-text-field--disabled)+.mdc-text-field-helper-line .mdc-text-field-character-counter,.mdc-text-field:not(.mdc-text-field--disabled)+.mdc-text-field-helper-line .mdc-text-field-helper-text{color:rgba(0,0,0,.6)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__icon--leading,.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__icon--trailing{color:rgba(0,0,0,.54)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__affix--prefix,.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__affix--suffix{color:rgba(0,0,0,.6)}.mdc-text-field .mdc-floating-label{pointer-events:none;top:50%;transform:translateY(-50%)}.mdc-text-field__input{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;appearance:none;background:none;border:none;border-radius:0;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);height:28px;letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);min-width:0;padding:0;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit);transition:opacity .15s cubic-bezier(.4,0,.2,1) 0ms;width:100%}.mdc-text-field__input::-ms-clear{display:none}.mdc-text-field__input::-webkit-calendar-picker-indicator{display:none}.mdc-text-field__input:focus{outline:none}.mdc-text-field__input:invalid{box-shadow:none}@media{.mdc-text-field__input::placeholder{opacity:0;transition:opacity 67ms cubic-bezier(.4,0,.2,1) 0ms}}@media{.mdc-text-field__input:-ms-input-placeholder{opacity:0;transition:opacity 67ms cubic-bezier(.4,0,.2,1) 0ms}}@media{.mdc-text-field--focused .mdc-text-field__input::placeholder,.mdc-text-field--no-label .mdc-text-field__input::placeholder{opacity:1;transition-delay:40ms;transition-duration:.11s}}@media{.mdc-text-field--focused .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--no-label .mdc-text-field__input:-ms-input-placeholder{opacity:1;transition-delay:40ms;transition-duration:.11s}}.mdc-text-field__affix{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);height:28px;letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);opacity:0;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit);transition:opacity .15s cubic-bezier(.4,0,.2,1) 0ms;white-space:nowrap}.mdc-text-field--label-floating .mdc-text-field__affix,.mdc-text-field--no-label .mdc-text-field__affix{opacity:1}@supports(-webkit-hyphens:none){.mdc-text-field--outlined .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}.mdc-text-field__affix--prefix[dir=rtl],[dir=rtl] .mdc-text-field__affix--prefix{padding-left:2px;padding-right:0}.mdc-text-field--end-aligned .mdc-text-field__affix--prefix{padding-left:0;padding-right:12px}.mdc-text-field--end-aligned .mdc-text-field__affix--prefix[dir=rtl],.mdc-text-field__affix--suffix,[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--prefix{padding-left:12px;padding-right:0}.mdc-text-field__affix--suffix[dir=rtl],[dir=rtl] .mdc-text-field__affix--suffix{padding-left:0;padding-right:12px}.mdc-text-field--end-aligned .mdc-text-field__affix--suffix{padding-left:2px;padding-right:0}.mdc-text-field--end-aligned .mdc-text-field__affix--suffix[dir=rtl],[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--suffix{padding-left:0;padding-right:2px}.mdc-text-field--filled{height:56px}.mdc-text-field--filled .mdc-text-field__ripple:after,.mdc-text-field--filled .mdc-text-field__ripple:before{background-color:rgba(0,0,0,.87);background-color:var(--mdc-ripple-color,rgba(0,0,0,.87))}.mdc-text-field--filled.mdc-ripple-surface--hover .mdc-text-field__ripple:before,.mdc-text-field--filled:hover .mdc-text-field__ripple:before{opacity:.04;opacity:var(--mdc-ripple-hover-opacity,.04)}.mdc-text-field--filled.mdc-ripple-upgraded--background-focused .mdc-text-field__ripple:before,.mdc-text-field--filled:not(.mdc-ripple-upgraded):focus .mdc-text-field__ripple:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}.mdc-text-field--filled:before{content:"";display:inline-block;height:40px;vertical-align:0;width:0}.mdc-text-field--filled:not(.mdc-text-field--disabled){background-color:#f5f5f5}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-line-ripple:before{border-bottom-color:rgba(0,0,0,.42)}.mdc-text-field--filled:not(.mdc-text-field--disabled):hover .mdc-line-ripple:before{border-bottom-color:rgba(0,0,0,.87)}.mdc-text-field--filled .mdc-line-ripple:after{border-bottom-color:#6200ee;border-bottom-color:var(--mdc-theme-primary,#6200ee)}.mdc-text-field--filled .mdc-floating-label{left:16px;right:auto}.mdc-text-field--filled .mdc-floating-label[dir=rtl],[dir=rtl] .mdc-text-field--filled .mdc-floating-label{left:auto;right:16px}.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-106%) scale(.75)}.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{height:100%}.mdc-text-field--filled.mdc-text-field--no-label .mdc-floating-label,.mdc-text-field--filled.mdc-text-field--no-label:before{display:none}@supports(-webkit-hyphens:none){.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field--outlined{height:56px;overflow:visible}.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem;transform:translateY(-37.25px) scale(1)}.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem;transform:translateY(-34.75px) scale(.75)}.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined .25s 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined{0%{transform:translateX(0) translateY(-34.75px) scale(.75)}33%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translateX(4%) translateY(-34.75px) scale(.75)}66%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translateX(-4%) translateY(-34.75px) scale(.75)}to{transform:translateX(0) translateY(-34.75px) scale(.75)}}.mdc-text-field--outlined .mdc-text-field__input{height:100%}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.38)}.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.87)}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:#6200ee;border-color:var(--mdc-theme-primary,#6200ee)}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-bottom-left-radius:4px;border-bottom-left-radius:var(--mdc-shape-small,4px);border-bottom-right-radius:0;border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small,4px);border-top-right-radius:0}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl],[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-bottom-left-radius:0;border-bottom-right-radius:4px;border-bottom-right-radius:var(--mdc-shape-small,4px);border-top-left-radius:0;border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small,4px)}@supports(top:max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{width:max(12px,var(--mdc-shape-small,4px))}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__notch{max-width:calc(100% - max(12px, var(--mdc-shape-small, 4px))*2)}}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-bottom-left-radius:0;border-bottom-right-radius:4px;border-bottom-right-radius:var(--mdc-shape-small,4px);border-top-left-radius:0;border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small,4px)}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl],[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-bottom-left-radius:4px;border-bottom-left-radius:var(--mdc-shape-small,4px);border-bottom-right-radius:0;border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small,4px);border-top-right-radius:0}@supports(top:max(0%)){.mdc-text-field--outlined{padding-right:max(16px,var(--mdc-shape-small,4px))}.mdc-text-field--outlined,.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-left:max(16px,calc(var(--mdc-shape-small, 4px) + 4px))}.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-right:max(16px,var(--mdc-shape-small,4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-left:0}@supports(top:max(0%)){.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-right:max(16px,var(--mdc-shape-small,4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl],[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-right:0}@supports(top:max(0%)){.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl],[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-left:max(16px,var(--mdc-shape-small,4px))}}.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-right:0}@supports(top:max(0%)){.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-left:max(16px,calc(var(--mdc-shape-small, 4px) + 4px))}}.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl],[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-left:0}@supports(top:max(0%)){.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl],[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-right:max(16px,calc(var(--mdc-shape-small, 4px) + 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:1px}.mdc-text-field--outlined .mdc-text-field__ripple:after,.mdc-text-field--outlined .mdc-text-field__ripple:before{background-color:transparent;background-color:var(--mdc-ripple-color,transparent)}.mdc-text-field--outlined .mdc-floating-label{left:4px;right:auto}.mdc-text-field--outlined .mdc-floating-label[dir=rtl],[dir=rtl] .mdc-text-field--outlined .mdc-floating-label{left:auto;right:4px}.mdc-text-field--outlined .mdc-text-field__input{background-color:transparent;border:none!important;display:flex}.mdc-text-field--outlined .mdc-notched-outline{z-index:1}.mdc-text-field--textarea{align-items:center;flex-direction:column;height:auto;padding:0;transition:none;width:auto}.mdc-text-field--textarea .mdc-floating-label{top:19px}.mdc-text-field--textarea .mdc-floating-label:not(.mdc-floating-label--float-above){transform:none}.mdc-text-field--textarea .mdc-text-field__input{box-sizing:border-box;flex-grow:1;height:auto;line-height:1.5rem;min-height:1.5rem;overflow-x:hidden;overflow-y:auto;padding:0 16px;resize:none}.mdc-text-field--textarea.mdc-text-field--filled:before{display:none}.mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-10.25px) scale(.75)}.mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-filled .25s 1}@keyframes mdc-floating-label-shake-float-above-textarea-filled{0%{transform:translateX(0) translateY(-10.25px) scale(.75)}33%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translateX(4%) translateY(-10.25px) scale(.75)}66%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translateX(-4%) translateY(-10.25px) scale(.75)}to{transform:translateX(0) translateY(-10.25px) scale(.75)}}.mdc-text-field--textarea.mdc-text-field--filled .mdc-text-field__input{margin-bottom:9px;margin-top:23px}.mdc-text-field--textarea.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{margin-bottom:16px;margin-top:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem;transform:translateY(-27.25px) scale(1)}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem;transform:translateY(-24.75px) scale(.75)}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-outlined .25s 1}@keyframes mdc-floating-label-shake-float-above-textarea-outlined{0%{transform:translateX(0) translateY(-24.75px) scale(.75)}33%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translateX(4%) translateY(-24.75px) scale(.75)}66%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translateX(-4%) translateY(-24.75px) scale(.75)}to{transform:translateX(0) translateY(-24.75px) scale(.75)}}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-text-field__input{margin-bottom:16px;margin-top:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label{top:18px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field__input{margin-bottom:2px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter{align-self:flex-end;padding:0 16px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter:after{content:"";display:inline-block;height:16px;vertical-align:-16px;width:0}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter:before{display:none}.mdc-text-field__resizer{align-self:stretch;display:inline-flex;flex-direction:column;flex-grow:1;max-height:100%;max-width:100%;min-height:56px;min-width:fit-content;min-width:-moz-available;min-width:-webkit-fill-available;overflow:hidden;resize:both}.mdc-text-field--filled .mdc-text-field__resizer{transform:translateY(-1px)}.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field-character-counter,.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field__input{transform:translateY(1px)}.mdc-text-field--outlined .mdc-text-field__resizer{transform:translateX(-1px) translateY(-1px)}.mdc-text-field--outlined .mdc-text-field__resizer[dir=rtl],[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer{transform:translateX(1px) translateY(-1px)}.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter,.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input{transform:translateX(1px) translateY(1px)}.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter[dir=rtl],.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input[dir=rtl],[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter,[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input{transform:translateX(-1px) translateY(1px)}.mdc-text-field--with-leading-icon{padding-left:0;padding-right:16px}.mdc-text-field--with-leading-icon[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon{padding-left:16px;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label{left:48px;max-width:calc(100% - 48px);right:auto}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label{left:auto;right:48px}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(133.33333% - 85.33333px)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label{left:36px;right:auto}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label{left:auto;right:36px}.mdc-text-field--with-leading-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) translateX(-32px) scale(1)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) translateX(32px) scale(1)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) translateX(-32px) scale(.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) translateX(32px) scale(.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon .25s 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon{0%{transform:translateX(-32px) translateY(-34.75px) scale(.75)}33%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translateX(calc(4% - 32px)) translateY(-34.75px) scale(.75)}66%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translateX(calc(-4% - 32px)) translateY(-34.75px) scale(.75)}to{transform:translateX(-32px) translateY(-34.75px) scale(.75)}}.mdc-text-field--with-leading-icon.mdc-text-field--outlined[dir=rtl] .mdc-floating-label--shake,[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon .25s 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-rtl{0%{transform:translateX(32px) translateY(-34.75px) scale(.75)}33%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translateX(calc(4% + 32px)) translateY(-34.75px) scale(.75)}66%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translateX(calc(-4% + 32px)) translateY(-34.75px) scale(.75)}to{transform:translateX(32px) translateY(-34.75px) scale(.75)}}.mdc-text-field--with-trailing-icon{padding-left:16px;padding-right:0}.mdc-text-field--with-trailing-icon[dir=rtl],[dir=rtl] .mdc-text-field--with-trailing-icon{padding-left:0;padding-right:16px}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 64px)}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(133.33333% - 85.33333px)}.mdc-text-field--with-trailing-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 96px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(133.33333% - 128px)}.mdc-text-field-helper-line{box-sizing:border-box;display:flex;justify-content:space-between}.mdc-text-field+.mdc-text-field-helper-line{padding-left:16px;padding-right:16px}.mdc-form-field>.mdc-text-field+label{align-self:flex-start}.mdc-text-field--focused:not(.mdc-text-field--disabled) .mdc-floating-label{color:rgba(98,0,238,.87)}.mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--focused .mdc-notched-outline__trailing{border-width:2px}.mdc-text-field--focused+.mdc-text-field-helper-line .mdc-text-field-helper-text:not(.mdc-text-field-helper-text--validation-msg){opacity:1}.mdc-text-field--focused.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:2px}.mdc-text-field--focused.mdc-text-field--outlined.mdc-text-field--textarea .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple:after,.mdc-text-field--invalid:not(.mdc-text-field--disabled):hover .mdc-line-ripple:before{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error,#b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label,.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{color:#b00020;color:var(--mdc-theme-error,#b00020)}.mdc-text-field--invalid .mdc-text-field__input{caret-color:#b00020;caret-color:var(--mdc-theme-error,#b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__icon--trailing{color:#b00020;color:var(--mdc-theme-error,#b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple:before{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error,#b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing,.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing,.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error,#b00020)}.mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{opacity:1}.mdc-text-field--disabled{pointer-events:none}.mdc-text-field--disabled .mdc-text-field__input{color:rgba(0,0,0,.38)}@media{.mdc-text-field--disabled .mdc-text-field__input::placeholder{color:rgba(0,0,0,.38)}}@media{.mdc-text-field--disabled .mdc-text-field__input:-ms-input-placeholder{color:rgba(0,0,0,.38)}}.mdc-text-field--disabled .mdc-floating-label,.mdc-text-field--disabled .mdc-text-field-character-counter,.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-character-counter,.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-helper-text{color:rgba(0,0,0,.38)}.mdc-text-field--disabled .mdc-text-field__icon--leading,.mdc-text-field--disabled .mdc-text-field__icon--trailing{color:rgba(0,0,0,.3)}.mdc-text-field--disabled .mdc-text-field__affix--prefix,.mdc-text-field--disabled .mdc-text-field__affix--suffix{color:rgba(0,0,0,.38)}.mdc-text-field--disabled .mdc-line-ripple:before{border-bottom-color:rgba(0,0,0,.06)}.mdc-text-field--disabled .mdc-notched-outline__leading,.mdc-text-field--disabled .mdc-notched-outline__notch,.mdc-text-field--disabled .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.06)}@media (-ms-high-contrast:active),screen and (forced-colors:active){.mdc-text-field--disabled .mdc-text-field__input::placeholder{color:GrayText}}@media (-ms-high-contrast:active),screen and (forced-colors:active){.mdc-text-field--disabled .mdc-text-field__input:-ms-input-placeholder{color:GrayText}}@media (-ms-high-contrast:active),screen and (forced-colors:active){.mdc-text-field--disabled .mdc-floating-label,.mdc-text-field--disabled .mdc-text-field-character-counter,.mdc-text-field--disabled .mdc-text-field__affix--prefix,.mdc-text-field--disabled .mdc-text-field__affix--suffix,.mdc-text-field--disabled .mdc-text-field__icon--leading,.mdc-text-field--disabled .mdc-text-field__icon--trailing,.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-character-counter,.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-helper-text{color:GrayText}.mdc-text-field--disabled .mdc-line-ripple:before{border-bottom-color:GrayText}.mdc-text-field--disabled .mdc-notched-outline__leading,.mdc-text-field--disabled .mdc-notched-outline__notch,.mdc-text-field--disabled .mdc-notched-outline__trailing{border-color:GrayText}}@media screen and (forced-colors:active){.mdc-text-field--disabled .mdc-text-field__input{background-color:Window}.mdc-text-field--disabled .mdc-floating-label{z-index:1}}.mdc-text-field--disabled .mdc-floating-label{cursor:default}.mdc-text-field--disabled.mdc-text-field--filled{background-color:#fafafa}.mdc-text-field--disabled.mdc-text-field--filled .mdc-text-field__ripple{display:none}.mdc-text-field--disabled .mdc-text-field__input{pointer-events:auto}.mdc-text-field--end-aligned .mdc-text-field__input{text-align:right}.mdc-text-field--end-aligned .mdc-text-field__input[dir=rtl],[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__input{text-align:left}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input{direction:ltr}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix{padding-left:12px;padding-right:0}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--leading,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--leading{order:1}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix{order:2}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input{order:3}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix{order:4}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--trailing,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--trailing{order:5}.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__input,[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__input{text-align:right}.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--prefix,[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--prefix{padding-right:12px}.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--suffix,[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--suffix{padding-left:2px}.smui-text-field--standard{height:56px;padding:0}.smui-text-field--standard:before{content:"";display:inline-block;height:40px;vertical-align:0;width:0}.smui-text-field--standard:not(.mdc-text-field--disabled){background-color:transparent}.smui-text-field--standard:not(.mdc-text-field--disabled) .mdc-line-ripple:before{border-bottom-color:rgba(0,0,0,.42)}.smui-text-field--standard:not(.mdc-text-field--disabled):hover .mdc-line-ripple:before{border-bottom-color:rgba(0,0,0,.87)}.smui-text-field--standard .mdc-line-ripple:after{border-bottom-color:#6200ee;border-bottom-color:var(--mdc-theme-primary,#6200ee)}.smui-text-field--standard .mdc-floating-label{left:0;right:auto}.smui-text-field--standard .mdc-floating-label[dir=rtl],[dir=rtl] .smui-text-field--standard .mdc-floating-label{left:auto;right:0}.smui-text-field--standard .mdc-floating-label--float-above{transform:translateY(-106%) scale(.75)}.smui-text-field--standard.mdc-text-field--no-label .mdc-text-field__input{height:100%}.smui-text-field--standard.mdc-text-field--no-label .mdc-floating-label,.smui-text-field--standard.mdc-text-field--no-label:before{display:none}@supports(-webkit-hyphens:none){.smui-text-field--standard.mdc-text-field--no-label .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field--with-leading-icon.smui-text-field--standard .mdc-floating-label{left:32px;max-width:calc(100% - 32px);right:auto}.mdc-text-field--with-leading-icon.smui-text-field--standard .mdc-floating-label[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon.smui-text-field--standard .mdc-floating-label{left:auto;right:32px}.mdc-text-field--with-leading-icon.smui-text-field--standard .mdc-floating-label--float-above{max-width:calc(133.33333% - 64px)}.mdc-text-field--with-trailing-icon.smui-text-field--standard .mdc-floating-label{max-width:calc(100% - 36px)}.mdc-text-field--with-trailing-icon.smui-text-field--standard .mdc-floating-label--float-above{max-width:calc(133.33333% - 48px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.smui-text-field--standard .mdc-floating-label{max-width:calc(100% - 68px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.smui-text-field--standard .mdc-floating-label--float-above{max-width:calc(133.33333% - 90.66667px)}.mdc-text-field+.mdc-text-field-helper-line{padding-left:0;padding-right:0}.mdc-text-field-character-counter{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-caption-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:.75rem;font-size:var(--mdc-typography-caption-font-size,.75rem);font-weight:400;font-weight:var(--mdc-typography-caption-font-weight,400);letter-spacing:.0333333333em;letter-spacing:var(--mdc-typography-caption-letter-spacing,.0333333333em);line-height:1.25rem;line-height:var(--mdc-typography-caption-line-height,1.25rem);line-height:normal;margin-left:auto;margin-right:0;margin-top:0;padding-left:16px;padding-right:0;text-decoration:inherit;text-decoration:var(--mdc-typography-caption-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-caption-text-transform,inherit);white-space:nowrap}.mdc-text-field-character-counter:before{content:"";display:inline-block;height:16px;vertical-align:0;width:0}.mdc-text-field-character-counter[dir=rtl],[dir=rtl] .mdc-text-field-character-counter{margin-left:0;margin-right:auto;padding-left:0;padding-right:16px}.mdc-text-field-helper-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-caption-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:.75rem;font-size:var(--mdc-typography-caption-font-size,.75rem);font-weight:400;font-weight:var(--mdc-typography-caption-font-weight,400);letter-spacing:.0333333333em;letter-spacing:var(--mdc-typography-caption-letter-spacing,.0333333333em);line-height:1.25rem;line-height:var(--mdc-typography-caption-line-height,1.25rem);line-height:normal;margin:0;opacity:0;text-decoration:inherit;text-decoration:var(--mdc-typography-caption-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-caption-text-transform,inherit);transition:opacity .15s cubic-bezier(.4,0,.2,1) 0ms;will-change:opacity}.mdc-text-field-helper-text:before{content:"";display:inline-block;height:16px;vertical-align:0;width:0}.mdc-text-field-helper-text--persistent{opacity:1;transition:none;will-change:auto}.mdc-text-field__icon{align-self:center;cursor:pointer}.mdc-text-field__icon:not([tabindex]),.mdc-text-field__icon[tabindex="-1"]{cursor:default;pointer-events:none}.mdc-text-field__icon svg{display:block}.mdc-text-field__icon--leading{margin-left:16px;margin-right:8px}.mdc-text-field__icon--leading[dir=rtl],[dir=rtl] .mdc-text-field__icon--leading{margin-left:8px;margin-right:16px}.mdc-text-field__icon--trailing{margin-left:0;margin-right:0;padding:12px}.mdc-text-field__icon--trailing[dir=rtl],[dir=rtl] .mdc-text-field__icon--trailing{margin-left:0;margin-right:0}.smui-text-field--standard .mdc-text-field__icon--leading{margin-left:0;margin-right:8px}.smui-text-field--standard .mdc-text-field__icon--leading[dir=rtl],[dir=rtl] .smui-text-field--standard .mdc-text-field__icon--leading{margin-left:8px;margin-right:0}.smui-text-field--standard .mdc-text-field__icon--trailing{margin-left:0;margin-right:0;padding:12px 0 12px 12px}.smui-text-field--standard .mdc-text-field__icon--trailing[dir=rtl],[dir=rtl] .smui-text-field--standard .mdc-text-field__icon--trailing{margin-left:0;margin-right:0;padding-left:0;padding-right:12px}';
(0, _injectCss.default)(e, {});
},{"./../../ext/rollup-plugin-styles/dist/runtime/inject-css.js":"../node_modules/@cosmograph/ui/ext/rollup-plugin-styles/dist/runtime/inject-css.js"}],"../node_modules/@cosmograph/ui/scrollbar.css.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.css = void 0;
var _injectCss = _interopRequireDefault(require("./ext/rollup-plugin-styles/dist/runtime/inject-css.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var o = exports.default = exports.css = ":root *{--scrollbar-background:hsla(0,0%,100%,.1);scrollbar-track-color:transparent;scrollbar-face-color:var(--scrollbar-background);scrollbar-color:var(--scrollbar-background) transparent;scrollbar-width:thin;text-underline-offset:.5px}:root ::-webkit-scrollbar{border-radius:.3rem;height:5px;width:5px}:root ::-webkit-scrollbar-track{border-radius:.3rem}:root ::-webkit-scrollbar-corner{background:none!important}:root ::-webkit-scrollbar-thumb{background-color:var(--scrollbar-background);border:3px solid var(--scrollbar-background);border-radius:20px;transition:background-color .5s}";
(0, _injectCss.default)(o, {});
},{"./ext/rollup-plugin-styles/dist/runtime/inject-css.js":"../node_modules/@cosmograph/ui/ext/rollup-plugin-styles/dist/runtime/inject-css.js"}],"../node_modules/@cosmograph/ui/modules/search/search.css.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.css = void 0;
var _injectCss = _interopRequireDefault(require("./../../ext/rollup-plugin-styles/dist/runtime/inject-css.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var a = exports.default = exports.css = ":root{--cosmograph-search-text-color:#fff;--cosmograph-search-list-background:#222;--cosmograph-search-font-family:inherit;--cosmograph-search-input-background:#222;--cosmograph-search-mark-background:hsla(0,0%,100%,.2);--cosmograph-search-accessor-background:hsla(0,0%,100%,.2);--cosmograph-search-interactive-background:hsla(0,0%,100%,.4);--cosmograph-search-hover-color:hsla(0,0%,100%,.05)}.search-icon.svelte-1xknafk.svelte-1xknafk{color:var(--cosmograph-search-text-color)!important;opacity:.6}.search.svelte-1xknafk .cosmograph-search-accessor{align-content:center;background-color:var(--cosmograph-search-accessor-background);border-radius:10px;color:var(--cosmograph-search-text-color);cursor:pointer;display:flex;display:block;font-size:12px;font-style:normal;justify-content:center;line-height:1;margin-right:.5rem;overflow:hidden;padding:5px 8px;text-overflow:ellipsis;transition:background .15s linear;white-space:nowrap;z-index:1}.search.svelte-1xknafk .cosmograph-search-accessor.active,.search.svelte-1xknafk .cosmograph-search-accessor:hover{background-color:var(--cosmograph-search-interactive-background)}.search.svelte-1xknafk .disabled{cursor:default;pointer-events:none}.search.svelte-1xknafk.svelte-1xknafk{background:var(--cosmograph-search-input-background);display:flex;flex-direction:column;font-family:var(--cosmograph-search-font-family),sans-serif;text-align:left;width:100%}.search.svelte-1xknafk mark{background:var(--cosmograph-search-mark-background);border-radius:2px;color:var(--cosmograph-search-text-color);padding:1px 0}.search.svelte-1xknafk .cosmograph-search-match{-webkit-box-orient:vertical;cursor:pointer;display:-webkit-box;line-height:1.35;overflow:hidden;padding:calc(var(--margin-v)*1px) calc(var(--margin-h)*1px);text-overflow:ellipsis;white-space:normal}.search.svelte-1xknafk .cosmograph-search-match:hover{background:var(--cosmograph-search-hover-color)}.search.svelte-1xknafk .cosmograph-search-result{display:inline;font-size:12px;font-weight:600;text-transform:uppercase}.search.svelte-1xknafk .cosmograph-search-result>span{font-weight:400;letter-spacing:1;margin-left:4px}.search.svelte-1xknafk .cosmograph-search-result>span>t{margin-right:4px}.search.svelte-1xknafk .mdc-menu-surface{background-color:var(--cosmograph-search-list-background)!important;max-height:none!important}.search.svelte-1xknafk .openListUpwards.svelte-1xknafk .mdc-menu-surface{bottom:55px!important;top:unset!important}.search.svelte-1xknafk .mdc-text-field__input{caret-color:var(--cosmograph-search-text-color)!important;height:100%;letter-spacing:-.01em;line-height:2;line-height:2!important;padding-top:15px!important}.search.svelte-1xknafk .mdc-floating-label,.search.svelte-1xknafk .mdc-text-field__input{color:var(--cosmograph-search-text-color)!important;font-family:var(--cosmograph-search-font-family),sans-serif!important}.search.svelte-1xknafk .mdc-floating-label{opacity:.65;pointer-events:none!important}.search.svelte-1xknafk .mdc-line-ripple:after,.search.svelte-1xknafk .mdc-line-ripple:before{border-bottom-color:var(--cosmograph-search-text-color)!important;opacity:.1}.search.svelte-1xknafk .mdc-deprecated-list{background:var(--cosmograph-search-list-background);color:var(--cosmograph-search-text-color)!important;font-size:14px!important;padding-top:4px!important}.search.svelte-1xknafk .mdc-deprecated-list-item{height:28px!important}.search.svelte-1xknafk .mdc-text-field__icon--leading{margin-right:10px!important}.search.svelte-1xknafk .mdc-floating-label--float-above{left:26px!important;pointer-events:none!important}.search.svelte-1xknafk .mdc-text-field__icon--trailing{cursor:default!important;max-width:35%}.search.svelte-1xknafk .cosmograph-search-first-field{font-size:12.5px;font-weight:400;opacity:.8;text-transform:uppercase}";
(0, _injectCss.default)(a, {});
},{"./../../ext/rollup-plugin-styles/dist/runtime/inject-css.js":"../node_modules/@cosmograph/ui/ext/rollup-plugin-styles/dist/runtime/inject-css.js"}],"../node_modules/@cosmograph/ui/modules/search/search.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _indexMjs = require("./../../ext/svelte/internal/index.mjs.js");
var _resizeObserver = require("@juggle/resize-observer");
var _escapeStringRegexp = _interopRequireDefault(require("escape-string-regexp"));
var _ListSvelte = _interopRequireDefault(require("./../../ext/@smui/list/dist/List.svelte.js"));
var _ItemSvelte = _interopRequireDefault(require("./../../ext/@smui/list/dist/Item.svelte.js"));
var _Text = _interopRequireDefault(require("./../../ext/@smui/list/dist/Text.js"));
require("./../../ext/@smui/list/dist/PrimaryText.js");
require("./../../ext/@smui/list/dist/SecondaryText.js");
require("./../../ext/@smui/list/dist/Meta.js");
require("./../../ext/@smui/list/dist/Group.js");
require("./../../ext/@smui/list/dist/Subheader.js");
var _TextfieldSvelte = _interopRequireDefault(require("./../../ext/@smui/textfield/dist/Textfield.svelte.js"));
require("./../../ext/@smui/textfield/dist/Prefix.js");
require("./../../ext/@smui/textfield/dist/Suffix.js");
require("./../../ext/@smui/textfield/dist/HelperLine.js");
var _IconSvelte = _interopRequireDefault(require("./../../ext/@smui/textfield/dist/icon/Icon.svelte.js"));
var _MenuSvelte = _interopRequireDefault(require("./../../ext/@smui/menu/dist/Menu.svelte.js"));
require("./../../ext/@smui/menu/dist/SelectionGroupIcon.js");
var _types = require("./types.js");
var _config = require("./config.js");
var _searchSvgSvelte = _interopRequireDefault(require("./search-svg.svelte.js"));
require("./smui.css.js");
require("../../scrollbar.css.js");
require("./search.css.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function F(t, e, n) {
  const s = t.slice();
  return s[53] = e[n], s[52] = n, s;
}
function G(t, e, n) {
  const s = t.slice();
  return s[50] = e[n], s[52] = n, s;
}
function J(t) {
  let e, n, s;
  return n = new _searchSvgSvelte.default({}), {
    c() {
      e = (0, _indexMjs.element)("div"), (0, _indexMjs.create_component)(n.$$.fragment), (0, _indexMjs.attr)(e, "class", "search-icon svelte-1xknafk");
    },
    m(t, o) {
      (0, _indexMjs.insert)(t, e, o), (0, _indexMjs.mount_component)(n, e, null), s = !0;
    },
    p: _indexMjs.noop,
    i(t) {
      s || ((0, _indexMjs.transition_in)(n.$$.fragment, t), s = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(n.$$.fragment, t), s = !1;
    },
    d(t) {
      t && (0, _indexMjs.detach)(e), (0, _indexMjs.destroy_component)(n);
    }
  };
}
function Y(t) {
  let e, n;
  return e = new _IconSvelte.default({
    props: {
      slot: "leadingIcon",
      $$slots: {
        default: [J]
      },
      $$scope: {
        ctx: t
      }
    }
  }), {
    c() {
      (0, _indexMjs.create_component)(e.$$.fragment);
    },
    m(t, s) {
      (0, _indexMjs.mount_component)(e, t, s), n = !0;
    },
    p(t, n) {
      const s = {};
      16777216 & n[1] && (s.$$scope = {
        dirty: n,
        ctx: t
      }), e.$set(s);
    },
    i(t) {
      n || ((0, _indexMjs.transition_in)(e.$$.fragment, t), n = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(e.$$.fragment, t), n = !1;
    },
    d(t) {
      (0, _indexMjs.destroy_component)(e, t);
    }
  };
}
function K(t) {
  let e,
    n,
    s = t[11].label + "";
  return {
    c() {
      e = (0, _indexMjs.element)("div"), n = (0, _indexMjs.text)(s), (0, _indexMjs.attr)(e, "class", "cosmograph-search-accessor"), (0, _indexMjs.toggle_class)(e, "active", t[2]), (0, _indexMjs.toggle_class)(e, "disabled", !t[9]);
    },
    m(t, s) {
      (0, _indexMjs.insert)(t, e, s), (0, _indexMjs.append)(e, n);
    },
    p(t, o) {
      2048 & o[0] && s !== (s = t[11].label + "") && (0, _indexMjs.set_data)(n, s), 4 & o[0] && (0, _indexMjs.toggle_class)(e, "active", t[2]), 512 & o[0] && (0, _indexMjs.toggle_class)(e, "disabled", !t[9]);
    },
    d(t) {
      t && (0, _indexMjs.detach)(e);
    }
  };
}
function Q(t) {
  let e,
    n = t[11] && K(t);
  return {
    c() {
      n && n.c(), e = (0, _indexMjs.empty)();
    },
    m(t, s) {
      n && n.m(t, s), (0, _indexMjs.insert)(t, e, s);
    },
    p(t, s) {
      t[11] ? n ? n.p(t, s) : (n = K(t), n.c(), n.m(e.parentNode, e)) : n && (n.d(1), n = null);
    },
    d(t) {
      n && n.d(t), t && (0, _indexMjs.detach)(e);
    }
  };
}
function W(t) {
  let e, n;
  return e = new _IconSvelte.default({
    props: {
      role: "button",
      style: "display: flex;",
      slot: "trailingIcon",
      $$slots: {
        default: [Q]
      },
      $$scope: {
        ctx: t
      }
    }
  }), e.$on("SMUITextField:icon", t[14]), {
    c() {
      (0, _indexMjs.create_component)(e.$$.fragment);
    },
    m(t, s) {
      (0, _indexMjs.mount_component)(e, t, s), n = !0;
    },
    p(t, n) {
      const s = {};
      2564 & n[0] | 16777216 & n[1] && (s.$$scope = {
        dirty: n,
        ctx: t
      }), e.$set(s);
    },
    i(t) {
      n || ((0, _indexMjs.transition_in)(e.$$.fragment, t), n = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(e.$$.fragment, t), n = !1;
    },
    d(t) {
      (0, _indexMjs.destroy_component)(e, t);
    }
  };
}
function X(t) {
  let e, n, s;
  return n = new _ItemSvelte.default({
    props: {
      $$slots: {
        default: [nt]
      },
      $$scope: {
        ctx: t
      }
    }
  }), {
    c() {
      e = (0, _indexMjs.element)("div"), (0, _indexMjs.create_component)(n.$$.fragment), (0, _indexMjs.set_style)(e, "pointer-events", "none");
    },
    m(t, o) {
      (0, _indexMjs.insert)(t, e, o), (0, _indexMjs.mount_component)(n, e, null), s = !0;
    },
    p(t, e) {
      const s = {};
      16777216 & e[1] && (s.$$scope = {
        dirty: e,
        ctx: t
      }), n.$set(s);
    },
    i(t) {
      s || ((0, _indexMjs.transition_in)(n.$$.fragment, t), s = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(n.$$.fragment, t), s = !1;
    },
    d(t) {
      t && (0, _indexMjs.detach)(e), (0, _indexMjs.destroy_component)(n);
    }
  };
}
function Z(t) {
  let e,
    n = [],
    s = new Map(),
    o = t[4];
  const i = t => t[52];
  for (let e = 0; e < o.length; e += 1) {
    let r = F(t, o, e),
      l = i(r);
    s.set(l, n[e] = st(l, r));
  }
  return {
    c() {
      for (let t = 0; t < n.length; t += 1) n[t].c();
      e = (0, _indexMjs.empty)();
    },
    m(t, s) {
      for (let e = 0; e < n.length; e += 1) n[e] && n[e].m(t, s);
      (0, _indexMjs.insert)(t, e, s);
    },
    p(t, r) {
      655376 & r[0] && (o = t[4], n = (0, _indexMjs.update_keyed_each)(n, r, i, 1, t, o, s, e.parentNode, _indexMjs.destroy_block, st, e, F));
    },
    i: _indexMjs.noop,
    o: _indexMjs.noop,
    d(t) {
      for (let e = 0; e < n.length; e += 1) n[e].d(t);
      t && (0, _indexMjs.detach)(e);
    }
  };
}
function tt(t) {
  let e,
    n,
    s = t[1]?.accessors?.length && ot(t);
  return {
    c() {
      s && s.c(), e = (0, _indexMjs.empty)();
    },
    m(t, o) {
      s && s.m(t, o), (0, _indexMjs.insert)(t, e, o), n = !0;
    },
    p(t, n) {
      t[1]?.accessors?.length ? s ? (s.p(t, n), 2 & n[0] && (0, _indexMjs.transition_in)(s, 1)) : (s = ot(t), s.c(), (0, _indexMjs.transition_in)(s, 1), s.m(e.parentNode, e)) : s && ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(s, 1, 1, () => {
        s = null;
      }), (0, _indexMjs.check_outros)());
    },
    i(t) {
      n || ((0, _indexMjs.transition_in)(s), n = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(s), n = !1;
    },
    d(t) {
      s && s.d(t), t && (0, _indexMjs.detach)(e);
    }
  };
}
function et(t) {
  let e;
  return {
    c() {
      e = (0, _indexMjs.text)("No matches found");
    },
    m(t, n) {
      (0, _indexMjs.insert)(t, e, n);
    },
    d(t) {
      t && (0, _indexMjs.detach)(e);
    }
  };
}
function nt(t) {
  let e, n;
  return e = new _Text.default({
    props: {
      $$slots: {
        default: [et]
      },
      $$scope: {
        ctx: t
      }
    }
  }), {
    c() {
      (0, _indexMjs.create_component)(e.$$.fragment);
    },
    m(t, s) {
      (0, _indexMjs.mount_component)(e, t, s), n = !0;
    },
    p(t, n) {
      const s = {};
      16777216 & n[1] && (s.$$scope = {
        dirty: n,
        ctx: t
      }), e.$set(s);
    },
    i(t) {
      n || ((0, _indexMjs.transition_in)(e.$$.fragment, t), n = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(e.$$.fragment, t), n = !1;
    },
    d(t) {
      (0, _indexMjs.destroy_component)(e, t);
    }
  };
}
function st(t, e) {
  let n,
    s,
    o,
    r,
    u,
    m = e[19](e[53]) + "";
  return {
    key: t,
    first: null,
    c() {
      n = (0, _indexMjs.element)("div"), s = (0, _indexMjs.element)("div"), o = (0, _indexMjs.space)(), (0, _indexMjs.attr)(n, "class", "cosmograph-search-match"), (0, _indexMjs.set_style)(n, "--margin-v", mt), (0, _indexMjs.set_style)(n, "--margin-h", pt), this.first = n;
    },
    m(t, i) {
      (0, _indexMjs.insert)(t, n, i), (0, _indexMjs.append)(n, s), s.innerHTML = m, (0, _indexMjs.append)(n, o), r || (u = [(0, _indexMjs.listen)(n, "click", function () {
        (0, _indexMjs.is_function)(e[17](e[53])) && e[17](e[53]).apply(this, arguments);
      }), (0, _indexMjs.listen)(n, "keydown", function () {
        (0, _indexMjs.is_function)(e[17](e[53])) && e[17](e[53]).apply(this, arguments);
      })], r = !0);
    },
    p(t, n) {
      e = t, 16 & n[0] && m !== (m = e[19](e[53]) + "") && (s.innerHTML = m);
    },
    d(t) {
      t && (0, _indexMjs.detach)(n), r = !1, (0, _indexMjs.run_all)(u);
    }
  };
}
function ot(t) {
  let e,
    n,
    s,
    o,
    a,
    u = [],
    p = new Map();
  n = new _ItemSvelte.default({
    props: {
      $$slots: {
        default: [it]
      },
      $$scope: {
        ctx: t
      }
    }
  });
  let $ = t[1]?.accessors;
  const v = t => t[52];
  for (let e = 0; e < $.length; e += 1) {
    let n = G(t, $, e),
      s = v(n);
    p.set(s, u[e] = ct(s, n));
  }
  return {
    c() {
      e = (0, _indexMjs.element)("div"), (0, _indexMjs.create_component)(n.$$.fragment), s = (0, _indexMjs.space)();
      for (let t = 0; t < u.length; t += 1) u[t].c();
      o = (0, _indexMjs.empty)(), (0, _indexMjs.set_style)(e, "pointer-events", "none"), (0, _indexMjs.set_style)(e, "font-size", "10px", 1);
    },
    m(t, i) {
      (0, _indexMjs.insert)(t, e, i), (0, _indexMjs.mount_component)(n, e, null), (0, _indexMjs.insert)(t, s, i);
      for (let e = 0; e < u.length; e += 1) u[e] && u[e].m(t, i);
      (0, _indexMjs.insert)(t, o, i), a = !0;
    },
    p(t, e) {
      const s = {};
      16777216 & e[1] && (s.$$scope = {
        dirty: e,
        ctx: t
      }), n.$set(s), 8194 & e[0] && ($ = t[1]?.accessors, (0, _indexMjs.group_outros)(), u = (0, _indexMjs.update_keyed_each)(u, e, v, 1, t, $, p, o.parentNode, _indexMjs.outro_and_destroy_block, ct, o, G), (0, _indexMjs.check_outros)());
    },
    i(t) {
      if (!a) {
        (0, _indexMjs.transition_in)(n.$$.fragment, t);
        for (let t = 0; t < $.length; t += 1) (0, _indexMjs.transition_in)(u[t]);
        a = !0;
      }
    },
    o(t) {
      (0, _indexMjs.transition_out)(n.$$.fragment, t);
      for (let t = 0; t < u.length; t += 1) (0, _indexMjs.transition_out)(u[t]);
      a = !1;
    },
    d(t) {
      t && (0, _indexMjs.detach)(e), (0, _indexMjs.destroy_component)(n), t && (0, _indexMjs.detach)(s);
      for (let e = 0; e < u.length; e += 1) u[e].d(t);
      t && (0, _indexMjs.detach)(o);
    }
  };
}
function it(t) {
  let e;
  return {
    c() {
      e = (0, _indexMjs.element)("div"), e.textContent = "select accessor to search", (0, _indexMjs.attr)(e, "class", "cosmograph-search-result");
    },
    m(t, n) {
      (0, _indexMjs.insert)(t, e, n);
    },
    p: _indexMjs.noop,
    d(t) {
      t && (0, _indexMjs.detach)(e);
    }
  };
}
function rt(t) {
  let e,
    n = t[50].label + "";
  return {
    c() {
      e = (0, _indexMjs.text)(n);
    },
    m(t, n) {
      (0, _indexMjs.insert)(t, e, n);
    },
    p(t, s) {
      2 & s[0] && n !== (n = t[50].label + "") && (0, _indexMjs.set_data)(e, n);
    },
    d(t) {
      t && (0, _indexMjs.detach)(e);
    }
  };
}
function lt(t) {
  let e, n, s;
  return e = new _Text.default({
    props: {
      $$slots: {
        default: [rt]
      },
      $$scope: {
        ctx: t
      }
    }
  }), {
    c() {
      (0, _indexMjs.create_component)(e.$$.fragment), n = (0, _indexMjs.space)();
    },
    m(t, o) {
      (0, _indexMjs.mount_component)(e, t, o), (0, _indexMjs.insert)(t, n, o), s = !0;
    },
    p(t, n) {
      const s = {};
      2 & n[0] | 16777216 & n[1] && (s.$$scope = {
        dirty: n,
        ctx: t
      }), e.$set(s);
    },
    i(t) {
      s || ((0, _indexMjs.transition_in)(e.$$.fragment, t), s = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(e.$$.fragment, t), s = !1;
    },
    d(t) {
      (0, _indexMjs.destroy_component)(e, t), t && (0, _indexMjs.detach)(n);
    }
  };
}
function ct(t, e) {
  let n, s, o;
  return s = new _ItemSvelte.default({
    props: {
      $$slots: {
        default: [lt]
      },
      $$scope: {
        ctx: e
      }
    }
  }), s.$on("click", function () {
    (0, _indexMjs.is_function)(e[13](e[50], e[52])) && e[13](e[50], e[52]).apply(this, arguments);
  }), {
    key: t,
    first: null,
    c() {
      n = (0, _indexMjs.empty)(), (0, _indexMjs.create_component)(s.$$.fragment), this.first = n;
    },
    m(t, e) {
      (0, _indexMjs.insert)(t, n, e), (0, _indexMjs.mount_component)(s, t, e), o = !0;
    },
    p(t, n) {
      e = t;
      const o = {};
      2 & n[0] | 16777216 & n[1] && (o.$$scope = {
        dirty: n,
        ctx: e
      }), s.$set(o);
    },
    i(t) {
      o || ((0, _indexMjs.transition_in)(s.$$.fragment, t), o = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(s.$$.fragment, t), o = !1;
    },
    d(t) {
      t && (0, _indexMjs.detach)(n), (0, _indexMjs.destroy_component)(s, t);
    }
  };
}
function at(t) {
  let e, n, s, o;
  const r = [tt, Z, X],
    l = [];
  function c(t, e) {
    return t[2] ? 0 : t[4].length ? 1 : 2;
  }
  return n = c(t), s = l[n] = r[n](t), {
    c() {
      e = (0, _indexMjs.element)("div"), s.c();
    },
    m(s, i) {
      (0, _indexMjs.insert)(s, e, i), l[n].m(e, null), t[28](e), o = !0;
    },
    p(t, o) {
      let i = n;
      n = c(t), n === i ? l[n].p(t, o) : ((0, _indexMjs.group_outros)(), (0, _indexMjs.transition_out)(l[i], 1, 1, () => {
        l[i] = null;
      }), (0, _indexMjs.check_outros)(), s = l[n], s ? s.p(t, o) : (s = l[n] = r[n](t), s.c()), (0, _indexMjs.transition_in)(s, 1), s.m(e, null));
    },
    i(t) {
      o || ((0, _indexMjs.transition_in)(s), o = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(s), o = !1;
    },
    d(s) {
      s && (0, _indexMjs.detach)(e), l[n].d(), t[28](null);
    }
  };
}
function ut(t) {
  let e, n;
  return e = new _ListSvelte.default({
    props: {
      style: "max-height: " + t[8] + "px; transition: max-height 0.1s linear;",
      $$slots: {
        default: [at]
      },
      $$scope: {
        ctx: t
      }
    }
  }), {
    c() {
      (0, _indexMjs.create_component)(e.$$.fragment);
    },
    m(t, s) {
      (0, _indexMjs.mount_component)(e, t, s), n = !0;
    },
    p(t, n) {
      const s = {};
      256 & n[0] && (s.style = "max-height: " + t[8] + "px; transition: max-height 0.1s linear;"), 86 & n[0] | 16777216 & n[1] && (s.$$scope = {
        dirty: n,
        ctx: t
      }), e.$set(s);
    },
    i(t) {
      n || ((0, _indexMjs.transition_in)(e.$$.fragment, t), n = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(e.$$.fragment, t), n = !1;
    },
    d(t) {
      (0, _indexMjs.destroy_component)(e, t);
    }
  };
}
function dt(t) {
  let e, n, v, y, b, w, j, I, S;
  function k(e) {
    t[26](e);
  }
  function O(e) {
    t[27](e);
  }
  let M = {
    style: "opacity: " + (t[1].isDisabled ? .5 : 1),
    label: t[1].placeholder,
    $$slots: {
      trailingIcon: [W],
      leadingIcon: [Y]
    },
    $$scope: {
      ctx: t
    }
  };
  function _(e) {
    t[29](e);
  }
  void 0 !== t[0] && (M.value = t[0]), void 0 !== t[12] && (M.disabled = t[12]), n = new _TextfieldSvelte.default({
    props: M
  }), t[25](n), _indexMjs.binding_callbacks.push(() => (0, _indexMjs.bind)(n, "value", k)), _indexMjs.binding_callbacks.push(() => (0, _indexMjs.bind)(n, "disabled", O)), n.$on("click", t[18]), n.$on("focus", t[20]), n.$on("input", t[16]), n.$on("keydown", t[15]);
  let L = {
    style: "width: 100%; bottom: initial;",
    $$slots: {
      default: [ut]
    },
    $$scope: {
      ctx: t
    }
  };
  return void 0 !== t[3] && (L.open = t[3]), j = new _MenuSvelte.default({
    props: L
  }), _indexMjs.binding_callbacks.push(() => (0, _indexMjs.bind)(j, "open", _)), t[30](j), {
    c() {
      e = (0, _indexMjs.element)("div"), (0, _indexMjs.create_component)(n.$$.fragment), b = (0, _indexMjs.space)(), w = (0, _indexMjs.element)("div"), (0, _indexMjs.create_component)(j.$$.fragment), (0, _indexMjs.set_style)(w, "position", "relative"), (0, _indexMjs.attr)(w, "class", "svelte-1xknafk"), (0, _indexMjs.toggle_class)(w, "openListUpwards", t[1].openListUpwards), (0, _indexMjs.toggle_class)(w, "accessors", t[2]), (0, _indexMjs.attr)(e, "class", "search svelte-1xknafk");
    },
    m(s, o) {
      (0, _indexMjs.insert)(s, e, o), (0, _indexMjs.mount_component)(n, e, null), (0, _indexMjs.append)(e, b), (0, _indexMjs.append)(e, w), (0, _indexMjs.mount_component)(j, w, null), t[31](e), S = !0;
    },
    p(t, e) {
      const s = {};
      2 & e[0] && (s.style = "opacity: " + (t[1].isDisabled ? .5 : 1)), 2 & e[0] && (s.label = t[1].placeholder), 2564 & e[0] | 16777216 & e[1] && (s.$$scope = {
        dirty: e,
        ctx: t
      }), !v && 1 & e[0] && (v = !0, s.value = t[0], (0, _indexMjs.add_flush_callback)(() => v = !1)), !y && 4096 & e[0] && (y = !0, s.disabled = t[12], (0, _indexMjs.add_flush_callback)(() => y = !1)), n.$set(s);
      const o = {};
      342 & e[0] | 16777216 & e[1] && (o.$$scope = {
        dirty: e,
        ctx: t
      }), !I && 8 & e[0] && (I = !0, o.open = t[3], (0, _indexMjs.add_flush_callback)(() => I = !1)), j.$set(o), (!S || 2 & e[0]) && (0, _indexMjs.toggle_class)(w, "openListUpwards", t[1].openListUpwards), (!S || 4 & e[0]) && (0, _indexMjs.toggle_class)(w, "accessors", t[2]);
    },
    i(t) {
      S || ((0, _indexMjs.transition_in)(n.$$.fragment, t), (0, _indexMjs.transition_in)(j.$$.fragment, t), S = !0);
    },
    o(t) {
      (0, _indexMjs.transition_out)(n.$$.fragment, t), (0, _indexMjs.transition_out)(j.$$.fragment, t), S = !1;
    },
    d(s) {
      s && (0, _indexMjs.detach)(e), t[25](null), (0, _indexMjs.destroy_component)(n), t[30](null), (0, _indexMjs.destroy_component)(j), t[31](null);
    }
  };
}
const mt = 4,
  pt = 12;
function $t(t, e, n) {
  let o;
  var i, r;
  const l = (0, _indexMjs.createEventDispatcher)();
  let c,
    a,
    u,
    d,
    m,
    p,
    {
      config: $
    } = e,
    {
      data: f = []
    } = e,
    {
      textInput: g = ""
    } = e,
    h = !0,
    x = !1,
    w = !1,
    j = [];
  const I = new Set(),
    S = new DOMParser();
  let k;
  const O = t => {
      if (!f) return;
      if (!t.trim()) return void n(4, j = []);
      let e = 0;
      const s = new RegExp((0, _escapeStringRegexp.default)(t), "i"),
        o = t => String(k.accessor(t));
      n(4, j = f.filter(t => {
        if ($.limitSuggestions && e >= $.limitSuggestions) return !1;
        const n = o(t).match(s);
        return n && (e += 1), n;
      })), j.length > 0 && j.sort((e, n) => {
        const s = o(e).toLowerCase(),
          i = o(n).toLowerCase(),
          r = t.toLowerCase();
        if (s === r && i !== r) return -1;
        if (i === r && s !== r) return 1;
        const l = s.indexOf(r),
          c = i.indexOf(r);
        return l !== c ? l - c : s.localeCompare(i);
      }), l(_types.Events.Input, j);
    },
    M = t => {
      return RegExp.prototype.test.bind(/(<([^>]+)>)/i)(t) ? (e = t, S.parseFromString(e, "text/html").documentElement.textContent || "") : t;
      var e;
    },
    _ = t => t.replace(/[&<>]/g, t => ({
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;"
    })[t] || t),
    L = (t, e) => {
      const n = M(t),
        s = $ && $.truncateValues ? $.truncateValues : n.length,
        o = (t => new RegExp((0, _escapeStringRegexp.default)(t), "i"))(g),
        i = e ? ((t, e) => t.search(e))(n, o) : -1;
      if (-1 === i) return n.substring(0, +s) + (n.length > s ? "..." : "");
      const {
          startPosition: r,
          endPosition: l
        } = ((t, e, n) => {
          let s = Math.max(0, t - Math.floor(e / 2));
          const o = Math.min(n, s + e);
          return o - t < e / 2 && (s = Math.max(0, o - e)), {
            startPosition: s,
            endPosition: o
          };
        })(i, +s, n.length),
        c = n.substring(r, l),
        a = r > 0 ? "..." : "",
        u = l < n.length ? "..." : "";
      return `${a}${e ? c.replace(o, t => `<mark>${t}</mark>`) : c}${u}`;
    },
    T = () => {
      setTimeout(() => {
        var t;
        let e,
          s = 0;
        const o = null !== (t = $.maxVisibleItems) && void 0 !== t ? t : _config.defaultSearchConfig.maxVisibleItems;
        a.querySelectorAll(`.cosmograph-search-match:nth-child(-n+${o})`).forEach(t => {
          s += t.offsetHeight;
        }), s = j.length ? s + 6 : 46, e = $.openListUpwards ? u.getBoundingClientRect().top - window.scrollY - 60 : window.innerHeight - u.getBoundingClientRect().bottom - 60, s > e && (s = e), n(8, m = s);
      }, 0);
    },
    E = () => {
      setTimeout(() => {
        var t;
        let e = 0;
        const s = null !== (t = $.maxVisibleItems) && void 0 !== t ? t : _config.defaultSearchConfig.maxVisibleItems;
        a.querySelectorAll(`li:nth-child(-n+${s})`).forEach(t => {
          e += t.offsetHeight;
        }), n(8, m = e + 24);
      }, 0);
    };
  (0, _indexMjs.onMount)(() => {
    d = new _resizeObserver.ResizeObserver(() => {
      d && a && (j && T(), x && E());
    }), d.observe(u);
  }), (0, _indexMjs.onDestroy)(() => {
    d.disconnect();
  });
  return t.$$set = t => {
    "config" in t && n(1, $ = t.config), "data" in t && n(21, f = t.data), "textInput" in t && n(0, g = t.textInput);
  }, t.$$.update = () => {
    if (25165826 & t.$$.dirty[0]) {
      n(11, k = (() => {
        var t, e, n;
        return null != $.activeAccessorIndex && (null === (t = $.accessors) || void 0 === t ? void 0 : t[$.activeAccessorIndex]) ? $.accessors[$.activeAccessorIndex] : k && $.accessors ? $.accessors.find(t => t === k) || (null === (e = $.accessors) || void 0 === e ? void 0 : e[0]) : null === (n = $.accessors) || void 0 === n ? void 0 : n[0];
      })());
      const t = null !== n(24, r = null === n(23, i = $.accessors) || void 0 === i ? void 0 : i.length) && void 0 !== r ? r : 0;
      n(9, h = t > 1);
    }
    12 & t.$$.dirty[0] && x && !w && setTimeout(() => {
      n(2, x = !1);
    }, 100), 2097158 & t.$$.dirty[0] && n(12, o = !f.length || x || !!$.isDisabled), 16 & t.$$.dirty[0] && j && T(), 4 & t.$$.dirty[0] && x && E();
  }, [g, $, x, w, j, c, a, u, m, h, p, k, o, (t, e) => {
    void 0 === $.activeAccessorIndex && n(11, k = t), null == p || p.setOpen(!1), setTimeout(() => {
      n(2, x = !1);
    }, 100), l(_types.Events.AccessorSelect, {
      index: e,
      accessor: k
    });
  }, () => {
    h && (n(0, g = ""), null == p || p.setOpen(!1), setTimeout(() => {
      null == p || p.setOpen(!0), n(2, x = !0);
    }, 100));
  }, t => {
    "Enter" === t.key && void 0 !== $.minMatch && g.length >= $.minMatch && l(_types.Events.Enter, {
      textInput: g,
      accessor: k
    });
  }, t => {
    const e = null == t ? void 0 : t.target;
    x || (void 0 !== $.minMatch && e.value.length < $.minMatch ? null == p || p.setOpen(!1) : (null == p || p.setOpen(!0), O(e.value)));
  }, t => e => {
    null !== document.activeElement && document.activeElement.blur(), p.setOpen(!1), I.size >= 5 && I.delete(I.values().next().value), I.add(t), l(_types.Events.Select, t);
  }, () => {
    setTimeout(() => {
      x || w || 0 !== g.length || (I.size ? n(4, j = Array.from(I)) : f.length && n(4, j = f.slice(0, $.maxVisibleItems)), p.setOpen(!0));
    }, 110);
  }, t => (t => {
    var e;
    const {
      [k.label]: n,
      ...s
    } = t;
    if (Object.keys(s).length > 0) {
      const t = null !== (e = $.matchPalette) && void 0 !== e ? e : _config.defaultSearchConfig.matchPalette,
        o = e => `color: ${t[e % t.length]}`,
        i = Object.entries(s).map(([t, e], n) => {
          const s = L("object" == typeof e ? JSON.stringify(e) : String(e));
          return `<span style="${o(n)}"><t>·</t><b>${_(t)}</b>: ${s}</span>`;
        });
      return `\n      <span class="cosmograph-search-first-field"><b>${_(k.label)}</b>:</span>\n      ${L(String(n), !0)}\n      <div class='cosmograph-search-result'>\n        ${i.join("")} \n      </div>\n    `;
    }
    return L(String(n), !0);
  })((t => {
    const e = {},
      n = Object.keys(t),
      s = k.accessor(t);
    if (s && (e[k.label] = s), !$.ordering || !$.ordering.order && !$.ordering.include) {
      const s = Object.entries(t).findIndex(([t, e]) => k.accessor({
        [t]: e
      }));
      -1 !== s && n.splice(s, 1);
      for (const s of n) e[s] = t[s];
      return e;
    }
    const o = $.ordering.order || [];
    let i = $.ordering.include ? new Set($.ordering.include) : null;
    if (i || (i = new Set(n)), o.length > 0) for (const n of o) n in t && (e[n] = t[n]);
    for (const n in t) !Object.prototype.hasOwnProperty.call(e, n) && i.has(n) && (e[n] = t[n]);
    return e;
  })(t)), t => {
    t.preventDefault();
  }, f, t => {
    null == p || p.setOpen(t);
  }, i, r, function (t) {
    _indexMjs.binding_callbacks[t ? "unshift" : "push"](() => {
      c = t, n(5, c);
    });
  }, function (t) {
    g = t, n(0, g);
  }, function (t) {
    o = t, n(12, o), n(21, f), n(2, x), n(1, $), n(3, w);
  }, function (t) {
    _indexMjs.binding_callbacks[t ? "unshift" : "push"](() => {
      a = t, n(6, a);
    });
  }, function (t) {
    w = t, n(3, w);
  }, function (t) {
    _indexMjs.binding_callbacks[t ? "unshift" : "push"](() => {
      p = t, n(10, p);
    });
  }, function (t) {
    _indexMjs.binding_callbacks[t ? "unshift" : "push"](() => {
      u = t, n(7, u);
    });
  }];
}
class ft extends _indexMjs.SvelteComponent {
  constructor(t) {
    super(), (0, _indexMjs.init)(this, t, $t, dt, _indexMjs.safe_not_equal, {
      config: 1,
      data: 21,
      textInput: 0,
      setListState: 22
    }, null, [-1, -1]);
  }
  get setListState() {
    return this.$$.ctx[22];
  }
}
exports.default = ft;
},{"./../../ext/svelte/internal/index.mjs.js":"../node_modules/@cosmograph/ui/ext/svelte/internal/index.mjs.js","@juggle/resize-observer":"../node_modules/@juggle/resize-observer/lib/exports/resize-observer.js","escape-string-regexp":"../node_modules/escape-string-regexp/index.js","./../../ext/@smui/list/dist/List.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/List.svelte.js","./../../ext/@smui/list/dist/Item.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Item.svelte.js","./../../ext/@smui/list/dist/Text.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Text.js","./../../ext/@smui/list/dist/PrimaryText.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/PrimaryText.js","./../../ext/@smui/list/dist/SecondaryText.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/SecondaryText.js","./../../ext/@smui/list/dist/Meta.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Meta.js","./../../ext/@smui/list/dist/Group.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Group.js","./../../ext/@smui/list/dist/Subheader.js":"../node_modules/@cosmograph/ui/ext/@smui/list/dist/Subheader.js","./../../ext/@smui/textfield/dist/Textfield.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/Textfield.svelte.js","./../../ext/@smui/textfield/dist/Prefix.js":"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/Prefix.js","./../../ext/@smui/textfield/dist/Suffix.js":"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/Suffix.js","./../../ext/@smui/textfield/dist/HelperLine.js":"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/HelperLine.js","./../../ext/@smui/textfield/dist/icon/Icon.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/textfield/dist/icon/Icon.svelte.js","./../../ext/@smui/menu/dist/Menu.svelte.js":"../node_modules/@cosmograph/ui/ext/@smui/menu/dist/Menu.svelte.js","./../../ext/@smui/menu/dist/SelectionGroupIcon.js":"../node_modules/@cosmograph/ui/ext/@smui/menu/dist/SelectionGroupIcon.js","./types.js":"../node_modules/@cosmograph/ui/modules/search/types.js","./config.js":"../node_modules/@cosmograph/ui/modules/search/config.js","./search-svg.svelte.js":"../node_modules/@cosmograph/ui/modules/search/search-svg.svelte.js","./smui.css.js":"../node_modules/@cosmograph/ui/modules/search/smui.css.js","../../scrollbar.css.js":"../node_modules/@cosmograph/ui/scrollbar.css.js","./search.css.js":"../node_modules/@cosmograph/ui/modules/search/search.css.js"}],"../node_modules/@cosmograph/ui/modules/search/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Search = void 0;
var _config = require("./config.js");
var _types = require("./types.js");
var _searchSvelte = _interopRequireDefault(require("./search.svelte.js"));
var _utils = require("../../utils.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class o {
  constructor(o, n) {
    this._config = {}, this._containerNode = o, this._config = (0, _utils.merge)(_config.defaultSearchConfig, null != n ? n : {}), this._search = new _searchSvelte.default({
      target: o,
      props: {
        config: this._config
      }
    }), this._search.$on(_types.Events.Input, ({
      detail: t
    }) => {
      var e, i;
      return null === (i = null === (e = this._config.events) || void 0 === e ? void 0 : e.onSearch) || void 0 === i ? void 0 : i.call(e, t);
    }), this._search.$on(_types.Events.Select, ({
      detail: t
    }) => {
      var e, i;
      return null === (i = null === (e = this._config.events) || void 0 === e ? void 0 : e.onSelect) || void 0 === i ? void 0 : i.call(e, t);
    }), this._search.$on(_types.Events.Enter, ({
      detail: t
    }) => {
      var e, i;
      return null === (i = null === (e = this._config.events) || void 0 === e ? void 0 : e.onEnter) || void 0 === i ? void 0 : i.call(e, t);
    }), this._search.$on(_types.Events.AccessorSelect, ({
      detail: t
    }) => {
      var e, i;
      return null === (i = null === (e = this._config.events) || void 0 === e ? void 0 : e.onAccessorSelect) || void 0 === i ? void 0 : i.call(e, t);
    });
  }
  setData(t) {
    this._search.$set({
      data: t,
      textInput: ""
    });
  }
  setConfig(e) {
    this._config = (0, _utils.merge)(_config.defaultSearchConfig, null != e ? e : {}), this._search.$set({
      config: this._config,
      textInput: ""
    });
  }
  setListState(t) {
    this._search.setListState(t);
  }
  clearInput() {
    this._search.$set({
      textInput: ""
    });
  }
  getConfig() {
    return this._config;
  }
  destroy() {
    this._containerNode.innerHTML = "";
  }
}
exports.Search = o;
},{"./config.js":"../node_modules/@cosmograph/ui/modules/search/config.js","./types.js":"../node_modules/@cosmograph/ui/modules/search/types.js","./search.svelte.js":"../node_modules/@cosmograph/ui/modules/search/search.svelte.js","../../utils.js":"../node_modules/@cosmograph/ui/utils.js"}],"../node_modules/@cosmograph/ui/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Config", {
  enumerable: true,
  get: function () {
    return _utils.Config;
  }
});
Object.defineProperty(exports, "Histogram", {
  enumerable: true,
  get: function () {
    return _index2.Histogram;
  }
});
Object.defineProperty(exports, "HistogramConfig", {
  enumerable: true,
  get: function () {
    return _config2.HistogramConfig;
  }
});
Object.defineProperty(exports, "Search", {
  enumerable: true,
  get: function () {
    return _index3.Search;
  }
});
Object.defineProperty(exports, "Timeline", {
  enumerable: true,
  get: function () {
    return _index.Timeline;
  }
});
Object.defineProperty(exports, "TimelineConfig", {
  enumerable: true,
  get: function () {
    return _config.TimelineConfig;
  }
});
Object.defineProperty(exports, "merge", {
  enumerable: true,
  get: function () {
    return _utils.merge;
  }
});
var _index = require("./modules/timeline/index.js");
var _index2 = require("./modules/histogram/index.js");
var _index3 = require("./modules/search/index.js");
var _utils = require("./utils.js");
var _config = require("./modules/timeline/config.js");
var _config2 = require("./modules/histogram/config.js");
},{"./modules/timeline/index.js":"../node_modules/@cosmograph/ui/modules/timeline/index.js","./modules/histogram/index.js":"../node_modules/@cosmograph/ui/modules/histogram/index.js","./modules/search/index.js":"../node_modules/@cosmograph/ui/modules/search/index.js","./utils.js":"../node_modules/@cosmograph/ui/utils.js","./modules/timeline/config.js":"../node_modules/@cosmograph/ui/modules/timeline/config.js","./modules/histogram/config.js":"../node_modules/@cosmograph/ui/modules/histogram/config.js"}],"../node_modules/@cosmograph/cosmograph/modules/cosmograph/watermark.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.watermark = void 0;
const c = exports.watermark = '<svg fill="currentColor" height="11" viewBox="0 0 163 11" width="163" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor"><path d="m2.45674 8-1.925002-5.379h.924002l1.617 4.73h.154l1.617-4.73h.924l-1.925 5.379z"/><path d="m7.02243 8v-5.379h.869v5.379zm.44-6.215c-.19067 0-.352-.06233-.484-.187-.12467-.12467-.187-.28233-.187-.473 0-.198.06233-.359333.187-.484.132-.124667.29333-.187.484-.187.19066 0 .34833.062333.473.187.12466.124667.187.286.187.484 0 .19067-.06234.34833-.187.473-.12467.12467-.28234.187-.473.187z"/><path d="m11.8857 8.154c-.6673 0-1.232-.154-1.694-.462-.45465-.308-.72965-.79567-.82499-1.463l.82499-.187c.0587.352.1687.63067.33.836.1613.198.3593.341.594.429.242.08067.4987.121.77.121.4033 0 .7223-.08067.957-.242s.352-.37767.352-.649c0-.27867-.1137-.473-.341-.583-.22-.11733-.5243-.21267-.913-.286l-.451-.077c-.3447-.05867-.66-.15033-.946-.275s-.5133-.29333-.68199-.506c-.16866-.21267-.25299-.48033-.25299-.803 0-.484.18699-.86167.56098-1.133.374-.27133.869-.407 1.485-.407.6087 0 1.1.13933 1.474.418.3813.27133.627.65633.737 1.155l-.814.209c-.066-.38867-.2237-.66-.473-.814-.2493-.16133-.5573-.242-.924-.242s-.6563.06967-.869.209c-.2127.132-.319.33-.319.594 0 .25667.099.44733.297.572.2053.11733.4767.20533.814.264l.451.077c.3813.066.7223.15767 1.023.275.308.11.55.27133.726.484.1833.21267.275.49133.275.836 0 .528-.198.935-.594 1.221-.3887.286-.913.429-1.573.429z"/><path d="m17.5765 8.099c-.3887 0-.748-.08433-1.078-.253-.3227-.16867-.5793-.418-.77-.748-.1833-.33733-.275-.74433-.275-1.221v-3.256h.869v3.19c0 .53533.132.924.396 1.166.2713.242.6343.363 1.089.363.5133 0 .935-.16867 1.265-.506s.495-.83967.495-1.507v-2.706h.869v5.379h-.847v-.913h-.154c-.1173.25667-.319.49133-.605.704-.286.20533-.704.308-1.254.308z"/><path d="m23.9048 8.154c-.374 0-.715-.066-1.023-.198s-.55-.32267-.726-.572-.264-.55367-.264-.913c0-.36667.088-.66733.264-.902.176-.242.418-.42167.726-.539.308-.12467.6527-.187 1.034-.187h1.815v-.396c0-.38133-.1136-.682-.341-.902-.22-.22-.55-.33-.99-.33-.4326 0-.77.10633-1.012.319-.242.20533-.407.484-.495.836l-.814-.264c.088-.30067.2274-.572.418-.814.1907-.24933.4437-.44733.759-.594.3227-.154.7077-.231 1.155-.231.6894 0 1.2247.17967 1.606.539.3814.352.572.85067.572 1.496v2.431c0 .22.1027.33.308.33h.495v.737h-.759c-.242 0-.4363-.066-.583-.198-.1466-.13933-.22-.32267-.22-.55v-.055h-.132c-.0806.13933-.1906.286-.33.44-.132.14667-.3153.26767-.55.363-.2346.10267-.539.154-.913.154zm.099-.748c.5134 0 .9277-.15033 1.243-.451.3227-.308.484-.737.484-1.287v-.121h-1.782c-.3446 0-.6306.077-.858.231-.22.14667-.33.37033-.33.671s.1137.53533.341.704c.2347.16867.5354.253.902.253z"/><path d="m28.582 8v-7.7h.869v7.7z"/><path d="m31.2783 8v-5.379h.869v5.379zm.44-6.215c-.1907 0-.352-.06233-.484-.187-.1247-.12467-.187-.28233-.187-.473 0-.198.0623-.359333.187-.484.132-.124667.2933-.187.484-.187s.3483.062333.473.187.187.286.187.484c0 .19067-.0623.34833-.187.473s-.2823.187-.473.187z"/><path d="m33.7326 8v-1.122l3.421-3.377v-.121h-3.311v-.759h4.224v1.122l-3.432 3.377v.132h3.52v.748z"/><path d="m41.9601 8.154c-.5427 0-1.0194-.11367-1.43-.341-.4107-.23467-.7297-.561-.957-.979-.2274-.418-.341-.902-.341-1.452v-.132c0-.55733.1136-1.045.341-1.463.2273-.418.5426-.74067.946-.968.4033-.23467.8653-.352 1.386-.352.506 0 .9533.11 1.342.33.3886.21267.693.52067.913.924s.33.87633.33 1.419v.396h-4.389c.022.57933.209 1.034.561 1.364.352.32267.792.484 1.32.484.462 0 .8176-.10633 1.067-.319.2493-.21267.44-.46567.572-.759l.748.363c-.11.22733-.264.45467-.462.682-.1907.22733-.4437.418-.759.572-.308.154-.704.231-1.188.231zm-1.848-3.333h3.498c-.0294-.49867-.2017-.88733-.517-1.166-.308-.27867-.704-.418-1.188-.418-.4914 0-.8947.13933-1.21.418-.3154.27867-.5097.66733-.583 1.166z"/><path d="m48.2828 8.154c-.462 0-.8873-.11-1.276-.33-.3886-.22-.6966-.539-.924-.957-.2273-.418-.341-.913-.341-1.485v-.143c0-.572.1137-1.06333.341-1.474.2274-.418.5317-.737.913-.957.3887-.22733.8177-.341 1.287-.341.374 0 .6894.05133.946.154.264.09533.4767.22.638.374.1614.14667.286.30433.374.473h.154v-3.168h.869v7.7h-.847v-.891h-.154c-.1466.27133-.374.51333-.682.726s-.7406.319-1.298.319zm.231-.77c.5574 0 1.0084-.176 1.353-.528.352-.35933.528-.858.528-1.496v-.099c0-.638-.176-1.133-.528-1.485-.3446-.35933-.7956-.539-1.353-.539-.55 0-1.0046.17967-1.364.539-.352.352-.528.847-.528 1.485v.099c0 .638.176 1.13667.528 1.496.3594.352.814.528 1.364.528z"/><path d="m58.8911 8.154c-.5573 0-.9936-.10633-1.309-.319-.308-.21267-.5316-.45467-.671-.726h-.154v.891h-.847v-7.7h.869v3.168h.154c.088-.16867.2127-.32633.374-.473.1614-.154.3704-.27867.627-.374.264-.10267.583-.154.957-.154.4694 0 .8947.11367 1.276.341.3887.22.6967.539.924.957.2274.41067.341.902.341 1.474v.143c0 .572-.1173 1.067-.352 1.485-.2273.418-.5353.737-.924.957-.3813.22-.803.33-1.265.33zm-.231-.77c.5574 0 1.0084-.176 1.353-.528.352-.35933.528-.858.528-1.496v-.099c0-.638-.176-1.133-.528-1.485-.3446-.35933-.7956-.539-1.353-.539-.55 0-1.0046.17967-1.364.539-.352.352-.528.847-.528 1.485v.099c0 .638.176 1.13667.528 1.496.3594.352.814.528 1.364.528z"/><path d="m63.6382 10.2v-.77h3.08c.2127 0 .319-.11.319-.33v-1.958h-.154c-.0733.154-.187.308-.341.462-.1466.14667-.341.26767-.583.363-.242.088-.5463.132-.913.132-.3886 0-.748-.08433-1.078-.253-.3226-.16867-.5793-.418-.77-.748-.1833-.33-.275-.73333-.275-1.21v-3.267h.869v3.201c0 .528.132.913.396 1.155.2714.242.6344.363 1.089.363.5134 0 .935-.16867 1.265-.506s.495-.83967.495-1.507v-2.706h.869v6.633c0 .29333-.0843.52433-.253.693-.1613.1687-.3996.253-.715.253z"/><path d="m75.2998 8.154c-.9167 0-1.6464-.264-2.189-.792-.5427-.53533-.814-1.31267-.814-2.332v-1.76c0-1.01933.2713-1.793.814-2.321.5426-.535333 1.2723-.803 2.189-.803.9093 0 1.606.253 2.09.759.4913.506.737 1.199.737 2.079v.055h-.913v-.088c0-.57933-.1577-1.05233-.473-1.419-.308-.374-.7884-.561-1.441-.561-.6527 0-1.1624.20167-1.529.605-.3667.396-.55.95333-.55 1.672v1.804c0 .71867.1833 1.27967.55 1.683.3666.396.8763.594 1.529.594.6526 0 1.133-.18333 1.441-.55.3153-.374.473-.85067.473-1.43v-.176h.913v.143c0 .88-.2457 1.573-.737 2.079-.484.506-1.1807.759-2.09.759z"/><path d="m82.0934 8.154c-.5427 0-1.023-.11367-1.441-.341-.4107-.22733-.7333-.54633-.968-.957-.2273-.418-.341-.90933-.341-1.474v-.143c0-.55733.1137-1.045.341-1.463.2347-.418.5573-.74067.968-.968.418-.22733.8983-.341 1.441-.341s1.0193.11367 1.43.341c.418.22733.7407.55.968.968.2347.418.352.90567.352 1.463v.143c0 .56467-.1173 1.056-.352 1.474-.2273.41067-.55.72967-.968.957-.4107.22733-.8873.341-1.43.341zm0-.781c.572 0 1.0267-.17967 1.364-.539.3447-.36667.517-.858.517-1.474v-.099c0-.616-.1723-1.10367-.517-1.463-.3373-.36667-.792-.55-1.364-.55-.5647 0-1.0193.18333-1.364.55-.3447.35933-.517.847-.517 1.463v.099c0 .616.1723 1.10733.517 1.474.3447.35933.7993.539 1.364.539z"/><path d="m88.5742 8.154c-.6673 0-1.232-.154-1.694-.462-.4547-.308-.7297-.79567-.825-1.463l.825-.187c.0587.352.1687.63067.33.836.1613.198.3593.341.594.429.242.08067.4987.121.77.121.4033 0 .7223-.08067.957-.242s.352-.37767.352-.649c0-.27867-.1137-.473-.341-.583-.22-.11733-.5243-.21267-.913-.286l-.451-.077c-.3447-.05867-.66-.15033-.946-.275s-.5133-.29333-.682-.506-.253-.48033-.253-.803c0-.484.187-.86167.561-1.133s.869-.407 1.485-.407c.6087 0 1.1.13933 1.474.418.3813.27133.627.65633.737 1.155l-.814.209c-.066-.38867-.2237-.66-.473-.814-.2493-.16133-.5573-.242-.924-.242s-.6563.06967-.869.209c-.2127.132-.319.33-.319.594 0 .25667.099.44733.297.572.2053.11733.4767.20533.814.264l.451.077c.3813.066.7223.15767 1.023.275.308.11.55.27133.726.484.1833.21267.275.49133.275.836 0 .528-.198.935-.594 1.221-.3887.286-.913.429-1.573.429z"/><path d="m92.208 8v-5.379h.847v.671h.154c.1026-.19067.2713-.36667.506-.528.2346-.16133.5646-.242.99-.242.418 0 .7553.09167 1.012.275.264.18333.4546.407.572.671h.154c.1246-.264.3116-.48767.561-.671.2566-.18333.6123-.275 1.067-.275.3593 0 .6746.07333.946.22.2713.14667.484.35933.638.638.1613.27133.242.59767.242.979v3.641h-.869v-3.564c0-.35933-.1064-.64167-.319-.847-.2054-.21267-.495-.319-.869-.319-.396 0-.7224.12833-.979.385-.2494.25667-.374.627-.374 1.111v3.234h-.869v-3.564c0-.35933-.1064-.64167-.319-.847-.2054-.21267-.495-.319-.869-.319-.396 0-.7224.12833-.979.385-.2494.25667-.374.627-.374 1.111v3.234z"/><path d="m104.158 8.154c-.543 0-1.023-.11367-1.441-.341-.411-.22733-.733-.54633-.968-.957-.227-.418-.341-.90933-.341-1.474v-.143c0-.55733.114-1.045.341-1.463.235-.418.557-.74067.968-.968.418-.22733.898-.341 1.441-.341s1.019.11367 1.43.341c.418.22733.741.55.968.968.235.418.352.90567.352 1.463v.143c0 .56467-.117 1.056-.352 1.474-.227.41067-.55.72967-.968.957-.411.22733-.887.341-1.43.341zm0-.781c.572 0 1.027-.17967 1.364-.539.345-.36667.517-.858.517-1.474v-.099c0-.616-.172-1.10367-.517-1.463-.337-.36667-.792-.55-1.364-.55-.565 0-1.019.18333-1.364.55-.345.35933-.517.847-.517 1.463v.099c0 .616.172 1.10733.517 1.474.345.35933.799.539 1.364.539z"/><path d="m108.208 5.338v-.154c0-.56467.113-1.04867.341-1.452.227-.40333.535-.715.924-.935.388-.22.814-.33 1.276-.33.564 0 .997.11 1.298.33.308.21267.535.451.682.715h.154v-.891h.825v6.633c0 .29333-.081.52433-.242.693-.162.1687-.396.253-.704.253h-3.652v-.77h3.421c.22 0 .33-.11.33-.33v-2.046h-.154c-.088.16133-.213.319-.374.473-.162.154-.371.28233-.627.385-.257.09533-.576.143-.957.143-.462 0-.888-.11-1.276-.33-.389-.22-.697-.53167-.924-.935-.228-.41067-.341-.89467-.341-1.452zm2.772 1.947c.557 0 1.008-.176 1.353-.528.352-.352.528-.836.528-1.452v-.088c0-.62333-.176-1.10733-.528-1.452-.345-.352-.796-.528-1.353-.528-.55 0-1.005.176-1.364.528-.352.34467-.528.82867-.528 1.452v.088c0 .616.176 1.1.528 1.452.359.352.814.528 1.364.528z"/><path d="m115.529 8v-5.379h.847v.66h.154c.096-.23467.242-.407.44-.517s.459-.165.781-.165h.638v.792h-.693c-.388 0-.704.11-.946.33-.234.21267-.352.54633-.352 1.001v3.278z"/><path d="m121.143 8.154c-.374 0-.715-.066-1.023-.198s-.55-.32267-.726-.572-.264-.55367-.264-.913c0-.36667.088-.66733.264-.902.176-.242.418-.42167.726-.539.308-.12467.653-.187 1.034-.187h1.815v-.396c0-.38133-.114-.682-.341-.902-.22-.22-.55-.33-.99-.33-.433 0-.77.10633-1.012.319-.242.20533-.407.484-.495.836l-.814-.264c.088-.30067.227-.572.418-.814.191-.24933.444-.44733.759-.594.323-.154.708-.231 1.155-.231.689 0 1.225.17967 1.606.539.381.352.572.85067.572 1.496v2.431c0 .22.103.33.308.33h.495v.737h-.759c-.242 0-.436-.066-.583-.198-.147-.13933-.22-.32267-.22-.55v-.055h-.132c-.081.13933-.191.286-.33.44-.132.14667-.315.26767-.55.363-.235.10267-.539.154-.913.154zm.099-.748c.513 0 .928-.15033 1.243-.451.323-.308.484-.737.484-1.287v-.121h-1.782c-.345 0-.631.077-.858.231-.22.14667-.33.37033-.33.671s.114.53533.341.704c.235.16867.535.253.902.253z"/><path d="m125.82 10.2v-7.579h.847v.891h.154c.14-.27133.363-.51333.671-.726.316-.21267.752-.319 1.309-.319.462 0 .884.11367 1.265.341.389.22.697.53533.924.946.235.41067.352.90567.352 1.485v.143c0 .572-.113 1.067-.341 1.485-.227.418-.535.737-.924.957-.381.22-.806.33-1.276.33-.374 0-.693-.05133-.957-.154-.256-.09533-.465-.22-.627-.374-.161-.154-.286-.31167-.374-.473h-.154v3.047zm2.75-2.816c.558 0 1.009-.176 1.353-.528.352-.35933.528-.858.528-1.496v-.099c0-.638-.176-1.133-.528-1.485-.344-.35933-.795-.539-1.353-.539-.55 0-1.004.17967-1.364.539-.352.352-.528.847-.528 1.485v.099c0 .638.176 1.13667.528 1.496.36.352.814.528 1.364.528z"/><path d="m132.899 8v-7.7h.869v3.179h.154c.074-.16133.184-.31167.33-.451.154-.14667.349-.26767.583-.363.242-.09533.547-.143.913-.143.404 0 .763.088 1.078.264.323.16867.58.418.77.748.191.32267.286.726.286 1.21v3.256h-.869v-3.19c0-.53533-.135-.924-.407-1.166-.264-.242-.623-.363-1.078-.363-.52 0-.946.16867-1.276.506-.322.33733-.484.83967-.484 1.507v2.706z"/><path d="m140.118 8.154c-.212 0-.392-.06967-.539-.209-.139-.13933-.209-.319-.209-.539s.07-.39967.209-.539c.147-.13933.327-.209.539-.209.22 0 .4.06967.539.209.14.13933.209.319.209.539s-.069.39967-.209.539c-.139.13933-.319.209-.539.209z"/><path d="m144.078 8.154c-.374 0-.715-.066-1.023-.198s-.55-.32267-.726-.572-.264-.55367-.264-.913c0-.36667.088-.66733.264-.902.176-.242.418-.42167.726-.539.308-.12467.652-.187 1.034-.187h1.815v-.396c0-.38133-.114-.682-.341-.902-.22-.22-.55-.33-.99-.33-.433 0-.77.10633-1.012.319-.242.20533-.407.484-.495.836l-.814-.264c.088-.30067.227-.572.418-.814.19-.24933.443-.44733.759-.594.322-.154.707-.231 1.155-.231.689 0 1.224.17967 1.606.539.381.352.572.85067.572 1.496v2.431c0 .22.102.33.308.33h.495v.737h-.759c-.242 0-.437-.066-.583-.198-.147-.13933-.22-.32267-.22-.55v-.055h-.132c-.081.13933-.191.286-.33.44-.132.14667-.316.26767-.55.363-.235.10267-.539.154-.913.154zm.099-.748c.513 0 .927-.15033 1.243-.451.322-.308.484-.737.484-1.287v-.121h-1.782c-.345 0-.631.077-.858.231-.22.14667-.33.37033-.33.671s.113.53533.341.704c.234.16867.535.253.902.253z"/><path d="m148.755 10.2v-7.579h.847v.891h.154c.139-.27133.363-.51333.671-.726.315-.21267.752-.319 1.309-.319.462 0 .884.11367 1.265.341.389.22.697.53533.924.946.235.41067.352.90567.352 1.485v.143c0 .572-.114 1.067-.341 1.485s-.535.737-.924.957c-.381.22-.807.33-1.276.33-.374 0-.693-.05133-.957-.154-.257-.09533-.466-.22-.627-.374s-.286-.31167-.374-.473h-.154v3.047zm2.75-2.816c.557 0 1.008-.176 1.353-.528.352-.35933.528-.858.528-1.496v-.099c0-.638-.176-1.133-.528-1.485-.345-.35933-.796-.539-1.353-.539-.55 0-1.005.17967-1.364.539-.352.352-.528.847-.528 1.485v.099c0 .638.176 1.13667.528 1.496.359.352.814.528 1.364.528z"/><path d="m155.834 10.2v-7.579h.847v.891h.154c.139-.27133.363-.51333.671-.726.315-.21267.752-.319 1.309-.319.462 0 .884.11367 1.265.341.389.22.697.53533.924.946.235.41067.352.90567.352 1.485v.143c0 .572-.114 1.067-.341 1.485s-.535.737-.924.957c-.381.22-.807.33-1.276.33-.374 0-.693-.05133-.957-.154-.257-.09533-.466-.22-.627-.374s-.286-.31167-.374-.473h-.154v3.047zm2.75-2.816c.557 0 1.008-.176 1.353-.528.352-.35933.528-.858.528-1.496v-.099c0-.638-.176-1.133-.528-1.485-.345-.35933-.796-.539-1.353-.539-.55 0-1.005.17967-1.364.539-.352.352-.528.847-.528 1.485v.099c0 .638.176 1.13667.528 1.496.359.352.814.528 1.364.528z"/><path d="m71.6368 9.375h90.3682v.55h-90.3682z"/></g></svg>';
},{}],"../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/bundle-url.js":[function(require,module,exports) {
var bundleURL = null;
function getBundleURLCached() {
  if (!bundleURL) {
    bundleURL = getBundleURL();
  }
  return bundleURL;
}
function getBundleURL() {
  // Attempt to find the URL of the current script and use that as the base URL
  try {
    throw new Error();
  } catch (err) {
    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);
    if (matches) {
      return getBaseURL(matches[0]);
    }
  }
  return '/';
}
function getBaseURL(url) {
  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)?\/[^/]+(?:\?.*)?$/, '$1') + '/';
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
},{}],"../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/bundle-loader.js":[function(require,module,exports) {
var getBundleURL = require('./bundle-url').getBundleURL;
function loadBundlesLazy(bundles) {
  if (!Array.isArray(bundles)) {
    bundles = [bundles];
  }
  var id = bundles[bundles.length - 1];
  try {
    return Promise.resolve(require(id));
  } catch (err) {
    if (err.code === 'MODULE_NOT_FOUND') {
      return new LazyPromise(function (resolve, reject) {
        loadBundles(bundles.slice(0, -1)).then(function () {
          return require(id);
        }).then(resolve, reject);
      });
    }
    throw err;
  }
}
function loadBundles(bundles) {
  return Promise.all(bundles.map(loadBundle));
}
var bundleLoaders = {};
function registerBundleLoader(type, loader) {
  bundleLoaders[type] = loader;
}
module.exports = exports = loadBundlesLazy;
exports.load = loadBundles;
exports.register = registerBundleLoader;
var bundles = {};
function loadBundle(bundle) {
  var id;
  if (Array.isArray(bundle)) {
    id = bundle[1];
    bundle = bundle[0];
  }
  if (bundles[bundle]) {
    return bundles[bundle];
  }
  var type = (bundle.substring(bundle.lastIndexOf('.') + 1, bundle.length) || bundle).toLowerCase();
  var bundleLoader = bundleLoaders[type];
  if (bundleLoader) {
    return bundles[bundle] = bundleLoader(getBundleURL() + bundle).then(function (resolved) {
      if (resolved) {
        module.bundle.register(id, resolved);
      }
      return resolved;
    }).catch(function (e) {
      delete bundles[bundle];
      throw e;
    });
  }
}
function LazyPromise(executor) {
  this.executor = executor;
  this.promise = null;
}
LazyPromise.prototype.then = function (onSuccess, onError) {
  if (this.promise === null) this.promise = new Promise(this.executor);
  return this.promise.then(onSuccess, onError);
};
LazyPromise.prototype.catch = function (onError) {
  if (this.promise === null) this.promise = new Promise(this.executor);
  return this.promise.catch(onError);
};
},{"./bundle-url":"../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/bundle-url.js"}],"../node_modules/@supabase/functions-js/dist/module/helper.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveFetch = void 0;
const resolveFetch = customFetch => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === 'undefined') {
    _fetch = (...args) => require("_bundle_loader")(require.resolve('@supabase/node-fetch')).then(({
      default: fetch
    }) => fetch(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
exports.resolveFetch = resolveFetch;
},{"_bundle_loader":"../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/bundle-loader.js","@supabase/node-fetch":[["browser.d202933b.js","../node_modules/@supabase/node-fetch/browser.js"],"browser.d202933b.js.map","../node_modules/@supabase/node-fetch/browser.js"]}],"../node_modules/@supabase/functions-js/dist/module/types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FunctionsRelayError = exports.FunctionsHttpError = exports.FunctionsFetchError = exports.FunctionsError = void 0;
class FunctionsError extends Error {
  constructor(message, name = 'FunctionsError', context) {
    super(message);
    this.name = name;
    this.context = context;
  }
}
exports.FunctionsError = FunctionsError;
class FunctionsFetchError extends FunctionsError {
  constructor(context) {
    super('Failed to send a request to the Edge Function', 'FunctionsFetchError', context);
  }
}
exports.FunctionsFetchError = FunctionsFetchError;
class FunctionsRelayError extends FunctionsError {
  constructor(context) {
    super('Relay Error invoking the Edge Function', 'FunctionsRelayError', context);
  }
}
exports.FunctionsRelayError = FunctionsRelayError;
class FunctionsHttpError extends FunctionsError {
  constructor(context) {
    super('Edge Function returned a non-2xx status code', 'FunctionsHttpError', context);
  }
}
exports.FunctionsHttpError = FunctionsHttpError;
},{}],"../node_modules/@supabase/functions-js/dist/module/FunctionsClient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FunctionsClient = void 0;
var _helper = require("./helper");
var _types = require("./types");
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class FunctionsClient {
  constructor(url, {
    headers = {},
    customFetch
  } = {}) {
    this.url = url;
    this.headers = headers;
    this.fetch = (0, _helper.resolveFetch)(customFetch);
  }
  /**
   * Updates the authorization header
   * @param token - the new jwt token sent in the authorisation header
   */
  setAuth(token) {
    this.headers.Authorization = `Bearer ${token}`;
  }
  /**
   * Invokes a function
   * @param functionName - The name of the Function to invoke.
   * @param options - Options for invoking the Function.
   */
  invoke(functionName, options = {}) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const {
          headers,
          method,
          body: functionArgs
        } = options;
        let _headers = {};
        let body;
        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type') || !headers)) {
          if (typeof Blob !== 'undefined' && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
            // will work for File as File inherits Blob
            // also works for ArrayBuffer as it is the same underlying structure as a Blob
            _headers['Content-Type'] = 'application/octet-stream';
            body = functionArgs;
          } else if (typeof functionArgs === 'string') {
            // plain string
            _headers['Content-Type'] = 'text/plain';
            body = functionArgs;
          } else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {
            // don't set content-type headers
            // Request will automatically add the right boundary value
            body = functionArgs;
          } else {
            // default, assume this is JSON
            _headers['Content-Type'] = 'application/json';
            body = JSON.stringify(functionArgs);
          }
        }
        const response = yield this.fetch(`${this.url}/${functionName}`, {
          method: method || 'POST',
          // headers priority is (high to low):
          // 1. invoke-level headers
          // 2. client-level headers
          // 3. default Content-Type header
          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
          body
        }).catch(fetchError => {
          throw new _types.FunctionsFetchError(fetchError);
        });
        const isRelayError = response.headers.get('x-relay-error');
        if (isRelayError && isRelayError === 'true') {
          throw new _types.FunctionsRelayError(response);
        }
        if (!response.ok) {
          throw new _types.FunctionsHttpError(response);
        }
        let responseType = ((_a = response.headers.get('Content-Type')) !== null && _a !== void 0 ? _a : 'text/plain').split(';')[0].trim();
        let data;
        if (responseType === 'application/json') {
          data = yield response.json();
        } else if (responseType === 'application/octet-stream') {
          data = yield response.blob();
        } else if (responseType === 'multipart/form-data') {
          data = yield response.formData();
        } else {
          // default to text
          data = yield response.text();
        }
        return {
          data,
          error: null
        };
      } catch (error) {
        return {
          data: null,
          error
        };
      }
    });
  }
}
exports.FunctionsClient = FunctionsClient;
},{"./helper":"../node_modules/@supabase/functions-js/dist/module/helper.js","./types":"../node_modules/@supabase/functions-js/dist/module/types.js"}],"../node_modules/@supabase/functions-js/dist/module/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "FunctionsClient", {
  enumerable: true,
  get: function () {
    return _FunctionsClient.FunctionsClient;
  }
});
Object.defineProperty(exports, "FunctionsError", {
  enumerable: true,
  get: function () {
    return _types.FunctionsError;
  }
});
Object.defineProperty(exports, "FunctionsFetchError", {
  enumerable: true,
  get: function () {
    return _types.FunctionsFetchError;
  }
});
Object.defineProperty(exports, "FunctionsHttpError", {
  enumerable: true,
  get: function () {
    return _types.FunctionsHttpError;
  }
});
Object.defineProperty(exports, "FunctionsRelayError", {
  enumerable: true,
  get: function () {
    return _types.FunctionsRelayError;
  }
});
var _FunctionsClient = require("./FunctionsClient");
var _types = require("./types");
},{"./FunctionsClient":"../node_modules/@supabase/functions-js/dist/module/FunctionsClient.js","./types":"../node_modules/@supabase/functions-js/dist/module/types.js"}],"../node_modules/@supabase/postgrest-js/dist/module/PostgrestError.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
class PostgrestError extends Error {
  constructor(context) {
    super(context.message);
    this.name = 'PostgrestError';
    this.details = context.details;
    this.hint = context.hint;
    this.code = context.code;
  }
}
exports.default = PostgrestError;
},{}],"../node_modules/@supabase/postgrest-js/dist/module/PostgrestBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _nodeFetch = _interopRequireDefault(require("@supabase/node-fetch"));
var _PostgrestError = _interopRequireDefault(require("./PostgrestError"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-ignore

class PostgrestBuilder {
  constructor(builder) {
    this.shouldThrowOnError = false;
    this.method = builder.method;
    this.url = builder.url;
    this.headers = builder.headers;
    this.schema = builder.schema;
    this.body = builder.body;
    this.shouldThrowOnError = builder.shouldThrowOnError;
    this.signal = builder.signal;
    this.isMaybeSingle = builder.isMaybeSingle;
    if (builder.fetch) {
      this.fetch = builder.fetch;
    } else if (typeof fetch === 'undefined') {
      this.fetch = _nodeFetch.default;
    } else {
      this.fetch = fetch;
    }
  }
  /**
   * If there's an error with the query, throwOnError will reject the promise by
   * throwing the error instead of returning it as part of a successful response.
   *
   * {@link https://github.com/supabase/supabase-js/issues/92}
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  then(onfulfilled, onrejected) {
    // https://postgrest.org/en/stable/api.html#switching-schemas
    if (this.schema === undefined) {
      // skip
    } else if (['GET', 'HEAD'].includes(this.method)) {
      this.headers['Accept-Profile'] = this.schema;
    } else {
      this.headers['Content-Profile'] = this.schema;
    }
    if (this.method !== 'GET' && this.method !== 'HEAD') {
      this.headers['Content-Type'] = 'application/json';
    }
    // NOTE: Invoke w/o `this` to avoid illegal invocation error.
    // https://github.com/supabase/postgrest-js/pull/247
    const _fetch = this.fetch;
    let res = _fetch(this.url.toString(), {
      method: this.method,
      headers: this.headers,
      body: JSON.stringify(this.body),
      signal: this.signal
    }).then(async res => {
      var _a, _b, _c;
      let error = null;
      let data = null;
      let count = null;
      let status = res.status;
      let statusText = res.statusText;
      if (res.ok) {
        if (this.method !== 'HEAD') {
          const body = await res.text();
          if (body === '') {
            // Prefer: return=minimal
          } else if (this.headers['Accept'] === 'text/csv') {
            data = body;
          } else if (this.headers['Accept'] && this.headers['Accept'].includes('application/vnd.pgrst.plan+text')) {
            data = body;
          } else {
            data = JSON.parse(body);
          }
        }
        const countHeader = (_a = this.headers['Prefer']) === null || _a === void 0 ? void 0 : _a.match(/count=(exact|planned|estimated)/);
        const contentRange = (_b = res.headers.get('content-range')) === null || _b === void 0 ? void 0 : _b.split('/');
        if (countHeader && contentRange && contentRange.length > 1) {
          count = parseInt(contentRange[1]);
        }
        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361
        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`
        if (this.isMaybeSingle && this.method === 'GET' && Array.isArray(data)) {
          if (data.length > 1) {
            error = {
              // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
              code: 'PGRST116',
              details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
              hint: null,
              message: 'JSON object requested, multiple (or no) rows returned'
            };
            data = null;
            count = null;
            status = 406;
            statusText = 'Not Acceptable';
          } else if (data.length === 1) {
            data = data[0];
          } else {
            data = null;
          }
        }
      } else {
        const body = await res.text();
        try {
          error = JSON.parse(body);
          // Workaround for https://github.com/supabase/postgrest-js/issues/295
          if (Array.isArray(error) && res.status === 404) {
            data = [];
            error = null;
            status = 200;
            statusText = 'OK';
          }
        } catch (_d) {
          // Workaround for https://github.com/supabase/postgrest-js/issues/295
          if (res.status === 404 && body === '') {
            status = 204;
            statusText = 'No Content';
          } else {
            error = {
              message: body
            };
          }
        }
        if (error && this.isMaybeSingle && ((_c = error === null || error === void 0 ? void 0 : error.details) === null || _c === void 0 ? void 0 : _c.includes('0 rows'))) {
          error = null;
          status = 200;
          statusText = 'OK';
        }
        if (error && this.shouldThrowOnError) {
          throw new _PostgrestError.default(error);
        }
      }
      const postgrestResponse = {
        error,
        data,
        count,
        status,
        statusText
      };
      return postgrestResponse;
    });
    if (!this.shouldThrowOnError) {
      res = res.catch(fetchError => {
        var _a, _b, _c;
        return {
          error: {
            message: `${(_a = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _a !== void 0 ? _a : 'FetchError'}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
            details: `${(_b = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _b !== void 0 ? _b : ''}`,
            hint: '',
            code: `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) !== null && _c !== void 0 ? _c : ''}`
          },
          data: null,
          count: null,
          status: 0,
          statusText: ''
        };
      });
    }
    return res.then(onfulfilled, onrejected);
  }
}
exports.default = PostgrestBuilder;
},{"@supabase/node-fetch":"../node_modules/@supabase/node-fetch/browser.js","./PostgrestError":"../node_modules/@supabase/postgrest-js/dist/module/PostgrestError.js"}],"../node_modules/@supabase/postgrest-js/dist/module/PostgrestTransformBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _PostgrestBuilder = _interopRequireDefault(require("./PostgrestBuilder"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class PostgrestTransformBuilder extends _PostgrestBuilder.default {
  /**
   * Perform a SELECT on the query result.
   *
   * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
   * return modified rows. By calling this method, modified rows are returned in
   * `data`.
   *
   * @param columns - The columns to retrieve, separated by commas
   */
  select(columns) {
    // Remove whitespaces except when quoted
    let quoted = false;
    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(c => {
      if (/\s/.test(c) && !quoted) {
        return '';
      }
      if (c === '"') {
        quoted = !quoted;
      }
      return c;
    }).join('');
    this.url.searchParams.set('select', cleanedColumns);
    if (this.headers['Prefer']) {
      this.headers['Prefer'] += ',';
    }
    this.headers['Prefer'] += 'return=representation';
    return this;
  }
  /**
   * Order the query result by `column`.
   *
   * You can call this method multiple times to order by multiple columns.
   *
   * You can order referenced tables, but it only affects the ordering of the
   * parent table if you use `!inner` in the query.
   *
   * @param column - The column to order by
   * @param options - Named parameters
   * @param options.ascending - If `true`, the result will be in ascending order
   * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
   * `null`s appear last.
   * @param options.referencedTable - Set this to order a referenced table by
   * its columns
   * @param options.foreignTable - Deprecated, use `options.referencedTable`
   * instead
   */
  order(column, {
    ascending = true,
    nullsFirst,
    foreignTable,
    referencedTable = foreignTable
  } = {}) {
    const key = referencedTable ? `${referencedTable}.order` : 'order';
    const existingOrder = this.url.searchParams.get(key);
    this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'}`);
    return this;
  }
  /**
   * Limit the query result by `count`.
   *
   * @param count - The maximum number of rows to return
   * @param options - Named parameters
   * @param options.referencedTable - Set this to limit rows of referenced
   * tables instead of the parent table
   * @param options.foreignTable - Deprecated, use `options.referencedTable`
   * instead
   */
  limit(count, {
    foreignTable,
    referencedTable = foreignTable
  } = {}) {
    const key = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`;
    this.url.searchParams.set(key, `${count}`);
    return this;
  }
  /**
   * Limit the query result by starting at an offset (`from`) and ending at the offset (`from + to`).
   * Only records within this range are returned.
   * This respects the query order and if there is no order clause the range could behave unexpectedly.
   * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
   * and fourth rows of the query.
   *
   * @param from - The starting index from which to limit the result
   * @param to - The last index to which to limit the result
   * @param options - Named parameters
   * @param options.referencedTable - Set this to limit rows of referenced
   * tables instead of the parent table
   * @param options.foreignTable - Deprecated, use `options.referencedTable`
   * instead
   */
  range(from, to, {
    foreignTable,
    referencedTable = foreignTable
  } = {}) {
    const keyOffset = typeof referencedTable === 'undefined' ? 'offset' : `${referencedTable}.offset`;
    const keyLimit = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`;
    this.url.searchParams.set(keyOffset, `${from}`);
    // Range is inclusive, so add 1
    this.url.searchParams.set(keyLimit, `${to - from + 1}`);
    return this;
  }
  /**
   * Set the AbortSignal for the fetch request.
   *
   * @param signal - The AbortSignal to use for the fetch request
   */
  abortSignal(signal) {
    this.signal = signal;
    return this;
  }
  /**
   * Return `data` as a single object instead of an array of objects.
   *
   * Query result must be one row (e.g. using `.limit(1)`), otherwise this
   * returns an error.
   */
  single() {
    this.headers['Accept'] = 'application/vnd.pgrst.object+json';
    return this;
  }
  /**
   * Return `data` as a single object instead of an array of objects.
   *
   * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
   * this returns an error.
   */
  maybeSingle() {
    // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361
    // Issue persists e.g. for `.insert([...]).select().maybeSingle()`
    if (this.method === 'GET') {
      this.headers['Accept'] = 'application/json';
    } else {
      this.headers['Accept'] = 'application/vnd.pgrst.object+json';
    }
    this.isMaybeSingle = true;
    return this;
  }
  /**
   * Return `data` as a string in CSV format.
   */
  csv() {
    this.headers['Accept'] = 'text/csv';
    return this;
  }
  /**
   * Return `data` as an object in [GeoJSON](https://geojson.org) format.
   */
  geojson() {
    this.headers['Accept'] = 'application/geo+json';
    return this;
  }
  /**
   * Return `data` as the EXPLAIN plan for the query.
   *
   * You need to enable the
   * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
   * setting before using this method.
   *
   * @param options - Named parameters
   *
   * @param options.analyze - If `true`, the query will be executed and the
   * actual run time will be returned
   *
   * @param options.verbose - If `true`, the query identifier will be returned
   * and `data` will include the output columns of the query
   *
   * @param options.settings - If `true`, include information on configuration
   * parameters that affect query planning
   *
   * @param options.buffers - If `true`, include information on buffer usage
   *
   * @param options.wal - If `true`, include information on WAL record generation
   *
   * @param options.format - The format of the output, can be `"text"` (default)
   * or `"json"`
   */
  explain({
    analyze = false,
    verbose = false,
    settings = false,
    buffers = false,
    wal = false,
    format = 'text'
  } = {}) {
    var _a;
    const options = [analyze ? 'analyze' : null, verbose ? 'verbose' : null, settings ? 'settings' : null, buffers ? 'buffers' : null, wal ? 'wal' : null].filter(Boolean).join('|');
    // An Accept header can carry multiple media types but postgrest-js always sends one
    const forMediatype = (_a = this.headers['Accept']) !== null && _a !== void 0 ? _a : 'application/json';
    this.headers['Accept'] = `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`;
    if (format === 'json') return this;else return this;
  }
  /**
   * Rollback the query.
   *
   * `data` will still be returned, but the query is not committed.
   */
  rollback() {
    var _a;
    if (((_a = this.headers['Prefer']) !== null && _a !== void 0 ? _a : '').trim().length > 0) {
      this.headers['Prefer'] += ',tx=rollback';
    } else {
      this.headers['Prefer'] = 'tx=rollback';
    }
    return this;
  }
  /**
   * Override the type of the returned `data`.
   *
   * @typeParam NewResult - The new result type to override with
   */
  returns() {
    return this;
  }
}
exports.default = PostgrestTransformBuilder;
},{"./PostgrestBuilder":"../node_modules/@supabase/postgrest-js/dist/module/PostgrestBuilder.js"}],"../node_modules/@supabase/postgrest-js/dist/module/PostgrestFilterBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _PostgrestTransformBuilder = _interopRequireDefault(require("./PostgrestTransformBuilder"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class PostgrestFilterBuilder extends _PostgrestTransformBuilder.default {
  /**
   * Match only rows where `column` is equal to `value`.
   *
   * To check if the value of `column` is NULL, you should use `.is()` instead.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  eq(column, value) {
    this.url.searchParams.append(column, `eq.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is not equal to `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  neq(column, value) {
    this.url.searchParams.append(column, `neq.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is greater than `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  gt(column, value) {
    this.url.searchParams.append(column, `gt.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is greater than or equal to `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  gte(column, value) {
    this.url.searchParams.append(column, `gte.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is less than `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  lt(column, value) {
    this.url.searchParams.append(column, `lt.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is less than or equal to `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  lte(column, value) {
    this.url.searchParams.append(column, `lte.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` matches `pattern` case-sensitively.
   *
   * @param column - The column to filter on
   * @param pattern - The pattern to match with
   */
  like(column, pattern) {
    this.url.searchParams.append(column, `like.${pattern}`);
    return this;
  }
  /**
   * Match only rows where `column` matches all of `patterns` case-sensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  likeAllOf(column, patterns) {
    this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`);
    return this;
  }
  /**
   * Match only rows where `column` matches any of `patterns` case-sensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  likeAnyOf(column, patterns) {
    this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`);
    return this;
  }
  /**
   * Match only rows where `column` matches `pattern` case-insensitively.
   *
   * @param column - The column to filter on
   * @param pattern - The pattern to match with
   */
  ilike(column, pattern) {
    this.url.searchParams.append(column, `ilike.${pattern}`);
    return this;
  }
  /**
   * Match only rows where `column` matches all of `patterns` case-insensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  ilikeAllOf(column, patterns) {
    this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`);
    return this;
  }
  /**
   * Match only rows where `column` matches any of `patterns` case-insensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  ilikeAnyOf(column, patterns) {
    this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`);
    return this;
  }
  /**
   * Match only rows where `column` IS `value`.
   *
   * For non-boolean columns, this is only relevant for checking if the value of
   * `column` is NULL by setting `value` to `null`.
   *
   * For boolean columns, you can also set `value` to `true` or `false` and it
   * will behave the same way as `.eq()`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  is(column, value) {
    this.url.searchParams.append(column, `is.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is included in the `values` array.
   *
   * @param column - The column to filter on
   * @param values - The values array to filter with
   */
  in(column, values) {
    const cleanedValues = values.map(s => {
      // handle postgrest reserved characters
      // https://postgrest.org/en/v7.0.0/api.html#reserved-characters
      if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `"${s}"`;else return `${s}`;
    }).join(',');
    this.url.searchParams.append(column, `in.(${cleanedValues})`);
    return this;
  }
  /**
   * Only relevant for jsonb, array, and range columns. Match only rows where
   * `column` contains every element appearing in `value`.
   *
   * @param column - The jsonb, array, or range column to filter on
   * @param value - The jsonb, array, or range value to filter with
   */
  contains(column, value) {
    if (typeof value === 'string') {
      // range types can be inclusive '[', ']' or exclusive '(', ')' so just
      // keep it simple and accept a string
      this.url.searchParams.append(column, `cs.${value}`);
    } else if (Array.isArray(value)) {
      // array
      this.url.searchParams.append(column, `cs.{${value.join(',')}}`);
    } else {
      // json
      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
    }
    return this;
  }
  /**
   * Only relevant for jsonb, array, and range columns. Match only rows where
   * every element appearing in `column` is contained by `value`.
   *
   * @param column - The jsonb, array, or range column to filter on
   * @param value - The jsonb, array, or range value to filter with
   */
  containedBy(column, value) {
    if (typeof value === 'string') {
      // range
      this.url.searchParams.append(column, `cd.${value}`);
    } else if (Array.isArray(value)) {
      // array
      this.url.searchParams.append(column, `cd.{${value.join(',')}}`);
    } else {
      // json
      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
    }
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is greater than any element in `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeGt(column, range) {
    this.url.searchParams.append(column, `sr.${range}`);
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is either contained in `range` or greater than any element in
   * `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeGte(column, range) {
    this.url.searchParams.append(column, `nxl.${range}`);
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is less than any element in `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeLt(column, range) {
    this.url.searchParams.append(column, `sl.${range}`);
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is either contained in `range` or less than any element in
   * `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeLte(column, range) {
    this.url.searchParams.append(column, `nxr.${range}`);
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where `column` is
   * mutually exclusive to `range` and there can be no element between the two
   * ranges.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeAdjacent(column, range) {
    this.url.searchParams.append(column, `adj.${range}`);
    return this;
  }
  /**
   * Only relevant for array and range columns. Match only rows where
   * `column` and `value` have an element in common.
   *
   * @param column - The array or range column to filter on
   * @param value - The array or range value to filter with
   */
  overlaps(column, value) {
    if (typeof value === 'string') {
      // range
      this.url.searchParams.append(column, `ov.${value}`);
    } else {
      // array
      this.url.searchParams.append(column, `ov.{${value.join(',')}}`);
    }
    return this;
  }
  /**
   * Only relevant for text and tsvector columns. Match only rows where
   * `column` matches the query string in `query`.
   *
   * @param column - The text or tsvector column to filter on
   * @param query - The query text to match with
   * @param options - Named parameters
   * @param options.config - The text search configuration to use
   * @param options.type - Change how the `query` text is interpreted
   */
  textSearch(column, query, {
    config,
    type
  } = {}) {
    let typePart = '';
    if (type === 'plain') {
      typePart = 'pl';
    } else if (type === 'phrase') {
      typePart = 'ph';
    } else if (type === 'websearch') {
      typePart = 'w';
    }
    const configPart = config === undefined ? '' : `(${config})`;
    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);
    return this;
  }
  /**
   * Match only rows where each column in `query` keys is equal to its
   * associated value. Shorthand for multiple `.eq()`s.
   *
   * @param query - The object to filter with, with column names as keys mapped
   * to their filter values
   */
  match(query) {
    Object.entries(query).forEach(([column, value]) => {
      this.url.searchParams.append(column, `eq.${value}`);
    });
    return this;
  }
  /**
   * Match only rows which doesn't satisfy the filter.
   *
   * Unlike most filters, `opearator` and `value` are used as-is and need to
   * follow [PostgREST
   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
   * to make sure they are properly sanitized.
   *
   * @param column - The column to filter on
   * @param operator - The operator to be negated to filter with, following
   * PostgREST syntax
   * @param value - The value to filter with, following PostgREST syntax
   */
  not(column, operator, value) {
    this.url.searchParams.append(column, `not.${operator}.${value}`);
    return this;
  }
  /**
   * Match only rows which satisfy at least one of the filters.
   *
   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
   * to make sure it's properly sanitized.
   *
   * It's currently not possible to do an `.or()` filter across multiple tables.
   *
   * @param filters - The filters to use, following PostgREST syntax
   * @param options - Named parameters
   * @param options.referencedTable - Set this to filter on referenced tables
   * instead of the parent table
   * @param options.foreignTable - Deprecated, use `referencedTable` instead
   */
  or(filters, {
    foreignTable,
    referencedTable = foreignTable
  } = {}) {
    const key = referencedTable ? `${referencedTable}.or` : 'or';
    this.url.searchParams.append(key, `(${filters})`);
    return this;
  }
  /**
   * Match only rows which satisfy the filter. This is an escape hatch - you
   * should use the specific filter methods wherever possible.
   *
   * Unlike most filters, `opearator` and `value` are used as-is and need to
   * follow [PostgREST
   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
   * to make sure they are properly sanitized.
   *
   * @param column - The column to filter on
   * @param operator - The operator to filter with, following PostgREST syntax
   * @param value - The value to filter with, following PostgREST syntax
   */
  filter(column, operator, value) {
    this.url.searchParams.append(column, `${operator}.${value}`);
    return this;
  }
}
exports.default = PostgrestFilterBuilder;
},{"./PostgrestTransformBuilder":"../node_modules/@supabase/postgrest-js/dist/module/PostgrestTransformBuilder.js"}],"../node_modules/@supabase/postgrest-js/dist/module/PostgrestQueryBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _PostgrestFilterBuilder = _interopRequireDefault(require("./PostgrestFilterBuilder"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class PostgrestQueryBuilder {
  constructor(url, {
    headers = {},
    schema,
    fetch
  }) {
    this.url = url;
    this.headers = headers;
    this.schema = schema;
    this.fetch = fetch;
  }
  /**
   * Perform a SELECT query on the table or view.
   *
   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
   *
   * @param options - Named parameters
   *
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   *
   * @param options.count - Count algorithm to use to count rows in the table or view.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  select(columns, {
    head = false,
    count
  } = {}) {
    const method = head ? 'HEAD' : 'GET';
    // Remove whitespaces except when quoted
    let quoted = false;
    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(c => {
      if (/\s/.test(c) && !quoted) {
        return '';
      }
      if (c === '"') {
        quoted = !quoted;
      }
      return c;
    }).join('');
    this.url.searchParams.set('select', cleanedColumns);
    if (count) {
      this.headers['Prefer'] = `count=${count}`;
    }
    return new _PostgrestFilterBuilder.default({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
  /**
   * Perform an INSERT into the table or view.
   *
   * By default, inserted rows are not returned. To return it, chain the call
   * with `.select()`.
   *
   * @param values - The values to insert. Pass an object to insert a single row
   * or an array to insert multiple rows.
   *
   * @param options - Named parameters
   *
   * @param options.count - Count algorithm to use to count inserted rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   *
   * @param options.defaultToNull - Make missing fields default to `null`.
   * Otherwise, use the default value for the column. Only applies for bulk
   * inserts.
   */
  insert(values, {
    count,
    defaultToNull = true
  } = {}) {
    const method = 'POST';
    const prefersHeaders = [];
    if (this.headers['Prefer']) {
      prefersHeaders.push(this.headers['Prefer']);
    }
    if (count) {
      prefersHeaders.push(`count=${count}`);
    }
    if (!defaultToNull) {
      prefersHeaders.push('missing=default');
    }
    this.headers['Prefer'] = prefersHeaders.join(',');
    if (Array.isArray(values)) {
      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
      if (columns.length > 0) {
        const uniqueColumns = [...new Set(columns)].map(column => `"${column}"`);
        this.url.searchParams.set('columns', uniqueColumns.join(','));
      }
    }
    return new _PostgrestFilterBuilder.default({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: values,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
  /**
   * Perform an UPSERT on the table or view. Depending on the column(s) passed
   * to `onConflict`, `.upsert()` allows you to perform the equivalent of
   * `.insert()` if a row with the corresponding `onConflict` columns doesn't
   * exist, or if it does exist, perform an alternative action depending on
   * `ignoreDuplicates`.
   *
   * By default, upserted rows are not returned. To return it, chain the call
   * with `.select()`.
   *
   * @param values - The values to upsert with. Pass an object to upsert a
   * single row or an array to upsert multiple rows.
   *
   * @param options - Named parameters
   *
   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
   * duplicate rows are determined. Two rows are duplicates if all the
   * `onConflict` columns are equal.
   *
   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
   * `false`, duplicate rows are merged with existing rows.
   *
   * @param options.count - Count algorithm to use to count upserted rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   *
   * @param options.defaultToNull - Make missing fields default to `null`.
   * Otherwise, use the default value for the column. This only applies when
   * inserting new rows, not when merging with existing rows under
   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
   */
  upsert(values, {
    onConflict,
    ignoreDuplicates = false,
    count,
    defaultToNull = true
  } = {}) {
    const method = 'POST';
    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`];
    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);
    if (this.headers['Prefer']) {
      prefersHeaders.push(this.headers['Prefer']);
    }
    if (count) {
      prefersHeaders.push(`count=${count}`);
    }
    if (!defaultToNull) {
      prefersHeaders.push('missing=default');
    }
    this.headers['Prefer'] = prefersHeaders.join(',');
    if (Array.isArray(values)) {
      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
      if (columns.length > 0) {
        const uniqueColumns = [...new Set(columns)].map(column => `"${column}"`);
        this.url.searchParams.set('columns', uniqueColumns.join(','));
      }
    }
    return new _PostgrestFilterBuilder.default({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: values,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
  /**
   * Perform an UPDATE on the table or view.
   *
   * By default, updated rows are not returned. To return it, chain the call
   * with `.select()` after filters.
   *
   * @param values - The values to update with
   *
   * @param options - Named parameters
   *
   * @param options.count - Count algorithm to use to count updated rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  update(values, {
    count
  } = {}) {
    const method = 'PATCH';
    const prefersHeaders = [];
    if (this.headers['Prefer']) {
      prefersHeaders.push(this.headers['Prefer']);
    }
    if (count) {
      prefersHeaders.push(`count=${count}`);
    }
    this.headers['Prefer'] = prefersHeaders.join(',');
    return new _PostgrestFilterBuilder.default({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: values,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
  /**
   * Perform a DELETE on the table or view.
   *
   * By default, deleted rows are not returned. To return it, chain the call
   * with `.select()` after filters.
   *
   * @param options - Named parameters
   *
   * @param options.count - Count algorithm to use to count deleted rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  delete({
    count
  } = {}) {
    const method = 'DELETE';
    const prefersHeaders = [];
    if (count) {
      prefersHeaders.push(`count=${count}`);
    }
    if (this.headers['Prefer']) {
      prefersHeaders.unshift(this.headers['Prefer']);
    }
    this.headers['Prefer'] = prefersHeaders.join(',');
    return new _PostgrestFilterBuilder.default({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
}
exports.default = PostgrestQueryBuilder;
},{"./PostgrestFilterBuilder":"../node_modules/@supabase/postgrest-js/dist/module/PostgrestFilterBuilder.js"}],"../node_modules/@supabase/postgrest-js/dist/module/version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
const version = exports.version = '1.9.2';
},{}],"../node_modules/@supabase/postgrest-js/dist/module/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_HEADERS = void 0;
var _version = require("./version");
const DEFAULT_HEADERS = exports.DEFAULT_HEADERS = {
  'X-Client-Info': `postgrest-js/${_version.version}`
};
},{"./version":"../node_modules/@supabase/postgrest-js/dist/module/version.js"}],"../node_modules/@supabase/postgrest-js/dist/module/PostgrestClient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _PostgrestQueryBuilder = _interopRequireDefault(require("./PostgrestQueryBuilder"));
var _PostgrestFilterBuilder = _interopRequireDefault(require("./PostgrestFilterBuilder"));
var _constants = require("./constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * PostgREST client.
 *
 * @typeParam Database - Types for the schema from the [type
 * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)
 *
 * @typeParam SchemaName - Postgres schema to switch to. Must be a string
 * literal, the same one passed to the constructor. If the schema is not
 * `"public"`, this must be supplied manually.
 */
class PostgrestClient {
  // TODO: Add back shouldThrowOnError once we figure out the typings
  /**
   * Creates a PostgREST client.
   *
   * @param url - URL of the PostgREST endpoint
   * @param options - Named parameters
   * @param options.headers - Custom headers
   * @param options.schema - Postgres schema to switch to
   * @param options.fetch - Custom fetch
   */
  constructor(url, {
    headers = {},
    schema,
    fetch
  } = {}) {
    this.url = url;
    this.headers = Object.assign(Object.assign({}, _constants.DEFAULT_HEADERS), headers);
    this.schemaName = schema;
    this.fetch = fetch;
  }
  /**
   * Perform a query on a table or a view.
   *
   * @param relation - The table or view name to query
   */
  from(relation) {
    const url = new URL(`${this.url}/${relation}`);
    return new _PostgrestQueryBuilder.default(url, {
      headers: Object.assign({}, this.headers),
      schema: this.schemaName,
      fetch: this.fetch
    });
  }
  /**
   * Select a schema to query or perform an function (rpc) call.
   *
   * The schema needs to be on the list of exposed schemas inside Supabase.
   *
   * @param schema - The schema to query
   */
  schema(schema) {
    return new PostgrestClient(this.url, {
      headers: this.headers,
      schema,
      fetch: this.fetch
    });
  }
  /**
   * Perform a function call.
   *
   * @param fn - The function name to call
   * @param args - The arguments to pass to the function call
   * @param options - Named parameters
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   * @param options.count - Count algorithm to use to count rows returned by the
   * function. Only applicable for [set-returning
   * functions](https://www.postgresql.org/docs/current/functions-srf.html).
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  rpc(fn, args = {}, {
    head = false,
    count
  } = {}) {
    let method;
    const url = new URL(`${this.url}/rpc/${fn}`);
    let body;
    if (head) {
      method = 'HEAD';
      Object.entries(args).forEach(([name, value]) => {
        url.searchParams.append(name, `${value}`);
      });
    } else {
      method = 'POST';
      body = args;
    }
    const headers = Object.assign({}, this.headers);
    if (count) {
      headers['Prefer'] = `count=${count}`;
    }
    return new _PostgrestFilterBuilder.default({
      method,
      url,
      headers,
      schema: this.schemaName,
      body,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
}
exports.default = PostgrestClient;
},{"./PostgrestQueryBuilder":"../node_modules/@supabase/postgrest-js/dist/module/PostgrestQueryBuilder.js","./PostgrestFilterBuilder":"../node_modules/@supabase/postgrest-js/dist/module/PostgrestFilterBuilder.js","./constants":"../node_modules/@supabase/postgrest-js/dist/module/constants.js"}],"../node_modules/@supabase/postgrest-js/dist/module/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "PostgrestBuilder", {
  enumerable: true,
  get: function () {
    return _PostgrestBuilder.default;
  }
});
Object.defineProperty(exports, "PostgrestClient", {
  enumerable: true,
  get: function () {
    return _PostgrestClient.default;
  }
});
Object.defineProperty(exports, "PostgrestFilterBuilder", {
  enumerable: true,
  get: function () {
    return _PostgrestFilterBuilder.default;
  }
});
Object.defineProperty(exports, "PostgrestQueryBuilder", {
  enumerable: true,
  get: function () {
    return _PostgrestQueryBuilder.default;
  }
});
Object.defineProperty(exports, "PostgrestTransformBuilder", {
  enumerable: true,
  get: function () {
    return _PostgrestTransformBuilder.default;
  }
});
var _PostgrestClient = _interopRequireDefault(require("./PostgrestClient"));
var _PostgrestQueryBuilder = _interopRequireDefault(require("./PostgrestQueryBuilder"));
var _PostgrestFilterBuilder = _interopRequireDefault(require("./PostgrestFilterBuilder"));
var _PostgrestTransformBuilder = _interopRequireDefault(require("./PostgrestTransformBuilder"));
var _PostgrestBuilder = _interopRequireDefault(require("./PostgrestBuilder"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./PostgrestClient":"../node_modules/@supabase/postgrest-js/dist/module/PostgrestClient.js","./PostgrestQueryBuilder":"../node_modules/@supabase/postgrest-js/dist/module/PostgrestQueryBuilder.js","./PostgrestFilterBuilder":"../node_modules/@supabase/postgrest-js/dist/module/PostgrestFilterBuilder.js","./PostgrestTransformBuilder":"../node_modules/@supabase/postgrest-js/dist/module/PostgrestTransformBuilder.js","./PostgrestBuilder":"../node_modules/@supabase/postgrest-js/dist/module/PostgrestBuilder.js"}],"../node_modules/@supabase/realtime-js/dist/module/lib/version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
const version = exports.version = '2.9.3';
},{}],"../node_modules/@supabase/realtime-js/dist/module/lib/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WS_CLOSE_NORMAL = exports.VSN = exports.TRANSPORTS = exports.SOCKET_STATES = exports.DEFAULT_TIMEOUT = exports.DEFAULT_HEADERS = exports.CONNECTION_STATE = exports.CHANNEL_STATES = exports.CHANNEL_EVENTS = void 0;
var _version = require("./version");
const DEFAULT_HEADERS = exports.DEFAULT_HEADERS = {
  'X-Client-Info': `realtime-js/${_version.version}`
};
const VSN = exports.VSN = '1.0.0';
const DEFAULT_TIMEOUT = exports.DEFAULT_TIMEOUT = 10000;
const WS_CLOSE_NORMAL = exports.WS_CLOSE_NORMAL = 1000;
var SOCKET_STATES;
(function (SOCKET_STATES) {
  SOCKET_STATES[SOCKET_STATES["connecting"] = 0] = "connecting";
  SOCKET_STATES[SOCKET_STATES["open"] = 1] = "open";
  SOCKET_STATES[SOCKET_STATES["closing"] = 2] = "closing";
  SOCKET_STATES[SOCKET_STATES["closed"] = 3] = "closed";
})(SOCKET_STATES || (exports.SOCKET_STATES = SOCKET_STATES = {}));
var CHANNEL_STATES;
(function (CHANNEL_STATES) {
  CHANNEL_STATES["closed"] = "closed";
  CHANNEL_STATES["errored"] = "errored";
  CHANNEL_STATES["joined"] = "joined";
  CHANNEL_STATES["joining"] = "joining";
  CHANNEL_STATES["leaving"] = "leaving";
})(CHANNEL_STATES || (exports.CHANNEL_STATES = CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function (CHANNEL_EVENTS) {
  CHANNEL_EVENTS["close"] = "phx_close";
  CHANNEL_EVENTS["error"] = "phx_error";
  CHANNEL_EVENTS["join"] = "phx_join";
  CHANNEL_EVENTS["reply"] = "phx_reply";
  CHANNEL_EVENTS["leave"] = "phx_leave";
  CHANNEL_EVENTS["access_token"] = "access_token";
})(CHANNEL_EVENTS || (exports.CHANNEL_EVENTS = CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function (TRANSPORTS) {
  TRANSPORTS["websocket"] = "websocket";
})(TRANSPORTS || (exports.TRANSPORTS = TRANSPORTS = {}));
var CONNECTION_STATE;
(function (CONNECTION_STATE) {
  CONNECTION_STATE["Connecting"] = "connecting";
  CONNECTION_STATE["Open"] = "open";
  CONNECTION_STATE["Closing"] = "closing";
  CONNECTION_STATE["Closed"] = "closed";
})(CONNECTION_STATE || (exports.CONNECTION_STATE = CONNECTION_STATE = {}));
},{"./version":"../node_modules/@supabase/realtime-js/dist/module/lib/version.js"}],"../node_modules/@supabase/realtime-js/dist/module/lib/timer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.
 *
 * @example
 *    let reconnectTimer = new Timer(() => this.connect(), function(tries){
 *      return [1000, 5000, 10000][tries - 1] || 10000
 *    })
 *    reconnectTimer.scheduleTimeout() // fires after 1000
 *    reconnectTimer.scheduleTimeout() // fires after 5000
 *    reconnectTimer.reset()
 *    reconnectTimer.scheduleTimeout() // fires after 1000
 */
class Timer {
  constructor(callback, timerCalc) {
    this.callback = callback;
    this.timerCalc = timerCalc;
    this.timer = undefined;
    this.tries = 0;
    this.callback = callback;
    this.timerCalc = timerCalc;
  }
  reset() {
    this.tries = 0;
    clearTimeout(this.timer);
  }
  // Cancels any previous scheduleTimeout and schedules callback
  scheduleTimeout() {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this.tries = this.tries + 1;
      this.callback();
    }, this.timerCalc(this.tries + 1));
  }
}
exports.default = Timer;
},{}],"../node_modules/@supabase/realtime-js/dist/module/lib/serializer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe
// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md
class Serializer {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(rawPayload, callback) {
    if (rawPayload.constructor === ArrayBuffer) {
      return callback(this._binaryDecode(rawPayload));
    }
    if (typeof rawPayload === 'string') {
      return callback(JSON.parse(rawPayload));
    }
    return callback({});
  }
  _binaryDecode(buffer) {
    const view = new DataView(buffer);
    const decoder = new TextDecoder();
    return this._decodeBroadcast(buffer, view, decoder);
  }
  _decodeBroadcast(buffer, view, decoder) {
    const topicSize = view.getUint8(1);
    const eventSize = view.getUint8(2);
    let offset = this.HEADER_LENGTH + 2;
    const topic = decoder.decode(buffer.slice(offset, offset + topicSize));
    offset = offset + topicSize;
    const event = decoder.decode(buffer.slice(offset, offset + eventSize));
    offset = offset + eventSize;
    const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));
    return {
      ref: null,
      topic: topic,
      event: event,
      payload: data
    };
  }
}
exports.default = Serializer;
},{}],"../node_modules/@supabase/realtime-js/dist/module/lib/push.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _constants = require("../lib/constants");
class Push {
  /**
   * Initializes the Push
   *
   * @param channel The Channel
   * @param event The event, for example `"phx_join"`
   * @param payload The payload, for example `{user_id: 123}`
   * @param timeout The push timeout in milliseconds
   */
  constructor(channel, event, payload = {}, timeout = _constants.DEFAULT_TIMEOUT) {
    this.channel = channel;
    this.event = event;
    this.payload = payload;
    this.timeout = timeout;
    this.sent = false;
    this.timeoutTimer = undefined;
    this.ref = '';
    this.receivedResp = null;
    this.recHooks = [];
    this.refEvent = null;
  }
  resend(timeout) {
    this.timeout = timeout;
    this._cancelRefEvent();
    this.ref = '';
    this.refEvent = null;
    this.receivedResp = null;
    this.sent = false;
    this.send();
  }
  send() {
    if (this._hasReceived('timeout')) {
      return;
    }
    this.startTimeout();
    this.sent = true;
    this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload,
      ref: this.ref,
      join_ref: this.channel._joinRef()
    });
  }
  updatePayload(payload) {
    this.payload = Object.assign(Object.assign({}, this.payload), payload);
  }
  receive(status, callback) {
    var _a;
    if (this._hasReceived(status)) {
      callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);
    }
    this.recHooks.push({
      status,
      callback
    });
    return this;
  }
  startTimeout() {
    if (this.timeoutTimer) {
      return;
    }
    this.ref = this.channel.socket._makeRef();
    this.refEvent = this.channel._replyEventName(this.ref);
    const callback = payload => {
      this._cancelRefEvent();
      this._cancelTimeout();
      this.receivedResp = payload;
      this._matchReceive(payload);
    };
    this.channel._on(this.refEvent, {}, callback);
    this.timeoutTimer = setTimeout(() => {
      this.trigger('timeout', {});
    }, this.timeout);
  }
  trigger(status, response) {
    if (this.refEvent) this.channel._trigger(this.refEvent, {
      status,
      response
    });
  }
  destroy() {
    this._cancelRefEvent();
    this._cancelTimeout();
  }
  _cancelRefEvent() {
    if (!this.refEvent) {
      return;
    }
    this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = undefined;
  }
  _matchReceive({
    status,
    response
  }) {
    this.recHooks.filter(h => h.status === status).forEach(h => h.callback(response));
  }
  _hasReceived(status) {
    return this.receivedResp && this.receivedResp.status === status;
  }
}
exports.default = Push;
},{"../lib/constants":"../node_modules/@supabase/realtime-js/dist/module/lib/constants.js"}],"../node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.REALTIME_PRESENCE_LISTEN_EVENTS = void 0;
/*
  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js
  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md
*/
var REALTIME_PRESENCE_LISTEN_EVENTS;
(function (REALTIME_PRESENCE_LISTEN_EVENTS) {
  REALTIME_PRESENCE_LISTEN_EVENTS["SYNC"] = "sync";
  REALTIME_PRESENCE_LISTEN_EVENTS["JOIN"] = "join";
  REALTIME_PRESENCE_LISTEN_EVENTS["LEAVE"] = "leave";
})(REALTIME_PRESENCE_LISTEN_EVENTS || (exports.REALTIME_PRESENCE_LISTEN_EVENTS = REALTIME_PRESENCE_LISTEN_EVENTS = {}));
class RealtimePresence {
  /**
   * Initializes the Presence.
   *
   * @param channel - The RealtimeChannel
   * @param opts - The options,
   *        for example `{events: {state: 'state', diff: 'diff'}}`
   */
  constructor(channel, opts) {
    this.channel = channel;
    this.state = {};
    this.pendingDiffs = [];
    this.joinRef = null;
    this.caller = {
      onJoin: () => {},
      onLeave: () => {},
      onSync: () => {}
    };
    const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
      state: 'presence_state',
      diff: 'presence_diff'
    };
    this.channel._on(events.state, {}, newState => {
      const {
        onJoin,
        onLeave,
        onSync
      } = this.caller;
      this.joinRef = this.channel._joinRef();
      this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
      this.pendingDiffs.forEach(diff => {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
      });
      this.pendingDiffs = [];
      onSync();
    });
    this.channel._on(events.diff, {}, diff => {
      const {
        onJoin,
        onLeave,
        onSync
      } = this.caller;
      if (this.inPendingSyncState()) {
        this.pendingDiffs.push(diff);
      } else {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
        onSync();
      }
    });
    this.onJoin((key, currentPresences, newPresences) => {
      this.channel._trigger('presence', {
        event: 'join',
        key,
        currentPresences,
        newPresences
      });
    });
    this.onLeave((key, currentPresences, leftPresences) => {
      this.channel._trigger('presence', {
        event: 'leave',
        key,
        currentPresences,
        leftPresences
      });
    });
    this.onSync(() => {
      this.channel._trigger('presence', {
        event: 'sync'
      });
    });
  }
  /**
   * Used to sync the list of presences on the server with the
   * client's state.
   *
   * An optional `onJoin` and `onLeave` callback can be provided to
   * react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @internal
   */
  static syncState(currentState, newState, onJoin, onLeave) {
    const state = this.cloneDeep(currentState);
    const transformedState = this.transformState(newState);
    const joins = {};
    const leaves = {};
    this.map(state, (key, presences) => {
      if (!transformedState[key]) {
        leaves[key] = presences;
      }
    });
    this.map(transformedState, (key, newPresences) => {
      const currentPresences = state[key];
      if (currentPresences) {
        const newPresenceRefs = newPresences.map(m => m.presence_ref);
        const curPresenceRefs = currentPresences.map(m => m.presence_ref);
        const joinedPresences = newPresences.filter(m => curPresenceRefs.indexOf(m.presence_ref) < 0);
        const leftPresences = currentPresences.filter(m => newPresenceRefs.indexOf(m.presence_ref) < 0);
        if (joinedPresences.length > 0) {
          joins[key] = joinedPresences;
        }
        if (leftPresences.length > 0) {
          leaves[key] = leftPresences;
        }
      } else {
        joins[key] = newPresences;
      }
    });
    return this.syncDiff(state, {
      joins,
      leaves
    }, onJoin, onLeave);
  }
  /**
   * Used to sync a diff of presence join and leave events from the
   * server, as they happen.
   *
   * Like `syncState`, `syncDiff` accepts optional `onJoin` and
   * `onLeave` callbacks to react to a user joining or leaving from a
   * device.
   *
   * @internal
   */
  static syncDiff(state, diff, onJoin, onLeave) {
    const {
      joins,
      leaves
    } = {
      joins: this.transformState(diff.joins),
      leaves: this.transformState(diff.leaves)
    };
    if (!onJoin) {
      onJoin = () => {};
    }
    if (!onLeave) {
      onLeave = () => {};
    }
    this.map(joins, (key, newPresences) => {
      var _a;
      const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];
      state[key] = this.cloneDeep(newPresences);
      if (currentPresences.length > 0) {
        const joinedPresenceRefs = state[key].map(m => m.presence_ref);
        const curPresences = currentPresences.filter(m => joinedPresenceRefs.indexOf(m.presence_ref) < 0);
        state[key].unshift(...curPresences);
      }
      onJoin(key, currentPresences, newPresences);
    });
    this.map(leaves, (key, leftPresences) => {
      let currentPresences = state[key];
      if (!currentPresences) return;
      const presenceRefsToRemove = leftPresences.map(m => m.presence_ref);
      currentPresences = currentPresences.filter(m => presenceRefsToRemove.indexOf(m.presence_ref) < 0);
      state[key] = currentPresences;
      onLeave(key, currentPresences, leftPresences);
      if (currentPresences.length === 0) delete state[key];
    });
    return state;
  }
  /** @internal */
  static map(obj, func) {
    return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]));
  }
  /**
   * Remove 'metas' key
   * Change 'phx_ref' to 'presence_ref'
   * Remove 'phx_ref' and 'phx_ref_prev'
   *
   * @example
   * // returns {
   *  abc123: [
   *    { presence_ref: '2', user_id: 1 },
   *    { presence_ref: '3', user_id: 2 }
   *  ]
   * }
   * RealtimePresence.transformState({
   *  abc123: {
   *    metas: [
   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
   *      { phx_ref: '3', user_id: 2 }
   *    ]
   *  }
   * })
   *
   * @internal
   */
  static transformState(state) {
    state = this.cloneDeep(state);
    return Object.getOwnPropertyNames(state).reduce((newState, key) => {
      const presences = state[key];
      if ('metas' in presences) {
        newState[key] = presences.metas.map(presence => {
          presence['presence_ref'] = presence['phx_ref'];
          delete presence['phx_ref'];
          delete presence['phx_ref_prev'];
          return presence;
        });
      } else {
        newState[key] = presences;
      }
      return newState;
    }, {});
  }
  /** @internal */
  static cloneDeep(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  /** @internal */
  onJoin(callback) {
    this.caller.onJoin = callback;
  }
  /** @internal */
  onLeave(callback) {
    this.caller.onLeave = callback;
  }
  /** @internal */
  onSync(callback) {
    this.caller.onSync = callback;
  }
  /** @internal */
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
}
exports.default = RealtimePresence;
},{}],"../node_modules/@supabase/realtime-js/dist/module/lib/transformers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toTimestampString = exports.toNumber = exports.toJson = exports.toBoolean = exports.toArray = exports.convertColumn = exports.convertChangeData = exports.convertCell = exports.PostgresTypes = void 0;
/**
 * Helpers to convert the change Payload into native JS types.
 */
// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under
// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE
var PostgresTypes;
(function (PostgresTypes) {
  PostgresTypes["abstime"] = "abstime";
  PostgresTypes["bool"] = "bool";
  PostgresTypes["date"] = "date";
  PostgresTypes["daterange"] = "daterange";
  PostgresTypes["float4"] = "float4";
  PostgresTypes["float8"] = "float8";
  PostgresTypes["int2"] = "int2";
  PostgresTypes["int4"] = "int4";
  PostgresTypes["int4range"] = "int4range";
  PostgresTypes["int8"] = "int8";
  PostgresTypes["int8range"] = "int8range";
  PostgresTypes["json"] = "json";
  PostgresTypes["jsonb"] = "jsonb";
  PostgresTypes["money"] = "money";
  PostgresTypes["numeric"] = "numeric";
  PostgresTypes["oid"] = "oid";
  PostgresTypes["reltime"] = "reltime";
  PostgresTypes["text"] = "text";
  PostgresTypes["time"] = "time";
  PostgresTypes["timestamp"] = "timestamp";
  PostgresTypes["timestamptz"] = "timestamptz";
  PostgresTypes["timetz"] = "timetz";
  PostgresTypes["tsrange"] = "tsrange";
  PostgresTypes["tstzrange"] = "tstzrange";
})(PostgresTypes || (exports.PostgresTypes = PostgresTypes = {}));
/**
 * Takes an array of columns and an object of string values then converts each string value
 * to its mapped type.
 *
 * @param {{name: String, type: String}[]} columns
 * @param {Object} record
 * @param {Object} options The map of various options that can be applied to the mapper
 * @param {Array} options.skipTypes The array of types that should not be converted
 *
 * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})
 * //=>{ first_name: 'Paul', age: 33 }
 */
const convertChangeData = (columns, record, options = {}) => {
  var _a;
  const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];
  return Object.keys(record).reduce((acc, rec_key) => {
    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
    return acc;
  }, {});
};
/**
 * Converts the value of an individual column.
 *
 * @param {String} columnName The column that you want to convert
 * @param {{name: String, type: String}[]} columns All of the columns
 * @param {Object} record The map of string values
 * @param {Array} skipTypes An array of types that should not be converted
 * @return {object} Useless information
 *
 * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])
 * //=> 33
 * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])
 * //=> "33"
 */
exports.convertChangeData = convertChangeData;
const convertColumn = (columnName, columns, record, skipTypes) => {
  const column = columns.find(x => x.name === columnName);
  const colType = column === null || column === void 0 ? void 0 : column.type;
  const value = record[columnName];
  if (colType && !skipTypes.includes(colType)) {
    return convertCell(colType, value);
  }
  return noop(value);
};
/**
 * If the value of the cell is `null`, returns null.
 * Otherwise converts the string value to the correct type.
 * @param {String} type A postgres column type
 * @param {String} value The cell value
 *
 * @example convertCell('bool', 't')
 * //=> true
 * @example convertCell('int8', '10')
 * //=> 10
 * @example convertCell('_int4', '{1,2,3,4}')
 * //=> [1,2,3,4]
 */
exports.convertColumn = convertColumn;
const convertCell = (type, value) => {
  // if data type is an array
  if (type.charAt(0) === '_') {
    const dataType = type.slice(1, type.length);
    return toArray(value, dataType);
  }
  // If not null, convert to correct type.
  switch (type) {
    case PostgresTypes.bool:
      return toBoolean(value);
    case PostgresTypes.float4:
    case PostgresTypes.float8:
    case PostgresTypes.int2:
    case PostgresTypes.int4:
    case PostgresTypes.int8:
    case PostgresTypes.numeric:
    case PostgresTypes.oid:
      return toNumber(value);
    case PostgresTypes.json:
    case PostgresTypes.jsonb:
      return toJson(value);
    case PostgresTypes.timestamp:
      return toTimestampString(value);
    // Format to be consistent with PostgREST
    case PostgresTypes.abstime: // To allow users to cast it based on Timezone
    case PostgresTypes.date: // To allow users to cast it based on Timezone
    case PostgresTypes.daterange:
    case PostgresTypes.int4range:
    case PostgresTypes.int8range:
    case PostgresTypes.money:
    case PostgresTypes.reltime: // To allow users to cast it based on Timezone
    case PostgresTypes.text:
    case PostgresTypes.time: // To allow users to cast it based on Timezone
    case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone
    case PostgresTypes.timetz: // To allow users to cast it based on Timezone
    case PostgresTypes.tsrange:
    case PostgresTypes.tstzrange:
      return noop(value);
    default:
      // Return the value for remaining types
      return noop(value);
  }
};
exports.convertCell = convertCell;
const noop = value => {
  return value;
};
const toBoolean = value => {
  switch (value) {
    case 't':
      return true;
    case 'f':
      return false;
    default:
      return value;
  }
};
exports.toBoolean = toBoolean;
const toNumber = value => {
  if (typeof value === 'string') {
    const parsedValue = parseFloat(value);
    if (!Number.isNaN(parsedValue)) {
      return parsedValue;
    }
  }
  return value;
};
exports.toNumber = toNumber;
const toJson = value => {
  if (typeof value === 'string') {
    try {
      return JSON.parse(value);
    } catch (error) {
      console.log(`JSON parse error: ${error}`);
      return value;
    }
  }
  return value;
};
/**
 * Converts a Postgres Array into a native JS array
 *
 * @example toArray('{}', 'int4')
 * //=> []
 * @example toArray('{"[2021-01-01,2021-12-31)","(2021-01-01,2021-12-32]"}', 'daterange')
 * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']
 * @example toArray([1,2,3,4], 'int4')
 * //=> [1,2,3,4]
 */
exports.toJson = toJson;
const toArray = (value, type) => {
  if (typeof value !== 'string') {
    return value;
  }
  const lastIdx = value.length - 1;
  const closeBrace = value[lastIdx];
  const openBrace = value[0];
  // Confirm value is a Postgres array by checking curly brackets
  if (openBrace === '{' && closeBrace === '}') {
    let arr;
    const valTrim = value.slice(1, lastIdx);
    // TODO: find a better solution to separate Postgres array data
    try {
      arr = JSON.parse('[' + valTrim + ']');
    } catch (_) {
      // WARNING: splitting on comma does not cover all edge cases
      arr = valTrim ? valTrim.split(',') : [];
    }
    return arr.map(val => convertCell(type, val));
  }
  return value;
};
/**
 * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'
 * See https://github.com/supabase/supabase/issues/18
 *
 * @example toTimestampString('2019-09-10 00:00:00')
 * //=> '2019-09-10T00:00:00'
 */
exports.toArray = toArray;
const toTimestampString = value => {
  if (typeof value === 'string') {
    return value.replace(' ', 'T');
  }
  return value;
};
exports.toTimestampString = toTimestampString;
},{}],"../node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.REALTIME_SUBSCRIBE_STATES = exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = exports.REALTIME_LISTEN_TYPES = exports.REALTIME_CHANNEL_STATES = void 0;
var _constants = require("./lib/constants");
var _push = _interopRequireDefault(require("./lib/push"));
var _timer = _interopRequireDefault(require("./lib/timer"));
var _RealtimePresence = _interopRequireDefault(require("./RealtimePresence"));
var Transformers = _interopRequireWildcard(require("./lib/transformers"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["ALL"] = "*";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["INSERT"] = "INSERT";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["UPDATE"] = "UPDATE";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["DELETE"] = "DELETE";
})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
var REALTIME_LISTEN_TYPES;
(function (REALTIME_LISTEN_TYPES) {
  REALTIME_LISTEN_TYPES["BROADCAST"] = "broadcast";
  REALTIME_LISTEN_TYPES["PRESENCE"] = "presence";
  /**
   * listen to Postgres changes.
   */
  REALTIME_LISTEN_TYPES["POSTGRES_CHANGES"] = "postgres_changes";
})(REALTIME_LISTEN_TYPES || (exports.REALTIME_LISTEN_TYPES = REALTIME_LISTEN_TYPES = {}));
var REALTIME_SUBSCRIBE_STATES;
(function (REALTIME_SUBSCRIBE_STATES) {
  REALTIME_SUBSCRIBE_STATES["SUBSCRIBED"] = "SUBSCRIBED";
  REALTIME_SUBSCRIBE_STATES["TIMED_OUT"] = "TIMED_OUT";
  REALTIME_SUBSCRIBE_STATES["CLOSED"] = "CLOSED";
  REALTIME_SUBSCRIBE_STATES["CHANNEL_ERROR"] = "CHANNEL_ERROR";
})(REALTIME_SUBSCRIBE_STATES || (exports.REALTIME_SUBSCRIBE_STATES = REALTIME_SUBSCRIBE_STATES = {}));
const REALTIME_CHANNEL_STATES = exports.REALTIME_CHANNEL_STATES = _constants.CHANNEL_STATES;
/** A channel is the basic building block of Realtime
 * and narrows the scope of data flow to subscribed clients.
 * You can think of a channel as a chatroom where participants are able to see who's online
 * and send and receive messages.
 */
class RealtimeChannel {
  constructor( /** Topic name can be any string. */
  topic, params = {
    config: {}
  }, socket) {
    this.topic = topic;
    this.params = params;
    this.socket = socket;
    this.bindings = {};
    this.state = _constants.CHANNEL_STATES.closed;
    this.joinedOnce = false;
    this.pushBuffer = [];
    this.subTopic = topic.replace(/^realtime:/i, '');
    this.params.config = Object.assign({
      broadcast: {
        ack: false,
        self: false
      },
      presence: {
        key: ''
      }
    }, params.config);
    this.timeout = this.socket.timeout;
    this.joinPush = new _push.default(this, _constants.CHANNEL_EVENTS.join, this.params, this.timeout);
    this.rejoinTimer = new _timer.default(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
    this.joinPush.receive('ok', () => {
      this.state = _constants.CHANNEL_STATES.joined;
      this.rejoinTimer.reset();
      this.pushBuffer.forEach(pushEvent => pushEvent.send());
      this.pushBuffer = [];
    });
    this._onClose(() => {
      this.rejoinTimer.reset();
      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);
      this.state = _constants.CHANNEL_STATES.closed;
      this.socket._remove(this);
    });
    this._onError(reason => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log('channel', `error ${this.topic}`, reason);
      this.state = _constants.CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive('timeout', () => {
      if (!this._isJoining()) {
        return;
      }
      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);
      this.state = _constants.CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this._on(_constants.CHANNEL_EVENTS.reply, {}, (payload, ref) => {
      this._trigger(this._replyEventName(ref), payload);
    });
    this.presence = new _RealtimePresence.default(this);
    this.broadcastEndpointURL = this._broadcastEndpointURL();
  }
  /** Subscribe registers your client with the server */
  subscribe(callback, timeout = this.timeout) {
    var _a, _b;
    if (!this.socket.isConnected()) {
      this.socket.connect();
    }
    if (this.joinedOnce) {
      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;
    } else {
      const {
        config: {
          broadcast,
          presence
        }
      } = this.params;
      this._onError(e => callback && callback('CHANNEL_ERROR', e));
      this._onClose(() => callback && callback('CLOSED'));
      const accessTokenPayload = {};
      const config = {
        broadcast,
        presence,
        postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(r => r.filter)) !== null && _b !== void 0 ? _b : []
      };
      if (this.socket.accessToken) {
        accessTokenPayload.access_token = this.socket.accessToken;
      }
      this.updateJoinPayload(Object.assign({
        config
      }, accessTokenPayload));
      this.joinedOnce = true;
      this._rejoin(timeout);
      this.joinPush.receive('ok', ({
        postgres_changes: serverPostgresFilters
      }) => {
        var _a;
        this.socket.accessToken && this.socket.setAuth(this.socket.accessToken);
        if (serverPostgresFilters === undefined) {
          callback && callback('SUBSCRIBED');
          return;
        } else {
          const clientPostgresBindings = this.bindings.postgres_changes;
          const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;
          const newPostgresBindings = [];
          for (let i = 0; i < bindingsLen; i++) {
            const clientPostgresBinding = clientPostgresBindings[i];
            const {
              filter: {
                event,
                schema,
                table,
                filter
              }
            } = clientPostgresBinding;
            const serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];
            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {
              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {
                id: serverPostgresFilter.id
              }));
            } else {
              this.unsubscribe();
              callback && callback('CHANNEL_ERROR', new Error('mismatch between server and client bindings for postgres changes'));
              return;
            }
          }
          this.bindings.postgres_changes = newPostgresBindings;
          callback && callback('SUBSCRIBED');
          return;
        }
      }).receive('error', error => {
        callback && callback('CHANNEL_ERROR', new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));
        return;
      }).receive('timeout', () => {
        callback && callback('TIMED_OUT');
        return;
      });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  async track(payload, opts = {}) {
    return await this.send({
      type: 'presence',
      event: 'track',
      payload
    }, opts.timeout || this.timeout);
  }
  async untrack(opts = {}) {
    return await this.send({
      type: 'presence',
      event: 'untrack'
    }, opts);
  }
  on(type, filter, callback) {
    return this._on(type, filter, callback);
  }
  /**
   * Sends a message into the channel.
   *
   * @param args Arguments to send to channel
   * @param args.type The type of event to send
   * @param args.event The name of the event being sent
   * @param args.payload Payload to be sent
   * @param opts Options to be used during the send process
   */
  async send(args, opts = {}) {
    var _a, _b;
    if (!this._canPush() && args.type === 'broadcast') {
      const {
        event,
        payload: endpoint_payload
      } = args;
      const options = {
        method: 'POST',
        headers: {
          apikey: (_a = this.socket.apiKey) !== null && _a !== void 0 ? _a : '',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          messages: [{
            topic: this.subTopic,
            event,
            payload: endpoint_payload
          }]
        })
      };
      try {
        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_b = opts.timeout) !== null && _b !== void 0 ? _b : this.timeout);
        if (response.ok) {
          return 'ok';
        } else {
          return 'error';
        }
      } catch (error) {
        if (error.name === 'AbortError') {
          return 'timed out';
        } else {
          return 'error';
        }
      }
    } else {
      return new Promise(resolve => {
        var _a, _b, _c;
        const push = this._push(args.type, args, opts.timeout || this.timeout);
        if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
          resolve('ok');
        }
        push.receive('ok', () => resolve('ok'));
        push.receive('timeout', () => resolve('timed out'));
      });
    }
  }
  updateJoinPayload(payload) {
    this.joinPush.updatePayload(payload);
  }
  /**
   * Leaves the channel.
   *
   * Unsubscribes from server events, and instructs channel to terminate on server.
   * Triggers onClose() hooks.
   *
   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
   * channel.unsubscribe().receive("ok", () => alert("left!") )
   */
  unsubscribe(timeout = this.timeout) {
    this.state = _constants.CHANNEL_STATES.leaving;
    const onClose = () => {
      this.socket.log('channel', `leave ${this.topic}`);
      this._trigger(_constants.CHANNEL_EVENTS.close, 'leave', this._joinRef());
    };
    this.rejoinTimer.reset();
    // Destroy joinPush to avoid connection timeouts during unscription phase
    this.joinPush.destroy();
    return new Promise(resolve => {
      const leavePush = new _push.default(this, _constants.CHANNEL_EVENTS.leave, {}, timeout);
      leavePush.receive('ok', () => {
        onClose();
        resolve('ok');
      }).receive('timeout', () => {
        onClose();
        resolve('timed out');
      }).receive('error', () => {
        resolve('error');
      });
      leavePush.send();
      if (!this._canPush()) {
        leavePush.trigger('ok', {});
      }
    });
  }
  /** @internal */
  _broadcastEndpointURL() {
    let url = this.socket.endPoint;
    url = url.replace(/^ws/i, 'http');
    url = url.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, '');
    return url.replace(/\/+$/, '') + '/api/broadcast';
  }
  async _fetchWithTimeout(url, options, timeout) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {
      signal: controller.signal
    }));
    clearTimeout(id);
    return response;
  }
  /** @internal */
  _push(event, payload, timeout = this.timeout) {
    if (!this.joinedOnce) {
      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    }
    let pushEvent = new _push.default(this, event, payload, timeout);
    if (this._canPush()) {
      pushEvent.send();
    } else {
      pushEvent.startTimeout();
      this.pushBuffer.push(pushEvent);
    }
    return pushEvent;
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling before dispatching to the channel callbacks.
   * Must return the payload, modified or unmodified.
   *
   * @internal
   */
  _onMessage(_event, payload, _ref) {
    return payload;
  }
  /** @internal */
  _isMember(topic) {
    return this.topic === topic;
  }
  /** @internal */
  _joinRef() {
    return this.joinPush.ref;
  }
  /** @internal */
  _trigger(type, payload, ref) {
    var _a, _b;
    const typeLower = type.toLocaleLowerCase();
    const {
      close,
      error,
      leave,
      join
    } = _constants.CHANNEL_EVENTS;
    const events = [close, error, leave, join];
    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
      return;
    }
    let handledPayload = this._onMessage(typeLower, payload, ref);
    if (payload && !handledPayload) {
      throw 'channel onMessage callbacks must return the payload, modified or unmodified';
    }
    if (['insert', 'update', 'delete'].includes(typeLower)) {
      (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(bind => {
        var _a, _b, _c;
        return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
      }).map(bind => bind.callback(handledPayload, ref));
    } else {
      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(bind => {
        var _a, _b, _c, _d, _e, _f;
        if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {
          if ('id' in bind) {
            const bindId = bind.id;
            const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;
            return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
          } else {
            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
            return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
          }
        } else {
          return bind.type.toLocaleLowerCase() === typeLower;
        }
      }).map(bind => {
        if (typeof handledPayload === 'object' && 'ids' in handledPayload) {
          const postgresChanges = handledPayload.data;
          const {
            schema,
            table,
            commit_timestamp,
            type,
            errors
          } = postgresChanges;
          const enrichedPayload = {
            schema: schema,
            table: table,
            commit_timestamp: commit_timestamp,
            eventType: type,
            new: {},
            old: {},
            errors: errors
          };
          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
        }
        bind.callback(handledPayload, ref);
      });
    }
  }
  /** @internal */
  _isClosed() {
    return this.state === _constants.CHANNEL_STATES.closed;
  }
  /** @internal */
  _isJoined() {
    return this.state === _constants.CHANNEL_STATES.joined;
  }
  /** @internal */
  _isJoining() {
    return this.state === _constants.CHANNEL_STATES.joining;
  }
  /** @internal */
  _isLeaving() {
    return this.state === _constants.CHANNEL_STATES.leaving;
  }
  /** @internal */
  _replyEventName(ref) {
    return `chan_reply_${ref}`;
  }
  /** @internal */
  _on(type, filter, callback) {
    const typeLower = type.toLocaleLowerCase();
    const binding = {
      type: typeLower,
      filter: filter,
      callback: callback
    };
    if (this.bindings[typeLower]) {
      this.bindings[typeLower].push(binding);
    } else {
      this.bindings[typeLower] = [binding];
    }
    return this;
  }
  /** @internal */
  _off(type, filter) {
    const typeLower = type.toLocaleLowerCase();
    this.bindings[typeLower] = this.bindings[typeLower].filter(bind => {
      var _a;
      return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
    });
    return this;
  }
  /** @internal */
  static isEqual(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length) {
      return false;
    }
    for (const k in obj1) {
      if (obj1[k] !== obj2[k]) {
        return false;
      }
    }
    return true;
  }
  /** @internal */
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout();
    if (this.socket.isConnected()) {
      this._rejoin();
    }
  }
  /**
   * Registers a callback that will be executed when the channel closes.
   *
   * @internal
   */
  _onClose(callback) {
    this._on(_constants.CHANNEL_EVENTS.close, {}, callback);
  }
  /**
   * Registers a callback that will be executed when the channel encounteres an error.
   *
   * @internal
   */
  _onError(callback) {
    this._on(_constants.CHANNEL_EVENTS.error, {}, reason => callback(reason));
  }
  /**
   * Returns `true` if the socket is connected and the channel has been joined.
   *
   * @internal
   */
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  /** @internal */
  _rejoin(timeout = this.timeout) {
    if (this._isLeaving()) {
      return;
    }
    this.socket._leaveOpenTopic(this.topic);
    this.state = _constants.CHANNEL_STATES.joining;
    this.joinPush.resend(timeout);
  }
  /** @internal */
  _getPayloadRecords(payload) {
    const records = {
      new: {},
      old: {}
    };
    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {
      records.new = Transformers.convertChangeData(payload.columns, payload.record);
    }
    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {
      records.old = Transformers.convertChangeData(payload.columns, payload.old_record);
    }
    return records;
  }
}
exports.default = RealtimeChannel;
},{"./lib/constants":"../node_modules/@supabase/realtime-js/dist/module/lib/constants.js","./lib/push":"../node_modules/@supabase/realtime-js/dist/module/lib/push.js","./lib/timer":"../node_modules/@supabase/realtime-js/dist/module/lib/timer.js","./RealtimePresence":"../node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js","./lib/transformers":"../node_modules/@supabase/realtime-js/dist/module/lib/transformers.js"}],"../node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _constants = require("./lib/constants");
var _timer = _interopRequireDefault(require("./lib/timer"));
var _serializer = _interopRequireDefault(require("./lib/serializer"));
var _RealtimeChannel = _interopRequireDefault(require("./RealtimeChannel"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const noop = () => {};
const NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== 'undefined';
class RealtimeClient {
  /**
   * Initializes the Socket.
   *
   * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
   * @param options.transport The Websocket Transport, for example WebSocket.
   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
   * @param options.params The optional params to pass when connecting.
   * @param options.headers The optional headers to pass when connecting.
   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
   */
  constructor(endPoint, options) {
    var _a;
    this.accessToken = null;
    this.apiKey = null;
    this.channels = [];
    this.endPoint = '';
    this.headers = _constants.DEFAULT_HEADERS;
    this.params = {};
    this.timeout = _constants.DEFAULT_TIMEOUT;
    this.heartbeatIntervalMs = 30000;
    this.heartbeatTimer = undefined;
    this.pendingHeartbeatRef = null;
    this.ref = 0;
    this.logger = noop;
    this.conn = null;
    this.sendBuffer = [];
    this.serializer = new _serializer.default();
    this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    };
    /**
     * Use either custom fetch, if provided, or default fetch to make HTTP requests
     *
     * @internal
     */
    this._resolveFetch = customFetch => {
      let _fetch;
      if (customFetch) {
        _fetch = customFetch;
      } else if (typeof fetch === 'undefined') {
        _fetch = (...args) => require("_bundle_loader")(require.resolve('@supabase/node-fetch')).then(({
          default: fetch
        }) => fetch(...args));
      } else {
        _fetch = fetch;
      }
      return (...args) => _fetch(...args);
    };
    this.endPoint = `${endPoint}/${_constants.TRANSPORTS.websocket}`;
    if (options === null || options === void 0 ? void 0 : options.transport) {
      this.transport = options.transport;
    } else {
      this.transport = null;
    }
    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;
    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);
    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;
    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;
    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;
    const accessToken = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey;
    if (accessToken) {
      this.accessToken = accessToken;
      this.apiKey = accessToken;
    }
    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : tries => {
      return [1000, 2000, 5000, 10000][tries - 1] || 10000;
    };
    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {
      return callback(JSON.stringify(payload));
    };
    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);
    this.reconnectTimer = new _timer.default(async () => {
      this.disconnect();
      this.connect();
    }, this.reconnectAfterMs);
    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
  }
  /**
   * Connects the socket, unless already connected.
   */
  connect() {
    if (this.conn) {
      return;
    }
    if (this.transport) {
      this.conn = new this.transport(this._endPointURL(), undefined, {
        headers: this.headers
      });
      return;
    }
    if (NATIVE_WEBSOCKET_AVAILABLE) {
      this.conn = new WebSocket(this._endPointURL());
      this.setupConnection();
      return;
    }
    this.conn = new WSWebSocketDummy(this._endPointURL(), undefined, {
      close: () => {
        this.conn = null;
      }
    });
    require("_bundle_loader")(require.resolve('ws')).then(({
      default: WS
    }) => {
      this.conn = new WS(this._endPointURL(), undefined, {
        headers: this.headers
      });
      this.setupConnection();
    });
  }
  /**
   * Disconnects the socket.
   *
   * @param code A numeric status code to send on disconnect.
   * @param reason A custom reason for the disconnect.
   */
  disconnect(code, reason) {
    if (this.conn) {
      this.conn.onclose = function () {}; // noop
      if (code) {
        this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');
      } else {
        this.conn.close();
      }
      this.conn = null;
      // remove open handles
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.reconnectTimer.reset();
    }
  }
  /**
   * Returns all created channels
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Unsubscribes and removes a single channel
   * @param channel A RealtimeChannel instance
   */
  async removeChannel(channel) {
    const status = await channel.unsubscribe();
    if (this.channels.length === 0) {
      this.disconnect();
    }
    return status;
  }
  /**
   * Unsubscribes and removes all channels
   */
  async removeAllChannels() {
    const values_1 = await Promise.all(this.channels.map(channel => channel.unsubscribe()));
    this.disconnect();
    return values_1;
  }
  /**
   * Logs the message.
   *
   * For customized logging, `this.logger` can be overridden.
   */
  log(kind, msg, data) {
    this.logger(kind, msg, data);
  }
  /**
   * Returns the current state of the socket.
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case _constants.SOCKET_STATES.connecting:
        return _constants.CONNECTION_STATE.Connecting;
      case _constants.SOCKET_STATES.open:
        return _constants.CONNECTION_STATE.Open;
      case _constants.SOCKET_STATES.closing:
        return _constants.CONNECTION_STATE.Closing;
      default:
        return _constants.CONNECTION_STATE.Closed;
    }
  }
  /**
   * Returns `true` is the connection is open.
   */
  isConnected() {
    return this.connectionState() === _constants.CONNECTION_STATE.Open;
  }
  channel(topic, params = {
    config: {}
  }) {
    const chan = new _RealtimeChannel.default(`realtime:${topic}`, params, this);
    this.channels.push(chan);
    return chan;
  }
  /**
   * Push out a message if the socket is connected.
   *
   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
   */
  push(data) {
    const {
      topic,
      event,
      payload,
      ref
    } = data;
    const callback = () => {
      this.encode(data, result => {
        var _a;
        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);
      });
    };
    this.log('push', `${topic} ${event} (${ref})`, payload);
    if (this.isConnected()) {
      callback();
    } else {
      this.sendBuffer.push(callback);
    }
  }
  /**
   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
   *
   * @param token A JWT string.
   */
  setAuth(token) {
    this.accessToken = token;
    this.channels.forEach(channel => {
      token && channel.updateJoinPayload({
        access_token: token
      });
      if (channel.joinedOnce && channel._isJoined()) {
        channel._push(_constants.CHANNEL_EVENTS.access_token, {
          access_token: token
        });
      }
    });
  }
  /**
   * Return the next message ref, accounting for overflows
   *
   * @internal
   */
  _makeRef() {
    let newRef = this.ref + 1;
    if (newRef === this.ref) {
      this.ref = 0;
    } else {
      this.ref = newRef;
    }
    return this.ref.toString();
  }
  /**
   * Unsubscribe from channels with the specified topic.
   *
   * @internal
   */
  _leaveOpenTopic(topic) {
    let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));
    if (dupChannel) {
      this.log('transport', `leaving duplicate topic "${topic}"`);
      dupChannel.unsubscribe();
    }
  }
  /**
   * Removes a subscription from the socket.
   *
   * @param channel An open subscription.
   *
   * @internal
   */
  _remove(channel) {
    this.channels = this.channels.filter(c => c._joinRef() !== channel._joinRef());
  }
  /**
   * Sets up connection handlers.
   *
   * @internal
   */
  setupConnection() {
    if (this.conn) {
      this.conn.binaryType = 'arraybuffer';
      this.conn.onopen = () => this._onConnOpen();
      this.conn.onerror = error => this._onConnError(error);
      this.conn.onmessage = event => this._onConnMessage(event);
      this.conn.onclose = event => this._onConnClose(event);
    }
  }
  /**
   * Returns the URL of the websocket.
   *
   * @internal
   */
  _endPointURL() {
    return this._appendParams(this.endPoint, Object.assign({}, this.params, {
      vsn: _constants.VSN
    }));
  }
  /** @internal */
  _onConnMessage(rawMessage) {
    this.decode(rawMessage.data, msg => {
      let {
        topic,
        event,
        payload,
        ref
      } = msg;
      if (ref && ref === this.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {
        this.pendingHeartbeatRef = null;
      }
      this.log('receive', `${payload.status || ''} ${topic} ${event} ${ref && '(' + ref + ')' || ''}`, payload);
      this.channels.filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));
      this.stateChangeCallbacks.message.forEach(callback => callback(msg));
    });
  }
  /** @internal */
  _onConnOpen() {
    this.log('transport', `connected to ${this._endPointURL()}`);
    this._flushSendBuffer();
    this.reconnectTimer.reset();
    this.heartbeatTimer && clearInterval(this.heartbeatTimer);
    this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);
    this.stateChangeCallbacks.open.forEach(callback => callback());
  }
  /** @internal */
  _onConnClose(event) {
    this.log('transport', 'close', event);
    this._triggerChanError();
    this.heartbeatTimer && clearInterval(this.heartbeatTimer);
    this.reconnectTimer.scheduleTimeout();
    this.stateChangeCallbacks.close.forEach(callback => callback(event));
  }
  /** @internal */
  _onConnError(error) {
    this.log('transport', error.message);
    this._triggerChanError();
    this.stateChangeCallbacks.error.forEach(callback => callback(error));
  }
  /** @internal */
  _triggerChanError() {
    this.channels.forEach(channel => channel._trigger(_constants.CHANNEL_EVENTS.error));
  }
  /** @internal */
  _appendParams(url, params) {
    if (Object.keys(params).length === 0) {
      return url;
    }
    const prefix = url.match(/\?/) ? '&' : '?';
    const query = new URLSearchParams(params);
    return `${url}${prefix}${query}`;
  }
  /** @internal */
  _flushSendBuffer() {
    if (this.isConnected() && this.sendBuffer.length > 0) {
      this.sendBuffer.forEach(callback => callback());
      this.sendBuffer = [];
    }
  }
  /** @internal */
  _sendHeartbeat() {
    var _a;
    if (!this.isConnected()) {
      return;
    }
    if (this.pendingHeartbeatRef) {
      this.pendingHeartbeatRef = null;
      this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');
      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(_constants.WS_CLOSE_NORMAL, 'hearbeat timeout');
      return;
    }
    this.pendingHeartbeatRef = this._makeRef();
    this.push({
      topic: 'phoenix',
      event: 'heartbeat',
      payload: {},
      ref: this.pendingHeartbeatRef
    });
    this.setAuth(this.accessToken);
  }
}
exports.default = RealtimeClient;
class WSWebSocketDummy {
  constructor(address, _protocols, options) {
    this.binaryType = 'arraybuffer';
    this.onclose = () => {};
    this.onerror = () => {};
    this.onmessage = () => {};
    this.onopen = () => {};
    this.readyState = _constants.SOCKET_STATES.connecting;
    this.send = () => {};
    this.url = null;
    this.url = address;
    this.close = options.close;
  }
}
},{"./lib/constants":"../node_modules/@supabase/realtime-js/dist/module/lib/constants.js","./lib/timer":"../node_modules/@supabase/realtime-js/dist/module/lib/timer.js","./lib/serializer":"../node_modules/@supabase/realtime-js/dist/module/lib/serializer.js","./RealtimeChannel":"../node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js","_bundle_loader":"../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/bundle-loader.js","@supabase/node-fetch":[["browser.d202933b.js","../node_modules/@supabase/node-fetch/browser.js"],"browser.d202933b.js.map","../node_modules/@supabase/node-fetch/browser.js"],"ws":[["browser.02c2c747.js","../node_modules/ws/browser.js"],"browser.02c2c747.js.map","../node_modules/ws/browser.js"]}],"../node_modules/@supabase/realtime-js/dist/module/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "REALTIME_CHANNEL_STATES", {
  enumerable: true,
  get: function () {
    return _RealtimeChannel.REALTIME_CHANNEL_STATES;
  }
});
Object.defineProperty(exports, "REALTIME_LISTEN_TYPES", {
  enumerable: true,
  get: function () {
    return _RealtimeChannel.REALTIME_LISTEN_TYPES;
  }
});
Object.defineProperty(exports, "REALTIME_POSTGRES_CHANGES_LISTEN_EVENT", {
  enumerable: true,
  get: function () {
    return _RealtimeChannel.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
  }
});
Object.defineProperty(exports, "REALTIME_PRESENCE_LISTEN_EVENTS", {
  enumerable: true,
  get: function () {
    return _RealtimePresence.REALTIME_PRESENCE_LISTEN_EVENTS;
  }
});
Object.defineProperty(exports, "REALTIME_SUBSCRIBE_STATES", {
  enumerable: true,
  get: function () {
    return _RealtimeChannel.REALTIME_SUBSCRIBE_STATES;
  }
});
Object.defineProperty(exports, "RealtimeChannel", {
  enumerable: true,
  get: function () {
    return _RealtimeChannel.default;
  }
});
Object.defineProperty(exports, "RealtimeClient", {
  enumerable: true,
  get: function () {
    return _RealtimeClient.default;
  }
});
Object.defineProperty(exports, "RealtimePresence", {
  enumerable: true,
  get: function () {
    return _RealtimePresence.default;
  }
});
var _RealtimeClient = _interopRequireDefault(require("./RealtimeClient"));
var _RealtimeChannel = _interopRequireWildcard(require("./RealtimeChannel"));
var _RealtimePresence = _interopRequireWildcard(require("./RealtimePresence"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./RealtimeClient":"../node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js","./RealtimeChannel":"../node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js","./RealtimePresence":"../node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js"}],"../node_modules/@supabase/storage-js/dist/module/lib/errors.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StorageUnknownError = exports.StorageError = exports.StorageApiError = void 0;
exports.isStorageError = isStorageError;
class StorageError extends Error {
  constructor(message) {
    super(message);
    this.__isStorageError = true;
    this.name = 'StorageError';
  }
}
exports.StorageError = StorageError;
function isStorageError(error) {
  return typeof error === 'object' && error !== null && '__isStorageError' in error;
}
class StorageApiError extends StorageError {
  constructor(message, status) {
    super(message);
    this.name = 'StorageApiError';
    this.status = status;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
}
exports.StorageApiError = StorageApiError;
class StorageUnknownError extends StorageError {
  constructor(message, originalError) {
    super(message);
    this.name = 'StorageUnknownError';
    this.originalError = originalError;
  }
}
exports.StorageUnknownError = StorageUnknownError;
},{}],"../node_modules/@supabase/storage-js/dist/module/lib/helpers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveResponse = exports.resolveFetch = void 0;
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const resolveFetch = customFetch => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === 'undefined') {
    _fetch = (...args) => require("_bundle_loader")(require.resolve('@supabase/node-fetch')).then(({
      default: fetch
    }) => fetch(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
exports.resolveFetch = resolveFetch;
const resolveResponse = () => __awaiter(void 0, void 0, void 0, function* () {
  if (typeof Response === 'undefined') {
    // @ts-ignore
    return (yield require("_bundle_loader")(require.resolve('@supabase/node-fetch'))).Response;
  }
  return Response;
});
exports.resolveResponse = resolveResponse;
},{"_bundle_loader":"../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/bundle-loader.js","@supabase/node-fetch":[["browser.d202933b.js","../node_modules/@supabase/node-fetch/browser.js"],"browser.d202933b.js.map","../node_modules/@supabase/node-fetch/browser.js"]}],"../node_modules/@supabase/storage-js/dist/module/lib/fetch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.get = get;
exports.post = post;
exports.put = put;
exports.remove = remove;
var _errors = require("./errors");
var _helpers = require("./helpers");
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const _getErrorMessage = err => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const handleError = (error, reject) => __awaiter(void 0, void 0, void 0, function* () {
  const Res = yield (0, _helpers.resolveResponse)();
  if (error instanceof Res) {
    error.json().then(err => {
      reject(new _errors.StorageApiError(_getErrorMessage(err), error.status || 500));
    }).catch(err => {
      reject(new _errors.StorageUnknownError(_getErrorMessage(err), err));
    });
  } else {
    reject(new _errors.StorageUnknownError(_getErrorMessage(error), error));
  }
});
const _getRequestParams = (method, options, parameters, body) => {
  const params = {
    method,
    headers: (options === null || options === void 0 ? void 0 : options.headers) || {}
  };
  if (method === 'GET') {
    return params;
  }
  params.headers = Object.assign({
    'Content-Type': 'application/json'
  }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body);
  return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest(fetcher, method, url, options, parameters, body) {
  return __awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      fetcher(url, _getRequestParams(method, options, parameters, body)).then(result => {
        if (!result.ok) throw result;
        if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;
        return result.json();
      }).then(data => resolve(data)).catch(error => handleError(error, reject));
    });
  });
}
function get(fetcher, url, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, 'GET', url, options, parameters);
  });
}
function post(fetcher, url, body, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, 'POST', url, options, parameters, body);
  });
}
function put(fetcher, url, body, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, 'PUT', url, options, parameters, body);
  });
}
function remove(fetcher, url, body, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, 'DELETE', url, options, parameters, body);
  });
}
},{"./errors":"../node_modules/@supabase/storage-js/dist/module/lib/errors.js","./helpers":"../node_modules/@supabase/storage-js/dist/module/lib/helpers.js"}],"../node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _errors = require("../lib/errors");
var _fetch = require("../lib/fetch");
var _helpers = require("../lib/helpers");
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const DEFAULT_SEARCH_OPTIONS = {
  limit: 100,
  offset: 0,
  sortBy: {
    column: 'name',
    order: 'asc'
  }
};
const DEFAULT_FILE_OPTIONS = {
  cacheControl: '3600',
  contentType: 'text/plain;charset=UTF-8',
  upsert: false
};
class StorageFileApi {
  constructor(url, headers = {}, bucketId, fetch) {
    this.url = url;
    this.headers = headers;
    this.bucketId = bucketId;
    this.fetch = (0, _helpers.resolveFetch)(fetch);
  }
  /**
   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
   *
   * @param method HTTP method.
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadOrUpdate(method, path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let body;
        const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
        const headers = Object.assign(Object.assign({}, this.headers), method === 'POST' && {
          'x-upsert': String(options.upsert)
        });
        if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {
          body = new FormData();
          body.append('cacheControl', options.cacheControl);
          body.append('', fileBody);
        } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {
          body = fileBody;
          body.append('cacheControl', options.cacheControl);
        } else {
          body = fileBody;
          headers['cache-control'] = `max-age=${options.cacheControl}`;
          headers['content-type'] = options.contentType;
        }
        const cleanPath = this._removeEmptyFolders(path);
        const _path = this._getFinalPath(cleanPath);
        const res = yield this.fetch(`${this.url}/object/${_path}`, Object.assign({
          method,
          body: body,
          headers
        }, (options === null || options === void 0 ? void 0 : options.duplex) ? {
          duplex: options.duplex
        } : {}));
        const data = yield res.json();
        if (res.ok) {
          return {
            data: {
              path: cleanPath,
              id: data.Id,
              fullPath: data.Key
            },
            error: null
          };
        } else {
          const error = data;
          return {
            data: null,
            error
          };
        }
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Uploads a file to an existing bucket.
   *
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  upload(path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.uploadOrUpdate('POST', path, fileBody, fileOptions);
    });
  }
  /**
   * Upload a file with a token generated from `createSignedUploadUrl`.
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param token The token generated from `createSignedUploadUrl`
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadToSignedUrl(path, token, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      const cleanPath = this._removeEmptyFolders(path);
      const _path = this._getFinalPath(cleanPath);
      const url = new URL(this.url + `/object/upload/sign/${_path}`);
      url.searchParams.set('token', token);
      try {
        let body;
        const options = Object.assign({
          upsert: DEFAULT_FILE_OPTIONS.upsert
        }, fileOptions);
        const headers = Object.assign(Object.assign({}, this.headers), {
          'x-upsert': String(options.upsert)
        });
        if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {
          body = new FormData();
          body.append('cacheControl', options.cacheControl);
          body.append('', fileBody);
        } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {
          body = fileBody;
          body.append('cacheControl', options.cacheControl);
        } else {
          body = fileBody;
          headers['cache-control'] = `max-age=${options.cacheControl}`;
          headers['content-type'] = options.contentType;
        }
        const res = yield this.fetch(url.toString(), {
          method: 'PUT',
          body: body,
          headers
        });
        const data = yield res.json();
        if (res.ok) {
          return {
            data: {
              path: cleanPath,
              fullPath: data.Key
            },
            error: null
          };
        } else {
          const error = data;
          return {
            data: null,
            error
          };
        }
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed upload URL.
   * Signed upload URLs can be used to upload files to the bucket without further authentication.
   * They are valid for 2 hours.
   * @param path The file path, including the current file name. For example `folder/image.png`.
   */
  createSignedUploadUrl(path) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        const data = yield (0, _fetch.post)(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, {
          headers: this.headers
        });
        const url = new URL(this.url + data.url);
        const token = url.searchParams.get('token');
        if (!token) {
          throw new _errors.StorageError('No token returned by API');
        }
        return {
          data: {
            signedUrl: url.toString(),
            path,
            token
          },
          error: null
        };
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Replaces an existing file at the specified path with a new one.
   *
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  update(path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.uploadOrUpdate('PUT', path, fileBody, fileOptions);
    });
  }
  /**
   * Moves an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
   */
  move(fromPath, toPath) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0, _fetch.post)(this.fetch, `${this.url}/object/move`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath
        }, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Copies an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
   */
  copy(fromPath, toPath) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0, _fetch.post)(this.fetch, `${this.url}/object/copy`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath
        }, {
          headers: this.headers
        });
        return {
          data: {
            path: data.Key
          },
          error: null
        };
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  createSignedUrl(path, expiresIn, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        let data = yield (0, _fetch.post)(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({
          expiresIn
        }, (options === null || options === void 0 ? void 0 : options.transform) ? {
          transform: options.transform
        } : {}), {
          headers: this.headers
        });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? '' : options.download}` : '';
        const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);
        data = {
          signedUrl
        };
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   */
  createSignedUrls(paths, expiresIn, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0, _fetch.post)(this.fetch, `${this.url}/object/sign/${this.bucketId}`, {
          expiresIn,
          paths
        }, {
          headers: this.headers
        });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? '' : options.download}` : '';
        return {
          data: data.map(datum => Object.assign(Object.assign({}, datum), {
            signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null
          })),
          error: null
        };
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
   *
   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
   * @param options.transform Transform the asset before serving it to the client.
   */
  download(path, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== 'undefined';
      const renderPath = wantsTransformation ? 'render/image/authenticated' : 'object';
      const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
      const queryString = transformationQuery ? `?${transformationQuery}` : '';
      try {
        const _path = this._getFinalPath(path);
        const res = yield (0, _fetch.get)(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
          headers: this.headers,
          noResolveJson: true
        });
        const data = yield res.blob();
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
   *
   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  getPublicUrl(path, options) {
    const _path = this._getFinalPath(path);
    const _queryString = [];
    const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? '' : options.download}` : '';
    if (downloadQueryParam !== '') {
      _queryString.push(downloadQueryParam);
    }
    const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== 'undefined';
    const renderPath = wantsTransformation ? 'render/image' : 'object';
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    if (transformationQuery !== '') {
      _queryString.push(transformationQuery);
    }
    let queryString = _queryString.join('&');
    if (queryString !== '') {
      queryString = `?${queryString}`;
    }
    return {
      data: {
        publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`)
      }
    };
  }
  /**
   * Deletes files within the same bucket
   *
   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
   */
  remove(paths) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0, _fetch.remove)(this.fetch, `${this.url}/object/${this.bucketId}`, {
          prefixes: paths
        }, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Get file metadata
   * @param id the file id to retrieve metadata
   */
  // async getMetadata(
  //   id: string
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Update file metadata
   * @param id the file id to update metadata
   * @param meta the new file metadata
   */
  // async updateMetadata(
  //   id: string,
  //   meta: Metadata
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await post(
  //       this.fetch,
  //       `${this.url}/metadata/${id}`,
  //       { ...meta },
  //       { headers: this.headers }
  //     )
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Lists all the files within a bucket.
   * @param path The folder path.
   */
  list(path, options, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), {
          prefix: path || ''
        });
        const data = yield (0, _fetch.post)(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, {
          headers: this.headers
        }, parameters);
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  _getFinalPath(path) {
    return `${this.bucketId}/${path}`;
  }
  _removeEmptyFolders(path) {
    return path.replace(/^\/|\/$/g, '').replace(/\/+/g, '/');
  }
  transformOptsToQueryString(transform) {
    const params = [];
    if (transform.width) {
      params.push(`width=${transform.width}`);
    }
    if (transform.height) {
      params.push(`height=${transform.height}`);
    }
    if (transform.resize) {
      params.push(`resize=${transform.resize}`);
    }
    if (transform.format) {
      params.push(`format=${transform.format}`);
    }
    if (transform.quality) {
      params.push(`quality=${transform.quality}`);
    }
    return params.join('&');
  }
}
exports.default = StorageFileApi;
},{"../lib/errors":"../node_modules/@supabase/storage-js/dist/module/lib/errors.js","../lib/fetch":"../node_modules/@supabase/storage-js/dist/module/lib/fetch.js","../lib/helpers":"../node_modules/@supabase/storage-js/dist/module/lib/helpers.js"}],"../node_modules/@supabase/storage-js/dist/module/lib/version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
// generated by genversion
const version = exports.version = '2.5.5';
},{}],"../node_modules/@supabase/storage-js/dist/module/lib/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_HEADERS = void 0;
var _version = require("./version");
const DEFAULT_HEADERS = exports.DEFAULT_HEADERS = {
  'X-Client-Info': `storage-js/${_version.version}`
};
},{"./version":"../node_modules/@supabase/storage-js/dist/module/lib/version.js"}],"../node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _constants = require("../lib/constants");
var _errors = require("../lib/errors");
var _fetch = require("../lib/fetch");
var _helpers = require("../lib/helpers");
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class StorageBucketApi {
  constructor(url, headers = {}, fetch) {
    this.url = url;
    this.headers = Object.assign(Object.assign({}, _constants.DEFAULT_HEADERS), headers);
    this.fetch = (0, _helpers.resolveFetch)(fetch);
  }
  /**
   * Retrieves the details of all Storage buckets within an existing project.
   */
  listBuckets() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0, _fetch.get)(this.fetch, `${this.url}/bucket`, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of an existing Storage bucket.
   *
   * @param id The unique identifier of the bucket you would like to retrieve.
   */
  getBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0, _fetch.get)(this.fetch, `${this.url}/bucket/${id}`, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a new Storage bucket
   *
   * @param id A unique identifier for the bucket you are creating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   * @returns newly created bucket id
   */
  createBucket(id, options = {
    public: false
  }) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0, _fetch.post)(this.fetch, `${this.url}/bucket`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Updates a Storage bucket
   *
   * @param id A unique identifier for the bucket you are updating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   */
  updateBucket(id, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0, _fetch.put)(this.fetch, `${this.url}/bucket/${id}`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Removes all objects inside a single bucket.
   *
   * @param id The unique identifier of the bucket you would like to empty.
   */
  emptyBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0, _fetch.post)(this.fetch, `${this.url}/bucket/${id}/empty`, {}, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
   * You must first `empty()` the bucket.
   *
   * @param id The unique identifier of the bucket you would like to delete.
   */
  deleteBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0, _fetch.remove)(this.fetch, `${this.url}/bucket/${id}`, {}, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0, _errors.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
}
exports.default = StorageBucketApi;
},{"../lib/constants":"../node_modules/@supabase/storage-js/dist/module/lib/constants.js","../lib/errors":"../node_modules/@supabase/storage-js/dist/module/lib/errors.js","../lib/fetch":"../node_modules/@supabase/storage-js/dist/module/lib/fetch.js","../lib/helpers":"../node_modules/@supabase/storage-js/dist/module/lib/helpers.js"}],"../node_modules/@supabase/storage-js/dist/module/StorageClient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StorageClient = void 0;
var _StorageFileApi = _interopRequireDefault(require("./packages/StorageFileApi"));
var _StorageBucketApi = _interopRequireDefault(require("./packages/StorageBucketApi"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class StorageClient extends _StorageBucketApi.default {
  constructor(url, headers = {}, fetch) {
    super(url, headers, fetch);
  }
  /**
   * Perform file operation in a bucket.
   *
   * @param id The bucket id to operate on.
   */
  from(id) {
    return new _StorageFileApi.default(this.url, this.headers, id, this.fetch);
  }
}
exports.StorageClient = StorageClient;
},{"./packages/StorageFileApi":"../node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js","./packages/StorageBucketApi":"../node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js"}],"../node_modules/@supabase/storage-js/dist/module/lib/types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/@supabase/storage-js/dist/module/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  StorageClient: true
};
Object.defineProperty(exports, "StorageClient", {
  enumerable: true,
  get: function () {
    return _StorageClient.StorageClient;
  }
});
var _StorageClient = require("./StorageClient");
var _types = require("./lib/types");
Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});
var _errors = require("./lib/errors");
Object.keys(_errors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _errors[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _errors[key];
    }
  });
});
},{"./StorageClient":"../node_modules/@supabase/storage-js/dist/module/StorageClient.js","./lib/types":"../node_modules/@supabase/storage-js/dist/module/lib/types.js","./lib/errors":"../node_modules/@supabase/storage-js/dist/module/lib/errors.js"}],"../node_modules/@supabase/supabase-js/dist/module/lib/version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
const version = exports.version = '2.39.3';
},{}],"../node_modules/@supabase/supabase-js/dist/module/lib/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_HEADERS = void 0;
var _version = require("./version");
// constants.ts

let JS_ENV = '';
// @ts-ignore
if (typeof Deno !== 'undefined') {
  JS_ENV = 'deno';
} else if (typeof document !== 'undefined') {
  JS_ENV = 'web';
} else if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
  JS_ENV = 'react-native';
} else {
  JS_ENV = 'node';
}
const DEFAULT_HEADERS = exports.DEFAULT_HEADERS = {
  'X-Client-Info': `supabase-js-${JS_ENV}/${_version.version}`
};
},{"./version":"../node_modules/@supabase/supabase-js/dist/module/lib/version.js"}],"../node_modules/@supabase/supabase-js/dist/module/lib/fetch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveHeadersConstructor = exports.resolveFetch = exports.fetchWithAuth = void 0;
var _nodeFetch = _interopRequireWildcard(require("@supabase/node-fetch"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
// @ts-ignore

const resolveFetch = customFetch => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === 'undefined') {
    _fetch = _nodeFetch.default;
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
exports.resolveFetch = resolveFetch;
const resolveHeadersConstructor = () => {
  if (typeof Headers === 'undefined') {
    return _nodeFetch.Headers;
  }
  return Headers;
};
exports.resolveHeadersConstructor = resolveHeadersConstructor;
const fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
  const fetch = resolveFetch(customFetch);
  const HeadersConstructor = resolveHeadersConstructor();
  return (input, init) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const accessToken = (_a = yield getAccessToken()) !== null && _a !== void 0 ? _a : supabaseKey;
    let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
    if (!headers.has('apikey')) {
      headers.set('apikey', supabaseKey);
    }
    if (!headers.has('Authorization')) {
      headers.set('Authorization', `Bearer ${accessToken}`);
    }
    return fetch(input, Object.assign(Object.assign({}, init), {
      headers
    }));
  });
};
exports.fetchWithAuth = fetchWithAuth;
},{"@supabase/node-fetch":"../node_modules/@supabase/node-fetch/browser.js"}],"../node_modules/@supabase/supabase-js/dist/module/lib/helpers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applySettingDefaults = applySettingDefaults;
exports.isBrowser = void 0;
exports.stripTrailingSlash = stripTrailingSlash;
exports.uuid = uuid;
function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
      v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
function stripTrailingSlash(url) {
  return url.replace(/\/$/, '');
}
const isBrowser = () => typeof window !== 'undefined';
exports.isBrowser = isBrowser;
function applySettingDefaults(options, defaults) {
  const {
    db: dbOptions,
    auth: authOptions,
    realtime: realtimeOptions,
    global: globalOptions
  } = options;
  const {
    db: DEFAULT_DB_OPTIONS,
    auth: DEFAULT_AUTH_OPTIONS,
    realtime: DEFAULT_REALTIME_OPTIONS,
    global: DEFAULT_GLOBAL_OPTIONS
  } = defaults;
  return {
    db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS), dbOptions),
    auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), authOptions),
    realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS), realtimeOptions),
    global: Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS), globalOptions)
  };
}
},{}],"../node_modules/@supabase/gotrue-js/dist/module/lib/helpers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Deferred = void 0;
exports.decodeBase64URL = decodeBase64URL;
exports.decodeJWTPayload = decodeJWTPayload;
exports.expiresAt = expiresAt;
exports.generatePKCEChallenge = generatePKCEChallenge;
exports.generatePKCEVerifier = generatePKCEVerifier;
exports.looksLikeFetchResponse = exports.isBrowser = exports.getItemAsync = void 0;
exports.parseParametersFromURL = parseParametersFromURL;
exports.resolveFetch = exports.removeItemAsync = void 0;
exports.retryable = retryable;
exports.setItemAsync = void 0;
exports.sleep = sleep;
exports.supportsLocalStorage = void 0;
exports.uuid = uuid;
function expiresAt(expiresIn) {
  const timeNow = Math.round(Date.now() / 1000);
  return timeNow + expiresIn;
}
function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    const r = Math.random() * 16 | 0,
      v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
const isBrowser = () => typeof document !== 'undefined';
exports.isBrowser = isBrowser;
const localStorageWriteTests = {
  tested: false,
  writable: false
};
/**
 * Checks whether localStorage is supported on this browser.
 */
const supportsLocalStorage = () => {
  if (!isBrowser()) {
    return false;
  }
  try {
    if (typeof globalThis.localStorage !== 'object') {
      return false;
    }
  } catch (e) {
    // DOM exception when accessing `localStorage`
    return false;
  }
  if (localStorageWriteTests.tested) {
    return localStorageWriteTests.writable;
  }
  const randomKey = `lswt-${Math.random()}${Math.random()}`;
  try {
    globalThis.localStorage.setItem(randomKey, randomKey);
    globalThis.localStorage.removeItem(randomKey);
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = true;
  } catch (e) {
    // localStorage can't be written to
    // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = false;
  }
  return localStorageWriteTests.writable;
};
/**
 * Extracts parameters encoded in the URL both in the query and fragment.
 */
exports.supportsLocalStorage = supportsLocalStorage;
function parseParametersFromURL(href) {
  const result = {};
  const url = new URL(href);
  if (url.hash && url.hash[0] === '#') {
    try {
      const hashSearchParams = new URLSearchParams(url.hash.substring(1));
      hashSearchParams.forEach((value, key) => {
        result[key] = value;
      });
    } catch (e) {
      // hash is not a query string
    }
  }
  // search parameters take precedence over hash parameters
  url.searchParams.forEach((value, key) => {
    result[key] = value;
  });
  return result;
}
const resolveFetch = customFetch => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === 'undefined') {
    _fetch = (...args) => require("_bundle_loader")(require.resolve('@supabase/node-fetch')).then(({
      default: fetch
    }) => fetch(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
exports.resolveFetch = resolveFetch;
const looksLikeFetchResponse = maybeResponse => {
  return typeof maybeResponse === 'object' && maybeResponse !== null && 'status' in maybeResponse && 'ok' in maybeResponse && 'json' in maybeResponse && typeof maybeResponse.json === 'function';
};
// Storage helpers
exports.looksLikeFetchResponse = looksLikeFetchResponse;
const setItemAsync = async (storage, key, data) => {
  await storage.setItem(key, JSON.stringify(data));
};
exports.setItemAsync = setItemAsync;
const getItemAsync = async (storage, key) => {
  const value = await storage.getItem(key);
  if (!value) {
    return null;
  }
  try {
    return JSON.parse(value);
  } catch (_a) {
    return value;
  }
};
exports.getItemAsync = getItemAsync;
const removeItemAsync = async (storage, key) => {
  await storage.removeItem(key);
};
exports.removeItemAsync = removeItemAsync;
function decodeBase64URL(value) {
  const key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  let base64 = '';
  let chr1, chr2, chr3;
  let enc1, enc2, enc3, enc4;
  let i = 0;
  value = value.replace('-', '+').replace('_', '/');
  while (i < value.length) {
    enc1 = key.indexOf(value.charAt(i++));
    enc2 = key.indexOf(value.charAt(i++));
    enc3 = key.indexOf(value.charAt(i++));
    enc4 = key.indexOf(value.charAt(i++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    base64 = base64 + String.fromCharCode(chr1);
    if (enc3 != 64 && chr2 != 0) {
      base64 = base64 + String.fromCharCode(chr2);
    }
    if (enc4 != 64 && chr3 != 0) {
      base64 = base64 + String.fromCharCode(chr3);
    }
  }
  return base64;
}
/**
 * A deferred represents some asynchronous work that is not yet finished, which
 * may or may not culminate in a value.
 * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts
 */
class Deferred {
  constructor() {
    // eslint-disable-next-line @typescript-eslint/no-extra-semi
    ;
    this.promise = new Deferred.promiseConstructor((res, rej) => {
      // eslint-disable-next-line @typescript-eslint/no-extra-semi
      ;
      this.resolve = res;
      this.reject = rej;
    });
  }
}
exports.Deferred = Deferred;
Deferred.promiseConstructor = Promise;
// Taken from: https://stackoverflow.com/questions/38552003/how-to-decode-jwt-token-in-javascript-without-using-a-library
function decodeJWTPayload(token) {
  // Regex checks for base64url format
  const base64UrlRegex = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i;
  const parts = token.split('.');
  if (parts.length !== 3) {
    throw new Error('JWT is not valid: not a JWT structure');
  }
  if (!base64UrlRegex.test(parts[1])) {
    throw new Error('JWT is not valid: payload is not in base64url format');
  }
  const base64Url = parts[1];
  return JSON.parse(decodeBase64URL(base64Url));
}
/**
 * Creates a promise that resolves to null after some time.
 */
async function sleep(time) {
  return await new Promise(accept => {
    setTimeout(() => accept(null), time);
  });
}
/**
 * Converts the provided async function into a retryable function. Each result
 * or thrown error is sent to the isRetryable function which should return true
 * if the function should run again.
 */
function retryable(fn, isRetryable) {
  const promise = new Promise((accept, reject) => {
    // eslint-disable-next-line @typescript-eslint/no-extra-semi
    ;
    (async () => {
      for (let attempt = 0; attempt < Infinity; attempt++) {
        try {
          const result = await fn(attempt);
          if (!isRetryable(attempt, null, result)) {
            accept(result);
            return;
          }
        } catch (e) {
          if (!isRetryable(attempt, e)) {
            reject(e);
            return;
          }
        }
      }
    })();
  });
  return promise;
}
function dec2hex(dec) {
  return ('0' + dec.toString(16)).substr(-2);
}
// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs
function generatePKCEVerifier() {
  const verifierLength = 56;
  const array = new Uint32Array(verifierLength);
  if (typeof crypto === 'undefined') {
    const charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
    const charSetLen = charSet.length;
    let verifier = '';
    for (let i = 0; i < verifierLength; i++) {
      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
    }
    return verifier;
  }
  crypto.getRandomValues(array);
  return Array.from(array, dec2hex).join('');
}
async function sha256(randomString) {
  const encoder = new TextEncoder();
  const encodedData = encoder.encode(randomString);
  const hash = await crypto.subtle.digest('SHA-256', encodedData);
  const bytes = new Uint8Array(hash);
  return Array.from(bytes).map(c => String.fromCharCode(c)).join('');
}
function base64urlencode(str) {
  return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}
async function generatePKCEChallenge(verifier) {
  const hasCryptoSupport = typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined' && typeof TextEncoder !== 'undefined';
  if (!hasCryptoSupport) {
    console.warn('WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.');
    return verifier;
  }
  const hashed = await sha256(verifier);
  return base64urlencode(hashed);
}
},{"_bundle_loader":"../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/bundle-loader.js","@supabase/node-fetch":[["browser.d202933b.js","../node_modules/@supabase/node-fetch/browser.js"],"browser.d202933b.js.map","../node_modules/@supabase/node-fetch/browser.js"]}],"../node_modules/@supabase/gotrue-js/dist/module/lib/errors.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomAuthError = exports.AuthWeakPasswordError = exports.AuthUnknownError = exports.AuthSessionMissingError = exports.AuthRetryableFetchError = exports.AuthPKCEGrantCodeExchangeError = exports.AuthInvalidTokenResponseError = exports.AuthInvalidCredentialsError = exports.AuthImplicitGrantRedirectError = exports.AuthError = exports.AuthApiError = void 0;
exports.isAuthApiError = isAuthApiError;
exports.isAuthError = isAuthError;
exports.isAuthRetryableFetchError = isAuthRetryableFetchError;
exports.isAuthWeakPasswordError = isAuthWeakPasswordError;
class AuthError extends Error {
  constructor(message, status) {
    super(message);
    this.__isAuthError = true;
    this.name = 'AuthError';
    this.status = status;
  }
}
exports.AuthError = AuthError;
function isAuthError(error) {
  return typeof error === 'object' && error !== null && '__isAuthError' in error;
}
class AuthApiError extends AuthError {
  constructor(message, status) {
    super(message, status);
    this.name = 'AuthApiError';
    this.status = status;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
}
exports.AuthApiError = AuthApiError;
function isAuthApiError(error) {
  return isAuthError(error) && error.name === 'AuthApiError';
}
class AuthUnknownError extends AuthError {
  constructor(message, originalError) {
    super(message);
    this.name = 'AuthUnknownError';
    this.originalError = originalError;
  }
}
exports.AuthUnknownError = AuthUnknownError;
class CustomAuthError extends AuthError {
  constructor(message, name, status) {
    super(message);
    this.name = name;
    this.status = status;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
}
exports.CustomAuthError = CustomAuthError;
class AuthSessionMissingError extends CustomAuthError {
  constructor() {
    super('Auth session missing!', 'AuthSessionMissingError', 400);
  }
}
exports.AuthSessionMissingError = AuthSessionMissingError;
class AuthInvalidTokenResponseError extends CustomAuthError {
  constructor() {
    super('Auth session or user missing', 'AuthInvalidTokenResponseError', 500);
  }
}
exports.AuthInvalidTokenResponseError = AuthInvalidTokenResponseError;
class AuthInvalidCredentialsError extends CustomAuthError {
  constructor(message) {
    super(message, 'AuthInvalidCredentialsError', 400);
  }
}
exports.AuthInvalidCredentialsError = AuthInvalidCredentialsError;
class AuthImplicitGrantRedirectError extends CustomAuthError {
  constructor(message, details = null) {
    super(message, 'AuthImplicitGrantRedirectError', 500);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
}
exports.AuthImplicitGrantRedirectError = AuthImplicitGrantRedirectError;
class AuthPKCEGrantCodeExchangeError extends CustomAuthError {
  constructor(message, details = null) {
    super(message, 'AuthPKCEGrantCodeExchangeError', 500);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
}
exports.AuthPKCEGrantCodeExchangeError = AuthPKCEGrantCodeExchangeError;
class AuthRetryableFetchError extends CustomAuthError {
  constructor(message, status) {
    super(message, 'AuthRetryableFetchError', status);
  }
}
exports.AuthRetryableFetchError = AuthRetryableFetchError;
function isAuthRetryableFetchError(error) {
  return isAuthError(error) && error.name === 'AuthRetryableFetchError';
}
/**
 * This error is thrown on certain methods when the password used is deemed
 * weak. Inspect the reasons to identify what password strength rules are
 * inadequate.
 */
class AuthWeakPasswordError extends CustomAuthError {
  constructor(message, status, reasons) {
    super(message, 'AuthWeakPasswordError', status);
    this.reasons = reasons;
  }
}
exports.AuthWeakPasswordError = AuthWeakPasswordError;
function isAuthWeakPasswordError(error) {
  return isAuthError(error) && error.name === 'AuthWeakPasswordError';
}
},{}],"../node_modules/@supabase/gotrue-js/dist/module/lib/fetch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._generateLinkResponse = _generateLinkResponse;
exports._noResolveJsonResponse = _noResolveJsonResponse;
exports._request = _request;
exports._sessionResponse = _sessionResponse;
exports._sessionResponsePassword = _sessionResponsePassword;
exports._ssoResponse = _ssoResponse;
exports._userResponse = _userResponse;
var _helpers = require("./helpers");
var _errors = require("./errors");
var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
const _getErrorMessage = err => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const NETWORK_ERROR_CODES = [502, 503, 504];
async function handleError(error) {
  if (!(0, _helpers.looksLikeFetchResponse)(error)) {
    throw new _errors.AuthRetryableFetchError(_getErrorMessage(error), 0);
  }
  if (NETWORK_ERROR_CODES.includes(error.status)) {
    // status in 500...599 range - server had an error, request might be retryed.
    throw new _errors.AuthRetryableFetchError(_getErrorMessage(error), error.status);
  }
  let data;
  try {
    data = await error.json();
  } catch (e) {
    throw new _errors.AuthUnknownError(_getErrorMessage(e), e);
  }
  if (typeof data === 'object' && data && typeof data.weak_password === 'object' && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i) => a && typeof i === 'string', true)) {
    throw new _errors.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);
  }
  throw new _errors.AuthApiError(_getErrorMessage(data), error.status || 500);
}
const _getRequestParams = (method, options, parameters, body) => {
  const params = {
    method,
    headers: (options === null || options === void 0 ? void 0 : options.headers) || {}
  };
  if (method === 'GET') {
    return params;
  }
  params.headers = Object.assign({
    'Content-Type': 'application/json;charset=UTF-8'
  }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body);
  return Object.assign(Object.assign({}, params), parameters);
};
async function _request(fetcher, method, url, options) {
  var _a;
  const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
  if (options === null || options === void 0 ? void 0 : options.jwt) {
    headers['Authorization'] = `Bearer ${options.jwt}`;
  }
  const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};
  if (options === null || options === void 0 ? void 0 : options.redirectTo) {
    qs['redirect_to'] = options.redirectTo;
  }
  const queryString = Object.keys(qs).length ? '?' + new URLSearchParams(qs).toString() : '';
  const data = await _handleRequest(fetcher, method, url + queryString, {
    headers,
    noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
  }, {}, options === null || options === void 0 ? void 0 : options.body);
  return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : {
    data: Object.assign({}, data),
    error: null
  };
}
async function _handleRequest(fetcher, method, url, options, parameters, body) {
  const requestParams = _getRequestParams(method, options, parameters, body);
  let result;
  try {
    result = await fetcher(url, requestParams);
  } catch (e) {
    console.error(e);
    // fetch failed, likely due to a network or CORS error
    throw new _errors.AuthRetryableFetchError(_getErrorMessage(e), 0);
  }
  if (!result.ok) {
    await handleError(result);
  }
  if (options === null || options === void 0 ? void 0 : options.noResolveJson) {
    return result;
  }
  try {
    return await result.json();
  } catch (e) {
    await handleError(e);
  }
}
function _sessionResponse(data) {
  var _a;
  let session = null;
  if (hasSession(data)) {
    session = Object.assign({}, data);
    if (!data.expires_at) {
      session.expires_at = (0, _helpers.expiresAt)(data.expires_in);
    }
  }
  const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
  return {
    data: {
      session,
      user
    },
    error: null
  };
}
function _sessionResponsePassword(data) {
  const response = _sessionResponse(data);
  if (!response.error && data.weak_password && typeof data.weak_password === 'object' && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === 'string' && data.weak_password.reasons.reduce((a, i) => a && typeof i === 'string', true)) {
    response.data.weak_password = data.weak_password;
  }
  return response;
}
function _userResponse(data) {
  var _a;
  const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
  return {
    data: {
      user
    },
    error: null
  };
}
function _ssoResponse(data) {
  return {
    data,
    error: null
  };
}
function _generateLinkResponse(data) {
  const {
      action_link,
      email_otp,
      hashed_token,
      redirect_to,
      verification_type
    } = data,
    rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
  const properties = {
    action_link,
    email_otp,
    hashed_token,
    redirect_to,
    verification_type
  };
  const user = Object.assign({}, rest);
  return {
    data: {
      properties,
      user
    },
    error: null
  };
}
function _noResolveJsonResponse(data) {
  return data;
}
/**
 * hasSession checks if the response object contains a valid session
 * @param data A response object
 * @returns true if a session is in the response
 */
function hasSession(data) {
  return data.access_token && data.refresh_token && data.expires_in;
}
},{"./helpers":"../node_modules/@supabase/gotrue-js/dist/module/lib/helpers.js","./errors":"../node_modules/@supabase/gotrue-js/dist/module/lib/errors.js"}],"../node_modules/@supabase/gotrue-js/dist/module/GoTrueAdminApi.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _fetch = require("./lib/fetch");
var _helpers = require("./lib/helpers");
var _errors = require("./lib/errors");
var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
class GoTrueAdminApi {
  constructor({
    url = '',
    headers = {},
    fetch
  }) {
    this.url = url;
    this.headers = headers;
    this.fetch = (0, _helpers.resolveFetch)(fetch);
    this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    };
  }
  /**
   * Removes a logged-in session.
   * @param jwt A valid, logged-in JWT.
   * @param scope The logout sope.
   */
  async signOut(jwt, scope = 'global') {
    try {
      await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/logout?scope=${scope}`, {
        headers: this.headers,
        jwt,
        noResolveJson: true
      });
      return {
        data: null,
        error: null
      };
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  /**
   * Sends an invite link to an email address.
   * @param email The email address of the user.
   * @param options Additional options to be included when inviting.
   */
  async inviteUserByEmail(email, options = {}) {
    try {
      return await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/invite`, {
        body: {
          email,
          data: options.data
        },
        headers: this.headers,
        redirectTo: options.redirectTo,
        xform: _fetch._userResponse
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Generates email links and OTPs to be sent via a custom email provider.
   * @param email The user's email.
   * @param options.password User password. For signup only.
   * @param options.data Optional user metadata. For signup only.
   * @param options.redirectTo The redirect url which should be appended to the generated link
   */
  async generateLink(params) {
    try {
      const {
          options
        } = params,
        rest = __rest(params, ["options"]);
      const body = Object.assign(Object.assign({}, rest), options);
      if ('newEmail' in rest) {
        // replace newEmail with new_email in request body
        body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
        delete body['newEmail'];
      }
      return await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/admin/generate_link`, {
        body: body,
        headers: this.headers,
        xform: _fetch._generateLinkResponse,
        redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            properties: null,
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  // User Admin API
  /**
   * Creates a new user.
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async createUser(attributes) {
    try {
      return await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/admin/users`, {
        body: attributes,
        headers: this.headers,
        xform: _fetch._userResponse
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Get a list of users.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
   */
  async listUsers(params) {
    var _a, _b, _c, _d, _e, _f, _g;
    try {
      const pagination = {
        nextPage: null,
        lastPage: 0,
        total: 0
      };
      const response = await (0, _fetch._request)(this.fetch, 'GET', `${this.url}/admin/users`, {
        headers: this.headers,
        noResolveJson: true,
        query: {
          page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '',
          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''
        },
        xform: _fetch._noResolveJsonResponse
      });
      if (response.error) throw response.error;
      const users = await response.json();
      const total = (_e = response.headers.get('x-total-count')) !== null && _e !== void 0 ? _e : 0;
      const links = (_g = (_f = response.headers.get('link')) === null || _f === void 0 ? void 0 : _f.split(',')) !== null && _g !== void 0 ? _g : [];
      if (links.length > 0) {
        links.forEach(link => {
          const page = parseInt(link.split(';')[0].split('=')[1].substring(0, 1));
          const rel = JSON.parse(link.split(';')[1].split('=')[1]);
          pagination[`${rel}Page`] = page;
        });
        pagination.total = parseInt(total);
      }
      return {
        data: Object.assign(Object.assign({}, users), pagination),
        error: null
      };
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            users: []
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Get user by id.
   *
   * @param uid The user's unique identifier
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async getUserById(uid) {
    try {
      return await (0, _fetch._request)(this.fetch, 'GET', `${this.url}/admin/users/${uid}`, {
        headers: this.headers,
        xform: _fetch._userResponse
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Updates the user data.
   *
   * @param attributes The data you want to update.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async updateUserById(uid, attributes) {
    try {
      return await (0, _fetch._request)(this.fetch, 'PUT', `${this.url}/admin/users/${uid}`, {
        body: attributes,
        headers: this.headers,
        xform: _fetch._userResponse
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Delete a user. Requires a `service_role` key.
   *
   * @param id The user id you want to remove.
   * @param shouldSoftDelete If true, then the user will be soft-deleted (setting `deleted_at` to the current timestamp and disabling their account while preserving their data) from the auth schema.
   * Defaults to false for backward compatibility.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async deleteUser(id, shouldSoftDelete = false) {
    try {
      return await (0, _fetch._request)(this.fetch, 'DELETE', `${this.url}/admin/users/${id}`, {
        headers: this.headers,
        body: {
          should_soft_delete: shouldSoftDelete
        },
        xform: _fetch._userResponse
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  async _listFactors(params) {
    try {
      const {
        data,
        error
      } = await (0, _fetch._request)(this.fetch, 'GET', `${this.url}/admin/users/${params.userId}/factors`, {
        headers: this.headers,
        xform: factors => {
          return {
            data: {
              factors
            },
            error: null
          };
        }
      });
      return {
        data,
        error
      };
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  async _deleteFactor(params) {
    try {
      const data = await (0, _fetch._request)(this.fetch, 'DELETE', `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {
        headers: this.headers
      });
      return {
        data,
        error: null
      };
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
}
exports.default = GoTrueAdminApi;
},{"./lib/fetch":"../node_modules/@supabase/gotrue-js/dist/module/lib/fetch.js","./lib/helpers":"../node_modules/@supabase/gotrue-js/dist/module/lib/helpers.js","./lib/errors":"../node_modules/@supabase/gotrue-js/dist/module/lib/errors.js"}],"../node_modules/@supabase/gotrue-js/dist/module/lib/version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
// Generated by genversion.
const version = exports.version = '0.0.0';
},{}],"../node_modules/@supabase/gotrue-js/dist/module/lib/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.STORAGE_KEY = exports.NETWORK_FAILURE = exports.GOTRUE_URL = exports.EXPIRY_MARGIN = exports.DEFAULT_HEADERS = exports.AUDIENCE = void 0;
var _version = require("./version");
const GOTRUE_URL = exports.GOTRUE_URL = 'http://localhost:9999';
const STORAGE_KEY = exports.STORAGE_KEY = 'supabase.auth.token';
const AUDIENCE = exports.AUDIENCE = '';
const DEFAULT_HEADERS = exports.DEFAULT_HEADERS = {
  'X-Client-Info': `gotrue-js/${_version.version}`
};
const EXPIRY_MARGIN = exports.EXPIRY_MARGIN = 10; // in seconds
const NETWORK_FAILURE = exports.NETWORK_FAILURE = {
  MAX_RETRIES: 10,
  RETRY_INTERVAL: 2 // in deciseconds
};
},{"./version":"../node_modules/@supabase/gotrue-js/dist/module/lib/version.js"}],"../node_modules/@supabase/gotrue-js/dist/module/lib/local-storage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.localStorageAdapter = void 0;
exports.memoryLocalStorageAdapter = memoryLocalStorageAdapter;
var _helpers = require("./helpers");
/**
 * Provides safe access to the globalThis.localStorage property.
 */
const localStorageAdapter = exports.localStorageAdapter = {
  getItem: key => {
    if (!(0, _helpers.supportsLocalStorage)()) {
      return null;
    }
    return globalThis.localStorage.getItem(key);
  },
  setItem: (key, value) => {
    if (!(0, _helpers.supportsLocalStorage)()) {
      return;
    }
    globalThis.localStorage.setItem(key, value);
  },
  removeItem: key => {
    if (!(0, _helpers.supportsLocalStorage)()) {
      return;
    }
    globalThis.localStorage.removeItem(key);
  }
};
/**
 * Returns a localStorage-like object that stores the key-value pairs in
 * memory.
 */
function memoryLocalStorageAdapter(store = {}) {
  return {
    getItem: key => {
      return store[key] || null;
    },
    setItem: (key, value) => {
      store[key] = value;
    },
    removeItem: key => {
      delete store[key];
    }
  };
}
},{"./helpers":"../node_modules/@supabase/gotrue-js/dist/module/lib/helpers.js"}],"../node_modules/@supabase/gotrue-js/dist/module/lib/polyfills.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polyfillGlobalThis = polyfillGlobalThis;
/**
 * https://mathiasbynens.be/notes/globalthis
 */
function polyfillGlobalThis() {
  if (typeof globalThis === 'object') return;
  try {
    Object.defineProperty(Object.prototype, '__magic__', {
      get: function () {
        return this;
      },
      configurable: true
    });
    // @ts-expect-error 'Allow access to magic'
    __magic__.globalThis = __magic__;
    // @ts-expect-error 'Allow access to magic'
    delete Object.prototype.__magic__;
  } catch (e) {
    if (typeof self !== 'undefined') {
      // @ts-expect-error 'Allow access to globals'
      self.globalThis = self;
    }
  }
}
},{}],"../node_modules/@supabase/gotrue-js/dist/module/lib/locks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.internals = exports.NavigatorLockAcquireTimeoutError = exports.LockAcquireTimeoutError = void 0;
exports.navigatorLock = navigatorLock;
var _helpers = require("./helpers");
/**
 * @experimental
 */
const internals = exports.internals = {
  /**
   * @experimental
   */
  debug: !!(globalThis && (0, _helpers.supportsLocalStorage)() && globalThis.localStorage && globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true')
};
/**
 * An error thrown when a lock cannot be acquired after some amount of time.
 *
 * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.
 */
class LockAcquireTimeoutError extends Error {
  constructor(message) {
    super(message);
    this.isAcquireTimeout = true;
  }
}
exports.LockAcquireTimeoutError = LockAcquireTimeoutError;
class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {}
/**
 * Implements a global exclusive lock using the Navigator LockManager API. It
 * is available on all browsers released after 2022-03-15 with Safari being the
 * last one to release support. If the API is not available, this function will
 * throw. Make sure you check availablility before configuring {@link
 * GoTrueClient}.
 *
 * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`
 * local storage item to `true`.
 *
 * Internals:
 *
 * Since the LockManager API does not preserve stack traces for the async
 * function passed in the `request` method, a trick is used where acquiring the
 * lock releases a previously started promise to run the operation in the `fn`
 * function. The lock waits for that promise to finish (with or without error),
 * while the function will finally wait for the result anyway.
 *
 * @param name Name of the lock to be acquired.
 * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if
 *                       the lock can't be acquired without waiting. If positive, the lock acquire
 *                       will time out after so many milliseconds. An error is
 *                       a timeout if it has `isAcquireTimeout` set to true.
 * @param fn The operation to run once the lock is acquired.
 */
exports.NavigatorLockAcquireTimeoutError = NavigatorLockAcquireTimeoutError;
async function navigatorLock(name, acquireTimeout, fn) {
  if (internals.debug) {
    console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);
  }
  const abortController = new globalThis.AbortController();
  if (acquireTimeout > 0) {
    setTimeout(() => {
      abortController.abort();
      if (internals.debug) {
        console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);
      }
    }, acquireTimeout);
  }
  // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request
  return await globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {
    mode: 'exclusive',
    ifAvailable: true
  } : {
    mode: 'exclusive',
    signal: abortController.signal
  }, async lock => {
    if (lock) {
      if (internals.debug) {
        console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);
      }
      try {
        return await fn();
      } finally {
        if (internals.debug) {
          console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);
        }
      }
    } else {
      if (acquireTimeout === 0) {
        if (internals.debug) {
          console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);
        }
        throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);
      } else {
        if (internals.debug) {
          try {
            const result = await globalThis.navigator.locks.query();
            console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));
          } catch (e) {
            console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);
          }
        }
        // Browser is not following the Navigator LockManager spec, it
        // returned a null lock when we didn't use ifAvailable. So we can
        // pretend the lock is acquired in the name of backward compatibility
        // and user experience and just run the function.
        console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');
        return await fn();
      }
    }
  });
}
},{"./helpers":"../node_modules/@supabase/gotrue-js/dist/module/lib/helpers.js"}],"../node_modules/@supabase/gotrue-js/dist/module/GoTrueClient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _GoTrueAdminApi = _interopRequireDefault(require("./GoTrueAdminApi"));
var _constants = require("./lib/constants");
var _errors = require("./lib/errors");
var _fetch = require("./lib/fetch");
var _helpers = require("./lib/helpers");
var _localStorage = require("./lib/local-storage");
var _polyfills = require("./lib/polyfills");
var _version = require("./lib/version");
var _locks = require("./lib/locks");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
(0, _polyfills.polyfillGlobalThis)(); // Make "globalThis" available
const DEFAULT_OPTIONS = {
  url: _constants.GOTRUE_URL,
  storageKey: _constants.STORAGE_KEY,
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  headers: _constants.DEFAULT_HEADERS,
  flowType: 'implicit',
  debug: false
};
/** Current session will be checked for refresh at this interval. */
const AUTO_REFRESH_TICK_DURATION = 30 * 1000;
/**
 * A token refresh will be attempted this many ticks before the current session expires. */
const AUTO_REFRESH_TICK_THRESHOLD = 3;
async function lockNoOp(name, acquireTimeout, fn) {
  return await fn();
}
class GoTrueClient {
  /**
   * Create a new client for use in the browser.
   */
  constructor(options) {
    var _a, _b;
    this.memoryStorage = null;
    this.stateChangeEmitters = new Map();
    this.autoRefreshTicker = null;
    this.visibilityChangedCallback = null;
    this.refreshingDeferred = null;
    /**
     * Keeps track of the async client initialization.
     * When null or not yet resolved the auth state is `unknown`
     * Once resolved the the auth state is known and it's save to call any further client methods.
     * Keep extra care to never reject or throw uncaught errors
     */
    this.initializePromise = null;
    this.detectSessionInUrl = true;
    this.lockAcquired = false;
    this.pendingInLock = [];
    /**
     * Used to broadcast state change events to other tabs listening.
     */
    this.broadcastChannel = null;
    this.logger = console.log;
    this.instanceID = GoTrueClient.nextInstanceID;
    GoTrueClient.nextInstanceID += 1;
    if (this.instanceID > 0 && (0, _helpers.isBrowser)()) {
      console.warn('Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.');
    }
    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    this.logDebugMessages = !!settings.debug;
    if (typeof settings.debug === 'function') {
      this.logger = settings.debug;
    }
    this.persistSession = settings.persistSession;
    this.storageKey = settings.storageKey;
    this.autoRefreshToken = settings.autoRefreshToken;
    this.admin = new _GoTrueAdminApi.default({
      url: settings.url,
      headers: settings.headers,
      fetch: settings.fetch
    });
    this.url = settings.url;
    this.headers = settings.headers;
    this.fetch = (0, _helpers.resolveFetch)(settings.fetch);
    this.lock = settings.lock || lockNoOp;
    this.detectSessionInUrl = settings.detectSessionInUrl;
    this.flowType = settings.flowType;
    if (settings.lock) {
      this.lock = settings.lock;
    } else if ((0, _helpers.isBrowser)() && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.locks)) {
      this.lock = _locks.navigatorLock;
    } else {
      this.lock = lockNoOp;
    }
    this.mfa = {
      verify: this._verify.bind(this),
      enroll: this._enroll.bind(this),
      unenroll: this._unenroll.bind(this),
      challenge: this._challenge.bind(this),
      listFactors: this._listFactors.bind(this),
      challengeAndVerify: this._challengeAndVerify.bind(this),
      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)
    };
    if (this.persistSession) {
      if (settings.storage) {
        this.storage = settings.storage;
      } else {
        if ((0, _helpers.supportsLocalStorage)()) {
          this.storage = _localStorage.localStorageAdapter;
        } else {
          this.memoryStorage = {};
          this.storage = (0, _localStorage.memoryLocalStorageAdapter)(this.memoryStorage);
        }
      }
    } else {
      this.memoryStorage = {};
      this.storage = (0, _localStorage.memoryLocalStorageAdapter)(this.memoryStorage);
    }
    if ((0, _helpers.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
      } catch (e) {
        console.error('Failed to create a new BroadcastChannel, multi-tab state changes will not be available', e);
      }
      (_b = this.broadcastChannel) === null || _b === void 0 ? void 0 : _b.addEventListener('message', async event => {
        this._debug('received broadcast notification from other tab or client', event);
        await this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages
      });
    }
    this.initialize();
  }
  _debug(...args) {
    if (this.logDebugMessages) {
      this.logger(`GoTrueClient@${this.instanceID} (${_version.version}) ${new Date().toISOString()}`, ...args);
    }
    return this;
  }
  /**
   * Initializes the client session either from the url or from storage.
   * This method is automatically called when instantiating the client, but should also be called
   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
   */
  async initialize() {
    if (this.initializePromise) {
      return await this.initializePromise;
    }
    this.initializePromise = (async () => {
      return await this._acquireLock(-1, async () => {
        return await this._initialize();
      });
    })();
    return await this.initializePromise;
  }
  /**
   * IMPORTANT:
   * 1. Never throw in this method, as it is called from the constructor
   * 2. Never return a session from this method as it would be cached over
   *    the whole lifetime of the client
   */
  async _initialize() {
    try {
      const isPKCEFlow = (0, _helpers.isBrowser)() ? await this._isPKCEFlow() : false;
      this._debug('#_initialize()', 'begin', 'is PKCE flow', isPKCEFlow);
      if (isPKCEFlow || this.detectSessionInUrl && this._isImplicitGrantFlow()) {
        const {
          data,
          error
        } = await this._getSessionFromURL(isPKCEFlow);
        if (error) {
          this._debug('#_initialize()', 'error detecting session from URL', error);
          // hacky workaround to keep the existing session if there's an error returned from identity linking
          // TODO: once error codes are ready, we should match against it instead of the message
          if ((error === null || error === void 0 ? void 0 : error.message) === 'Identity is already linked' || (error === null || error === void 0 ? void 0 : error.message) === 'Identity is already linked to another user') {
            return {
              error
            };
          }
          // failed login attempt via url,
          // remove old session as in verifyOtp, signUp and signInWith*
          await this._removeSession();
          return {
            error
          };
        }
        const {
          session,
          redirectType
        } = data;
        this._debug('#_initialize()', 'detected session in URL', session, 'redirect type', redirectType);
        await this._saveSession(session);
        setTimeout(async () => {
          if (redirectType === 'recovery') {
            await this._notifyAllSubscribers('PASSWORD_RECOVERY', session);
          } else {
            await this._notifyAllSubscribers('SIGNED_IN', session);
          }
        }, 0);
        return {
          error: null
        };
      }
      // no login attempt via callback url try to recover session from storage
      await this._recoverAndRefresh();
      return {
        error: null
      };
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          error
        };
      }
      return {
        error: new _errors.AuthUnknownError('Unexpected error during initialization', error)
      };
    } finally {
      await this._handleVisibilityChange();
      this._debug('#_initialize()', 'end');
    }
  }
  /**
   * Creates a new user.
   *
   * Be aware that if a user account exists in the system you may get back an
   * error message that attempts to hide this information from the user.
   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
   *
   * @returns A logged-in session if the server has "autoconfirm" ON
   * @returns A user if the server has "autoconfirm" OFF
   */
  async signUp(credentials) {
    var _a, _b, _c;
    try {
      await this._removeSession();
      let res;
      if ('email' in credentials) {
        const {
          email,
          password,
          options
        } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === 'pkce') {
          const codeVerifier = (0, _helpers.generatePKCEVerifier)();
          await (0, _helpers.setItemAsync)(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);
          codeChallenge = await (0, _helpers.generatePKCEChallenge)(codeVerifier);
          codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';
        }
        res = await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/signup`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: {
            email,
            password,
            data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          xform: _fetch._sessionResponse
        });
      } else if ('phone' in credentials) {
        const {
          phone,
          password,
          options
        } = credentials;
        res = await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone,
            password,
            data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},
            channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : 'sms',
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            }
          },
          xform: _fetch._sessionResponse
        });
      } else {
        throw new _errors.AuthInvalidCredentialsError('You must provide either an email or phone number and a password');
      }
      const {
        data,
        error
      } = res;
      if (error || !data) {
        return {
          data: {
            user: null,
            session: null
          },
          error: error
        };
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers('SIGNED_IN', session);
      }
      return {
        data: {
          user,
          session
        },
        error: null
      };
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Log in an existing user with an email and password or phone and password.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or that the
   * email/phone and password combination is wrong or that the account can only
   * be accessed via social login.
   */
  async signInWithPassword(credentials) {
    try {
      await this._removeSession();
      let res;
      if ('email' in credentials) {
        const {
          email,
          password,
          options
        } = credentials;
        res = await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            email,
            password,
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            }
          },
          xform: _fetch._sessionResponsePassword
        });
      } else if ('phone' in credentials) {
        const {
          phone,
          password,
          options
        } = credentials;
        res = await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            phone,
            password,
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            }
          },
          xform: _fetch._sessionResponsePassword
        });
      } else {
        throw new _errors.AuthInvalidCredentialsError('You must provide either an email or phone number and a password');
      }
      const {
        data,
        error
      } = res;
      if (error) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      } else if (!data || !data.session || !data.user) {
        return {
          data: {
            user: null,
            session: null
          },
          error: new _errors.AuthInvalidTokenResponseError()
        };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers('SIGNED_IN', data.session);
      }
      return {
        data: Object.assign({
          user: data.user,
          session: data.session
        }, data.weak_password ? {
          weakPassword: data.weak_password
        } : null),
        error
      };
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Log in an existing user via a third-party provider.
   * This method supports the PKCE flow.
   */
  async signInWithOAuth(credentials) {
    var _a, _b, _c, _d;
    await this._removeSession();
    return await this._handleProviderSignIn(credentials.provider, {
      redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,
      scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
      queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
      skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect
    });
  }
  /**
   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
   */
  async exchangeCodeForSession(authCode) {
    await this.initializePromise;
    return this._acquireLock(-1, async () => {
      return this._exchangeCodeForSession(authCode);
    });
  }
  async _exchangeCodeForSession(authCode) {
    const storageItem = await (0, _helpers.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
    const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : '').split('/');
    const {
      data,
      error
    } = await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/token?grant_type=pkce`, {
      headers: this.headers,
      body: {
        auth_code: authCode,
        code_verifier: codeVerifier
      },
      xform: _fetch._sessionResponse
    });
    await (0, _helpers.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
    if (error) {
      return {
        data: {
          user: null,
          session: null,
          redirectType: null
        },
        error
      };
    } else if (!data || !data.session || !data.user) {
      return {
        data: {
          user: null,
          session: null,
          redirectType: null
        },
        error: new _errors.AuthInvalidTokenResponseError()
      };
    }
    if (data.session) {
      await this._saveSession(data.session);
      await this._notifyAllSubscribers('SIGNED_IN', data.session);
    }
    return {
      data: Object.assign(Object.assign({}, data), {
        redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null
      }),
      error
    };
  }
  /**
   * Allows signing in with an OIDC ID token. The authentication provider used
   * should be enabled and configured.
   */
  async signInWithIdToken(credentials) {
    await this._removeSession();
    try {
      const {
        options,
        provider,
        token,
        access_token,
        nonce
      } = credentials;
      const res = await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {
        headers: this.headers,
        body: {
          provider,
          id_token: token,
          access_token,
          nonce,
          gotrue_meta_security: {
            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
          }
        },
        xform: _fetch._sessionResponse
      });
      const {
        data,
        error
      } = res;
      if (error) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      } else if (!data || !data.session || !data.user) {
        return {
          data: {
            user: null,
            session: null
          },
          error: new _errors.AuthInvalidTokenResponseError()
        };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers('SIGNED_IN', data.session);
      }
      return {
        data,
        error
      };
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Log in a user using magiclink or a one-time password (OTP).
   *
   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or, that the account
   * can only be accessed via social login.
   *
   * Do note that you will need to configure a Whatsapp sender on Twilio
   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
   * channel is not supported on other providers
   * at this time.
   * This method supports PKCE when an email is passed.
   */
  async signInWithOtp(credentials) {
    var _a, _b, _c, _d, _e;
    try {
      await this._removeSession();
      if ('email' in credentials) {
        const {
          email,
          options
        } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === 'pkce') {
          const codeVerifier = (0, _helpers.generatePKCEVerifier)();
          await (0, _helpers.setItemAsync)(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);
          codeChallenge = await (0, _helpers.generatePKCEChallenge)(codeVerifier);
          codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';
        }
        const {
          error
        } = await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email,
            data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
            create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      if ('phone' in credentials) {
        const {
          phone,
          options
        } = credentials;
        const {
          data,
          error
        } = await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/otp`, {
          headers: this.headers,
          body: {
            phone,
            data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},
            create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            },
            channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : 'sms'
          }
        });
        return {
          data: {
            user: null,
            session: null,
            messageId: data === null || data === void 0 ? void 0 : data.message_id
          },
          error
        };
      }
      throw new _errors.AuthInvalidCredentialsError('You must provide either an email or phone number.');
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
   */
  async verifyOtp(params) {
    var _a, _b;
    try {
      if (params.type !== 'email_change' && params.type !== 'phone_change') {
        // we don't want to remove the authenticated session if the user is performing an email_change or phone_change verification
        await this._removeSession();
      }
      let redirectTo = undefined;
      let captchaToken = undefined;
      if ('options' in params) {
        redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo;
        captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;
      }
      const {
        data,
        error
      } = await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/verify`, {
        headers: this.headers,
        body: Object.assign(Object.assign({}, params), {
          gotrue_meta_security: {
            captcha_token: captchaToken
          }
        }),
        redirectTo,
        xform: _fetch._sessionResponse
      });
      if (error) {
        throw error;
      }
      if (!data) {
        throw new Error('An error occurred on token verification.');
      }
      const session = data.session;
      const user = data.user;
      if (session === null || session === void 0 ? void 0 : session.access_token) {
        await this._saveSession(session);
        await this._notifyAllSubscribers(params.type == 'recovery' ? 'PASSWORD_RECOVERY' : 'SIGNED_IN', session);
      }
      return {
        data: {
          user,
          session
        },
        error: null
      };
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Attempts a single-sign on using an enterprise Identity Provider. A
   * successful SSO attempt will redirect the current page to the identity
   * provider authorization page. The redirect URL is implementation and SSO
   * protocol specific.
   *
   * You can use it by providing a SSO domain. Typically you can extract this
   * domain by asking users for their email address. If this domain is
   * registered on the Auth instance the redirect will use that organization's
   * currently active SSO Identity Provider for the login.
   *
   * If you have built an organization-specific login page, you can use the
   * organization's SSO Identity Provider UUID directly instead.
   */
  async signInWithSSO(params) {
    var _a, _b, _c;
    try {
      await this._removeSession();
      let codeChallenge = null;
      let codeChallengeMethod = null;
      if (this.flowType === 'pkce') {
        const codeVerifier = (0, _helpers.generatePKCEVerifier)();
        await (0, _helpers.setItemAsync)(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);
        codeChallenge = await (0, _helpers.generatePKCEChallenge)(codeVerifier);
        codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';
      }
      return await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/sso`, {
        body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {
          provider_id: params.providerId
        } : null), 'domain' in params ? {
          domain: params.domain
        } : null), {
          redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined
        }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {
          gotrue_meta_security: {
            captcha_token: params.options.captchaToken
          }
        } : null), {
          skip_http_redirect: true,
          code_challenge: codeChallenge,
          code_challenge_method: codeChallengeMethod
        }),
        headers: this.headers,
        xform: _fetch._ssoResponse
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  /**
   * Sends a reauthentication OTP to the user's email or phone number.
   * Requires the user to be signed-in.
   */
  async reauthenticate() {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._reauthenticate();
    });
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async result => {
        const {
          data: {
            session
          },
          error: sessionError
        } = result;
        if (sessionError) throw sessionError;
        if (!session) throw new _errors.AuthSessionMissingError();
        const {
          error
        } = await (0, _fetch._request)(this.fetch, 'GET', `${this.url}/reauthenticate`, {
          headers: this.headers,
          jwt: session.access_token
        });
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
   */
  async resend(credentials) {
    try {
      if (credentials.type != 'email_change' && credentials.type != 'phone_change') {
        await this._removeSession();
      }
      const endpoint = `${this.url}/resend`;
      if ('email' in credentials) {
        const {
          email,
          type,
          options
        } = credentials;
        const {
          error
        } = await (0, _fetch._request)(this.fetch, 'POST', endpoint, {
          headers: this.headers,
          body: {
            email,
            type,
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            }
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      } else if ('phone' in credentials) {
        const {
          phone,
          type,
          options
        } = credentials;
        const {
          data,
          error
        } = await (0, _fetch._request)(this.fetch, 'POST', endpoint, {
          headers: this.headers,
          body: {
            phone,
            type,
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            }
          }
        });
        return {
          data: {
            user: null,
            session: null,
            messageId: data === null || data === void 0 ? void 0 : data.message_id
          },
          error
        };
      }
      throw new _errors.AuthInvalidCredentialsError('You must provide either an email or phone number and a type');
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Returns the session, refreshing it if necessary.
   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
   */
  async getSession() {
    await this.initializePromise;
    return this._acquireLock(-1, async () => {
      return this._useSession(async result => {
        return result;
      });
    });
  }
  /**
   * Acquires a global lock based on the storage key.
   */
  async _acquireLock(acquireTimeout, fn) {
    this._debug('#_acquireLock', 'begin', acquireTimeout);
    try {
      if (this.lockAcquired) {
        const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
        const result = (async () => {
          await last;
          return await fn();
        })();
        this.pendingInLock.push((async () => {
          try {
            await result;
          } catch (e) {
            // we just care if it finished
          }
        })());
        return result;
      }
      return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {
        this._debug('#_acquireLock', 'lock acquired for storage key', this.storageKey);
        try {
          this.lockAcquired = true;
          const result = fn();
          this.pendingInLock.push((async () => {
            try {
              await result;
            } catch (e) {
              // we just care if it finished
            }
          })());
          await result;
          // keep draining the queue until there's nothing to wait on
          while (this.pendingInLock.length) {
            const waitOn = [...this.pendingInLock];
            await Promise.all(waitOn);
            this.pendingInLock.splice(0, waitOn.length);
          }
          return await result;
        } finally {
          this._debug('#_acquireLock', 'lock released for storage key', this.storageKey);
          this.lockAcquired = false;
        }
      });
    } finally {
      this._debug('#_acquireLock', 'end');
    }
  }
  /**
   * Use instead of {@link #getSession} inside the library. It is
   * semantically usually what you want, as getting a session involves some
   * processing afterwards that requires only one client operating on the
   * session at once across multiple tabs or processes.
   */
  async _useSession(fn) {
    this._debug('#_useSession', 'begin');
    try {
      // the use of __loadSession here is the only correct use of the function!
      const result = await this.__loadSession();
      return await fn(result);
    } finally {
      this._debug('#_useSession', 'end');
    }
  }
  /**
   * NEVER USE DIRECTLY!
   *
   * Always use {@link #_useSession}.
   */
  async __loadSession() {
    this._debug('#__loadSession()', 'begin');
    if (!this.lockAcquired) {
      this._debug('#__loadSession()', 'used outside of an acquired lock!', new Error().stack);
    }
    try {
      let currentSession = null;
      const maybeSession = await (0, _helpers.getItemAsync)(this.storage, this.storageKey);
      this._debug('#getSession()', 'session from storage', maybeSession);
      if (maybeSession !== null) {
        if (this._isValidSession(maybeSession)) {
          currentSession = maybeSession;
        } else {
          this._debug('#getSession()', 'session from storage is not valid');
          await this._removeSession();
        }
      }
      if (!currentSession) {
        return {
          data: {
            session: null
          },
          error: null
        };
      }
      const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;
      this._debug('#__loadSession()', `session has${hasExpired ? '' : ' not'} expired`, 'expires_at', currentSession.expires_at);
      if (!hasExpired) {
        return {
          data: {
            session: currentSession
          },
          error: null
        };
      }
      const {
        session,
        error
      } = await this._callRefreshToken(currentSession.refresh_token);
      if (error) {
        return {
          data: {
            session: null
          },
          error
        };
      }
      return {
        data: {
          session
        },
        error: null
      };
    } finally {
      this._debug('#__loadSession()', 'end');
    }
  }
  /**
   * Gets the current user details if there is an existing session.
   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.
   */
  async getUser(jwt) {
    if (jwt) {
      return await this._getUser(jwt);
    }
    await this.initializePromise;
    return this._acquireLock(-1, async () => {
      return await this._getUser();
    });
  }
  async _getUser(jwt) {
    try {
      if (jwt) {
        return await (0, _fetch._request)(this.fetch, 'GET', `${this.url}/user`, {
          headers: this.headers,
          jwt: jwt,
          xform: _fetch._userResponse
        });
      }
      return await this._useSession(async result => {
        var _a, _b;
        const {
          data,
          error
        } = result;
        if (error) {
          throw error;
        }
        return await (0, _fetch._request)(this.fetch, 'GET', `${this.url}/user`, {
          headers: this.headers,
          jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined,
          xform: _fetch._userResponse
        });
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Updates user data for a logged in user.
   */
  async updateUser(attributes, options = {}) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._updateUser(attributes, options);
    });
  }
  async _updateUser(attributes, options = {}) {
    try {
      return await this._useSession(async result => {
        const {
          data: sessionData,
          error: sessionError
        } = result;
        if (sessionError) {
          throw sessionError;
        }
        if (!sessionData.session) {
          throw new _errors.AuthSessionMissingError();
        }
        const session = sessionData.session;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === 'pkce' && attributes.email != null) {
          const codeVerifier = (0, _helpers.generatePKCEVerifier)();
          await (0, _helpers.setItemAsync)(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);
          codeChallenge = await (0, _helpers.generatePKCEChallenge)(codeVerifier);
          codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';
        }
        const {
          data,
          error: userError
        } = await (0, _fetch._request)(this.fetch, 'PUT', `${this.url}/user`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: Object.assign(Object.assign({}, attributes), {
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          }),
          jwt: session.access_token,
          xform: _fetch._userResponse
        });
        if (userError) throw userError;
        session.user = data.user;
        await this._saveSession(session);
        await this._notifyAllSubscribers('USER_UPDATED', session);
        return {
          data: {
            user: session.user
          },
          error: null
        };
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Decodes a JWT (without performing any validation).
   */
  _decodeJWT(jwt) {
    return (0, _helpers.decodeJWTPayload)(jwt);
  }
  /**
   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
   * If the refresh token or access token in the current session is invalid, an error will be thrown.
   * @param currentSession The current session that minimally contains an access token and refresh token.
   */
  async setSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._setSession(currentSession);
    });
  }
  async _setSession(currentSession) {
    try {
      if (!currentSession.access_token || !currentSession.refresh_token) {
        throw new _errors.AuthSessionMissingError();
      }
      const timeNow = Date.now() / 1000;
      let expiresAt = timeNow;
      let hasExpired = true;
      let session = null;
      const payload = (0, _helpers.decodeJWTPayload)(currentSession.access_token);
      if (payload.exp) {
        expiresAt = payload.exp;
        hasExpired = expiresAt <= timeNow;
      }
      if (hasExpired) {
        const {
          session: refreshedSession,
          error
        } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return {
            data: {
              user: null,
              session: null
            },
            error: error
          };
        }
        if (!refreshedSession) {
          return {
            data: {
              user: null,
              session: null
            },
            error: null
          };
        }
        session = refreshedSession;
      } else {
        const {
          data,
          error
        } = await this._getUser(currentSession.access_token);
        if (error) {
          throw error;
        }
        session = {
          access_token: currentSession.access_token,
          refresh_token: currentSession.refresh_token,
          user: data.user,
          token_type: 'bearer',
          expires_in: expiresAt - timeNow,
          expires_at: expiresAt
        };
        await this._saveSession(session);
        await this._notifyAllSubscribers('SIGNED_IN', session);
      }
      return {
        data: {
          user: session.user,
          session
        },
        error: null
      };
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            session: null,
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Returns a new session, regardless of expiry status.
   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
   * If the current session's refresh token is invalid, an error will be thrown.
   * @param currentSession The current session. If passed in, it must contain a refresh token.
   */
  async refreshSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._refreshSession(currentSession);
    });
  }
  async _refreshSession(currentSession) {
    try {
      return await this._useSession(async result => {
        var _a;
        if (!currentSession) {
          const {
            data,
            error
          } = result;
          if (error) {
            throw error;
          }
          currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;
        }
        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {
          throw new _errors.AuthSessionMissingError();
        }
        const {
          session,
          error
        } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return {
            data: {
              user: null,
              session: null
            },
            error: error
          };
        }
        if (!session) {
          return {
            data: {
              user: null,
              session: null
            },
            error: null
          };
        }
        return {
          data: {
            user: session.user,
            session
          },
          error: null
        };
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Gets the session data from a URL string
   */
  async _getSessionFromURL(isPKCEFlow) {
    try {
      if (!(0, _helpers.isBrowser)()) throw new _errors.AuthImplicitGrantRedirectError('No browser detected.');
      if (this.flowType === 'implicit' && !this._isImplicitGrantFlow()) {
        throw new _errors.AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');
      } else if (this.flowType == 'pkce' && !isPKCEFlow) {
        throw new _errors.AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.');
      }
      const params = (0, _helpers.parseParametersFromURL)(window.location.href);
      if (isPKCEFlow) {
        if (!params.code) throw new _errors.AuthPKCEGrantCodeExchangeError('No code detected.');
        const {
          data,
          error
        } = await this._exchangeCodeForSession(params.code);
        if (error) throw error;
        const url = new URL(window.location.href);
        url.searchParams.delete('code');
        window.history.replaceState(window.history.state, '', url.toString());
        return {
          data: {
            session: data.session,
            redirectType: null
          },
          error: null
        };
      }
      if (params.error || params.error_description || params.error_code) {
        throw new _errors.AuthImplicitGrantRedirectError(params.error_description || 'Error in URL with unspecified error_description', {
          error: params.error || 'unspecified_error',
          code: params.error_code || 'unspecified_code'
        });
      }
      const {
        provider_token,
        provider_refresh_token,
        access_token,
        refresh_token,
        expires_in,
        expires_at,
        token_type
      } = params;
      if (!access_token || !expires_in || !refresh_token || !token_type) {
        throw new _errors.AuthImplicitGrantRedirectError('No session defined in URL');
      }
      const timeNow = Math.round(Date.now() / 1000);
      const expiresIn = parseInt(expires_in);
      let expiresAt = timeNow + expiresIn;
      if (expires_at) {
        expiresAt = parseInt(expires_at);
      }
      const actuallyExpiresIn = expiresAt - timeNow;
      if (actuallyExpiresIn * 1000 <= AUTO_REFRESH_TICK_DURATION) {
        console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);
      }
      const issuedAt = expiresAt - expiresIn;
      if (timeNow - issuedAt >= 120) {
        console.warn('@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale', issuedAt, expiresAt, timeNow);
      } else if (timeNow - issuedAt < 0) {
        console.warn('@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clok for skew', issuedAt, expiresAt, timeNow);
      }
      const {
        data,
        error
      } = await this._getUser(access_token);
      if (error) throw error;
      const session = {
        provider_token,
        provider_refresh_token,
        access_token,
        expires_in: expiresIn,
        expires_at: expiresAt,
        refresh_token,
        token_type,
        user: data.user
      };
      // Remove tokens from URL
      window.location.hash = '';
      this._debug('#_getSessionFromURL()', 'clearing window.location.hash');
      return {
        data: {
          session,
          redirectType: params.type
        },
        error: null
      };
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            session: null,
            redirectType: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
   */
  _isImplicitGrantFlow() {
    const params = (0, _helpers.parseParametersFromURL)(window.location.href);
    return !!((0, _helpers.isBrowser)() && (params.access_token || params.error_description));
  }
  /**
   * Checks if the current URL and backing storage contain parameters given by a PKCE flow
   */
  async _isPKCEFlow() {
    const params = (0, _helpers.parseParametersFromURL)(window.location.href);
    const currentStorageContent = await (0, _helpers.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
    return !!(params.code && currentStorageContent);
  }
  /**
   * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
   *
   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
   *
   * If using `others` scope, no `SIGNED_OUT` event is fired!
   */
  async signOut(options = {
    scope: 'global'
  }) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._signOut(options);
    });
  }
  async _signOut({
    scope
  } = {
    scope: 'global'
  }) {
    return await this._useSession(async result => {
      var _a;
      const {
        data,
        error: sessionError
      } = result;
      if (sessionError) {
        return {
          error: sessionError
        };
      }
      const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;
      if (accessToken) {
        const {
          error
        } = await this.admin.signOut(accessToken, scope);
        if (error) {
          // ignore 404s since user might not exist anymore
          // ignore 401s since an invalid or expired JWT should sign out the current session
          if (!((0, _errors.isAuthApiError)(error) && (error.status === 404 || error.status === 401))) {
            return {
              error
            };
          }
        }
      }
      if (scope !== 'others') {
        await this._removeSession();
        await (0, _helpers.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        await this._notifyAllSubscribers('SIGNED_OUT', null);
      }
      return {
        error: null
      };
    });
  }
  /**
   * Receive a notification every time an auth event happens.
   * @param callback A callback function to be invoked when an auth event happens.
   */
  onAuthStateChange(callback) {
    const id = (0, _helpers.uuid)();
    const subscription = {
      id,
      callback,
      unsubscribe: () => {
        this._debug('#unsubscribe()', 'state change callback with id removed', id);
        this.stateChangeEmitters.delete(id);
      }
    };
    this._debug('#onAuthStateChange()', 'registered callback with id', id);
    this.stateChangeEmitters.set(id, subscription);
    (async () => {
      await this.initializePromise;
      await this._acquireLock(-1, async () => {
        this._emitInitialSession(id);
      });
    })();
    return {
      data: {
        subscription
      }
    };
  }
  async _emitInitialSession(id) {
    return await this._useSession(async result => {
      var _a, _b;
      try {
        const {
          data: {
            session
          },
          error
        } = result;
        if (error) throw error;
        await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback('INITIAL_SESSION', session));
        this._debug('INITIAL_SESSION', 'callback id', id, 'session', session);
      } catch (err) {
        await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback('INITIAL_SESSION', null));
        this._debug('INITIAL_SESSION', 'callback id', id, 'error', err);
        console.error(err);
      }
    });
  }
  /**
   * Sends a password reset request to an email address. This method supports the PKCE flow.
   *
   * @param email The email address of the user.
   * @param options.redirectTo The URL to send the user to after they click the password reset link.
   * @param options.captchaToken Verification token received when the user completes the captcha on the site.
   */
  async resetPasswordForEmail(email, options = {}) {
    let codeChallenge = null;
    let codeChallengeMethod = null;
    if (this.flowType === 'pkce') {
      const codeVerifier = (0, _helpers.generatePKCEVerifier)();
      await (0, _helpers.setItemAsync)(this.storage, `${this.storageKey}-code-verifier`, `${codeVerifier}/PASSWORD_RECOVERY`);
      codeChallenge = await (0, _helpers.generatePKCEChallenge)(codeVerifier);
      codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';
    }
    try {
      return await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/recover`, {
        body: {
          email,
          code_challenge: codeChallenge,
          code_challenge_method: codeChallengeMethod,
          gotrue_meta_security: {
            captcha_token: options.captchaToken
          }
        },
        headers: this.headers,
        redirectTo: options.redirectTo
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  /**
   * Gets all the identities linked to a user.
   */
  async getUserIdentities() {
    var _a;
    try {
      const {
        data,
        error
      } = await this.getUser();
      if (error) throw error;
      return {
        data: {
          identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : []
        },
        error: null
      };
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  /**
   * Links an oauth identity to an existing user.
   * This method supports the PKCE flow.
   */
  async linkIdentity(credentials) {
    var _a;
    try {
      const {
        data,
        error
      } = await this._useSession(async result => {
        var _a, _b, _c, _d, _e;
        const {
          data,
          error
        } = result;
        if (error) throw error;
        const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {
          redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,
          scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
          queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
          skipBrowserRedirect: true
        });
        return await (0, _fetch._request)(this.fetch, 'GET', url, {
          headers: this.headers,
          jwt: (_e = (_d = data.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : undefined
        });
      });
      if (error) throw error;
      if ((0, _helpers.isBrowser)() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) {
        window.location.assign(data === null || data === void 0 ? void 0 : data.url);
      }
      return {
        data: {
          provider: credentials.provider,
          url: data === null || data === void 0 ? void 0 : data.url
        },
        error: null
      };
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            provider: credentials.provider,
            url: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
   */
  async unlinkIdentity(identity) {
    try {
      return await this._useSession(async result => {
        var _a, _b;
        const {
          data,
          error
        } = result;
        if (error) {
          throw error;
        }
        return await (0, _fetch._request)(this.fetch, 'DELETE', `${this.url}/user/identities/${identity.identity_id}`, {
          headers: this.headers,
          jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined
        });
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  /**
   * Generates a new JWT.
   * @param refreshToken A valid refresh token that was returned on login.
   */
  async _refreshAccessToken(refreshToken) {
    const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, 'begin');
    try {
      const startedAt = Date.now();
      // will attempt to refresh the token with exponential backoff
      return await (0, _helpers.retryable)(async attempt => {
        await (0, _helpers.sleep)(attempt * 200); // 0, 200, 400, 800, ...
        this._debug(debugName, 'refreshing attempt', attempt);
        return await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {
          body: {
            refresh_token: refreshToken
          },
          headers: this.headers,
          xform: _fetch._sessionResponse
        });
      }, (attempt, _, result) => result && result.error && (0, _errors.isAuthRetryableFetchError)(result.error) &&
      // retryable only if the request can be sent before the backoff overflows the tick duration
      Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION);
    } catch (error) {
      this._debug(debugName, 'error', error);
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: {
            session: null,
            user: null
          },
          error
        };
      }
      throw error;
    } finally {
      this._debug(debugName, 'end');
    }
  }
  _isValidSession(maybeSession) {
    const isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;
    return isValidSession;
  }
  async _handleProviderSignIn(provider, options) {
    const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {
      redirectTo: options.redirectTo,
      scopes: options.scopes,
      queryParams: options.queryParams
    });
    this._debug('#_handleProviderSignIn()', 'provider', provider, 'options', options, 'url', url);
    // try to open on the browser
    if ((0, _helpers.isBrowser)() && !options.skipBrowserRedirect) {
      window.location.assign(url);
    }
    return {
      data: {
        provider,
        url
      },
      error: null
    };
  }
  /**
   * Recovers the session from LocalStorage and refreshes
   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
   */
  async _recoverAndRefresh() {
    var _a;
    const debugName = '#_recoverAndRefresh()';
    this._debug(debugName, 'begin');
    try {
      const currentSession = await (0, _helpers.getItemAsync)(this.storage, this.storageKey);
      this._debug(debugName, 'session from storage', currentSession);
      if (!this._isValidSession(currentSession)) {
        this._debug(debugName, 'session is not valid');
        if (currentSession !== null) {
          await this._removeSession();
        }
        return;
      }
      const timeNow = Math.round(Date.now() / 1000);
      const expiresWithMargin = ((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + _constants.EXPIRY_MARGIN;
      this._debug(debugName, `session has${expiresWithMargin ? '' : ' not'} expired with margin of ${_constants.EXPIRY_MARGIN}s`);
      if (expiresWithMargin) {
        if (this.autoRefreshToken && currentSession.refresh_token) {
          const {
            error
          } = await this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            console.error(error);
            if (!(0, _errors.isAuthRetryableFetchError)(error)) {
              this._debug(debugName, 'refresh failed with a non-retryable error, removing the session', error);
              await this._removeSession();
            }
          }
        }
      } else {
        // no need to persist currentSession again, as we just loaded it from
        // local storage; persisting it again may overwrite a value saved by
        // another client with access to the same local storage
        await this._notifyAllSubscribers('SIGNED_IN', currentSession);
      }
    } catch (err) {
      this._debug(debugName, 'error', err);
      console.error(err);
      return;
    } finally {
      this._debug(debugName, 'end');
    }
  }
  async _callRefreshToken(refreshToken) {
    var _a, _b;
    if (!refreshToken) {
      throw new _errors.AuthSessionMissingError();
    }
    // refreshing is already in progress
    if (this.refreshingDeferred) {
      return this.refreshingDeferred.promise;
    }
    const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, 'begin');
    try {
      this.refreshingDeferred = new _helpers.Deferred();
      const {
        data,
        error
      } = await this._refreshAccessToken(refreshToken);
      if (error) throw error;
      if (!data.session) throw new _errors.AuthSessionMissingError();
      await this._saveSession(data.session);
      await this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);
      const result = {
        session: data.session,
        error: null
      };
      this.refreshingDeferred.resolve(result);
      return result;
    } catch (error) {
      this._debug(debugName, 'error', error);
      if ((0, _errors.isAuthError)(error)) {
        const result = {
          session: null,
          error
        };
        if (!(0, _errors.isAuthRetryableFetchError)(error)) {
          await this._removeSession();
          await this._notifyAllSubscribers('SIGNED_OUT', null);
        }
        (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);
        return result;
      }
      (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);
      throw error;
    } finally {
      this.refreshingDeferred = null;
      this._debug(debugName, 'end');
    }
  }
  async _notifyAllSubscribers(event, session, broadcast = true) {
    const debugName = `#_notifyAllSubscribers(${event})`;
    this._debug(debugName, 'begin', session, `broadcast = ${broadcast}`);
    try {
      if (this.broadcastChannel && broadcast) {
        this.broadcastChannel.postMessage({
          event,
          session
        });
      }
      const errors = [];
      const promises = Array.from(this.stateChangeEmitters.values()).map(async x => {
        try {
          await x.callback(event, session);
        } catch (e) {
          errors.push(e);
        }
      });
      await Promise.all(promises);
      if (errors.length > 0) {
        for (let i = 0; i < errors.length; i += 1) {
          console.error(errors[i]);
        }
        throw errors[0];
      }
    } finally {
      this._debug(debugName, 'end');
    }
  }
  /**
   * set currentSession and currentUser
   * process to _startAutoRefreshToken if possible
   */
  async _saveSession(session) {
    this._debug('#_saveSession()', session);
    await (0, _helpers.setItemAsync)(this.storage, this.storageKey, session);
  }
  async _removeSession() {
    this._debug('#_removeSession()');
    await (0, _helpers.removeItemAsync)(this.storage, this.storageKey);
  }
  /**
   * Removes any registered visibilitychange callback.
   *
   * {@see #startAutoRefresh}
   * {@see #stopAutoRefresh}
   */
  _removeVisibilityChangedCallback() {
    this._debug('#_removeVisibilityChangedCallback()');
    const callback = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      if (callback && (0, _helpers.isBrowser)() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {
        window.removeEventListener('visibilitychange', callback);
      }
    } catch (e) {
      console.error('removing visibilitychange callback failed', e);
    }
  }
  /**
   * This is the private implementation of {@link #startAutoRefresh}. Use this
   * within the library.
   */
  async _startAutoRefresh() {
    await this._stopAutoRefresh();
    this._debug('#_startAutoRefresh()');
    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION);
    this.autoRefreshTicker = ticker;
    if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {
      // ticker is a NodeJS Timeout object that has an `unref` method
      // https://nodejs.org/api/timers.html#timeoutunref
      // When auto refresh is used in NodeJS (like for testing) the
      // `setInterval` is preventing the process from being marked as
      // finished and tests run endlessly. This can be prevented by calling
      // `unref()` on the returned object.
      ticker.unref();
      // @ts-ignore
    } else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {
      // similar like for NodeJS, but with the Deno API
      // https://deno.land/api@latest?unstable&s=Deno.unrefTimer
      // @ts-ignore
      Deno.unrefTimer(ticker);
    }
    // run the tick immediately, but in the next pass of the event loop so that
    // #_initialize can be allowed to complete without recursively waiting on
    // itself
    setTimeout(async () => {
      await this.initializePromise;
      await this._autoRefreshTokenTick();
    }, 0);
  }
  /**
   * This is the private implementation of {@link #stopAutoRefresh}. Use this
   * within the library.
   */
  async _stopAutoRefresh() {
    this._debug('#_stopAutoRefresh()');
    const ticker = this.autoRefreshTicker;
    this.autoRefreshTicker = null;
    if (ticker) {
      clearInterval(ticker);
    }
  }
  /**
   * Starts an auto-refresh process in the background. The session is checked
   * every few seconds. Close to the time of expiration a process is started to
   * refresh the session. If refreshing fails it will be retried for as long as
   * necessary.
   *
   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
   * to call this function, it will be called for you.
   *
   * On browsers the refresh process works only when the tab/window is in the
   * foreground to conserve resources as well as prevent race conditions and
   * flooding auth with requests. If you call this method any managed
   * visibility change callback will be removed and you must manage visibility
   * changes on your own.
   *
   * On non-browser platforms the refresh process works *continuously* in the
   * background, which may not be desirable. You should hook into your
   * platform's foreground indication mechanism and call these methods
   * appropriately to conserve resources.
   *
   * {@see #stopAutoRefresh}
   */
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._startAutoRefresh();
  }
  /**
   * Stops an active auto refresh process running in the background (if any).
   *
   * If you call this method any managed visibility change callback will be
   * removed and you must manage visibility changes on your own.
   *
   * See {@link #startAutoRefresh} for more details.
   */
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._stopAutoRefresh();
  }
  /**
   * Runs the auto refresh token tick.
   */
  async _autoRefreshTokenTick() {
    this._debug('#_autoRefreshTokenTick()', 'begin');
    try {
      await this._acquireLock(0, async () => {
        try {
          const now = Date.now();
          try {
            return await this._useSession(async result => {
              const {
                data: {
                  session
                }
              } = result;
              if (!session || !session.refresh_token || !session.expires_at) {
                this._debug('#_autoRefreshTokenTick()', 'no session');
                return;
              }
              // session will expire in this many ticks (or has already expired if <= 0)
              const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION);
              this._debug('#_autoRefreshTokenTick()', `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`);
              if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) {
                await this._callRefreshToken(session.refresh_token);
              }
            });
          } catch (e) {
            console.error('Auto refresh tick failed with error. This is likely a transient error.', e);
          }
        } finally {
          this._debug('#_autoRefreshTokenTick()', 'end');
        }
      });
    } catch (e) {
      if (e.isAcquireTimeout || e instanceof _locks.LockAcquireTimeoutError) {
        this._debug('auto refresh token tick lock not available');
      } else {
        throw e;
      }
    }
  }
  /**
   * Registers callbacks on the browser / platform, which in-turn run
   * algorithms when the browser window/tab are in foreground. On non-browser
   * platforms it assumes always foreground.
   */
  async _handleVisibilityChange() {
    this._debug('#_handleVisibilityChange()');
    if (!(0, _helpers.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
      if (this.autoRefreshToken) {
        // in non-browser environments the refresh token ticker runs always
        this.startAutoRefresh();
      }
      return false;
    }
    try {
      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false);
      window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', this.visibilityChangedCallback);
      // now immediately call the visbility changed callback to setup with the
      // current visbility state
      await this._onVisibilityChanged(true); // initial call
    } catch (error) {
      console.error('_handleVisibilityChange', error);
    }
  }
  /**
   * Callback registered with `window.addEventListener('visibilitychange')`.
   */
  async _onVisibilityChanged(calledFromInitialize) {
    const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
    this._debug(methodName, 'visibilityState', document.visibilityState);
    if (document.visibilityState === 'visible') {
      if (this.autoRefreshToken) {
        // in browser environments the refresh token ticker runs only on focused tabs
        // which prevents race conditions
        this._startAutoRefresh();
      }
      if (!calledFromInitialize) {
        // called when the visibility has changed, i.e. the browser
        // transitioned from hidden -> visible so we need to see if the session
        // should be recovered immediately... but to do that we need to acquire
        // the lock first asynchronously
        await this.initializePromise;
        await this._acquireLock(-1, async () => {
          if (document.visibilityState !== 'visible') {
            this._debug(methodName, 'acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting');
            // visibility has changed while waiting for the lock, abort
            return;
          }
          // recover the session
          await this._recoverAndRefresh();
        });
      }
    } else if (document.visibilityState === 'hidden') {
      if (this.autoRefreshToken) {
        this._stopAutoRefresh();
      }
    }
  }
  /**
   * Generates the relevant login URL for a third-party provider.
   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
   * @param options.scopes A space-separated list of scopes granted to the OAuth application.
   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
   */
  async _getUrlForProvider(url, provider, options) {
    const urlParams = [`provider=${encodeURIComponent(provider)}`];
    if (options === null || options === void 0 ? void 0 : options.redirectTo) {
      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
    }
    if (options === null || options === void 0 ? void 0 : options.scopes) {
      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
    }
    if (this.flowType === 'pkce') {
      const codeVerifier = (0, _helpers.generatePKCEVerifier)();
      await (0, _helpers.setItemAsync)(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);
      const codeChallenge = await (0, _helpers.generatePKCEChallenge)(codeVerifier);
      const codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';
      this._debug('PKCE', 'code verifier', `${codeVerifier.substring(0, 5)}...`, 'code challenge', codeChallenge, 'method', codeChallengeMethod);
      const flowParams = new URLSearchParams({
        code_challenge: `${encodeURIComponent(codeChallenge)}`,
        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
      });
      urlParams.push(flowParams.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.queryParams) {
      const query = new URLSearchParams(options.queryParams);
      urlParams.push(query.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {
      urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
    }
    return `${url}?${urlParams.join('&')}`;
  }
  async _unenroll(params) {
    try {
      return await this._useSession(async result => {
        var _a;
        const {
          data: sessionData,
          error: sessionError
        } = result;
        if (sessionError) {
          return {
            data: null,
            error: sessionError
          };
        }
        return await (0, _fetch._request)(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {
          headers: this.headers,
          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
        });
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  /**
   * {@see GoTrueMFAApi#enroll}
   */
  async _enroll(params) {
    try {
      return await this._useSession(async result => {
        var _a, _b;
        const {
          data: sessionData,
          error: sessionError
        } = result;
        if (sessionError) {
          return {
            data: null,
            error: sessionError
          };
        }
        const {
          data,
          error
        } = await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/factors`, {
          body: {
            friendly_name: params.friendlyName,
            factor_type: params.factorType,
            issuer: params.issuer
          },
          headers: this.headers,
          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
        });
        if (error) {
          return {
            data: null,
            error
          };
        }
        if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {
          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
        }
        return {
          data,
          error: null
        };
      });
    } catch (error) {
      if ((0, _errors.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  /**
   * {@see GoTrueMFAApi#verify}
   */
  async _verify(params) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async result => {
          var _a;
          const {
            data: sessionData,
            error: sessionError
          } = result;
          if (sessionError) {
            return {
              data: null,
              error: sessionError
            };
          }
          const {
            data,
            error
          } = await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/verify`, {
            body: {
              code: params.code,
              challenge_id: params.challengeId
            },
            headers: this.headers,
            jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
          });
          if (error) {
            return {
              data: null,
              error
            };
          }
          await this._saveSession(Object.assign({
            expires_at: Math.round(Date.now() / 1000) + data.expires_in
          }, data));
          await this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);
          return {
            data,
            error
          };
        });
      } catch (error) {
        if ((0, _errors.isAuthError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challenge}
   */
  async _challenge(params) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async result => {
          var _a;
          const {
            data: sessionData,
            error: sessionError
          } = result;
          if (sessionError) {
            return {
              data: null,
              error: sessionError
            };
          }
          return await (0, _fetch._request)(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/challenge`, {
            headers: this.headers,
            jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
          });
        });
      } catch (error) {
        if ((0, _errors.isAuthError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challengeAndVerify}
   */
  async _challengeAndVerify(params) {
    // both _challenge and _verify independently acquire the lock, so no need
    // to acquire it here
    const {
      data: challengeData,
      error: challengeError
    } = await this._challenge({
      factorId: params.factorId
    });
    if (challengeError) {
      return {
        data: null,
        error: challengeError
      };
    }
    return await this._verify({
      factorId: params.factorId,
      challengeId: challengeData.id,
      code: params.code
    });
  }
  /**
   * {@see GoTrueMFAApi#listFactors}
   */
  async _listFactors() {
    // use #getUser instead of #_getUser as the former acquires a lock
    const {
      data: {
        user
      },
      error: userError
    } = await this.getUser();
    if (userError) {
      return {
        data: null,
        error: userError
      };
    }
    const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];
    const totp = factors.filter(factor => factor.factor_type === 'totp' && factor.status === 'verified');
    return {
      data: {
        all: factors,
        totp
      },
      error: null
    };
  }
  /**
   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
   */
  async _getAuthenticatorAssuranceLevel() {
    return this._acquireLock(-1, async () => {
      return await this._useSession(async result => {
        var _a, _b;
        const {
          data: {
            session
          },
          error: sessionError
        } = result;
        if (sessionError) {
          return {
            data: null,
            error: sessionError
          };
        }
        if (!session) {
          return {
            data: {
              currentLevel: null,
              nextLevel: null,
              currentAuthenticationMethods: []
            },
            error: null
          };
        }
        const payload = this._decodeJWT(session.access_token);
        let currentLevel = null;
        if (payload.aal) {
          currentLevel = payload.aal;
        }
        let nextLevel = currentLevel;
        const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(factor => factor.status === 'verified')) !== null && _b !== void 0 ? _b : [];
        if (verifiedFactors.length > 0) {
          nextLevel = 'aal2';
        }
        const currentAuthenticationMethods = payload.amr || [];
        return {
          data: {
            currentLevel,
            nextLevel,
            currentAuthenticationMethods
          },
          error: null
        };
      });
    });
  }
}
exports.default = GoTrueClient;
GoTrueClient.nextInstanceID = 0;
},{"./GoTrueAdminApi":"../node_modules/@supabase/gotrue-js/dist/module/GoTrueAdminApi.js","./lib/constants":"../node_modules/@supabase/gotrue-js/dist/module/lib/constants.js","./lib/errors":"../node_modules/@supabase/gotrue-js/dist/module/lib/errors.js","./lib/fetch":"../node_modules/@supabase/gotrue-js/dist/module/lib/fetch.js","./lib/helpers":"../node_modules/@supabase/gotrue-js/dist/module/lib/helpers.js","./lib/local-storage":"../node_modules/@supabase/gotrue-js/dist/module/lib/local-storage.js","./lib/polyfills":"../node_modules/@supabase/gotrue-js/dist/module/lib/polyfills.js","./lib/version":"../node_modules/@supabase/gotrue-js/dist/module/lib/version.js","./lib/locks":"../node_modules/@supabase/gotrue-js/dist/module/lib/locks.js"}],"../node_modules/@supabase/gotrue-js/dist/module/AuthAdminApi.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _GoTrueAdminApi = _interopRequireDefault(require("./GoTrueAdminApi"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const AuthAdminApi = _GoTrueAdminApi.default;
var _default = exports.default = AuthAdminApi;
},{"./GoTrueAdminApi":"../node_modules/@supabase/gotrue-js/dist/module/GoTrueAdminApi.js"}],"../node_modules/@supabase/gotrue-js/dist/module/AuthClient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _GoTrueClient = _interopRequireDefault(require("./GoTrueClient"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const AuthClient = _GoTrueClient.default;
var _default = exports.default = AuthClient;
},{"./GoTrueClient":"../node_modules/@supabase/gotrue-js/dist/module/GoTrueClient.js"}],"../node_modules/@supabase/gotrue-js/dist/module/lib/types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/@supabase/gotrue-js/dist/module/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  GoTrueAdminApi: true,
  GoTrueClient: true,
  AuthAdminApi: true,
  AuthClient: true,
  navigatorLock: true,
  NavigatorLockAcquireTimeoutError: true,
  lockInternals: true
};
Object.defineProperty(exports, "AuthAdminApi", {
  enumerable: true,
  get: function () {
    return _AuthAdminApi.default;
  }
});
Object.defineProperty(exports, "AuthClient", {
  enumerable: true,
  get: function () {
    return _AuthClient.default;
  }
});
Object.defineProperty(exports, "GoTrueAdminApi", {
  enumerable: true,
  get: function () {
    return _GoTrueAdminApi.default;
  }
});
Object.defineProperty(exports, "GoTrueClient", {
  enumerable: true,
  get: function () {
    return _GoTrueClient.default;
  }
});
Object.defineProperty(exports, "NavigatorLockAcquireTimeoutError", {
  enumerable: true,
  get: function () {
    return _locks.NavigatorLockAcquireTimeoutError;
  }
});
Object.defineProperty(exports, "lockInternals", {
  enumerable: true,
  get: function () {
    return _locks.internals;
  }
});
Object.defineProperty(exports, "navigatorLock", {
  enumerable: true,
  get: function () {
    return _locks.navigatorLock;
  }
});
var _GoTrueAdminApi = _interopRequireDefault(require("./GoTrueAdminApi"));
var _GoTrueClient = _interopRequireDefault(require("./GoTrueClient"));
var _AuthAdminApi = _interopRequireDefault(require("./AuthAdminApi"));
var _AuthClient = _interopRequireDefault(require("./AuthClient"));
var _types = require("./lib/types");
Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});
var _errors = require("./lib/errors");
Object.keys(_errors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _errors[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _errors[key];
    }
  });
});
var _locks = require("./lib/locks");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./GoTrueAdminApi":"../node_modules/@supabase/gotrue-js/dist/module/GoTrueAdminApi.js","./GoTrueClient":"../node_modules/@supabase/gotrue-js/dist/module/GoTrueClient.js","./AuthAdminApi":"../node_modules/@supabase/gotrue-js/dist/module/AuthAdminApi.js","./AuthClient":"../node_modules/@supabase/gotrue-js/dist/module/AuthClient.js","./lib/types":"../node_modules/@supabase/gotrue-js/dist/module/lib/types.js","./lib/errors":"../node_modules/@supabase/gotrue-js/dist/module/lib/errors.js","./lib/locks":"../node_modules/@supabase/gotrue-js/dist/module/lib/locks.js"}],"../node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SupabaseAuthClient = void 0;
var _gotrueJs = require("@supabase/gotrue-js");
class SupabaseAuthClient extends _gotrueJs.GoTrueClient {
  constructor(options) {
    super(options);
  }
}
exports.SupabaseAuthClient = SupabaseAuthClient;
},{"@supabase/gotrue-js":"../node_modules/@supabase/gotrue-js/dist/module/index.js"}],"../node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _functionsJs = require("@supabase/functions-js");
var _postgrestJs = require("@supabase/postgrest-js");
var _realtimeJs = require("@supabase/realtime-js");
var _storageJs = require("@supabase/storage-js");
var _constants = require("./lib/constants");
var _fetch = require("./lib/fetch");
var _helpers = require("./lib/helpers");
var _SupabaseAuthClient = require("./lib/SupabaseAuthClient");
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const DEFAULT_GLOBAL_OPTIONS = {
  headers: _constants.DEFAULT_HEADERS
};
const DEFAULT_DB_OPTIONS = {
  schema: 'public'
};
const DEFAULT_AUTH_OPTIONS = {
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  flowType: 'implicit'
};
const DEFAULT_REALTIME_OPTIONS = {};
/**
 * Supabase Client.
 *
 * An isomorphic Javascript client for interacting with Postgres.
 */
class SupabaseClient {
  /**
   * Create a new client for use in the browser.
   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
   * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
   * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
   * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
   * @param options.realtime Options passed along to realtime-js constructor.
   * @param options.global.fetch A custom fetch implementation.
   * @param options.global.headers Any additional headers to send with each network request.
   */
  constructor(supabaseUrl, supabaseKey, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.supabaseUrl = supabaseUrl;
    this.supabaseKey = supabaseKey;
    /**
     * Perform a query on a table or a view.
     *
     * @param relation - The table or view name to query
     */
    this.from = relation => {
      return this.rest.from(relation);
    };
    /**
     * Perform a query on a schema distinct from the default schema supplied via
     * the `options.db.schema` constructor parameter.
     *
     * The schema needs to be on the list of exposed schemas inside Supabase.
     *
     * @param schema - The name of the schema to query
     */
    this.schema = schema => {
      return this.rest.schema(schema);
    };
    /**
     * Perform a function call.
     *
     * @param fn - The function name to call
     * @param args - The arguments to pass to the function call
     * @param options - Named parameters
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     * @param options.count - Count algorithm to use to count rows returned by the
     * function. Only applicable for [set-returning
     * functions](https://www.postgresql.org/docs/current/functions-srf.html).
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    this.rpc = (fn, args = {}, options) => {
      return this.rest.rpc(fn, args, options);
    };
    if (!supabaseUrl) throw new Error('supabaseUrl is required.');
    if (!supabaseKey) throw new Error('supabaseKey is required.');
    const _supabaseUrl = (0, _helpers.stripTrailingSlash)(supabaseUrl);
    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, 'ws');
    this.authUrl = `${_supabaseUrl}/auth/v1`;
    this.storageUrl = `${_supabaseUrl}/storage/v1`;
    this.functionsUrl = `${_supabaseUrl}/functions/v1`;
    // default storage key uses the supabase project ref as a namespace
    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split('.')[0]}-auth-token`;
    const DEFAULTS = {
      db: DEFAULT_DB_OPTIONS,
      realtime: DEFAULT_REALTIME_OPTIONS,
      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), {
        storageKey: defaultStorageKey
      }),
      global: DEFAULT_GLOBAL_OPTIONS
    };
    const settings = (0, _helpers.applySettingDefaults)(options !== null && options !== void 0 ? options : {}, DEFAULTS);
    this.storageKey = (_b = (_a = settings.auth) === null || _a === void 0 ? void 0 : _a.storageKey) !== null && _b !== void 0 ? _b : '';
    this.headers = (_d = (_c = settings.global) === null || _c === void 0 ? void 0 : _c.headers) !== null && _d !== void 0 ? _d : {};
    this.auth = this._initSupabaseAuthClient((_e = settings.auth) !== null && _e !== void 0 ? _e : {}, this.headers, (_f = settings.global) === null || _f === void 0 ? void 0 : _f.fetch);
    this.fetch = (0, _fetch.fetchWithAuth)(supabaseKey, this._getAccessToken.bind(this), (_g = settings.global) === null || _g === void 0 ? void 0 : _g.fetch);
    this.realtime = this._initRealtimeClient(Object.assign({
      headers: this.headers
    }, settings.realtime));
    this.rest = new _postgrestJs.PostgrestClient(`${_supabaseUrl}/rest/v1`, {
      headers: this.headers,
      schema: (_h = settings.db) === null || _h === void 0 ? void 0 : _h.schema,
      fetch: this.fetch
    });
    this._listenForAuthEvents();
  }
  /**
   * Supabase Functions allows you to deploy and invoke edge functions.
   */
  get functions() {
    return new _functionsJs.FunctionsClient(this.functionsUrl, {
      headers: this.headers,
      customFetch: this.fetch
    });
  }
  /**
   * Supabase Storage allows you to manage user-generated content, such as photos or videos.
   */
  get storage() {
    return new _storageJs.StorageClient(this.storageUrl, this.headers, this.fetch);
  }
  /**
   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
   *
   * @param {string} name - The name of the Realtime channel.
   * @param {Object} opts - The options to pass to the Realtime channel.
   *
   */
  channel(name, opts = {
    config: {}
  }) {
    return this.realtime.channel(name, opts);
  }
  /**
   * Returns all Realtime channels.
   */
  getChannels() {
    return this.realtime.getChannels();
  }
  /**
   * Unsubscribes and removes Realtime channel from Realtime client.
   *
   * @param {RealtimeChannel} channel - The name of the Realtime channel.
   *
   */
  removeChannel(channel) {
    return this.realtime.removeChannel(channel);
  }
  /**
   * Unsubscribes and removes all Realtime channels from Realtime client.
   */
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  _getAccessToken() {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
      const {
        data
      } = yield this.auth.getSession();
      return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : null;
    });
  }
  _initSupabaseAuthClient({
    autoRefreshToken,
    persistSession,
    detectSessionInUrl,
    storage,
    storageKey,
    flowType,
    debug
  }, headers, fetch) {
    const authHeaders = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`
    };
    return new _SupabaseAuthClient.SupabaseAuthClient({
      url: this.authUrl,
      headers: Object.assign(Object.assign({}, authHeaders), headers),
      storageKey: storageKey,
      autoRefreshToken,
      persistSession,
      detectSessionInUrl,
      storage,
      flowType,
      debug,
      fetch
    });
  }
  _initRealtimeClient(options) {
    return new _realtimeJs.RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), {
      params: Object.assign({
        apikey: this.supabaseKey
      }, options === null || options === void 0 ? void 0 : options.params)
    }));
  }
  _listenForAuthEvents() {
    let data = this.auth.onAuthStateChange((event, session) => {
      this._handleTokenChanged(event, 'CLIENT', session === null || session === void 0 ? void 0 : session.access_token);
    });
    return data;
  }
  _handleTokenChanged(event, source, token) {
    if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') && this.changedAccessToken !== token) {
      // Token has changed
      this.realtime.setAuth(token !== null && token !== void 0 ? token : null);
      this.changedAccessToken = token;
    } else if (event === 'SIGNED_OUT') {
      // Token is removed
      this.realtime.setAuth(this.supabaseKey);
      if (source == 'STORAGE') this.auth.signOut();
      this.changedAccessToken = undefined;
    }
  }
}
exports.default = SupabaseClient;
},{"@supabase/functions-js":"../node_modules/@supabase/functions-js/dist/module/index.js","@supabase/postgrest-js":"../node_modules/@supabase/postgrest-js/dist/module/index.js","@supabase/realtime-js":"../node_modules/@supabase/realtime-js/dist/module/index.js","@supabase/storage-js":"../node_modules/@supabase/storage-js/dist/module/index.js","./lib/constants":"../node_modules/@supabase/supabase-js/dist/module/lib/constants.js","./lib/fetch":"../node_modules/@supabase/supabase-js/dist/module/lib/fetch.js","./lib/helpers":"../node_modules/@supabase/supabase-js/dist/module/lib/helpers.js","./lib/SupabaseAuthClient":"../node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js"}],"../node_modules/@supabase/supabase-js/dist/module/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  createClient: true,
  SupabaseClient: true,
  FunctionsHttpError: true,
  FunctionsFetchError: true,
  FunctionsRelayError: true,
  FunctionsError: true
};
Object.defineProperty(exports, "FunctionsError", {
  enumerable: true,
  get: function () {
    return _functionsJs.FunctionsError;
  }
});
Object.defineProperty(exports, "FunctionsFetchError", {
  enumerable: true,
  get: function () {
    return _functionsJs.FunctionsFetchError;
  }
});
Object.defineProperty(exports, "FunctionsHttpError", {
  enumerable: true,
  get: function () {
    return _functionsJs.FunctionsHttpError;
  }
});
Object.defineProperty(exports, "FunctionsRelayError", {
  enumerable: true,
  get: function () {
    return _functionsJs.FunctionsRelayError;
  }
});
Object.defineProperty(exports, "SupabaseClient", {
  enumerable: true,
  get: function () {
    return _SupabaseClient.default;
  }
});
exports.createClient = void 0;
var _SupabaseClient = _interopRequireDefault(require("./SupabaseClient"));
var _gotrueJs = require("@supabase/gotrue-js");
Object.keys(_gotrueJs).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _gotrueJs[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _gotrueJs[key];
    }
  });
});
var _functionsJs = require("@supabase/functions-js");
var _realtimeJs = require("@supabase/realtime-js");
Object.keys(_realtimeJs).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _realtimeJs[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _realtimeJs[key];
    }
  });
});
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Creates a new Supabase Client.
 */
const createClient = (supabaseUrl, supabaseKey, options) => {
  return new _SupabaseClient.default(supabaseUrl, supabaseKey, options);
};
exports.createClient = createClient;
},{"./SupabaseClient":"../node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js","@supabase/gotrue-js":"../node_modules/@supabase/gotrue-js/dist/module/index.js","@supabase/functions-js":"../node_modules/@supabase/functions-js/dist/module/index.js","@supabase/realtime-js":"../node_modules/@supabase/realtime-js/dist/module/index.js"}],"../node_modules/@cosmograph/cosmograph/api/supabase/supabase.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addMetrics = I;
exports.supabase = void 0;
var _supabaseJs = require("@supabase/supabase-js");
const i = exports.supabase = (0, _supabaseJs.createClient)("https://xovkkfhojasbjinfslpx.supabase.co", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhvdmtrZmhvamFzYmppbmZzbHB4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE2OTM1ODQ0ODAsImV4cCI6MjAwOTE2MDQ4MH0.L3-X0p_un0oSTNubPwtfGo0D8g2bkPIfz7CaZ-iRYXY");
async function I(s) {
  const {
    error: I
  } = await i.from("metrics").insert(s);
  return I;
}
},{"@supabase/supabase-js":"../node_modules/@supabase/supabase-js/dist/module/index.js"}],"../node_modules/@cosmograph/cosmograph/ext/rollup-plugin-styles/dist/runtime/inject-css.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = n;
var e = [],
  t = [];
function n(n, r) {
  if (n && "undefined" != typeof document) {
    var a,
      s = !0 === r.prepend ? "prepend" : "append",
      d = !0 === r.singleTag,
      i = "string" == typeof r.container ? document.querySelector(r.container) : document.getElementsByTagName("head")[0];
    if (d) {
      var u = e.indexOf(i);
      -1 === u && (u = e.push(i) - 1, t[u] = {}), a = t[u] && t[u][s] ? t[u][s] : t[u][s] = c();
    } else a = c();
    65279 === n.charCodeAt(0) && (n = n.substring(1)), a.styleSheet ? a.styleSheet.cssText += n : a.appendChild(document.createTextNode(n));
  }
  function c() {
    var e = document.createElement("style");
    if (e.setAttribute("type", "text/css"), r.attributes) for (var t = Object.keys(r.attributes), n = 0; n < t.length; n++) e.setAttribute(t[n], r.attributes[t[n]]);
    var a = "prepend" === s ? "afterbegin" : "beforeend";
    return i.insertAdjacentElement(a, e), e;
  }
}
},{}],"../node_modules/@cosmograph/cosmograph/modules/cosmograph/style.module.css.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.css = void 0;
var _injectCss = _interopRequireDefault(require("./../../ext/rollup-plugin-styles/dist/runtime/inject-css.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var e = exports.css = ":root{--cosmograph-watermark-color:#fff}.style_module_watermark__6b4371ae{bottom:0;color:var(--cosmograph-watermark-color);cursor:pointer;line-height:0;margin:0 .6rem .6rem 0;position:absolute;right:0;user-select:none}.style_module_cosmograph__6b4371ae{display:flex;height:100%;overflow:hidden;position:relative;width:100%}.style_module_cosmographShowLabelsFor__6b4371ae{opacity:1}.style_module_cosmographShowTopLabels__6b4371ae{opacity:.9}.style_module_cosmographShowDynamicLabels__6b4371ae{opacity:.7}",
  a = exports.default = {
    watermark: "style_module_watermark__6b4371ae",
    cosmograph: "style_module_cosmograph__6b4371ae",
    cosmographShowLabelsFor: "style_module_cosmographShowLabelsFor__6b4371ae",
    cosmographShowTopLabels: "style_module_cosmographShowTopLabels__6b4371ae",
    cosmographShowDynamicLabels: "style_module_cosmographShowDynamicLabels__6b4371ae"
  };
(0, _injectCss.default)(e, {});
},{"./../../ext/rollup-plugin-styles/dist/runtime/inject-css.js":"../node_modules/@cosmograph/cosmograph/ext/rollup-plugin-styles/dist/runtime/inject-css.js"}],"../node_modules/@cosmograph/cosmograph/modules/cosmograph/config.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultCosmographConfig = void 0;
const o = exports.defaultCosmographConfig = {
  disableSimulation: null,
  showDynamicLabels: !0,
  showTopLabels: !1,
  showTopLabelsLimit: 100,
  showTopLabelsValueKey: void 0,
  showLabelsFor: void 0,
  showHoveredNodeLabel: !0,
  nodeLabelAccessor: o => o.id,
  nodeLabelClassName: void 0,
  nodeLabelColor: void 0,
  hoveredNodeLabelClassName: void 0,
  hoveredNodeLabelColor: void 0,
  onSetData: void 0,
  onNodesFiltered: void 0,
  onLinksFiltered: void 0,
  onLabelClick: void 0
};
},{}],"../node_modules/crossfilter2/src/array.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
let array8 = arrayUntyped,
  array16 = arrayUntyped,
  array32 = arrayUntyped,
  arrayLengthen = arrayLengthenUntyped,
  arrayWiden = arrayWidenUntyped;
if (typeof Uint8Array !== "undefined") {
  array8 = function (n) {
    return new Uint8Array(n);
  };
  array16 = function (n) {
    return new Uint16Array(n);
  };
  array32 = function (n) {
    return new Uint32Array(n);
  };
  arrayLengthen = function (array, length) {
    if (array.length >= length) return array;
    var copy = new array.constructor(length);
    copy.set(array);
    return copy;
  };
  arrayWiden = function (array, width) {
    var copy;
    switch (width) {
      case 16:
        copy = array16(array.length);
        break;
      case 32:
        copy = array32(array.length);
        break;
      default:
        throw new Error("invalid array width!");
    }
    copy.set(array);
    return copy;
  };
}
function arrayUntyped(n) {
  var array = new Array(n),
    i = -1;
  while (++i < n) array[i] = 0;
  return array;
}
function arrayLengthenUntyped(array, length) {
  var n = array.length;
  while (n < length) array[n++] = 0;
  return array;
}
function arrayWidenUntyped(array, width) {
  if (width > 32) throw new Error("invalid array width!");
  return array;
}

// An arbitrarily-wide array of bitmasks
function bitarray(n) {
  this.length = n;
  this.subarrays = 1;
  this.width = 8;
  this.masks = {
    0: 0
  };
  this[0] = array8(n);
}
bitarray.prototype.lengthen = function (n) {
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    this[i] = arrayLengthen(this[i], n);
  }
  this.length = n;
};

// Reserve a new bit index in the array, returns {offset, one}
bitarray.prototype.add = function () {
  var m, w, one, i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    m = this.masks[i];
    w = this.width - 32 * i;
    // isolate the rightmost zero bit and return it as an unsigned int of 32 bits, if NaN or -1, return a 0 
    one = (~m & m + 1) >>> 0;
    if (w >= 32 && !one) {
      continue;
    }
    if (w < 32 && one & 1 << w) {
      // widen this subarray
      this[i] = arrayWiden(this[i], w <<= 1);
      this.width = 32 * i + w;
    }
    this.masks[i] |= one;
    return {
      offset: i,
      one: one
    };
  }

  // add a new subarray
  this[this.subarrays] = array8(this.length);
  this.masks[this.subarrays] = 1;
  this.width += 8;
  return {
    offset: this.subarrays++,
    one: 1
  };
};

// Copy record from index src to index dest
bitarray.prototype.copy = function (dest, src) {
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    this[i][dest] = this[i][src];
  }
};

// Truncate the array to the given length
bitarray.prototype.truncate = function (n) {
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    for (var j = this.length - 1; j >= n; j--) {
      this[i][j] = 0;
    }
  }
  this.length = n;
};

// Checks that all bits for the given index are 0
bitarray.prototype.zero = function (n) {
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    if (this[i][n]) {
      return false;
    }
  }
  return true;
};

// Checks that all bits for the given index are 0 except for possibly one
bitarray.prototype.zeroExcept = function (n, offset, zero) {
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    if (i === offset ? this[i][n] & zero : this[i][n]) {
      return false;
    }
  }
  return true;
};

// Checks that all bits for the given index are 0 except for the specified mask.
// The mask should be an array of the same size as the filter subarrays width.
bitarray.prototype.zeroExceptMask = function (n, mask) {
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    if (this[i][n] & mask[i]) {
      return false;
    }
  }
  return true;
};

// Checks that only the specified bit is set for the given index
bitarray.prototype.only = function (n, offset, one) {
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    if (this[i][n] != (i === offset ? one : 0)) {
      return false;
    }
  }
  return true;
};

// Checks that only the specified bit is set for the given index except for possibly one other
bitarray.prototype.onlyExcept = function (n, offset, zero, onlyOffset, onlyOne) {
  var mask;
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    mask = this[i][n];
    if (i === offset) mask = (mask & zero) >>> 0;
    if (mask != (i === onlyOffset ? onlyOne : 0)) {
      return false;
    }
  }
  return true;
};
var _default = exports.default = {
  array8: arrayUntyped,
  array16: arrayUntyped,
  array32: arrayUntyped,
  arrayLengthen: arrayLengthenUntyped,
  arrayWiden: arrayWidenUntyped,
  bitarray: bitarray
};
},{}],"../node_modules/crossfilter2/src/filter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const filterExact = (bisect, value) => {
  return function (values) {
    var n = values.length;
    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];
  };
};
const filterRange = (bisect, range) => {
  var min = range[0],
    max = range[1];
  return function (values) {
    var n = values.length;
    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];
  };
};
const filterAll = values => {
  return [0, values.length];
};
var _default = exports.default = {
  filterExact,
  filterRange,
  filterAll
};
},{}],"../node_modules/crossfilter2/src/identity.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = d => {
  return d;
};
exports.default = _default;
},{}],"../node_modules/crossfilter2/src/null.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = () => {
  return null;
};
exports.default = _default;
},{}],"../node_modules/crossfilter2/src/zero.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = () => {
  return 0;
};
exports.default = _default;
},{}],"../node_modules/crossfilter2/src/heap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _identity = _interopRequireDefault(require("./identity"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function heap_by(f) {
  // Builds a binary heap within the specified array a[lo:hi]. The heap has the
  // property such that the parent a[lo+i] is always less than or equal to its
  // two children: a[lo+2*i+1] and a[lo+2*i+2].
  function heap(a, lo, hi) {
    var n = hi - lo,
      i = (n >>> 1) + 1;
    while (--i > 0) sift(a, i, n, lo);
    return a;
  }

  // Sorts the specified array a[lo:hi] in descending order, assuming it is
  // already a heap.
  function sort(a, lo, hi) {
    var n = hi - lo,
      t;
    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);
    return a;
  }

  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous
  // slice of array a[lo:lo+n]. This method can also be used to update the heap
  // incrementally, without incurring the full cost of reconstructing the heap.
  function sift(a, i, n, lo) {
    var d = a[--lo + i],
      x = f(d),
      child;
    while ((child = i << 1) <= n) {
      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;
      if (x <= f(a[lo + child])) break;
      a[lo + i] = a[lo + child];
      i = child;
    }
    a[lo + i] = d;
  }
  heap.sort = sort;
  return heap;
}
const h = heap_by(_identity.default);
h.by = heap_by;
var _default = exports.default = h;
},{"./identity":"../node_modules/crossfilter2/src/identity.js"}],"../node_modules/crossfilter2/src/heapselect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _identity = _interopRequireDefault(require("./identity"));
var _heap = _interopRequireDefault(require("./heap"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function heapselect_by(f) {
  var heap = _heap.default.by(f);

  // Returns a new array containing the top k elements in the array a[lo:hi].
  // The returned array is not sorted, but maintains the heap property. If k is
  // greater than hi - lo, then fewer than k elements will be returned. The
  // order of elements in a is unchanged by this operation.
  function heapselect(a, lo, hi, k) {
    var queue = new Array(k = Math.min(hi - lo, k)),
      min,
      i,
      d;
    for (i = 0; i < k; ++i) queue[i] = a[lo++];
    heap(queue, 0, k);
    if (lo < hi) {
      min = f(queue[0]);
      do {
        if (f(d = a[lo]) > min) {
          queue[0] = d;
          min = f(heap(queue, 0, k)[0]);
        }
      } while (++lo < hi);
    }
    return queue;
  }
  return heapselect;
}
const h = heapselect_by(_identity.default);
h.by = heapselect_by; // assign the raw function to the export as well
var _default = exports.default = h;
},{"./identity":"../node_modules/crossfilter2/src/identity.js","./heap":"../node_modules/crossfilter2/src/heap.js"}],"../node_modules/crossfilter2/src/bisect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _identity = _interopRequireDefault(require("./identity"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function bisect_by(f) {
  // Locate the insertion point for x in a to maintain sorted order. The
  // arguments lo and hi may be used to specify a subset of the array which
  // should be considered; by default the entire array is used. If x is already
  // present in a, the insertion point will be before (to the left of) any
  // existing entries. The return value is suitable for use as the first
  // argument to `array.splice` assuming that a is already sorted.
  //
  // The returned insertion point i partitions the array a into two halves so
  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in
  // a[i:hi] for the right side.
  function bisectLeft(a, x, lo, hi) {
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (f(a[mid]) < x) lo = mid + 1;else hi = mid;
    }
    return lo;
  }

  // Similar to bisectLeft, but returns an insertion point which comes after (to
  // the right of) any existing entries of x in a.
  //
  // The returned insertion point i partitions the array into two halves so that
  // all v <= x for v in a[lo:i] for the left side and all v > x for v in
  // a[i:hi] for the right side.
  function bisectRight(a, x, lo, hi) {
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (x < f(a[mid])) hi = mid;else lo = mid + 1;
    }
    return lo;
  }
  bisectRight.right = bisectRight;
  bisectRight.left = bisectLeft;
  return bisectRight;
}
const bisect = bisect_by(_identity.default);
bisect.by = bisect_by; // assign the raw function to the export as well
var _default = exports.default = bisect;
},{"./identity":"../node_modules/crossfilter2/src/identity.js"}],"../node_modules/crossfilter2/src/permute.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = (array, index, deep) => {
  for (var i = 0, n = index.length, copy = deep ? JSON.parse(JSON.stringify(array)) : new Array(n); i < n; ++i) {
    copy[i] = array[index[i]];
  }
  return copy;
};
exports.default = _default;
},{}],"../node_modules/crossfilter2/src/reduce.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const reduceIncrement = p => {
  return p + 1;
};
const reduceDecrement = p => {
  return p - 1;
};
const reduceAdd = f => {
  return function (p, v) {
    return p + +f(v);
  };
};
const reduceSubtract = f => {
  return function (p, v) {
    return p - f(v);
  };
};
var _default = exports.default = {
  reduceIncrement,
  reduceDecrement,
  reduceAdd,
  reduceSubtract
};
},{}],"../node_modules/@ranfdev/deepobj/dist/deepobj.m.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
function _default(t, e, i, n, r) {
  for (r in n = (i = i.split(".")).splice(-1, 1), i) e = e[i[r]] = e[i[r]] || {};
  return t(e, n);
}
;
},{}],"../node_modules/crossfilter2/src/result.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _deepobj = _interopRequireDefault(require("@ranfdev/deepobj"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// Note(cg): result was previsouly using lodash.result, not ESM compatible.

const get = (obj, prop) => {
  const value = obj[prop];
  return typeof value === 'function' ? value.call(obj) : value;
};

/**
 * get value of object at a deep path.
 * if the resolved value is a function,
 * it's invoked with the `this` binding of 
 * its parent object and its result is returned. 
 *  
 * @param  {Object} obj  the object (e.g. { 'a': [{ 'b': { 'c1': 3, 'c2': 4} }], 'd': {e:1} }; )
 * @param  {String} path deep path (e.g. `d.e`` or `a[0].b.c1`. Dot notation (a.0.b)is also supported)
 * @return {Any}      the resolved value
 */
const reg = /\[([\w\d]+)\]/g;
var _default = (obj, path) => {
  return (0, _deepobj.default)(get, obj, path.replace(reg, '.$1'));
};
exports.default = _default;
},{"@ranfdev/deepobj":"../node_modules/@ranfdev/deepobj/dist/deepobj.m.js"}],"../node_modules/crossfilter2/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _array = _interopRequireDefault(require("./array"));
var _filter = _interopRequireDefault(require("./filter"));
var _identity = _interopRequireDefault(require("./identity"));
var _null = _interopRequireDefault(require("./null"));
var _zero = _interopRequireDefault(require("./zero"));
var _heapselect = _interopRequireDefault(require("./heapselect"));
var _heap = _interopRequireDefault(require("./heap"));
var _bisect = _interopRequireDefault(require("./bisect"));
var _permute = _interopRequireDefault(require("./permute"));
var _reduce = _interopRequireDefault(require("./reduce"));
var _result = _interopRequireDefault(require("./result"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// constants
var REMOVED_INDEX = -1;
crossfilter.heap = _heap.default;
crossfilter.heapselect = _heapselect.default;
crossfilter.bisect = _bisect.default;
crossfilter.permute = _permute.default;
var _default = exports.default = crossfilter;
function crossfilter() {
  var crossfilter = {
    add: add,
    remove: removeData,
    dimension: dimension,
    groupAll: groupAll,
    size: size,
    all: all,
    allFiltered: allFiltered,
    onChange: onChange,
    isElementFiltered: isElementFiltered
  };
  var data = [],
    // the records
    n = 0,
    // the number of records; data.length
    filters,
    // 1 is filtered out
    filterListeners = [],
    // when the filters change
    dataListeners = [],
    // when data is added
    removeDataListeners = [],
    // when data is removed
    callbacks = [];
  filters = new _array.default.bitarray(0);

  // Adds the specified new records to this crossfilter.
  function add(newData) {
    var n0 = n,
      n1 = newData.length;

    // If there's actually new data to add…
    // Merge the new data into the existing data.
    // Lengthen the filter bitset to handle the new records.
    // Notify listeners (dimensions and groups) that new data is available.
    if (n1) {
      data = data.concat(newData);
      filters.lengthen(n += n1);
      dataListeners.forEach(function (l) {
        l(newData, n0, n1);
      });
      triggerOnChange('dataAdded');
    }
    return crossfilter;
  }

  // Removes all records that match the current filters, or if a predicate function is passed,
  // removes all records matching the predicate (ignoring filters).
  function removeData(predicate) {
    var
      // Mapping from old record indexes to new indexes (after records removed)
      newIndex = new Array(n),
      removed = [],
      usePred = typeof predicate === 'function',
      shouldRemove = function (i) {
        return usePred ? predicate(data[i], i) : filters.zero(i);
      };
    for (var index1 = 0, index2 = 0; index1 < n; ++index1) {
      if (shouldRemove(index1)) {
        removed.push(index1);
        newIndex[index1] = REMOVED_INDEX;
      } else {
        newIndex[index1] = index2++;
      }
    }

    // Remove all matching records from groups.
    filterListeners.forEach(function (l) {
      l(-1, -1, [], removed, true);
    });

    // Update indexes.
    removeDataListeners.forEach(function (l) {
      l(newIndex);
    });

    // Remove old filters and data by overwriting.
    for (var index3 = 0, index4 = 0; index3 < n; ++index3) {
      if (newIndex[index3] !== REMOVED_INDEX) {
        if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];
        ++index4;
      }
    }
    data.length = n = index4;
    filters.truncate(index4);
    triggerOnChange('dataRemoved');
  }
  function maskForDimensions(dimensions) {
    var n,
      d,
      len,
      id,
      mask = Array(filters.subarrays);
    for (n = 0; n < filters.subarrays; n++) {
      mask[n] = ~0;
    }
    for (d = 0, len = dimensions.length; d < len; d++) {
      // The top bits of the ID are the subarray offset and the lower bits are the bit
      // offset of the "one" mask.
      id = dimensions[d].id();
      mask[id >> 7] &= ~(0x1 << (id & 0x3f));
    }
    return mask;
  }

  // Return true if the data element at index i is filtered IN.
  // Optionally, ignore the filters of any dimensions in the ignore_dimensions list.
  function isElementFiltered(i, ignore_dimensions) {
    var mask = maskForDimensions(ignore_dimensions || []);
    return filters.zeroExceptMask(i, mask);
  }

  // Adds a new dimension with the specified value accessor function.
  function dimension(value, iterable) {
    if (typeof value === 'string') {
      var accessorPath = value;
      value = function (d) {
        return (0, _result.default)(d, accessorPath);
      };
    }
    var dimension = {
      filter: filter,
      filterExact: filterExact,
      filterRange: filterRange,
      filterFunction: filterFunction,
      filterAll: filterAll,
      currentFilter: currentFilter,
      hasCurrentFilter: hasCurrentFilter,
      top: top,
      bottom: bottom,
      group: group,
      groupAll: groupAll,
      dispose: dispose,
      remove: dispose,
      // for backwards-compatibility
      accessor: value,
      id: function () {
        return id;
      }
    };
    var one,
      // lowest unset bit as mask, e.g., 00001000
      zero,
      // inverted one, e.g., 11110111
      offset,
      // offset into the filters arrays
      id,
      // unique ID for this dimension (reused when dimensions are disposed)
      values,
      // sorted, cached array
      index,
      // maps sorted value index -> record index (in data)
      newValues,
      // temporary array storing newly-added values
      newIndex,
      // temporary array storing newly-added index
      iterablesIndexCount,
      iterablesIndexFilterStatus,
      iterablesEmptyRows = [],
      sortRange = function (n) {
        return cr_range(n).sort(function (A, B) {
          var a = newValues[A],
            b = newValues[B];
          return a < b ? -1 : a > b ? 1 : A - B;
        });
      },
      refilter = _filter.default.filterAll,
      // for recomputing filter
      refilterFunction,
      // the custom filter function in use
      filterValue,
      // the value used for filtering (value, array, function or undefined)
      filterValuePresent,
      // true if filterValue contains something
      indexListeners = [],
      // when data is added
      dimensionGroups = [],
      lo0 = 0,
      hi0 = 0,
      t = 0,
      k;

    // Updating a dimension is a two-stage process. First, we must update the
    // associated filters for the newly-added records. Once all dimensions have
    // updated their filters, the groups are notified to update.
    dataListeners.unshift(preAdd);
    dataListeners.push(postAdd);
    removeDataListeners.push(removeData);

    // Add a new dimension in the filter bitmap and store the offset and bitmask.
    var tmp = filters.add();
    offset = tmp.offset;
    one = tmp.one;
    zero = ~one;

    // Create a unique ID for the dimension
    // IDs will be re-used if dimensions are disposed.
    // For internal use the ID is the subarray offset shifted left 7 bits or'd with the
    // bit offset of the set bit in the dimension's "one" mask.
    id = offset << 7 | Math.log(one) / Math.log(2);
    preAdd(data, 0, n);
    postAdd(data, 0, n);

    // Incorporates the specified new records into this dimension.
    // This function is responsible for updating filters, values, and index.
    function preAdd(newData, n0, n1) {
      var newIterablesIndexCount, newIterablesIndexFilterStatus;
      if (iterable) {
        // Count all the values
        t = 0;
        j = 0;
        k = [];
        for (var i0 = 0; i0 < newData.length; i0++) {
          for (j = 0, k = value(newData[i0]); j < k.length; j++) {
            t++;
          }
        }
        newValues = [];
        newIterablesIndexCount = cr_range(newData.length);
        newIterablesIndexFilterStatus = cr_index(t, 1);
        var unsortedIndex = cr_range(t);
        for (var l = 0, index1 = 0; index1 < newData.length; index1++) {
          k = value(newData[index1]);
          //
          if (!k.length) {
            newIterablesIndexCount[index1] = 0;
            iterablesEmptyRows.push(index1 + n0);
            continue;
          }
          newIterablesIndexCount[index1] = k.length;
          for (j = 0; j < k.length; j++) {
            newValues.push(k[j]);
            unsortedIndex[l] = index1;
            l++;
          }
        }

        // Create the Sort map used to sort both the values and the valueToData indices
        var sortMap = sortRange(t);

        // Use the sortMap to sort the newValues
        newValues = (0, _permute.default)(newValues, sortMap);

        // Use the sortMap to sort the unsortedIndex map
        // newIndex should be a map of sortedValue -> crossfilterData
        newIndex = (0, _permute.default)(unsortedIndex, sortMap);
      } else {
        // Permute new values into natural order using a standard sorted index.
        newValues = newData.map(value);
        newIndex = sortRange(n1);
        newValues = (0, _permute.default)(newValues, newIndex);
      }

      // Bisect newValues to determine which new records are selected.
      var bounds = refilter(newValues),
        lo1 = bounds[0],
        hi1 = bounds[1];
      var index2, index3, index4;
      if (iterable) {
        n1 = t;
        if (refilterFunction) {
          for (index2 = 0; index2 < n1; ++index2) {
            if (!refilterFunction(newValues[index2], index2)) {
              if (--newIterablesIndexCount[newIndex[index2]] === 0) {
                filters[offset][newIndex[index2] + n0] |= one;
              }
              newIterablesIndexFilterStatus[index2] = 1;
            }
          }
        } else {
          for (index3 = 0; index3 < lo1; ++index3) {
            if (--newIterablesIndexCount[newIndex[index3]] === 0) {
              filters[offset][newIndex[index3] + n0] |= one;
            }
            newIterablesIndexFilterStatus[index3] = 1;
          }
          for (index4 = hi1; index4 < n1; ++index4) {
            if (--newIterablesIndexCount[newIndex[index4]] === 0) {
              filters[offset][newIndex[index4] + n0] |= one;
            }
            newIterablesIndexFilterStatus[index4] = 1;
          }
        }
      } else {
        if (refilterFunction) {
          for (index2 = 0; index2 < n1; ++index2) {
            if (!refilterFunction(newValues[index2], index2)) {
              filters[offset][newIndex[index2] + n0] |= one;
            }
          }
        } else {
          for (index3 = 0; index3 < lo1; ++index3) {
            filters[offset][newIndex[index3] + n0] |= one;
          }
          for (index4 = hi1; index4 < n1; ++index4) {
            filters[offset][newIndex[index4] + n0] |= one;
          }
        }
      }

      // If this dimension previously had no data, then we don't need to do the
      // more expensive merge operation; use the new values and index as-is.
      if (!n0) {
        values = newValues;
        index = newIndex;
        iterablesIndexCount = newIterablesIndexCount;
        iterablesIndexFilterStatus = newIterablesIndexFilterStatus;
        lo0 = lo1;
        hi0 = hi1;
        return;
      }
      var oldValues = values,
        oldIndex = index,
        oldIterablesIndexFilterStatus = iterablesIndexFilterStatus,
        old_n0,
        i1 = 0;
      i0 = 0;
      if (iterable) {
        old_n0 = n0;
        n0 = oldValues.length;
        n1 = t;
      }

      // Otherwise, create new arrays into which to merge new and old.
      values = iterable ? new Array(n0 + n1) : new Array(n);
      index = iterable ? new Array(n0 + n1) : cr_index(n, n);
      if (iterable) iterablesIndexFilterStatus = cr_index(n0 + n1, 1);

      // Concatenate the newIterablesIndexCount onto the old one.
      if (iterable) {
        var oldiiclength = iterablesIndexCount.length;
        iterablesIndexCount = _array.default.arrayLengthen(iterablesIndexCount, n);
        for (var j = 0; j + oldiiclength < n; j++) {
          iterablesIndexCount[j + oldiiclength] = newIterablesIndexCount[j];
        }
      }

      // Merge the old and new sorted values, and old and new index.
      var index5 = 0;
      for (; i0 < n0 && i1 < n1; ++index5) {
        if (oldValues[i0] < newValues[i1]) {
          values[index5] = oldValues[i0];
          if (iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];
          index[index5] = oldIndex[i0++];
        } else {
          values[index5] = newValues[i1];
          if (iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];
          index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);
        }
      }

      // Add any remaining old values.
      for (; i0 < n0; ++i0, ++index5) {
        values[index5] = oldValues[i0];
        if (iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];
        index[index5] = oldIndex[i0];
      }

      // Add any remaining new values.
      for (; i1 < n1; ++i1, ++index5) {
        values[index5] = newValues[i1];
        if (iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];
        index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);
      }

      // Bisect again to recompute lo0 and hi0.
      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];
    }

    // When all filters have updated, notify index listeners of the new values.
    function postAdd(newData, n0, n1) {
      indexListeners.forEach(function (l) {
        l(newValues, newIndex, n0, n1);
      });
      newValues = newIndex = null;
    }
    function removeData(reIndex) {
      if (iterable) {
        for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {
          if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {
            iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];
            i1++;
          }
        }
        iterablesEmptyRows.length = i1;
        for (i0 = 0, i1 = 0; i0 < n; i0++) {
          if (reIndex[i0] !== REMOVED_INDEX) {
            if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];
            i1++;
          }
        }
        iterablesIndexCount = iterablesIndexCount.slice(0, i1);
      }
      // Rewrite our index, overwriting removed values
      var n0 = values.length;
      for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {
        oldDataIndex = index[i];
        if (reIndex[oldDataIndex] !== REMOVED_INDEX) {
          if (i !== j) values[j] = values[i];
          index[j] = reIndex[oldDataIndex];
          if (iterable) {
            iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];
          }
          ++j;
        }
      }
      values.length = j;
      if (iterable) iterablesIndexFilterStatus = iterablesIndexFilterStatus.slice(0, j);
      while (j < n0) index[j++] = 0;

      // Bisect again to recompute lo0 and hi0.
      var bounds = refilter(values);
      lo0 = bounds[0], hi0 = bounds[1];
    }

    // Updates the selected values based on the specified bounds [lo, hi].
    // This implementation is used by all the public filter methods.
    function filterIndexBounds(bounds) {
      var lo1 = bounds[0],
        hi1 = bounds[1];
      if (refilterFunction) {
        refilterFunction = null;
        filterIndexFunction(function (d, i) {
          return lo1 <= i && i < hi1;
        }, bounds[0] === 0 && bounds[1] === values.length);
        lo0 = lo1;
        hi0 = hi1;
        return dimension;
      }
      var i,
        j,
        k,
        added = [],
        removed = [],
        valueIndexAdded = [],
        valueIndexRemoved = [];

      // Fast incremental update based on previous lo index.
      if (lo1 < lo0) {
        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
          added.push(index[i]);
          valueIndexAdded.push(i);
        }
      } else if (lo1 > lo0) {
        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
          removed.push(index[i]);
          valueIndexRemoved.push(i);
        }
      }

      // Fast incremental update based on previous hi index.
      if (hi1 > hi0) {
        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
          added.push(index[i]);
          valueIndexAdded.push(i);
        }
      } else if (hi1 < hi0) {
        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
          removed.push(index[i]);
          valueIndexRemoved.push(i);
        }
      }
      if (!iterable) {
        // Flip filters normally.

        for (i = 0; i < added.length; i++) {
          filters[offset][added[i]] ^= one;
        }
        for (i = 0; i < removed.length; i++) {
          filters[offset][removed[i]] ^= one;
        }
      } else {
        // For iterables, we need to figure out if the row has been completely removed vs partially included
        // Only count a row as added if it is not already being aggregated. Only count a row
        // as removed if the last element being aggregated is removed.

        var newAdded = [];
        var newRemoved = [];
        for (i = 0; i < added.length; i++) {
          iterablesIndexCount[added[i]]++;
          iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;
          if (iterablesIndexCount[added[i]] === 1) {
            filters[offset][added[i]] ^= one;
            newAdded.push(added[i]);
          }
        }
        for (i = 0; i < removed.length; i++) {
          iterablesIndexCount[removed[i]]--;
          iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;
          if (iterablesIndexCount[removed[i]] === 0) {
            filters[offset][removed[i]] ^= one;
            newRemoved.push(removed[i]);
          }
        }
        added = newAdded;
        removed = newRemoved;

        // Now handle empty rows.
        if (refilter === _filter.default.filterAll) {
          for (i = 0; i < iterablesEmptyRows.length; i++) {
            if (filters[offset][k = iterablesEmptyRows[i]] & one) {
              // Was not in the filter, so set the filter and add
              filters[offset][k] ^= one;
              added.push(k);
            }
          }
        } else {
          // filter in place - remove empty rows if necessary
          for (i = 0; i < iterablesEmptyRows.length; i++) {
            if (!(filters[offset][k = iterablesEmptyRows[i]] & one)) {
              // Was in the filter, so set the filter and remove
              filters[offset][k] ^= one;
              removed.push(k);
            }
          }
        }
      }
      lo0 = lo1;
      hi0 = hi1;
      filterListeners.forEach(function (l) {
        l(one, offset, added, removed);
      });
      triggerOnChange('filtered');
      return dimension;
    }

    // Filters this dimension using the specified range, value, or null.
    // If the range is null, this is equivalent to filterAll.
    // If the range is an array, this is equivalent to filterRange.
    // Otherwise, this is equivalent to filterExact.
    function filter(range) {
      return range == null ? filterAll() : Array.isArray(range) ? filterRange(range) : typeof range === "function" ? filterFunction(range) : filterExact(range);
    }

    // Filters this dimension to select the exact value.
    function filterExact(value) {
      filterValue = value;
      filterValuePresent = true;
      return filterIndexBounds((refilter = _filter.default.filterExact(_bisect.default, value))(values));
    }

    // Filters this dimension to select the specified range [lo, hi].
    // The lower bound is inclusive, and the upper bound is exclusive.
    function filterRange(range) {
      filterValue = range;
      filterValuePresent = true;
      return filterIndexBounds((refilter = _filter.default.filterRange(_bisect.default, range))(values));
    }

    // Clears any filters on this dimension.
    function filterAll() {
      filterValue = undefined;
      filterValuePresent = false;
      return filterIndexBounds((refilter = _filter.default.filterAll)(values));
    }

    // Filters this dimension using an arbitrary function.
    function filterFunction(f) {
      filterValue = f;
      filterValuePresent = true;
      refilterFunction = f;
      refilter = _filter.default.filterAll;
      filterIndexFunction(f, false);
      var bounds = refilter(values);
      lo0 = bounds[0], hi0 = bounds[1];
      return dimension;
    }
    function filterIndexFunction(f, filterAll) {
      var i,
        k,
        x,
        added = [],
        removed = [],
        valueIndexAdded = [],
        valueIndexRemoved = [],
        indexLength = values.length;
      if (!iterable) {
        for (i = 0; i < indexLength; ++i) {
          if (!(filters[offset][k = index[i]] & one) ^ !!(x = f(values[i], i))) {
            if (x) added.push(k);else removed.push(k);
          }
        }
      }
      if (iterable) {
        for (i = 0; i < indexLength; ++i) {
          if (f(values[i], i)) {
            added.push(index[i]);
            valueIndexAdded.push(i);
          } else {
            removed.push(index[i]);
            valueIndexRemoved.push(i);
          }
        }
      }
      if (!iterable) {
        for (i = 0; i < added.length; i++) {
          if (filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;
        }
        for (i = 0; i < removed.length; i++) {
          if (!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;
        }
      } else {
        var newAdded = [];
        var newRemoved = [];
        for (i = 0; i < added.length; i++) {
          // First check this particular value needs to be added
          if (iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {
            iterablesIndexCount[added[i]]++;
            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;
            if (iterablesIndexCount[added[i]] === 1) {
              filters[offset][added[i]] ^= one;
              newAdded.push(added[i]);
            }
          }
        }
        for (i = 0; i < removed.length; i++) {
          // First check this particular value needs to be removed
          if (iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {
            iterablesIndexCount[removed[i]]--;
            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;
            if (iterablesIndexCount[removed[i]] === 0) {
              filters[offset][removed[i]] ^= one;
              newRemoved.push(removed[i]);
            }
          }
        }
        added = newAdded;
        removed = newRemoved;

        // Now handle empty rows.
        if (filterAll) {
          for (i = 0; i < iterablesEmptyRows.length; i++) {
            if (filters[offset][k = iterablesEmptyRows[i]] & one) {
              // Was not in the filter, so set the filter and add
              filters[offset][k] ^= one;
              added.push(k);
            }
          }
        } else {
          // filter in place - remove empty rows if necessary
          for (i = 0; i < iterablesEmptyRows.length; i++) {
            if (!(filters[offset][k = iterablesEmptyRows[i]] & one)) {
              // Was in the filter, so set the filter and remove
              filters[offset][k] ^= one;
              removed.push(k);
            }
          }
        }
      }
      filterListeners.forEach(function (l) {
        l(one, offset, added, removed);
      });
      triggerOnChange('filtered');
    }
    function currentFilter() {
      return filterValue;
    }
    function hasCurrentFilter() {
      return filterValuePresent;
    }

    // Returns the top K selected records based on this dimension's order.
    // Note: observes this dimension's filter, unlike group and groupAll.
    function top(k, top_offset) {
      var array = [],
        i = hi0,
        j,
        toSkip = 0;
      if (top_offset && top_offset > 0) toSkip = top_offset;
      while (--i >= lo0 && k > 0) {
        if (filters.zero(j = index[i])) {
          if (toSkip > 0) {
            //skip matching row
            --toSkip;
          } else {
            array.push(data[j]);
            --k;
          }
        }
      }
      if (iterable) {
        for (i = 0; i < iterablesEmptyRows.length && k > 0; i++) {
          // Add row with empty iterable column at the end
          if (filters.zero(j = iterablesEmptyRows[i])) {
            if (toSkip > 0) {
              //skip matching row
              --toSkip;
            } else {
              array.push(data[j]);
              --k;
            }
          }
        }
      }
      return array;
    }

    // Returns the bottom K selected records based on this dimension's order.
    // Note: observes this dimension's filter, unlike group and groupAll.
    function bottom(k, bottom_offset) {
      var array = [],
        i,
        j,
        toSkip = 0;
      if (bottom_offset && bottom_offset > 0) toSkip = bottom_offset;
      if (iterable) {
        // Add row with empty iterable column at the top
        for (i = 0; i < iterablesEmptyRows.length && k > 0; i++) {
          if (filters.zero(j = iterablesEmptyRows[i])) {
            if (toSkip > 0) {
              //skip matching row
              --toSkip;
            } else {
              array.push(data[j]);
              --k;
            }
          }
        }
      }
      i = lo0;
      while (i < hi0 && k > 0) {
        if (filters.zero(j = index[i])) {
          if (toSkip > 0) {
            //skip matching row
            --toSkip;
          } else {
            array.push(data[j]);
            --k;
          }
        }
        i++;
      }
      return array;
    }

    // Adds a new group to this dimension, using the specified key function.
    function group(key) {
      var group = {
        top: top,
        all: all,
        reduce: reduce,
        reduceCount: reduceCount,
        reduceSum: reduceSum,
        order: order,
        orderNatural: orderNatural,
        size: size,
        dispose: dispose,
        remove: dispose // for backwards-compatibility
      };

      // Ensure that this group will be removed when the dimension is removed.
      dimensionGroups.push(group);
      var groups,
        // array of {key, value}
        groupIndex,
        // object id ↦ group id
        groupWidth = 8,
        groupCapacity = capacity(groupWidth),
        k = 0,
        // cardinality
        select,
        heap,
        reduceAdd,
        reduceRemove,
        reduceInitial,
        update = _null.default,
        reset = _null.default,
        resetNeeded = true,
        groupAll = key === _null.default,
        n0old;
      if (arguments.length < 1) key = _identity.default;

      // The group listens to the crossfilter for when any dimension changes, so
      // that it can update the associated reduce values. It must also listen to
      // the parent dimension for when data is added, and compute new keys.
      filterListeners.push(update);
      indexListeners.push(add);
      removeDataListeners.push(removeData);

      // Incorporate any existing data into the grouping.
      add(values, index, 0, n);

      // Incorporates the specified new values into this group.
      // This function is responsible for updating groups and groupIndex.
      function add(newValues, newIndex, n0, n1) {
        if (iterable) {
          n0old = n0;
          n0 = values.length - newValues.length;
          n1 = newValues.length;
        }
        var oldGroups = groups,
          reIndex = iterable ? [] : cr_index(k, groupCapacity),
          add = reduceAdd,
          remove = reduceRemove,
          initial = reduceInitial,
          k0 = k,
          // old cardinality
          i0 = 0,
          // index of old group
          i1 = 0,
          // index of new record
          j,
          // object id
          g0,
          // old group
          x0,
          // old key
          x1,
          // new key
          g,
          // group to add
          x; // key of group to add

        // If a reset is needed, we don't need to update the reduce values.
        if (resetNeeded) add = initial = _null.default;
        if (resetNeeded) remove = initial = _null.default;

        // Reset the new groups (k is a lower bound).
        // Also, make sure that groupIndex exists and is long enough.
        groups = new Array(k), k = 0;
        if (iterable) {
          groupIndex = k0 ? groupIndex : [];
        } else {
          groupIndex = k0 > 1 ? _array.default.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);
        }

        // Get the first old key (x0 of g0), if it exists.
        if (k0) x0 = (g0 = oldGroups[0]).key;

        // Find the first new key (x1), skipping NaN keys.
        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;

        // While new keys remain…
        while (i1 < n1) {
          // Determine the lesser of the two current keys; new and old.
          // If there are no old keys remaining, then always add the new key.
          if (g0 && x0 <= x1) {
            g = g0, x = x0;

            // Record the new index of the old group.
            reIndex[i0] = k;

            // Retrieve the next old key.
            g0 = oldGroups[++i0];
            if (g0) x0 = g0.key;
          } else {
            g = {
              key: x1,
              value: initial()
            }, x = x1;
          }

          // Add the lesser group.
          groups[k] = g;

          // Add any selected records belonging to the added group, while
          // advancing the new key and populating the associated group index.

          while (x1 <= x) {
            j = newIndex[i1] + (iterable ? n0old : n0);
            if (iterable) {
              if (groupIndex[j]) {
                groupIndex[j].push(k);
              } else {
                groupIndex[j] = [k];
              }
            } else {
              groupIndex[j] = k;
            }

            // Always add new values to groups. Only remove when not in filter.
            // This gives groups full information on data life-cycle.
            g.value = add(g.value, data[j], true);
            if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);
            if (++i1 >= n1) break;
            x1 = key(newValues[i1]);
          }
          groupIncrement();
        }

        // Add any remaining old groups that were greater th1an all new keys.
        // No incremental reduce is needed; these groups have no new records.
        // Also record the new index of the old group.
        while (i0 < k0) {
          groups[reIndex[i0] = k] = oldGroups[i0++];
          groupIncrement();
        }

        // Fill in gaps with empty arrays where there may have been rows with empty iterables
        if (iterable) {
          for (var index1 = 0; index1 < n; index1++) {
            if (!groupIndex[index1]) {
              groupIndex[index1] = [];
            }
          }
        }

        // If we added any new groups before any old groups,
        // update the group index of all the old records.
        if (k > i0) {
          if (iterable) {
            for (i0 = 0; i0 < n0old; ++i0) {
              for (index1 = 0; index1 < groupIndex[i0].length; index1++) {
                groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];
              }
            }
          } else {
            for (i0 = 0; i0 < n0; ++i0) {
              groupIndex[i0] = reIndex[groupIndex[i0]];
            }
          }
        }

        // Modify the update and reset behavior based on the cardinality.
        // If the cardinality is less than or equal to one, then the groupIndex
        // is not needed. If the cardinality is zero, then there are no records
        // and therefore no groups to update or reset. Note that we also must
        // change the registered listener to point to the new method.
        j = filterListeners.indexOf(update);
        if (k > 1 || iterable) {
          update = updateMany;
          reset = resetMany;
        } else {
          if (!k && groupAll) {
            k = 1;
            groups = [{
              key: null,
              value: initial()
            }];
          }
          if (k === 1) {
            update = updateOne;
            reset = resetOne;
          } else {
            update = _null.default;
            reset = _null.default;
          }
          groupIndex = null;
        }
        filterListeners[j] = update;

        // Count the number of added groups,
        // and widen the group index as needed.
        function groupIncrement() {
          if (iterable) {
            k++;
            return;
          }
          if (++k === groupCapacity) {
            reIndex = _array.default.arrayWiden(reIndex, groupWidth <<= 1);
            groupIndex = _array.default.arrayWiden(groupIndex, groupWidth);
            groupCapacity = capacity(groupWidth);
          }
        }
      }
      function removeData(reIndex) {
        if (k > 1 || iterable) {
          var oldK = k,
            oldGroups = groups,
            seenGroups = cr_index(oldK, oldK),
            i,
            i0,
            j;

          // Filter out non-matches by copying matching group index entries to
          // the beginning of the array.
          if (!iterable) {
            for (i = 0, j = 0; i < n; ++i) {
              if (reIndex[i] !== REMOVED_INDEX) {
                seenGroups[groupIndex[j] = groupIndex[i]] = 1;
                ++j;
              }
            }
          } else {
            for (i = 0, j = 0; i < n; ++i) {
              if (reIndex[i] !== REMOVED_INDEX) {
                groupIndex[j] = groupIndex[i];
                for (i0 = 0; i0 < groupIndex[j].length; i0++) {
                  seenGroups[groupIndex[j][i0]] = 1;
                }
                ++j;
              }
            }
            groupIndex = groupIndex.slice(0, j);
          }

          // Reassemble groups including only those groups that were referred
          // to by matching group index entries.  Note the new group index in
          // seenGroups.
          groups = [], k = 0;
          for (i = 0; i < oldK; ++i) {
            if (seenGroups[i]) {
              seenGroups[i] = k++;
              groups.push(oldGroups[i]);
            }
          }
          if (k > 1 || iterable) {
            // Reindex the group index using seenGroups to find the new index.
            if (!iterable) {
              for (i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];
            } else {
              for (i = 0; i < j; ++i) {
                for (i0 = 0; i0 < groupIndex[i].length; ++i0) {
                  groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];
                }
              }
            }
          } else {
            groupIndex = null;
          }
          filterListeners[filterListeners.indexOf(update)] = k > 1 || iterable ? (reset = resetMany, update = updateMany) : k === 1 ? (reset = resetOne, update = updateOne) : reset = update = _null.default;
        } else if (k === 1) {
          if (groupAll) return;
          for (var index3 = 0; index3 < n; ++index3) if (reIndex[index3] !== REMOVED_INDEX) return;
          groups = [], k = 0;
          filterListeners[filterListeners.indexOf(update)] = update = reset = _null.default;
        }
      }

      // Reduces the specified selected or deselected records.
      // This function is only used when the cardinality is greater than 1.
      // notFilter indicates a crossfilter.add/remove operation.
      function updateMany(filterOne, filterOffset, added, removed, notFilter) {
        if (filterOne === one && filterOffset === offset || resetNeeded) return;
        var i, j, k, n, g;
        if (iterable) {
          // Add the added values.
          for (i = 0, n = added.length; i < n; ++i) {
            if (filters.zeroExcept(k = added[i], offset, zero)) {
              for (j = 0; j < groupIndex[k].length; j++) {
                g = groups[groupIndex[k][j]];
                g.value = reduceAdd(g.value, data[k], false, j);
              }
            }
          }

          // Remove the removed values.
          for (i = 0, n = removed.length; i < n; ++i) {
            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {
              for (j = 0; j < groupIndex[k].length; j++) {
                g = groups[groupIndex[k][j]];
                g.value = reduceRemove(g.value, data[k], notFilter, j);
              }
            }
          }
          return;
        }

        // Add the added values.
        for (i = 0, n = added.length; i < n; ++i) {
          if (filters.zeroExcept(k = added[i], offset, zero)) {
            g = groups[groupIndex[k]];
            g.value = reduceAdd(g.value, data[k], false);
          }
        }

        // Remove the removed values.
        for (i = 0, n = removed.length; i < n; ++i) {
          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {
            g = groups[groupIndex[k]];
            g.value = reduceRemove(g.value, data[k], notFilter);
          }
        }
      }

      // Reduces the specified selected or deselected records.
      // This function is only used when the cardinality is 1.
      // notFilter indicates a crossfilter.add/remove operation.
      function updateOne(filterOne, filterOffset, added, removed, notFilter) {
        if (filterOne === one && filterOffset === offset || resetNeeded) return;
        var i,
          k,
          n,
          g = groups[0];

        // Add the added values.
        for (i = 0, n = added.length; i < n; ++i) {
          if (filters.zeroExcept(k = added[i], offset, zero)) {
            g.value = reduceAdd(g.value, data[k], false);
          }
        }

        // Remove the removed values.
        for (i = 0, n = removed.length; i < n; ++i) {
          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {
            g.value = reduceRemove(g.value, data[k], notFilter);
          }
        }
      }

      // Recomputes the group reduce values from scratch.
      // This function is only used when the cardinality is greater than 1.
      function resetMany() {
        var i, j, g;

        // Reset all group values.
        for (i = 0; i < k; ++i) {
          groups[i].value = reduceInitial();
        }

        // We add all records and then remove filtered records so that reducers
        // can build an 'unfiltered' view even if there are already filters in
        // place on other dimensions.
        if (iterable) {
          for (i = 0; i < n; ++i) {
            for (j = 0; j < groupIndex[i].length; j++) {
              g = groups[groupIndex[i][j]];
              g.value = reduceAdd(g.value, data[i], true, j);
            }
          }
          for (i = 0; i < n; ++i) {
            if (!filters.zeroExcept(i, offset, zero)) {
              for (j = 0; j < groupIndex[i].length; j++) {
                g = groups[groupIndex[i][j]];
                g.value = reduceRemove(g.value, data[i], false, j);
              }
            }
          }
          return;
        }
        for (i = 0; i < n; ++i) {
          g = groups[groupIndex[i]];
          g.value = reduceAdd(g.value, data[i], true);
        }
        for (i = 0; i < n; ++i) {
          if (!filters.zeroExcept(i, offset, zero)) {
            g = groups[groupIndex[i]];
            g.value = reduceRemove(g.value, data[i], false);
          }
        }
      }

      // Recomputes the group reduce values from scratch.
      // This function is only used when the cardinality is 1.
      function resetOne() {
        var i,
          g = groups[0];

        // Reset the singleton group values.
        g.value = reduceInitial();

        // We add all records and then remove filtered records so that reducers
        // can build an 'unfiltered' view even if there are already filters in
        // place on other dimensions.
        for (i = 0; i < n; ++i) {
          g.value = reduceAdd(g.value, data[i], true);
        }
        for (i = 0; i < n; ++i) {
          if (!filters.zeroExcept(i, offset, zero)) {
            g.value = reduceRemove(g.value, data[i], false);
          }
        }
      }

      // Returns the array of group values, in the dimension's natural order.
      function all() {
        if (resetNeeded) reset(), resetNeeded = false;
        return groups;
      }

      // Returns a new array containing the top K group values, in reduce order.
      function top(k) {
        var top = select(all(), 0, groups.length, k);
        return heap.sort(top, 0, top.length);
      }

      // Sets the reduce behavior for this group to use the specified functions.
      // This method lazily recomputes the reduce values, waiting until needed.
      function reduce(add, remove, initial) {
        reduceAdd = add;
        reduceRemove = remove;
        reduceInitial = initial;
        resetNeeded = true;
        return group;
      }

      // A convenience method for reducing by count.
      function reduceCount() {
        return reduce(_reduce.default.reduceIncrement, _reduce.default.reduceDecrement, _zero.default);
      }

      // A convenience method for reducing by sum(value).
      function reduceSum(value) {
        return reduce(_reduce.default.reduceAdd(value), _reduce.default.reduceSubtract(value), _zero.default);
      }

      // Sets the reduce order, using the specified accessor.
      function order(value) {
        select = _heapselect.default.by(valueOf);
        heap = _heap.default.by(valueOf);
        function valueOf(d) {
          return value(d.value);
        }
        return group;
      }

      // A convenience method for natural ordering by reduce value.
      function orderNatural() {
        return order(_identity.default);
      }

      // Returns the cardinality of this group, irrespective of any filters.
      function size() {
        return k;
      }

      // Removes this group and associated event listeners.
      function dispose() {
        var i = filterListeners.indexOf(update);
        if (i >= 0) filterListeners.splice(i, 1);
        i = indexListeners.indexOf(add);
        if (i >= 0) indexListeners.splice(i, 1);
        i = removeDataListeners.indexOf(removeData);
        if (i >= 0) removeDataListeners.splice(i, 1);
        i = dimensionGroups.indexOf(group);
        if (i >= 0) dimensionGroups.splice(i, 1);
        return group;
      }
      return reduceCount().orderNatural();
    }

    // A convenience function for generating a singleton group.
    function groupAll() {
      var g = group(_null.default),
        all = g.all;
      delete g.all;
      delete g.top;
      delete g.order;
      delete g.orderNatural;
      delete g.size;
      g.value = function () {
        return all()[0].value;
      };
      return g;
    }

    // Removes this dimension and associated groups and event listeners.
    function dispose() {
      dimensionGroups.forEach(function (group) {
        group.dispose();
      });
      var i = dataListeners.indexOf(preAdd);
      if (i >= 0) dataListeners.splice(i, 1);
      i = dataListeners.indexOf(postAdd);
      if (i >= 0) dataListeners.splice(i, 1);
      i = removeDataListeners.indexOf(removeData);
      if (i >= 0) removeDataListeners.splice(i, 1);
      filters.masks[offset] &= zero;
      return filterAll();
    }
    return dimension;
  }

  // A convenience method for groupAll on a dummy dimension.
  // This implementation can be optimized since it always has cardinality 1.
  function groupAll() {
    var group = {
      reduce: reduce,
      reduceCount: reduceCount,
      reduceSum: reduceSum,
      value: value,
      dispose: dispose,
      remove: dispose // for backwards-compatibility
    };
    var reduceValue,
      reduceAdd,
      reduceRemove,
      reduceInitial,
      resetNeeded = true;

    // The group listens to the crossfilter for when any dimension changes, so
    // that it can update the reduce value. It must also listen to the parent
    // dimension for when data is added.
    filterListeners.push(update);
    dataListeners.push(add);

    // For consistency; actually a no-op since resetNeeded is true.
    add(data, 0, n);

    // Incorporates the specified new values into this group.
    function add(newData, n0) {
      var i;
      if (resetNeeded) return;

      // Cycle through all the values.
      for (i = n0; i < n; ++i) {
        // Add all values all the time.
        reduceValue = reduceAdd(reduceValue, data[i], true);

        // Remove the value if filtered.
        if (!filters.zero(i)) {
          reduceValue = reduceRemove(reduceValue, data[i], false);
        }
      }
    }

    // Reduces the specified selected or deselected records.
    function update(filterOne, filterOffset, added, removed, notFilter) {
      var i, k, n;
      if (resetNeeded) return;

      // Add the added values.
      for (i = 0, n = added.length; i < n; ++i) {
        if (filters.zero(k = added[i])) {
          reduceValue = reduceAdd(reduceValue, data[k], notFilter);
        }
      }

      // Remove the removed values.
      for (i = 0, n = removed.length; i < n; ++i) {
        if (filters.only(k = removed[i], filterOffset, filterOne)) {
          reduceValue = reduceRemove(reduceValue, data[k], notFilter);
        }
      }
    }

    // Recomputes the group reduce value from scratch.
    function reset() {
      var i;
      reduceValue = reduceInitial();

      // Cycle through all the values.
      for (i = 0; i < n; ++i) {
        // Add all values all the time.
        reduceValue = reduceAdd(reduceValue, data[i], true);

        // Remove the value if it is filtered.
        if (!filters.zero(i)) {
          reduceValue = reduceRemove(reduceValue, data[i], false);
        }
      }
    }

    // Sets the reduce behavior for this group to use the specified functions.
    // This method lazily recomputes the reduce value, waiting until needed.
    function reduce(add, remove, initial) {
      reduceAdd = add;
      reduceRemove = remove;
      reduceInitial = initial;
      resetNeeded = true;
      return group;
    }

    // A convenience method for reducing by count.
    function reduceCount() {
      return reduce(_reduce.default.reduceIncrement, _reduce.default.reduceDecrement, _zero.default);
    }

    // A convenience method for reducing by sum(value).
    function reduceSum(value) {
      return reduce(_reduce.default.reduceAdd(value), _reduce.default.reduceSubtract(value), _zero.default);
    }

    // Returns the computed reduce value.
    function value() {
      if (resetNeeded) reset(), resetNeeded = false;
      return reduceValue;
    }

    // Removes this group and associated event listeners.
    function dispose() {
      var i = filterListeners.indexOf(update);
      if (i >= 0) filterListeners.splice(i, 1);
      i = dataListeners.indexOf(add);
      if (i >= 0) dataListeners.splice(i, 1);
      return group;
    }
    return reduceCount();
  }

  // Returns the number of records in this crossfilter, irrespective of any filters.
  function size() {
    return n;
  }

  // Returns the raw row data contained in this crossfilter
  function all() {
    return data;
  }

  // Returns row data with all dimension filters applied, except for filters in ignore_dimensions
  function allFiltered(ignore_dimensions) {
    var array = [],
      i = 0,
      mask = maskForDimensions(ignore_dimensions || []);
    for (i = 0; i < n; i++) {
      if (filters.zeroExceptMask(i, mask)) {
        array.push(data[i]);
      }
    }
    return array;
  }
  function onChange(cb) {
    if (typeof cb !== 'function') {
      /* eslint no-console: 0 */
      console.warn('onChange callback parameter must be a function!');
      return;
    }
    callbacks.push(cb);
    return function () {
      callbacks.splice(callbacks.indexOf(cb), 1);
    };
  }
  function triggerOnChange(eventName) {
    for (var i = 0; i < callbacks.length; i++) {
      callbacks[i](eventName);
    }
  }
  return arguments.length ? add(arguments[0]) : crossfilter;
}

// Returns an array of size n, big enough to store ids up to m.
function cr_index(n, m) {
  return (m < 0x101 ? _array.default.array8 : m < 0x10001 ? _array.default.array16 : _array.default.array32)(n);
}

// Constructs a new array of size n, with sequential values from 0 to n - 1.
function cr_range(n) {
  var range = cr_index(n, n);
  for (var i = -1; ++i < n;) range[i] = i;
  return range;
}
function capacity(w) {
  return w === 8 ? 0x100 : w === 16 ? 0x10000 : 0x100000000;
}
},{"./array":"../node_modules/crossfilter2/src/array.js","./filter":"../node_modules/crossfilter2/src/filter.js","./identity":"../node_modules/crossfilter2/src/identity.js","./null":"../node_modules/crossfilter2/src/null.js","./zero":"../node_modules/crossfilter2/src/zero.js","./heapselect":"../node_modules/crossfilter2/src/heapselect.js","./heap":"../node_modules/crossfilter2/src/heap.js","./bisect":"../node_modules/crossfilter2/src/bisect.js","./permute":"../node_modules/crossfilter2/src/permute.js","./reduce":"../node_modules/crossfilter2/src/reduce.js","./result":"../node_modules/crossfilter2/src/result.js"}],"../node_modules/crossfilter2/main.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _index.default;
  }
});
var _index = _interopRequireDefault(require("./src/index.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/index.js":"../node_modules/crossfilter2/src/index.js"}],"../node_modules/@cosmograph/cosmograph/modules/cosmograph/crossfilter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Filter = exports.Crossfilter = void 0;
var _crossfilter = _interopRequireDefault(require("crossfilter2"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class i {
  constructor(s, i, e) {
    this._crossfilter = s, this._selfRemove = i, this._syncUp = e;
  }
  setAccessor(s) {
    const {
      _crossfilter: i
    } = this;
    this.dispose(), this._dimension = i.dimension(s);
  }
  applyFilter(s) {
    var i, e;
    null === (i = this._dimension) || void 0 === i || i.filter(s), null === (e = this._syncUp) || void 0 === e || e.call(this);
  }
  clear() {
    var s, i;
    null === (s = this._dimension) || void 0 === s || s.filterAll(), null === (i = this._syncUp) || void 0 === i || i.call(this);
  }
  getAllValues() {
    const {
      _crossfilter: s,
      _dimension: i
    } = this;
    if (i) return s.all().map(i.accessor);
  }
  getFilteredValues() {
    const {
      _crossfilter: s,
      _dimension: i
    } = this;
    if (i) return s.allFiltered().map(i.accessor);
  }
  getFilteredRecords() {
    return this._crossfilter.allFiltered([this._dimension]);
  }
  isActive() {
    var s;
    return (null === (s = this._dimension) || void 0 === s ? void 0 : s.hasCurrentFilter()) || !1;
  }
  dispose() {
    var s;
    null === (s = this._dimension) || void 0 === s || s.dispose();
  }
  remove() {
    this.dispose(), this._selfRemove();
  }
}
exports.Filter = i;
class e {
  constructor(i) {
    this._crossfilter = (0, _crossfilter.default)(), this._filters = new Set(), this._syncUpFunction = i, this._crossfilter.onChange(s => {
      var i, e, t;
      switch (s) {
        case "filtered":
          null === (i = this.onFiltered) || void 0 === i || i.call(this), this._filters.forEach(s => {
            var i;
            null === (i = s.onFiltered) || void 0 === i || i.call(s);
          });
          break;
        case "dataAdded":
          null === (e = this.onDataAdded) || void 0 === e || e.call(this), this._filters.forEach(s => {
            var i;
            null === (i = s.onDataAdded) || void 0 === i || i.call(s);
          });
          break;
        case "dataRemoved":
          null === (t = this.onDataRemoved) || void 0 === t || t.call(this), this._filters.forEach(s => {
            var i;
            null === (i = s.onDataRemoved) || void 0 === i || i.call(s);
          });
      }
    });
  }
  addRecords(s) {
    const {
      _crossfilter: i
    } = this;
    this._records = s, i.remove(), i.add(s);
  }
  getFilteredRecords(s) {
    const {
      _crossfilter: i
    } = this;
    return (null == s ? void 0 : s.getFilteredRecords()) || i.allFiltered();
  }
  addFilter(s = !0) {
    const e = new i(this._crossfilter, () => {
      this._filters.delete(e);
    }, s ? this._syncUpFunction : void 0);
    return this._filters.add(e), e;
  }
  clearFilters() {
    this._filters.forEach(s => {
      s.clear();
    });
  }
  isAnyFiltersActive(s) {
    for (const i of this._filters.values()) if (i !== s && i.isActive()) return !0;
    return !1;
  }
  getAllRecords() {
    return this._records;
  }
}
exports.Crossfilter = e;
},{"crossfilter2":"../node_modules/crossfilter2/main.js"}],"../node_modules/@cosmograph/cosmograph/modules/cosmograph/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cosmograph = void 0;
var _cosmos = require("@cosmograph/cosmos");
var _cssLabels = require("@interacta/css-labels");
var _ui = require("@cosmograph/ui");
var _d3Color = require("d3-color");
var _watermark = require("./watermark.js");
var _supabase = require("../../api/supabase/supabase.js");
var _styleModuleCss = _interopRequireDefault(require("./style.module.css.js"));
var _config = require("./config.js");
var _crossfilter = require("./crossfilter.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class h {
  constructor(s, i) {
    var l;
    this._data = {
      nodes: [],
      links: []
    }, this._previousData = {
      nodes: [],
      links: []
    }, this._cosmographConfig = {}, this._cosmosConfig = {}, this._nodesForTopLabels = new Set(), this._nodesForForcedLabels = new Set(), this._trackedNodeToLabel = new Map(), this._isLabelsDestroyed = !1, this._svgParser = new DOMParser(), this._nodesCrossfilter = new _crossfilter.Crossfilter(this._applyLinksFilter.bind(this)), this._linksCrossfilter = new _crossfilter.Crossfilter(this._applyNodesFilter.bind(this)), this._nodesFilter = this._nodesCrossfilter.addFilter(!1), this._linksFilter = this._linksCrossfilter.addFilter(!1), this._selectedNodesFilter = this._nodesCrossfilter.addFilter(), this._isDataDifferent = () => {
      const s = JSON.stringify(this._data.nodes),
        e = JSON.stringify(this._previousData.nodes),
        o = JSON.stringify(this._data.links),
        t = JSON.stringify(this._previousData.links);
      return s !== e || o !== t;
    }, this._onClick = (...s) => {
      var e, o;
      null === (o = (e = this._cosmographConfig).onClick) || void 0 === o || o.call(e, ...s);
    }, this._onLabelClick = (s, e) => {
      var o, t, i;
      const n = null === (o = this._cosmos) || void 0 === o ? void 0 : o.graph.getNodeById(e.id);
      n && (null === (i = (t = this._cosmographConfig).onLabelClick) || void 0 === i || i.call(t, n, s));
    }, this._onHoveredNodeClick = s => {
      var e, o;
      this._hoveredNode && (null === (o = (e = this._cosmographConfig).onLabelClick) || void 0 === o || o.call(e, this._hoveredNode, s));
    }, this._onNodeMouseOver = (...s) => {
      var e, o;
      null === (o = (e = this._cosmographConfig).onNodeMouseOver) || void 0 === o || o.call(e, ...s);
      const [t,, i] = s;
      this._hoveredNode = t, this._renderLabelForHovered(t, i);
    }, this._onNodeMouseOut = (...s) => {
      var e, o;
      null === (o = (e = this._cosmographConfig).onNodeMouseOut) || void 0 === o || o.call(e, ...s), this._renderLabelForHovered();
    }, this._onMouseMove = (...s) => {
      var e, o;
      null === (o = (e = this._cosmographConfig).onMouseMove) || void 0 === o || o.call(e, ...s);
      const [t,, i] = s;
      this._renderLabelForHovered(t, i);
    }, this._onZoomStart = (...s) => {
      var e, o;
      null === (o = (e = this._cosmographConfig).onZoomStart) || void 0 === o || o.call(e, ...s);
    }, this._onZoom = (...s) => {
      var e, o;
      null === (o = (e = this._cosmographConfig).onZoom) || void 0 === o || o.call(e, ...s), this._renderLabelForHovered(), this._renderLabels();
    }, this._onZoomEnd = (...s) => {
      var e, o;
      null === (o = (e = this._cosmographConfig).onZoomEnd) || void 0 === o || o.call(e, ...s);
    }, this._onStart = (...s) => {
      var e, o;
      null === (o = (e = this._cosmographConfig).onSimulationStart) || void 0 === o || o.call(e, ...s);
    }, this._onTick = (...s) => {
      var e, o;
      null === (o = (e = this._cosmographConfig).onSimulationTick) || void 0 === o || o.call(e, ...s), this._renderLabels();
    }, this._onEnd = (...s) => {
      var e, o;
      null === (o = (e = this._cosmographConfig).onSimulationEnd) || void 0 === o || o.call(e, ...s);
    }, this._onPause = (...s) => {
      var e, o;
      null === (o = (e = this._cosmographConfig).onSimulationPause) || void 0 === o || o.call(e, ...s);
    }, this._onRestart = (...s) => {
      var e, o;
      null === (o = (e = this._cosmographConfig).onSimulationRestart) || void 0 === o || o.call(e, ...s);
    }, this._containerNode = s, this._containerNode.classList.add(_styleModuleCss.default.cosmograph), this._cosmographConfig = (0, _ui.merge)(_config.defaultCosmographConfig, null != i ? i : {}), this._cosmosConfig = this._createCosmosConfig(i), this._canvasElement = document.createElement("canvas"), this._labelsDivElement = document.createElement("div"), this._watermarkDivElement = document.createElement("div"), this._watermarkDivElement.classList.add(_styleModuleCss.default.watermark), this._watermarkDivElement.onclick = () => {
      var s;
      return null === (s = window.open("https://cosmograph.app/", "_blank")) || void 0 === s ? void 0 : s.focus();
    }, s.appendChild(this._canvasElement), s.appendChild(this._labelsDivElement), s.appendChild(this._watermarkDivElement), this._cssLabelsRenderer = new _cssLabels.LabelRenderer(this._labelsDivElement, {
      dispatchWheelEventElement: this._canvasElement,
      pointerEvents: "all",
      onLabelClick: this._onLabelClick.bind(this)
    }), this._hoveredCssLabel = new _cssLabels.CssLabel(this._labelsDivElement), this._hoveredCssLabel.setPointerEvents("all"), this._hoveredCssLabel.element.addEventListener("click", this._onHoveredNodeClick.bind(this)), this._linksFilter.setAccessor(s => [s.source, s.target]), this._nodesFilter.setAccessor(s => s.id), this._selectedNodesFilter.setAccessor(s => s.id), this._nodesCrossfilter.onFiltered = () => {
      var s, e, o, t;
      let i;
      this._nodesCrossfilter.isAnyFiltersActive() ? (i = this._nodesCrossfilter.getFilteredRecords(), null === (s = this._cosmos) || void 0 === s || s.selectNodesByIds(i.map(s => s.id))) : null === (e = this._cosmos) || void 0 === e || e.unselectNodes(), this._updateSelectedNodesSet(i), null === (t = (o = this._cosmographConfig).onNodesFiltered) || void 0 === t || t.call(o, i);
    }, this._linksCrossfilter.onFiltered = () => {
      var s, e;
      let o;
      this._linksCrossfilter.isAnyFiltersActive() && (o = this._linksCrossfilter.getFilteredRecords()), null === (e = (s = this._cosmographConfig).onLinksFiltered) || void 0 === e || e.call(s, o);
    };
    const h = this._svgParser.parseFromString(_watermark.watermark, "image/svg+xml").firstChild;
    null === (l = this._watermarkDivElement) || void 0 === l || l.appendChild(h);
  }
  get data() {
    return this._data;
  }
  get progress() {
    var s;
    return null === (s = this._cosmos) || void 0 === s ? void 0 : s.progress;
  }
  get isSimulationRunning() {
    var s;
    return null === (s = this._cosmos) || void 0 === s ? void 0 : s.isSimulationRunning;
  }
  get maxPointSize() {
    var s;
    return null === (s = this._cosmos) || void 0 === s ? void 0 : s.maxPointSize;
  }
  setData(e, o) {
    var t, i, n, r;
    const {
      _cosmographConfig: a
    } = this;
    this._data = {
      nodes: e,
      links: o
    };
    const d = null === a.disableSimulation ? !o.length : a.disableSimulation;
    this._cosmos || (this._disableSimulation = d, this._cosmosConfig.disableSimulation = this._disableSimulation, this._cosmos = new _cosmos.Graph(this._canvasElement, this._cosmosConfig), this.cosmos = this._cosmos), this._disableSimulation !== d && console.warn(`The \`disableSimulation\` was initialized to \`${this._disableSimulation}\` during initialization and will not be modified.`), this._cosmos.setData(e, o), this._nodesCrossfilter.addRecords(e), this._linksCrossfilter.addRecords(o), this._updateLabels(), null === (i = (t = this._cosmographConfig).onSetData) || void 0 === i || i.call(t, e, o), this._isDataDifferent() && (["cosmograph.app"].includes(window.location.hostname) || (0, _supabase.addMetrics)({
      browser: navigator.userAgent,
      hostname: window.location.hostname,
      mode: null,
      is_library_metric: !0,
      links_count: o.length,
      links_have_time: null,
      links_raw_columns: o.length && null !== (n = Object.keys(null == o ? void 0 : o[0]).length) && void 0 !== n ? n : 0,
      links_raw_lines: null,
      nodes_count: e.length,
      nodes_have_time: null,
      nodes_raw_columns: e.length && null !== (r = Object.keys(null == e ? void 0 : e[0]).length) && void 0 !== r ? r : 0,
      nodes_raw_lines: null
    })), this._previousData = {
      nodes: e,
      links: o
    };
  }
  setConfig(s) {
    var e, o;
    if (this._cosmographConfig = (0, _ui.merge)(_config.defaultCosmographConfig, null != s ? s : {}), this._cosmosConfig = this._createCosmosConfig(s), null === (e = this._cosmos) || void 0 === e || e.setConfig(this._cosmosConfig), null == s ? void 0 : s.backgroundColor) {
      const e = null === (o = (0, _d3Color.color)(null == s ? void 0 : s.backgroundColor)) || void 0 === o ? void 0 : o.formatHex();
      if (e) {
        const s = this._checkBrightness(e),
          o = document.querySelector(":root");
        s > .65 ? null == o || o.style.setProperty("--cosmograph-watermark-color", "#000000") : null == o || o.style.setProperty("--cosmograph-watermark-color", "#ffffff");
      }
    }
    this._updateLabels();
  }
  addNodesFilter() {
    return this._nodesCrossfilter.addFilter();
  }
  addLinksFilter() {
    return this._linksCrossfilter.addFilter();
  }
  selectNodesInRange(s) {
    var e;
    if (!this._cosmos) return;
    this._cosmos.selectNodesInRange(s);
    const o = new Set((null !== (e = this.getSelectedNodes()) && void 0 !== e ? e : []).map(s => s.id));
    this._selectedNodesFilter.applyFilter(s => o.has(s));
  }
  selectNodes(s) {
    if (!this._cosmos) return;
    const e = new Set(s.map(s => s.id));
    this._selectedNodesFilter.applyFilter(s => e.has(s));
  }
  selectNode(s, e = !1) {
    if (!this._cosmos) return;
    const o = new Set([s, ...(e && this._cosmos.getAdjacentNodes(s.id) || [])].map(s => s.id));
    this._selectedNodesFilter.applyFilter(s => o.has(s));
  }
  unselectNodes() {
    this._cosmos && this._selectedNodesFilter.clear();
  }
  getSelectedNodes() {
    if (this._cosmos) return this._cosmos.getSelectedNodes();
  }
  zoomToNode(s) {
    this._cosmos && this._cosmos.zoomToNodeById(s.id);
  }
  setZoomLevel(s, e = 0) {
    this._cosmos && this._cosmos.setZoomLevel(s, e);
  }
  getZoomLevel() {
    if (this._cosmos) return this._cosmos.getZoomLevel();
  }
  getNodePositions() {
    if (this._cosmos) return this._cosmos.getNodePositions();
  }
  getNodePositionsMap() {
    if (this._cosmos) return this._cosmos.getNodePositionsMap();
  }
  getNodePositionsArray() {
    if (this._cosmos) return this._cosmos.getNodePositionsArray();
  }
  fitView(s = 250) {
    this._cosmos && this._cosmos.fitView(s);
  }
  fitViewByNodeIds(s, e = 250) {
    this._cosmos && this._cosmos.fitViewByNodeIds(s, e);
  }
  focusNode(s) {
    this._cosmos && this._cosmos.setFocusedNodeById(null == s ? void 0 : s.id);
  }
  getAdjacentNodes(s) {
    if (this._cosmos) return this._cosmos.getAdjacentNodes(s);
  }
  spaceToScreenPosition(s) {
    if (this._cosmos) return this._cosmos.spaceToScreenPosition(s);
  }
  spaceToScreenRadius(s) {
    if (this._cosmos) return this._cosmos.spaceToScreenRadius(s);
  }
  getNodeRadiusByIndex(s) {
    if (this._cosmos) return this._cosmos.getNodeRadiusByIndex(s);
  }
  getNodeRadiusById(s) {
    if (this._cosmos) return this._cosmos.getNodeRadiusById(s);
  }
  getSampledNodePositionsMap() {
    if (this._cosmos) return this._cosmos.getSampledNodePositionsMap();
  }
  start(s = 1) {
    this._cosmos && this._cosmos.start(s);
  }
  pause() {
    this._cosmos && this._cosmos.pause();
  }
  restart() {
    this._cosmos && this._cosmos.restart();
  }
  step() {
    this._cosmos && this._cosmos.step();
  }
  remove() {
    var s;
    null === (s = this._cosmos) || void 0 === s || s.destroy(), this._isLabelsDestroyed || (this._containerNode.innerHTML = "", this._isLabelsDestroyed = !0, this._hoveredCssLabel.element.removeEventListener("click", this._onHoveredNodeClick.bind(this)), this._hoveredCssLabel.destroy(), this._cssLabelsRenderer.destroy());
  }
  create() {
    this._cosmos && this._cosmos.create();
  }
  getNodeDegrees() {
    if (this._cosmos) return this._cosmos.graph.degree;
  }
  _createCosmosConfig(s) {
    const e = {
      ...s,
      simulation: {
        ...Object.keys(null != s ? s : {}).filter(s => -1 !== s.indexOf("simulation")).reduce((e, o) => {
          const t = o.replace("simulation", "");
          return e[t.charAt(0).toLowerCase() + t.slice(1)] = null == s ? void 0 : s[o], e;
        }, {}),
        onStart: this._onStart.bind(this),
        onTick: this._onTick.bind(this),
        onEnd: this._onEnd.bind(this),
        onPause: this._onPause.bind(this),
        onRestart: this._onRestart.bind(this)
      },
      events: {
        onClick: this._onClick.bind(this),
        onNodeMouseOver: this._onNodeMouseOver.bind(this),
        onNodeMouseOut: this._onNodeMouseOut.bind(this),
        onMouseMove: this._onMouseMove.bind(this),
        onZoomStart: this._onZoomStart.bind(this),
        onZoom: this._onZoom.bind(this),
        onZoomEnd: this._onZoomEnd.bind(this)
      }
    };
    return delete e.disableSimulation, e;
  }
  _updateLabels() {
    if (this._isLabelsDestroyed || !this._cosmos) return;
    const {
      _cosmos: s,
      data: {
        nodes: e
      },
      _cosmographConfig: {
        showTopLabels: o,
        showTopLabelsLimit: t,
        showLabelsFor: i,
        showTopLabelsValueKey: n,
        nodeLabelAccessor: l
      }
    } = this;
    if (this._nodesForTopLabels.clear(), o && t) {
      let o;
      o = n ? [...e].sort((s, e) => {
        const o = s[n],
          t = e[n];
        return "number" == typeof o && "number" == typeof t ? t - o : 0;
      }) : Object.entries(s.graph.degree).sort((s, e) => e[1] - s[1]).slice(0, t).map(e => s.graph.getNodeByIndex(+e[0]));
      for (let s = 0; s < t && !(s >= e.length); s++) {
        const e = o[s];
        e && this._nodesForTopLabels.add(e);
      }
    }
    this._nodesForForcedLabels.clear(), null == i || i.forEach(this._nodesForForcedLabels.add, this._nodesForForcedLabels), this._trackedNodeToLabel.clear(), s.trackNodePositionsByIds([...(o ? this._nodesForTopLabels : []), ...this._nodesForForcedLabels].map(s => {
      var e;
      return this._trackedNodeToLabel.set(s, null !== (e = null == l ? void 0 : l(s)) && void 0 !== e ? e : s.id), s.id;
    })), this._renderLabels();
  }
  _updateSelectedNodesSet(s) {
    this._isLabelsDestroyed || (s ? (this._selectedNodesSet = new Set(), null == s || s.forEach(this._selectedNodesSet.add, this._selectedNodesSet)) : this._selectedNodesSet = void 0, this._renderLabels());
  }
  _renderLabels() {
    if (this._isLabelsDestroyed || !this._cosmos) return;
    const {
      _cosmos: s,
      _selectedNodesSet: e,
      _cosmographConfig: {
        showDynamicLabels: o,
        nodeLabelAccessor: t,
        nodeLabelColor: i,
        nodeLabelClassName: n
      }
    } = this;
    let l = [];
    const a = s.getTrackedNodePositionsMap(),
      d = new Map();
    if (o) {
      const e = this.getSampledNodePositionsMap();
      null == e || e.forEach((e, o) => {
        var i;
        const n = s.graph.getNodeById(o);
        n && d.set(n, [null !== (i = null == t ? void 0 : t(n)) && void 0 !== i ? i : n.id, e, _styleModuleCss.default.cosmographShowDynamicLabels, .7]);
      });
    }
    this._nodesForTopLabels.forEach(s => {
      d.set(s, [this._trackedNodeToLabel.get(s), a.get(s.id), _styleModuleCss.default.cosmographShowTopLabels, .9]);
    }), this._nodesForForcedLabels.forEach(s => {
      d.set(s, [this._trackedNodeToLabel.get(s), a.get(s.id), _styleModuleCss.default.cosmographShowLabelsFor, 1]);
    }), l = [...d.entries()].map(([o, [t, l, r, a]]) => {
      var d, h, c;
      const _ = this.spaceToScreenPosition([null !== (d = null == l ? void 0 : l[0]) && void 0 !== d ? d : 0, null !== (h = null == l ? void 0 : l[1]) && void 0 !== h ? h : 0]),
        m = this.spaceToScreenRadius(s.config.nodeSizeScale * this.getNodeRadiusById(o.id)),
        u = !!e,
        v = null == e ? void 0 : e.has(o);
      return {
        id: o.id,
        text: null != t ? t : "",
        x: _[0],
        y: _[1] - (m + 2),
        weight: u && !v ? .1 : a,
        shouldBeShown: this._nodesForForcedLabels.has(o),
        style: u && !v ? "opacity: 0.1;" : "",
        color: i && ("string" == typeof i ? i : null == i ? void 0 : i(o)),
        className: null !== (c = "string" == typeof n ? n : null == n ? void 0 : n(o)) && void 0 !== c ? c : r
      };
    }), this._cssLabelsRenderer.setLabels(l), this._cssLabelsRenderer.draw(!0);
  }
  _renderLabelForHovered(s, e) {
    var o, t;
    if (!this._cosmos) return;
    const {
      _cosmographConfig: {
        showHoveredNodeLabel: i,
        nodeLabelAccessor: n,
        hoveredNodeLabelClassName: l,
        hoveredNodeLabelColor: r
      }
    } = this;
    if (!this._isLabelsDestroyed) {
      if (i && s && e) {
        const i = this.spaceToScreenPosition(e),
          a = this.spaceToScreenRadius(this.getNodeRadiusById(s.id));
        this._hoveredCssLabel.setText(null !== (o = null == n ? void 0 : n(s)) && void 0 !== o ? o : s.id), this._hoveredCssLabel.setVisibility(!0), this._hoveredCssLabel.setPosition(i[0], i[1] - (a + 2)), this._hoveredCssLabel.setClassName("string" == typeof l ? l : null !== (t = null == l ? void 0 : l(s)) && void 0 !== t ? t : "");
        const d = r && ("string" == typeof r ? r : null == r ? void 0 : r(s));
        d && this._hoveredCssLabel.setColor(d);
      } else this._hoveredCssLabel.setVisibility(!1);
      this._hoveredCssLabel.draw();
    }
  }
  _applyLinksFilter() {
    if (this._nodesCrossfilter.isAnyFiltersActive(this._nodesFilter)) {
      const s = this._nodesCrossfilter.getFilteredRecords(this._nodesFilter),
        e = new Set(s.map(s => s.id));
      this._linksFilter.applyFilter(s => {
        const o = null == s ? void 0 : s[0],
          t = null == s ? void 0 : s[1];
        return e.has(o) && e.has(t);
      });
    } else this._linksFilter.clear();
  }
  _applyNodesFilter() {
    if (this._linksCrossfilter.isAnyFiltersActive(this._linksFilter)) {
      const s = this._linksCrossfilter.getFilteredRecords(this._linksFilter),
        e = new Set(s.map(s => [s.source, s.target]).flat());
      this._nodesFilter.applyFilter(s => e.has(s));
    } else this._nodesFilter.clear();
  }
  _checkBrightness(s) {
    const e = (s => {
      const e = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(s);
      return e ? {
        r: parseInt((e[1] || 0).toString(), 16),
        g: parseInt((e[2] || 0).toString(), 16),
        b: parseInt((e[3] || 0).toString(), 16)
      } : {
        r: 0,
        g: 0,
        b: 0
      };
    })(s);
    return (.2126 * e.r + .7152 * e.g + .0722 * e.b) / 255;
  }
}
exports.Cosmograph = h;
},{"@cosmograph/cosmos":"../node_modules/@cosmograph/cosmos/dist/index.js","@interacta/css-labels":"../node_modules/@interacta/css-labels/dist/index.js","@cosmograph/ui":"../node_modules/@cosmograph/ui/index.js","d3-color":"../node_modules/d3-color/src/index.js","./watermark.js":"../node_modules/@cosmograph/cosmograph/modules/cosmograph/watermark.js","../../api/supabase/supabase.js":"../node_modules/@cosmograph/cosmograph/api/supabase/supabase.js","./style.module.css.js":"../node_modules/@cosmograph/cosmograph/modules/cosmograph/style.module.css.js","./config.js":"../node_modules/@cosmograph/cosmograph/modules/cosmograph/config.js","./crossfilter.js":"../node_modules/@cosmograph/cosmograph/modules/cosmograph/crossfilter.js"}],"../node_modules/@cosmograph/cosmograph/modules/search/config.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultCosmographSearchConfig = void 0;
const o = exports.defaultCosmographSearchConfig = {
  onSelectResult: void 0,
  accessors: void 0
};
},{}],"../node_modules/@cosmograph/cosmograph/modules/search/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CosmographSearch = void 0;
var _ui = require("@cosmograph/ui");
var _config = require("./config.js");
class i {
  constructor(i, o, c) {
    this._config = {}, this._data = [], this._defaultAccessors = [], this._createDefaultAccessorOptions = s => s.length > 0 && s[0] ? Object.keys(s[0]).map(s => ({
      label: s,
      accessor: t => String(t[s])
    })) : [{
      label: "id",
      accessor: s => s.id
    }], this._onSelect = (...s) => {
      this._onSelectResult(...s);
    }, this._onSearch = (...s) => {
      var t, e;
      null === (e = (t = this._config).onSearch) || void 0 === e || e.call(t, ...s);
    }, this._onEnter = (...s) => {
      var t, e;
      null === (e = (t = this._config).onEnter) || void 0 === e || e.call(t, ...s);
    }, this._onAccessorSelect = (...s) => {
      var t, e;
      null === (e = (t = this._config).onAccessorSelect) || void 0 === e || e.call(t, ...s);
    }, this._cosmograph = i, this._config = (0, _ui.merge)(_config.defaultCosmographSearchConfig, null != c ? c : {}), this.search = new _ui.Search(o, this._createSearchConfig(c)), this._filter = this._cosmograph.addNodesFilter(), this._filter.onDataAdded = () => {
      this._updateData();
    }, this._updateData();
  }
  setConfig(t) {
    const i = (0, _ui.merge)(_config.defaultCosmographSearchConfig, null != t ? t : {});
    this._data.length && void 0 === i.accessors && (i.accessors = this._defaultAccessors), this.search.setConfig(this._createSearchConfig(i)), this._config = i;
  }
  _updateData() {
    const s = this._cosmograph.data.nodes;
    (null == s ? void 0 : s.length) && (this._data = s, this.search.setData(this._data), void 0 === this._config.accessors && (this._defaultAccessors = this._createDefaultAccessorOptions(this._data), this.setConfig({
      accessors: this._defaultAccessors
    })));
  }
  getConfig() {
    return this._config;
  }
  remove() {
    this.search.destroy();
  }
  setListState(s) {
    this.search.setListState(s);
  }
  clearInput() {
    this.search.clearInput();
  }
  _onSelectResult(s) {
    var t, e;
    this._cosmograph.pause(), this._cosmograph.zoomToNode(s), this._cosmograph.selectNode(s), null === (e = (t = this._config).onSelectResult) || void 0 === e || e.call(t, s);
  }
  _createSearchConfig(s) {
    return {
      ...s,
      events: {
        onSelect: this._onSelect.bind(this),
        onSearch: this._onSearch.bind(this),
        onEnter: this._onEnter.bind(this),
        onAccessorSelect: this._onAccessorSelect.bind(this)
      }
    };
  }
}
exports.CosmographSearch = i;
},{"@cosmograph/ui":"../node_modules/@cosmograph/ui/index.js","./config.js":"../node_modules/@cosmograph/cosmograph/modules/search/config.js"}],"../node_modules/@cosmograph/cosmograph/modules/cosmograph/types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterType = void 0;
var n;
!function (n) {
  n.Nodes = "nodes", n.Links = "links";
}(n || (exports.FilterType = n = {}));
},{}],"../node_modules/@cosmograph/cosmograph/modules/timeline/config.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultCosmographTimelineConfig = void 0;
var _types = require("../cosmograph/types.js");
const s = exports.defaultCosmographTimelineConfig = {
  accessor: o => o.date,
  filterType: _types.FilterType.Links
};
},{"../cosmograph/types.js":"../node_modules/@cosmograph/cosmograph/modules/cosmograph/types.js"}],"../node_modules/@cosmograph/cosmograph/modules/timeline/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CosmographTimeline = void 0;
var _ui = require("@cosmograph/ui");
var _types = require("../cosmograph/types.js");
var _config = require("./config.js");
class s {
  constructor(s, o, a) {
    this._config = {}, this.playAnimation = () => {
      this.timeline.playAnimation();
    }, this.pauseAnimation = () => {
      this.timeline.pauseAnimation();
    }, this.stopAnimation = () => {
      this.timeline.stopAnimation();
    }, this._onBrush = (i, t) => {
      var e, n;
      this._applyFilter(i), null === (n = (e = this._config).onSelection) || void 0 === n || n.call(e, i, t);
    }, this._onBarHover = (...i) => {
      var t, e;
      null === (e = (t = this._config).onBarHover) || void 0 === e || e.call(t, ...i);
    }, this._onAnimationPlay = (...i) => {
      var t, e;
      null === (e = (t = this._config).onAnimationPlay) || void 0 === e || e.call(t, ...i);
    }, this._onAnimationPause = (...i) => {
      var t, e;
      null === (e = (t = this._config).onAnimationPause) || void 0 === e || e.call(t, ...i);
    }, this._config = (0, _ui.merge)(_config.defaultCosmographTimelineConfig, null != a ? a : {}), this.timeline = new _ui.Timeline(o, this._createTimelineConfig(a)), this._cosmograph = s, this._filter = this._config.filterType === _types.FilterType.Nodes ? this._cosmograph.addNodesFilter() : this._cosmograph.addLinksFilter(), this._filter.onDataAdded = () => {
      this._updateData();
    }, this._updateDimension(), this._updateData();
  }
  setConfig(t) {
    var e, s;
    const o = (0, _ui.merge)(_config.defaultCosmographTimelineConfig, null != t ? t : {});
    this.timeline.setConfig(this._createTimelineConfig(t)), (null === (e = this._config.accessor) || void 0 === e ? void 0 : e.toString()) !== (null === (s = o.accessor) || void 0 === s ? void 0 : s.toString()) && this._updateData(), this._config = o;
  }
  getCurrentSelection() {
    return this.timeline.getCurrentSelection();
  }
  getCurrentSelectionInPixels() {
    return this.timeline.getCurrentSelectionInPixels();
  }
  getBarWidth() {
    return this.timeline.getBarWidth();
  }
  getIsAnimationRunning() {
    return this.timeline.getIsAnimationRunning();
  }
  setSelection(i) {
    this.timeline.setSelection(i);
  }
  setSelectionInPixels(i) {
    this.timeline.setSelectionInPixels(i);
  }
  _updateData() {
    const i = this._filter.getAllValues();
    i && this.timeline.setTimeData(i), this.timeline.render(), this.timeline.resize();
  }
  _updateDimension() {
    const {
      _config: {
        accessor: i
      },
      _filter: t
    } = this;
    t.setAccessor(i);
  }
  _applyFilter(i) {
    const {
      _filter: t
    } = this;
    i ? t.applyFilter(t => t >= i[0] && t <= i[1]) : t.clear();
  }
  getConfig() {
    return this._config;
  }
  remove() {
    this.timeline.destroy();
  }
  _createTimelineConfig(i) {
    return {
      ...i,
      events: {
        onBrush: this._onBrush.bind(this),
        onBarHover: this._onBarHover.bind(this),
        onAnimationPlay: this._onAnimationPlay.bind(this),
        onAnimationPause: this._onAnimationPause.bind(this)
      }
    };
  }
}
exports.CosmographTimeline = s;
},{"@cosmograph/ui":"../node_modules/@cosmograph/ui/index.js","../cosmograph/types.js":"../node_modules/@cosmograph/cosmograph/modules/cosmograph/types.js","./config.js":"../node_modules/@cosmograph/cosmograph/modules/timeline/config.js"}],"../node_modules/@cosmograph/cosmograph/modules/histogram/config.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultCosmographHistogramConfig = void 0;
var _types = require("../cosmograph/types.js");
const t = exports.defaultCosmographHistogramConfig = {
  accessor: o => o.value,
  customExtent: void 0,
  data: void 0,
  filterFunction: void 0,
  filterType: _types.FilterType.Nodes,
  onSelection: void 0,
  highlightCrossfiltered: !0
};
},{"../cosmograph/types.js":"../node_modules/@cosmograph/cosmograph/modules/cosmograph/types.js"}],"../node_modules/@cosmograph/cosmograph/modules/histogram/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CosmographHistogram = void 0;
var _ui = require("@cosmograph/ui");
var _types = require("../cosmograph/types.js");
var _config = require("./config.js");
class o {
  constructor(o, r, a) {
    this._onBrush = (t, i) => {
      var e, s;
      this._applyFilter(t), null === (s = (e = this._config).onSelection) || void 0 === s || s.call(e, t, i);
    }, this._onBarHover = (...t) => {
      var i, e;
      null === (e = (i = this._config).onBarHover) || void 0 === e || e.call(i, ...t);
    }, this._cosmograph = o, this._config = (0, _ui.merge)(_config.defaultCosmographHistogramConfig, null != a ? a : {}), this._histogram = new _ui.Histogram(r, this._createHistogramConfig(a)), this._filter = this._config.filterType === _types.FilterType.Nodes ? this._cosmograph.addNodesFilter() : this._cosmograph.addLinksFilter(), this._filter.onDataAdded = () => {
      this._updateData();
    }, this._filter.onFiltered = () => {
      this._config.highlightCrossfiltered && this._updateDynamicData();
    }, this._updateDimension(), this._updateData();
  }
  setConfig(i) {
    const e = (0, _ui.merge)(_config.defaultCosmographHistogramConfig, null != i ? i : {});
    this._histogram.setConfig(this._createHistogramConfig(i)), e.accessor === this._config.accessor && e.data === this._config.data && e.filterFunction === this._config.filterFunction || (this._updateDimension(), this._updateData(), this.setSelection()), this._config = e;
  }
  getCurrentSelection() {
    return this._histogram.getCurrentSelection;
  }
  getCurrentSelectionInPixels() {
    return this._histogram.getCurrentSelectionInPixels;
  }
  getBarWidth() {
    return this._histogram.getBarWidth();
  }
  setSelection(t) {
    this._histogram.setSelection(t);
  }
  getConfig() {
    return this._config;
  }
  remove() {
    this._histogram.destroy();
  }
  _createHistogramConfig(t) {
    return {
      ...t,
      events: {
        onBrush: this._onBrush.bind(this),
        onBarHover: this._onBarHover.bind(this)
      }
    };
  }
  _updateDimension() {
    const {
      _config: {
        accessor: t,
        filterFunction: i,
        data: s,
        filterType: o
      },
      _filter: r
    } = this;
    if (!t) return;
    i && s ? o === _types.FilterType.Nodes ? r.setAccessor(t => t.id) : r.setAccessor(t => [t.source, t.target]) : r.setAccessor(t);
  }
  _applyFilter(t) {
    const {
      _filter: i,
      _config: {
        filterFunction: s,
        data: o,
        filterType: r
      }
    } = this;
    if (t) {
      if (s && o) {
        const a = i.getFilteredRecords();
        if (r === _types.FilterType.Nodes) {
          const e = s(t, o, a),
            r = new Set(e.map(t => t.id));
          i.applyFilter(t => r.has(t));
        } else {
          const e = s(t, o, a),
            r = new Set(e.map(t => [t.source, t.target]).flat());
          i.applyFilter(t => {
            const i = null == t ? void 0 : t[0],
              e = null == t ? void 0 : t[1];
            return r.has(i) && r.has(e);
          });
        }
      } else i.applyFilter(i => i >= t[0] && i <= t[1]);
    } else i.clear();
  }
  _updateData() {
    const {
        _config: {
          data: t,
          filterFunction: i,
          accessor: e
        }
      } = this,
      s = i && t && e ? t.map(e) : this._filter.getAllValues();
    s && this._histogram.setHistogramData(s, this._config.customExtent);
  }
  _updateDynamicData() {
    const t = this._filter.getFilteredValues();
    this._histogram.setHighlightedData(t);
  }
}
exports.CosmographHistogram = o;
},{"@cosmograph/ui":"../node_modules/@cosmograph/ui/index.js","../cosmograph/types.js":"../node_modules/@cosmograph/cosmograph/modules/cosmograph/types.js","./config.js":"../node_modules/@cosmograph/cosmograph/modules/histogram/config.js"}],"../node_modules/@cosmograph/cosmograph/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Cosmograph", {
  enumerable: true,
  get: function () {
    return _index.Cosmograph;
  }
});
Object.defineProperty(exports, "CosmographHistogram", {
  enumerable: true,
  get: function () {
    return _index4.CosmographHistogram;
  }
});
Object.defineProperty(exports, "CosmographSearch", {
  enumerable: true,
  get: function () {
    return _index2.CosmographSearch;
  }
});
Object.defineProperty(exports, "CosmographTimeline", {
  enumerable: true,
  get: function () {
    return _index3.CosmographTimeline;
  }
});
var _index = require("./modules/cosmograph/index.js");
var _index2 = require("./modules/search/index.js");
var _index3 = require("./modules/timeline/index.js");
var _index4 = require("./modules/histogram/index.js");
},{"./modules/cosmograph/index.js":"../node_modules/@cosmograph/cosmograph/modules/cosmograph/index.js","./modules/search/index.js":"../node_modules/@cosmograph/cosmograph/modules/search/index.js","./modules/timeline/index.js":"../node_modules/@cosmograph/cosmograph/modules/timeline/index.js","./modules/histogram/index.js":"../node_modules/@cosmograph/cosmograph/modules/histogram/index.js"}],"cosmograph/config.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseConfig = void 0;
exports.BaseConfig = {
  backgroundColor: "#0f172a",
  nodeSize: 2.0,
  nodeLabelColor: 'white',
  simulationRepulsion: 1.6,
  simulationLinkDistance: 10,
  nodeLabelClassName: "css-label--label"
};
},{}],"cosmograph/graph.ts":[function(require,module,exports) {
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setLeftSide = exports.detailsOff = exports.detailsOn = exports.WallyGraph = void 0;
var cosmograph_1 = require("@cosmograph/cosmograph");
var config_1 = require("./config");
var WallyGraph = /*#__PURE__*/function () {
  function WallyGraph(data) {
    _classCallCheck(this, WallyGraph);
    this.nodes = [];
    this.links = [];
    this.clickedNodes = [];
    this.clickedNodeId = "";
    this.data = data;
    this.setConfig();
    this.setNodes();
    var cosmographContainer = document.getElementById("cosmograph");
    var searchContainer = document.getElementById("cosmosearch");
    this.cosmograph = new cosmograph_1.Cosmograph(cosmographContainer);
    this.cosmoSearch = new cosmograph_1.CosmographSearch(this.cosmograph, searchContainer);
  }
  _createClass(WallyGraph, [{
    key: "setConfig",
    value: function setConfig() {
      var _this = this;
      this.config = config_1.BaseConfig;
      this.config.nodeColor = function (n) {
        return _this.getClickedNodesColor(n);
      };
      this.config.linkColor = function (l) {
        return _this.getLinkColor(l);
      };
      this.config.nodeLabelAccessor = function (n) {
        return _this.getLabel(n);
      };
      this.config.onClick = function (node, i) {
        return _this.onNodeClick(node, i);
      };
      this.searchConfig = {
        maxVisibleItems: 5,
        events: {
          onSelect: function onSelect(node) {
            console.log('Selected Node: ', node.id);
          }
        }
      };
    }
  }, {
    key: "setNodes",
    value: function setNodes() {
      try {
        this.parseData();
      } catch (error) {
        console.error('Error loading Wally data:', error);
      }
    }
  }, {
    key: "parseData",
    value: function parseData() {
      var _this2 = this;
      this.data.forEach(function (finding) {
        finding.Paths.forEach(function (paths) {
          var prev = "";
          paths.forEach(function (path, i) {
            if (i === 0) {
              prev = path;
              _this2.addNodeIfNotExist(path, "purple", "");
            } else {
              if (i == paths.length - 1) {
                _this2.addNodeIfNotExist(path, "#984040", finding.MatchId);
              } else {
                _this2.addNodeIfNotExist(path, "#4287f5", "");
              }
              _this2.addEdgeIfNotExist(prev, path);
              prev = path;
            }
          });
        });
      });
    }
  }, {
    key: "nodeExists",
    value: function nodeExists(nodeId) {
      return this.nodes.some(function (node) {
        return node.id === nodeId;
      });
    }
  }, {
    key: "edgeExists",
    value: function edgeExists(source, target) {
      return this.links.some(function (link) {
        return link.source === source && link.target === target;
      });
    }
  }, {
    key: "addNodeIfNotExist",
    value: function addNodeIfNotExist(nodeId, color, findingId) {
      if (!this.nodeExists(nodeId)) {
        var label = this.extractFuncFromId(nodeId);
        label = label != null ? label : "";
        this.nodes.push({
          id: nodeId,
          label: label,
          color: color,
          green: "green",
          finding: findingId
        });
      } else {
        var node = this.nodes.find(function (node) {
          return node.id === nodeId;
        });
        if (node != null) {
          if (color == "#4287f5" && node.color == "purple") {
            node.color = "#FFCE85";
          }
          if (node.color == "#4287f5" && color == "purple") {
            node.color = "#FFCE85";
          }
        }
      }
    }
  }, {
    key: "addEdgeIfNotExist",
    value: function addEdgeIfNotExist(source, target) {
      if (!this.edgeExists(source, target)) {
        this.links.push({
          source: source,
          target: target,
          color: "#8C8C8C"
        });
      }
    }
  }, {
    key: "findAllPrecedingNodes",
    value: function findAllPrecedingNodes(nodeId) {
      var _this3 = this;
      var visited = new Set(); // To keep track of visited nodes
      var stack = [nodeId]; // Start with the target node
      var _loop = function _loop() {
        var current = stack.pop();
        // Add the current node to the visited set
        visited.add(current);
        // Find all links where the current node is a target
        var incomingLinks = _this3.links.filter(function (link) {
          return link.target === current;
        });
        incomingLinks.forEach(function (link) {
          // Add the source node of each link to the stack
          if (!visited.has(link.source)) {
            stack.push(link.source);
          }
        });
      };
      while (stack.length > 0) {
        _loop();
      }
      visited.delete(nodeId); // Remove the initial node from the result
      return Array.from(visited); // Convert the Set of visited nodes to an Array and return
    }
  }, {
    key: "findLinksByNodeId",
    value: function findLinksByNodeId(nodeId) {
      return this.links.filter(function (link) {
        return link.source === nodeId || link.target === nodeId;
      });
    }
  }, {
    key: "onNodeClick",
    value: function onNodeClick(node, i) {
      var _this4 = this;
      if (node == undefined) {
        this.clickedNodes = [];
        this.clickedNodeId = "";
        detailsOff();
        this.cosmoSearch.clearInput();
        this.cosmoSearch.setConfig(this.searchConfig);
      } else {
        var conn = this.findAllPrecedingNodes(node.id);
        this.clickedNodes = conn;
        this.clickedNodes.push(node.id);
        this.clickedNodeId = node.id;
        if (node.finding != "") {
          var finding = this.getFinding(node.finding);
          setLeftSide(finding);
        }
      }
      this.config.nodeColor = function (n) {
        return _this4.getClickedNodesColor(n);
      };
      this.config.linkColor = function (l) {
        return _this4.getLinkColor(l);
      };
      this.cosmograph.setConfig(this.config);
    }
  }, {
    key: "getClickedNodesColor",
    value: function getClickedNodesColor(node) {
      var defaultColor = node.color;
      if (this.clickedNodes.includes(node.id)) {
        return node.color;
      } else {
        if (this.clickedNodes.length > 0) {
          return [0, 0, 0, 0];
        } else {
          if (node.color == "purple" || node.color == "#984040") {
            return node.color;
          }
          return defaultColor;
        }
      }
    }
  }, {
    key: "getClickedNodeColor",
    value: function getClickedNodeColor(node) {
      var defaultColor = node.color;
      var clickedColor = 'green';
      if (this.clickedNodeId == node.id) {
        return clickedColor;
      } else {
        return defaultColor;
      }
    }
  }, {
    key: "setupGraph",
    value: function setupGraph() {
      this.cosmograph.setConfig(config_1.BaseConfig);
      this.cosmoSearch.setConfig(this.searchConfig);
      this.cosmograph.setData(this.nodes, this.links);
    }
  }, {
    key: "extractFuncFromId",
    value: function extractFuncFromId(nodeId) {
      var match = nodeId.match(/\[(.*?)\]/);
      return match ? match[1] : null;
    }
  }, {
    key: "getLinkColor",
    value: function getLinkColor(link) {
      var nt = this.clickedNodes.find(function (n) {
        return link.target === n;
      });
      if (nt != undefined && nt != null) {
        return "green";
      }
      if (this.clickedNodes.length > 0) {
        return [0, 0, 0, 0];
      }
      return link.color;
    }
  }, {
    key: "getLabel",
    value: function getLabel(node) {
      if (this.clickedNodes.includes(node.id)) {
        return node.id;
      } else {
        if (this.clickedNodes.length > 0) {
          return '';
        } else {
          return node.label;
        }
      }
    }
  }, {
    key: "getFinding",
    value: function getFinding(findingId) {
      var res;
      this.data.forEach(function (finding) {
        if (findingId == finding.MatchId) {
          res = finding;
        }
      });
      return res;
    }
  }]);
  return WallyGraph;
}();
exports.WallyGraph = WallyGraph;
// Containers in UI
var details = document.getElementById('details');
function detailsOn() {
  if (details != null && details.classList.contains('invisible')) {
    details.classList.remove('invisible');
  }
}
exports.detailsOn = detailsOn;
function detailsOff() {
  if (details != null && !details.classList.contains('invisible')) {
    details.classList.add('invisible');
  }
}
exports.detailsOff = detailsOff;
function setLeftSide(finding) {
  detailsOn();
  document.getElementById('pkg').textContent = finding.Indicator.Package;
  document.getElementById('func').textContent = finding.Indicator.Function;
  document.getElementById('params').textContent = JSON.stringify(finding.Indicator.Params);
  document.getElementById('enclosedBy').textContent = finding.EnclosedBy;
  document.getElementById('pos').textContent = finding.Pos;
  document.getElementById('pathNum').textContent = finding.Paths.length;
}
exports.setLeftSide = setLeftSide;
},{"@cosmograph/cosmograph":"../node_modules/@cosmograph/cosmograph/index.js","./config":"cosmograph/config.ts"}],"index.ts":[function(require,module,exports) {
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var graph_1 = require("./cosmograph/graph");
// Function to fetch and parse wally data
function loadWallyData() {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var fileName, fileUrl, response, jsonData, wallyGraph;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          fileName = "wally.json";
          _context.prev = 1;
          fileUrl = "/".concat(fileName); // Fetch wally file hosted by Go
          _context.next = 5;
          return fetch(fileUrl);
        case 5:
          response = _context.sent;
          if (response.ok) {
            _context.next = 8;
            break;
          }
          throw new Error("Failed to fetch ".concat(fileUrl, ": ").concat(response.statusText));
        case 8:
          _context.next = 10;
          return response.json();
        case 10:
          jsonData = _context.sent;
          wallyGraph = new graph_1.WallyGraph(jsonData);
          wallyGraph.setupGraph();
          _context.next = 18;
          break;
        case 15:
          _context.prev = 15;
          _context.t0 = _context["catch"](1);
          console.error('Error loading Wally data:', _context.t0);
        case 18:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[1, 15]]);
  }));
}
loadWallyData();
},{"./cosmograph/graph":"cosmograph/graph.ts"}],"../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "57063" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}],"../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/loaders/browser/js-loader.js":[function(require,module,exports) {
module.exports = function loadJSBundle(bundle) {
  return new Promise(function (resolve, reject) {
    var script = document.createElement('script');
    script.async = true;
    script.type = 'text/javascript';
    script.charset = 'utf-8';
    script.src = bundle;
    script.onerror = function (e) {
      script.onerror = script.onload = null;
      reject(e);
    };
    script.onload = function () {
      script.onerror = script.onload = null;
      resolve();
    };
    document.getElementsByTagName('head')[0].appendChild(script);
  });
};
},{}],0:[function(require,module,exports) {
var b=require("../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/bundle-loader.js");b.register("js",require("../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/loaders/browser/js-loader.js"));b.load([["browser.d202933b.js","../node_modules/@supabase/node-fetch/browser.js"]]).then(function(){require("index.ts");});
},{}]},{},["../../../../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/hmr-runtime.js",0], null)
//# sourceMappingURL=/src.77de5100.js.map